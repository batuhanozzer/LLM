[
  {
    "question": "Bir kullanıcının adını ve yaşını girmek için gerekli olan kodu tamamlayın. Adı bir 'char' dizisinde, yaşı ise bir 'int' değişkeninde saklayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char ad[50];  // Kullanıcının adını saklamak için char dizisi\n    int yas;     // Kullanıcının yaşını saklamak için int değişkeni\n\n    printf(\"Adınızı girin: \");\n    scanf(\"%s\", ad);  // Kullanıcıdan adı almak için\n\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);  // Kullanıcıdan yaşı almak için\n\n    printf(\"Adınız: %s, Yaşınız: %d\\n\", ad, yas);  // Kullanıcının verdiği bilgileri ekrana yazdırma\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:36.606892"
  },
  {
    "question": "Bir üçgenin taban ve yükseklik uzunluklarını kullanarak alanını hesaplamak için gerekli olan kodu tamamlayın. Taban uzunluğunu 'float' türünde, yükseklik uzunluğunu da 'float' türünde saklayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float taban;   // Üçgenin taban uzunluğunu saklamak için float değişkeni\n    float yukseklik; // Üçgenin yükseklik uzunluğunu saklamak için float değişkeni\n    float alan;     // Üçgenin alanını saklamak için float değişkeni\n\n    printf(\"Taban uzunluğunu girin: \");\n    scanf(\"%f\", &taban);  // Kullanıcıdan taban uzunluğunu almak için\n\n    printf(\"Yükseklik uzunluğunu girin: \");\n    scanf(\"%f\", &yukseklik);  // Kullanıcıdan yükseklik uzunluğunu almak için\n\n    alan = (taban * yukseklik) / 2;  // Üçgenin alanını hesaplama\n    printf(\"Üçgenin alanı: %.2f\\n\", alan);  // Hesaplanan alanı ekrana yazdırma\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:36.606964"
  },
  {
    "question": "Aşağıdaki C kodunun eksik yerlerini tamamlayarak, kullanıcının girdiği iki sayının toplamını hesaplayacak şekilde düzenleyin: \n\n#include <stdio.h>\n\nint main() {\n    int a, b, toplam;\n    printf(\"Lütfen iki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    \n    toplam = _____;\n    printf(\"Toplam: %d\\n\", _____);\n    return 0;\n}",
    "answer": "Kodun eksik yerlerini şu şekilde tamamlayabilirsiniz:\n\n    toplam = a + b;\n    printf(\"Toplam: %d\\n\", toplam);\n\nBu şekilde, kullanıcıdan alınan iki sayıyı 'a' ve 'b' değişkenlerine atıyoruz. Sonrasında, bu iki sayıyı toplayarak 'toplam' değişkenine atıyoruz. Son olarak, toplamı ekrana yazdırıyoruz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:45.033350"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcının girdiği bir sıcaklık değerini Celsius'tan Fahrenheit'a dönüştürmek için gerekli eksik yerleri doldurun: \n\n#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    printf(\"Celsius değerini girin: \");\n    scanf(\"%f\", &celsius);\n    \n    fahrenheit = _____;\n    printf(\"%.2f Celsius = %.2f Fahrenheit\\n\", celsius, _____);\n    return 0;\n}",
    "answer": "Kodun eksik yerlerini şu şekilde tamamlayabilirsiniz:\n\n    fahrenheit = (celsius * 9/5) + 32;\n    printf(\"%.2f Celsius = %.2f Fahrenheit\\n\", celsius, fahrenheit);\n\nBu işlemde, kullanıcının girdiği Celsius değerini alıyoruz ve Fahrenheit'a dönüştürüyoruz. Dönüşüm formülü olarak 'fahrenheit = (celsius * 9/5) + 32' kullanıyoruz. Son olarak, Celsius ve Fahrenheit değerlerini ekrana yazdırıyoruz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:45.033471"
  },
  {
    "question": "Aşağıda verilen kodun eksik kısmını tamamlayarak, kullanıcının girdiği iki sayının toplamını hesaplayan bir C programı yazın. \n\n#include <stdio.h>\n\nint main() {\n    int a, b, toplam;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, ...);\n    toplam = ...\n    printf(\"Toplam: %d\\n\", ...);\n    return 0;\n}",
    "answer": "Kodun tamamlanmış hali aşağıdaki gibi olmalıdır: \n\n#include <stdio.h>\n\nint main() {\n    int a, b, toplam;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    toplam = a + b;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\nAçıklama: Bu program, kullanıcıdan iki tam sayı alır ve bu sayıların toplamını hesaplayarak ekrana yazdırır. 'scanf' fonksiyonu ile kullanıcıdan girdi alırken 'b' değişkeni için '&b' kullanarak adresini belirtmemiz gerekir. 'toplam' değişkeni ise 'a' ve 'b' değişkenlerinin toplamını saklar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:56.884599"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayarak, bir dizi içerisindeki en büyük sayıyı bulan C programını yazın.\n\n#include <stdio.h>\n#define MAX 100\n\nint main() {\n    int dizi[MAX], i, n, enBüyük;\n    printf(\"Dizi eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Dizinin elemanlarını girin: \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    enBüyük = dizi[0];\n    for (i = 1; i < n; i++) {\n        ...\n    }\n    printf(\"En büyük sayı: %d\\n\", ...);\n    return 0;\n}",
    "answer": "Kodun tamamlanmış hali aşağıdaki gibi olmalıdır: \n\n#include <stdio.h>\n#define MAX 100\n\nint main() {\n    int dizi[MAX], i, n, enBüyük;\n    printf(\"Dizi eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Dizinin elemanlarını girin: \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    enBüyük = dizi[0];\n    for (i = 1; i < n; i++) {\n        if (dizi[i] > enBüyük) {\n            enBüyük = dizi[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", enBüyük);\n    return 0;\n}\n\nAçıklama: Bu program, kullanıcıdan bir dizi oluşturmasını ister ve dizi elemanlarını alır. Daha sonra, dizi içerisindeki en büyük sayıyı bulmak için bir döngü kullanılır. İlk eleman 'enBüyük' olarak atanır ve döngü içerisinde diğer elemanlarla karşılaştırılarak en büyük değer güncellenir. Son olarak, en büyük değer ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:19:56.884763"
  },
  {
    "question": "Aşağıdaki kod parçasında hata nedir ve nasıl düzeltilir? \n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    float b = 2.5;\n    int result;\n    result = a + b;\n    printf(\"Sonuç: %d\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda hata, float türündeki 'b' değişkeninin bir int değişkeni olan 'result'a atanmasında meydana geliyor. 'b' float türünden olduğu için doğrudan int'e atanamaz. Bunun yerine, 'b' değişkenini int'e dönüştürmek gerekir. Kod, aşağıdaki gibi düzeltilmelidir:\n\n```c\nresult = a + (int)b;\n``` \n\nBu düzeltme ile 'b' değişkeninin değeri tam sayıya dönüşür ve sonuç doğru bir şekilde hesaplanır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:07.303400"
  },
  {
    "question": "Aşağıdaki kodda bir hata var, bu hatayı bulup düzeltin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char letter = 'A';\n    int number = 10;\n    char result;\n    result = letter + number;\n    printf(\"Sonuç: %c\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda, 'letter' değişkeni bir karakter (char) ve 'number' değişkeni bir tam sayı (int) olup, bunların toplamı bir karakter olarak 'result' değişkenine atanıyor. Ancak, karakter ve tam sayı toplamı bir karakter olarak doğru bir şekilde ifade edilemez. Bu durumda, 'result' değişkenini bir tam sayı (int) olarak tanımlamak ve ardından sonucu 'printf' fonksiyonunda karakter olarak yazdırmak gerekir. Kod, aşağıdaki gibi düzeltilmelidir:\n\n```c\nresult = letter + number;\nprintf(\"Sonuç: %d\", result);\n```\n\nBu düzeltme ile, toplam doğru bir şekilde hesaplanır ve tam sayı olarak yazdırılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:07.303522"
  },
  {
    "question": "Aşağıdaki C kodu derleniyor ancak beklenmedik bir sonuç veriyor. Hata nerede ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    float b = 3.2;\n    int result;\n    result = a / b;\n    printf(\"Sonuç: %d\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda `result = a / b;` satırında bir hata var. `a` bir tam sayı (int) ve `b` bir ondalıklı sayı (float) olduğundan, `a / b` işlemi float bir sonuç üretir. Ancak, bu sonucu `int` bir değişkene atamaya çalışırken ondalık kısmı kaybediyoruz ve `result` değişkeni beklenmedik bir değer alabilir. Bunun düzeltilmesi için ya `result` değişkenini float olarak tanımlamalıyız ya da `result`'u float olarak hesaplayıp daha sonra tam sayıya dönüştürmeliyiz. İşte düzeltilmiş kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    float b = 3.2;\n    float result;\n    result = a / b;\n    printf(\"Sonuç: %.2f\", result);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:23.836891"
  },
  {
    "question": "Aşağıdaki C kodu, kullanıcıdan yaş bilgisini alıyor ama beklenen sonucu vermiyor. Hata nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint main() {\n    char age[3];\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", age);\n    printf(\"Yaşınız: %d\", age);\n    return 0;\n}\n```",
    "answer": "Bu kodda `char age[3];` tanımlaması yapılarak bir karakter dizisi oluşturulmuş. Ancak `scanf(\"%d\", age);` kısmında `%d` formatı, tamsayı beklerken, `age` bir karakter dizisi (string) olduğu için burada uyumsuzluk meydana geliyor. Sonuç olarak, program doğru çalışmıyor. Kullanıcının yaşını alırken bunu bir tamsayı olarak almak için `int age;` şeklinde tanımlamalıyız. Ayrıca, `printf` için de `%d` yerine `%d` kullanmalıyız.\n\nDüzeltilmiş kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n    printf(\"Yaşınız: %d\", age);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:23.837007"
  },
  {
    "question": "Aşağıdaki C kodunda `total` değişkeninin beklenmedik bir şekilde negatif bir değer almasının sebebi nedir? Kod: `int total = 0; for (int i = 0; i < 5; i++) { total -= i; } printf(\"Toplam: %d\", total);`",
    "answer": "Bu kod parçasında `total` değişkeni başlangıçta 0 olarak tanımlanıyor. Ancak döngü içerisinde `total` değeri `total -= i;` ifadesi ile `i` değişkeninin değerinin çıkarılması ile güncelleniyor. `i` 0'dan başlayarak 4'e kadar artıyor. Bu durumda `total` değerleri sırasıyla 0, -1, -3, -6, -10 oluyor. Negatif değer almasının nedeni, değişkenin çıkarma ile güncellenmesidir. Eğer `total`'ın toplamını almak istiyorsanız, `total += i;` şeklinde toplama yapmalısınız. Doğru kod şöyle olmalıdır: `int total = 0; for (int i = 0; i < 5; i++) { total += i; }`",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:35.887215"
  },
  {
    "question": "Aşağıdaki kodda `x` ve `y` değişkenlerinin beklenmedik bir sonuç vermesinin nedeni nedir? Kod: `float x = 1.5; int y = 3; x = y / 2; printf(\"x: %f\", x);`",
    "answer": "Bu kodda `y / 2` işlemi gerçekleştirildiğinde, `y` ve `2` tam sayılardır (int). C dilinde tam sayı bölmesi yapıldığında, sonuç yine tam sayı olacaktır. Bu durumda `y / 2` işlemi 1 sonucunu verir. Daha sonra bu değer `x` değişkenine atanır. Ancak `x` float bir değişken olduğundan bu değer `1.0` olarak saklanır. Eğer `x`'in 1.5'ten küçük bir değer almasını istemiyorsanız, bölme işlemini float bir değer ile yapmalısınız. Aşağıdaki gibi güncelleyebilirsiniz: `x = (float)y / 2;` Bu şekilde `x`'in değeri `1.5` olarak atanır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:35.887282"
  },
  {
    "question": "Bir kullanıcının yaşını tutmak için hangi veri tipini kullanmalıyım ve neden?",
    "answer": "Kullanıcının yaşını tutmak için 'int' (tam sayı) veri tipini kullanmalısınız. Çünkü yaş, genellikle tam bir sayı ile ifade edilir (örneğin 25, 30 vb.) ve ondalık kesirler gerektirmeyen bir değerdir. Örnek bir kod parçası: \n\n```c\nint kullaniciYasi = 25;  // Kullanıcının yaşı 25 olarak tanımlandı.\n```\nBu kodda 'kullaniciYasi' değişkeni, kullanıcının yaşını tam sayı olarak saklar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:44.270946"
  },
  {
    "question": "Bir kullanıcının adını saklamak için hangi veri tipini kullanmalıyım ve örnek bir kullanım gösterin.",
    "answer": "Bir kullanıcının adını saklamak için 'char' dizisi (string) veri tipini kullanmalısınız. Çünkü isimler harflerden oluştuğu için metin biçiminde tutulmalıdır. Örnek bir kod parçası: \n\n```c\nchar kullaniciAdi[50];  // Maksimum 49 karakterlik bir isim için dizi tanımlandı.\nstrcpy(kullaniciAdi, \"Ahmet\");  // 'kullaniciAdi' değişkenine 'Ahmet' atanıyor.\n```\nBu kodda 'kullaniciAdi' değişkeni, kullanıcı adını saklamak üzere bir karakter dizisi olarak tanımlanmıştır. 'strcpy' fonksiyonu, 'Ahmet' ifadesini bu diziye kopyalar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:20:44.271030"
  },
  {
    "question": "C dilinde bir değişkenin nasıl tanımlanacağını ve farklı veri tipleriyle nasıl kullanılacağını açıklayın. Örnek bir kod parçası ile gösterin.",
    "answer": "C dilinde bir değişken tanımlamak için öncelikle veri tipini belirtmemiz gerekir. Örneğin, 'int' tamsayılar için, 'float' ondalıklı sayılar için ve 'char' karakterler için kullanılır. Değişken tanımlarken, önce veri tipi, ardından değişken adı yazılır. Aşağıdaki örnekte, bir tamsayı ve bir ondalıklı sayı değişkeni tanımlanmış ve kullanılmıştır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 10; // 'sayi' isimli tamsayı değişkeni tanımlandı ve 10 değeri atandı.\n    float ondalikSayi = 5.5; // 'ondalikSayi' isimli ondalıklı sayı değişkeni tanımlandı ve 5.5 değeri atandı.\n\n    printf(\"Tam sayı: %d\\n\", sayi); // 'sayi' değişkeninin değeri yazdırılıyor.\n    printf(\"Ondalık sayı: %.2f\\n\", ondalikSayi); // 'ondalikSayi' değişkeninin değeri iki ondalık basamakla yazdırılıyor.\n\n    return 0;\n}\n```\nBu örnekte, 'sayi' değişkeni tamsayı olarak 10 değerini alırken, 'ondalikSayi' değişkeni 5.5 değerini alır. Değişkenler, program içerisinde birçok farklı hesaplama veya işleme yapılmasını sağlar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:04.036807"
  },
  {
    "question": "C dilinde bir dizi (array) tanımlamak ve kullanmak için hangi adımlar izlenmelidir? Örnek bir kod ile açıklayın.",
    "answer": "C dilinde diziler, aynı türdeki birden fazla veriyi saklamak için kullanılan veri yapılandırmalarıdır. Dizi tanımlarken, öncelikle veri tipi, ardından değişken adı ve en sonunda köşeli parantez içinde dizinin boyutu belirtilir. Aşağıdaki örnekte, bir tamsayı dizisi tanımlanmış ve elemanlarına erişim sağlanmıştır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayilar[5] = {1, 2, 3, 4, 5}; // 'sayilar' isimli bir tamsayı dizisi tanımlanıyor ve 5 eleman ile başlatılıyor.\n\n    printf(\"Dizinin 1. elemanı: %d\\n\", sayilar[0]); // Dizinin 1. elemanı yazdırılıyor. Diziler 0'dan başlar.\n    printf(\"Dizinin 3. elemanı: %d\\n\", sayilar[2]); // Dizinin 3. elemanı yazdırılıyor.\n\n    // Dizi elemanlarını döngü ile yazdırma\n    printf(\"Dizi elemanları:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"sayilar[%d]: %d\\n\", i, sayilar[i]); // Her bir eleman için indeks ve değer yazdırılıyor.\n    }\n\n    return 0;\n}\n```\nBu örnekte, 'sayilar' adında 5 elemanlı bir tamsayı dizisi oluşturulmuştur. Dizinin elemanlarına 'sayilar[index]' şeklinde erişim sağlanır. Ayrıca, bir döngü kullanarak dizinin tüm elemanlarını yazdırma işlemi gerçekleştirilmiştir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:04.036869"
  },
  {
    "question": "C dilinde bir değişkenin bellekte nasıl yer kapladığını ve veri türlerinin bellek yönetimini nasıl etkilediğini açıklayın. Örneklerle gösterin.",
    "answer": "C dilindeki her veri türü, bellekte farklı boyutlara ve özelliklere sahiptir. Örneğin, 'int' veri türü genellikle 4 byte'lık bir yer kaplarken, 'char' veri türü sadece 1 byte yer kaplar. Bu durum, bellek yönetiminde önemlidir çünkü değişkenlerin boyutları, programın genel bellek kullanımını etkiler. Örneğin: \n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 10;        // 4 byte\n    char karakter = 'A'; // 1 byte\n    float ondalik = 5.5; // 4 byte\n\n    printf(\"Sayi: %d, Boyut: %zu bytes\\n\", sayi, sizeof(sayi));\n    printf(\"Karakter: %c, Boyut: %zu bytes\\n\", karakter, sizeof(karakter));\n    printf(\"Ondalik: %.2f, Boyut: %zu bytes\\n\", ondalik, sizeof(ondalik));\n    return 0;\n}\n```\nBu kod parçası, farklı veri türlerinin boyutlarını ve bellekte ne kadar yer kapladığını göstermektedir. 'sizeof' operatörü, bir veri türünün bellekte kapladığı alanı byte cinsinden döner.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:16.753970"
  },
  {
    "question": "C dilinde 'unsigned int' ve 'signed int' veri türleri arasındaki farkı açıklayın ve kullanım senaryoları verin.",
    "answer": "'signed int' ve 'unsigned int' veri türleri C dilinde tamsayıları temsil eder, ancak işaret bitlerinin kullanımı açısından farkları vardır. 'signed int', hem pozitif hem de negatif sayıları temsil edebilirken, 'unsigned int' yalnızca pozitif sayıları ve sıfırı temsil eder. \n\nÖrneğin:\n```c\n#include <stdio.h>\n\nint main() {\n    signed int negatif = -10;  // Negatif sayılar\n    unsigned int pozitif = 10;  // Sadece pozitif sayılar\n\n    printf(\"Negatif: %d\\n\", negatif);\n    printf(\"Pozitif: %u\\n\", pozitif);\n\n    // Aşırı kullanımı\n    unsigned int buyukSayi = 3000000000; // 4 byte'lık unsigned int için sınır\n    printf(\"Buyuk Sayı: %u\\n\", buyukSayi);\n\n    return 0;\n}\n```\nBu kodda, 'signed int' değişkeni negatif bir sayıyı temsil ederken, 'unsigned int' değişkeni yalnızca pozitif bir değeri tutar. Ayrıca, 'unsigned int' kullanımı, pozitif sayılar için daha büyük bir aralık sağlar, bu nedenle büyük sayılarla çalışırken tercih edilebilir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:16.754056"
  },
  {
    "question": "Bir kişinin yaşını ve adını saklamak için C dilinde nasıl bir yapı oluşturursunuz?",
    "answer": "C dilinde bir kişinin yaşını ve adını saklamak için yapı (struct) kullanabiliriz. Aşağıdaki kod örneğinde, `Kisi` adında bir yapı tanımlayıp, içine `isim` (string) ve `yas` (integer) değişkenlerini ekliyoruz. Sonrasında bu yapıyı kullanarak bir kişinin bilgilerini saklayabiliriz.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Kisi {\n    char isim[50];\n    int yas;\n};\n\nint main() {\n    struct Kisi kisi;\n    strcpy(kisi.isim, \"Ali\"); // İsim atama\n    kisi.yas = 30; // Yaş atama\n\n    printf(\"İsim: %s\\n\", kisi.isim);\n    printf(\"Yaş: %d\\n\", kisi.yas);\n    return 0;\n}\n```\nBu kodda, `Kisi` yapısını tanımladıktan sonra, bir `kisi` değişkeni oluşturduk ve ismini \"Ali\" ve yaşını 30 olarak atadık. Program çalıştığında, isim ve yaş bilgilerini ekrana yazdıracaktır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:28.871996"
  },
  {
    "question": "Bir matematik işlemi yaparak iki sayı arasındaki toplam, fark, çarpım ve bölüm değerlerini nasıl hesaplayabilirsiniz?",
    "answer": "İki sayı arasındaki matematiksel işlemleri gerçekleştirmek için önce iki adet değişken tanımlıyoruz. Ardından bu değişkenlerin toplamını, farkını, çarpımını ve bölümünü hesaplayarak ekrana yazdıracağız. Aşağıdaki kod örneğinde iki sayı için işlemler gerçekleştirilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi1 = 10; // İlk sayı\n    int sayi2 = 5;  // İkinci sayı\n\n    int toplam = sayi1 + sayi2;      // Toplama işlemi\n    int fark = sayi1 - sayi2;        // Çıkarma işlemi\n    int carpim = sayi1 * sayi2;      // Çarpma işlemi\n    float bolum = (float)sayi1 / sayi2; // Bölme işlemi (float dönüşümü ile)\n\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Fark: %d\\n\", fark);\n    printf(\"Çarpım: %d\\n\", carpim);\n    printf(\"Bölüm: %.2f\\n\", bolum);\n    return 0;\n}\n```\nBu kodda, iki sayıyı tanımladık ve bu sayılar arasındaki dört temel matematiksel işlemi gerçekleştirerek sonuçları ekrana yazdırdık. Bölüm işlemi sonucu float veri tipinde olduğu için, `float` dönüşümü uyguladık ve sonucu iki ondalık haneli gösterdik.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:28.872046"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir C programı yazın. Bu programda değişkenleri ve veri tiplerini etkili bir şekilde kullanın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;  // Kullanıcının girdiği sayı için bir tam sayı değişkeni tanımlıyoruz.\n\n    printf(\"Bir sayı giriniz: \");\n    scanf(\"%d\", &sayi);  // Kullanıcıdan bir tam sayı alıyoruz.\n\n    // Sayının pozitif, negatif veya sıfır olup olmadığını kontrol ediyoruz.\n    if (sayi > 0) {\n        printf(\"Girdiğiniz sayı pozitiftir.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Girdiğiniz sayı negatiftir.\\n\");\n    } else {\n        printf(\"Girdiğiniz sayı sıfırdır.\\n\");\n    }\n\n    return 0;\n}\n\n/* Bu programda, 'int' veri tipi kullanarak bir tam sayı değişkeni tanımladık. Kullanıcıdan sayı alırken 'scanf' fonksiyonunu kullanıyoruz ve sayının durumunu kontrol etmek için 'if-else' yapısını kullanıyoruz. */",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:41.453109"
  },
  {
    "question": "Bir öğrencinin notunu alarak harf notunu veren bir C programı yazın. Programda değişkenleri ve veri tiplerini kullanarak uygun şekilde not aralıklarını kontrol edin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float not;  // Öğrenci notu için bir float değişkeni tanımlıyoruz.\n    char harfNotu;  // Harf notunu tutmak için bir char değişkeni tanımlıyoruz.\n\n    printf(\"Öğrenci notunu giriniz: \");\n    scanf(\"%f\", &not);  // Kullanıcıdan öğrenci notunu alıyoruz.\n\n    // Not aralıklarına göre harf notunu belirliyoruz.\n    if (not >= 90 && not <= 100) {\n        harfNotu = 'A';\n    } else if (not >= 80) {\n        harfNotu = 'B';\n    } else if (not >= 70) {\n        harfNotu = 'C';\n    } else if (not >= 60) {\n        harfNotu = 'D';\n    } else if (not >= 0) {\n        harfNotu = 'F';\n    } else {\n        printf(\"Geçersiz not!\\n\");\n        return 1;  // Geçersiz not girildiğinde programdan çıkıyoruz.\n    }\n\n    printf(\"Harf notu: %c\\n\", harfNotu);\n    return 0;\n}\n\n/* Bu programda 'float' veri tipi kullanarak bir not değişkeni tanımladık ve 'char' veri tipi ile harf notunu sakladık. Kullanıcının girdiği not aralıklarına göre harf notunu belirlemek için 'if-else' yapısını kullandık. */",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:41.453165"
  },
  {
    "question": "C dilinde, kullanıcıdan alınan bir dizi sayı için pozitif ve negatif sayıların ayrı ayrı toplamını bulan bir program yazın. Değişken türlerini uygun şekilde seçin ve açıklamalar ekleyin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int n; // dizi boyutu için tamsayı değişkeni\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    int sayilar[n]; // kullanıcının belirlediği boyutta bir dizi\n    int pozitifToplam = 0; // pozitif sayılar için toplam\n    int negatifToplam = 0; // negatif sayılar için toplam\n\n    // Kullanıcıdan dizi elemanlarını alma\n    for (int i = 0; i < n; i++) {\n        printf(\"Sayiyi girin: \");\n        scanf(\"%d\", &sayilar[i]);\n\n        // Pozitif veya negatif toplam hesaplama\n        if (sayilar[i] > 0) {\n            pozitifToplam += sayilar[i];\n        } else if (sayilar[i] < 0) {\n            negatifToplam += sayilar[i];\n        }\n    }\n\n    // Sonuçları yazdırma\n    printf(\"Pozitif toplam: %d\\n\", pozitifToplam);\n    printf(\"Negatif toplam: %d\\n\", negatifToplam);\n\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan sayı dizisi alarak pozitif ve negatif sayıların toplamını ayrı ayrı hesaplamaktadır. 'int' veri tipi kullanılarak sayılar ve toplamlar için uygun değişkenler tanımlanmıştır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:55.982191"
  },
  {
    "question": "Bir C programı yazarak, bir dizi içinde yer alan en büyük ve en küçük sayıyı bulan bir algoritma geliştirin. Veri tiplerini ve döngü yapılarını etkin kullanarak bu işlemi gerçekleştirin.",
    "answer": "#include <stdio.h>\n#include <limits.h> // INT_MAX ve INT_MIN için gerekli kütüphane\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    int sayilar[n]; // Kullanıcının belirlediği boyutta bir dizi\n    int enBuyuk = INT_MIN; // Başlangıçta en büyük sayı için en küçük tam sayı değeri\n    int enKucuk = INT_MAX; // Başlangıçta en küçük sayı için en büyük tam sayı değeri\n\n    // Kullanıcıdan dizi elemanlarını alma\n    for (int i = 0; i < n; i++) {\n        printf(\"Sayiyi girin: \");\n        scanf(\"%d\", &sayilar[i]);\n\n        // En büyük ve en küçük değerleri güncelleme\n        if (sayilar[i] > enBuyuk) {\n            enBuyuk = sayilar[i];\n        }\n        if (sayilar[i] < enKucuk) {\n            enKucuk = sayilar[i];\n        }\n    }\n\n    // Sonuçları yazdırma\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n    printf(\"En küçük sayı: %d\\n\", enKucuk);\n\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir dizi sayı alarak bu dizideki en büyük ve en küçük sayıyı bulmaktadır. 'int' veri tipi ile sayılar ve karşılaştırmalar yapılarak doğru sonuçlar elde edilmektedir. INT_MAX ve INT_MIN sabitleri, başlangıç değerleri için kullanılmıştır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:21:55.982257"
  },
  {
    "question": "Bir fonksiyonda iki tam sayıyı toplamak için 'int' veri tipini kullanıyorum. Ancak toplama işlemi sonucunun 'int' veri tipinin sınırlarını aşabileceğini göz önünde bulundurarak bunu nasıl optimize edebilirim?",
    "answer": "Bu durumda, önce toplama işlemi için daha büyük bir veri tipi kullanmalısınız. 'long long' veri tipini kullanarak bu sorunu çözebilirsiniz. Örnek bir kod parçası: \n\n```c\n#include <stdio.h>\n\nlong long topla(long long a, long long b) {\n    return a + b;\n}\n\nint main() {\n    long long sayi1 = 1000000000;\n    long long sayi2 = 2000000000;\n    printf(\"Toplam: %lld\\n\", topla(sayi1, sayi2));\n    return 0;\n}\n```\nBu sayede, toplama işlemi sonucu 'int' sınırlarını aşsa bile, 'long long' veri tipi ile bu problemi aşabilirsiniz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:22:09.809525"
  },
  {
    "question": "Bir dizinin elemanlarını sıralamak için 'float' veri tipini kullanıyorum ama bazen tam sayılar ile işlem yapmam gerekiyor. Bu durumu nasıl daha verimli bir şekilde yönetebilirim?",
    "answer": "Bu durumda, 'float' yerine 'double' veri tipini kullanmak daha uygun olacaktır. 'double', hem tam sayıları hem de ondalıklı sayıları daha geniş bir aralıkla saklayabilir. Ayrıca, diziyi sıralarken tam sayı verilerini de daha iyi yönetirsiniz. İşte bir örnek: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(double *)a - *(double *)b);\n}\n\nint main() {\n    double dizi[] = {3.5, 2.1, 4, 0.9, 7};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n\n    qsort(dizi, boyut, sizeof(double), compare);\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%.2f \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu şekilde, hem tam sayılar hem de ondalıklı sayılar ile işlem yapabilir ve sıralama işlemini daha verimli bir şekilde gerçekleştirebilirsiniz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:22:09.809589"
  },
  {
    "question": "C dilinde büyük veri setlerini yönetmek için bir yapı (struct) tanımlarken hangi veri tiplerini kullanmalıyım ve bellek kullanımını nasıl optimize edebilirim?",
    "answer": "Büyük veri setleri ile çalışırken, yapı tanımlarken veri tiplerini seçerken dikkatli olmak önemlidir. Örneğin, eğer yalnızca 0-255 aralığında tamsayı değerleri tutacaksanız 'unsigned char' kullanmak daha uygun olabilir. Bu hem bellek tasarrufu sağlar hem de performansı artırır. Ayrıca, veri yapılarını oluştururken 'bit field' kullanarak daha fazla alan tasarrufu sağlanabilir. Örneğin:\n\n```c\nstruct DataSet {\n    unsigned char type : 3; // 3 bit\n    unsigned char value : 5; // 5 bit\n};\n```\n\nBu yapı, toplamda 1 bayt alan kullanarak 8 bit veri tutar. Bu tür optimizasyonlar, bellek kullanımını ve erişim sürelerini iyileştirir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:22:19.329613"
  },
  {
    "question": "C dilinde dinamik bellek yönetimi yaparken hangi veri tiplerini ve fonksiyonları kullanmalıyım? Bellek sızıntılarını nasıl önleyebilirim?",
    "answer": "Dinamik bellek yönetimi için genellikle 'malloc', 'calloc', 'realloc' ve 'free' fonksiyonları kullanılır. Kullanıcıdan alınan verileri tutmak için 'char*' veya 'void*' gibi veri tipleri tercih edilebilir. Bellek sızıntılarını önlemek için her allocated (ayrılmış) bellek bloğunun serbest bırakıldığından emin olmalısınız. Örneğin:\n\n```c\nchar* buffer = (char*) malloc(256 * sizeof(char));\nif (buffer == NULL) {\n    // Hata durumu\n}\n\n// Kullanım\nstrcpy(buffer, \"Örnek veri\");\n\n// İşlem tamamlandıktan sonra\nfree(buffer); // Belleği serbest bırakın\n```\n\nAyrıca, bellek sızıntılarını tespit etmek için 'valgrind' gibi araçlar kullanabilirsiniz. Bu, programınızın çalışması sırasında hangi bellek alanlarının serbest bırakılmadığını gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-05-31T16:22:19.329664"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak, iki sayının toplamını hesaplayın ve sonucu ekrana yazdırın.\\nint main() {\\n    int a = 5;\\n    int b = 10;\\n    int toplam;\\n    toplam = ;\\n    printf('Toplam: %d', toplam);\\n    return 0;\\n}",
    "answer": "Kodun eksik kısmını toplam = a + b; şeklinde tamamlayarak, iki sayının toplamını hesaplayabilirsiniz.\\n\\nTamamlanmış kod: \\nint main() {\\n    int a = 5;\\n    int b = 10;\\n    int toplam;\\n    toplam = a + b; // a ve b'nin toplamı hesaplandı.\\n    printf('Toplam: %d', toplam); // Sonuç ekrana yazdırıldı.\\n    return 0;\\n}\\n\\nBu kodda, a ve b değişkenleri tanımlanmış ve toplam değişkenine a ile b'nin toplamı atanmıştır. Daha sonra, toplam değeri ekrana yazdırılmıştır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:32.091910"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olduğunu kontrol edin ve sonucu ekrana yazdırın.\\nint main() {\\n    int sayi;\\n    printf('Bir sayı girin: ');\\n    scanf('%d', &sayi);\\n    if (sayi ) {\\n        printf('Sayı pozitif.');\\n    } else if (sayi ) {\\n        printf('Sayı negatif.');\\n    } else {\\n        printf('Sayı sıfır.');\\n    }\\n    return 0;\\n}",
    "answer": "Kodun eksik kısımlarını if (sayi > 0), else if (sayi < 0) şeklinde tamamlayarak, sayının pozitif, negatif veya sıfır olup olmadığını kontrol edebilirsiniz.\\n\\nTamamlanmış kod: \\nint main() {\\n    int sayi;\\n    printf('Bir sayı girin: ');\\n    scanf('%d', &sayi);\\n    if (sayi > 0) { // Eğer sayı pozitif ise.\\n        printf('Sayı pozitif.');\\n    } else if (sayi < 0) { // Eğer sayı negatif ise.\\n        printf('Sayı negatif.');\\n    } else { // Eğer sayı sıfır ise.\\n        printf('Sayı sıfır.');\\n    }\\n    return 0;\\n}\\n\\nBu kodda, kullanıcıdan bir sayı girmesi istenir. Girilen sayının pozitif, negatif veya sıfır olup olmadığı if-else yapısı ile kontrol edilir ve uygun mesaj ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:32.092077"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak, kullanıcıdan alınan iki sayının toplamını ve farkını hesaplayın. Kodun eksik kısmını tamamlayın:\n\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n\n    int toplam;\n    int fark;\n\n    // Eksik kısmı tamamlayın\n\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Fark: %d\\n\", fark);\n    return 0;\n}",
    "answer": "Kodda eksik olan kısımda 'toplam' ve 'fark' değişkenlerini hesaplamamız gerekiyor. Bu değişkenleri, 'sayi1' ve 'sayi2' değişkenlerinin toplamı ve farkı olarak tanımlamalıyız. İşte tamamlanmış kod:\n\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n\n    int toplam;\n    int fark;\n\n    toplam = sayi1 + sayi2;  // 'toplam' değişkenini hesaplıyoruz\n    fark = sayi1 - sayi2;    // 'fark' değişkenini hesaplıyoruz\n\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Fark: %d\\n\", fark);\n    return 0;\n}\n\nBu kod, kullanıcıdan iki sayı alır ve bu sayıların toplamı ile farkını ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:44.553330"
  },
  {
    "question": "Aşağıdaki kodda eksik olan yerleri tamamlayarak, hem kullanıcının girdiği sayının pozitif, negatif veya sıfır olduğunu kontrol eden hem de sayının karesini hesaplayan bir program yazın:\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Eksik kısmı tamamlayın\n\n    return 0;\n}",
    "answer": "Bu programda, önce kullanıcının girdiği sayının pozitif, negatif veya sıfır olup olmadığını kontrol etmemiz gerekiyor. Ayrıca, sayının karesini de hesaplamalıyız. Aşağıda eksik kısımlar tamamlanmış hali verilmiştir:\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Sayının pozitif, negatif veya sıfır olduğunu kontrol ediyoruz\n    if (sayi > 0) {\n        printf(\"Sayı pozitiftir.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Sayı negatiftir.\\n\");\n    } else {\n        printf(\"Sayı sıfırdır.\\n\");\n    }\n\n    // Sayının karesini hesaplıyoruz\n    int kare = sayi * sayi;\n    printf(\"Sayının karesi: %d\\n\", kare);\n\n    return 0;\n}\n\nBu kod, kullanıcıdan bir sayı alır, sayının pozitif, negatif veya sıfır olduğunu belirler ve aynı zamanda sayının karesini hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:44.553440"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak iki sayının maksimumunu bulan bir fonksiyon yazınız. Fonksiyon, iki tam sayı almalı ve maksimum değeri döndürmelidir.",
    "answer": "#include <stdio.h>\n\nint maksimum(int a, int b) {\n    return (a > b) ? a : b; // Ternary operatör kullanarak maksimum değeri döndür\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Maksimum: %d\\n\", maksimum(x, y));\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:55.561566"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir fonksiyon yazınız. Fonksiyon, bir tam sayı almalı ve sonucu ekrana yazdırmalıdır.",
    "answer": "#include <stdio.h>\n\nvoid kontrol(int sayi) {\n    if (sayi > 0) {\n        printf(\"Pozitif\\n\");\n    } else if (sayi < 0) {\n        printf(\"Negatif\\n\");\n    } else {\n        printf(\"Sıfır\\n\");\n    }\n}\n\nint main() {\n    int x = -5;\n    kontrol(x);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:22:55.561632"
  },
  {
    "question": "Aşağıdaki kodda bir hata var. Hatanın ne olduğunu bul ve düzelt: int a = 5; int b = 10; int c = a b; printf('%d', c);",
    "answer": "Kodda 'a b' ifadesi geçerli bir operatör kullanmıyor. Doğru bir toplama işlemi yapmak için '+' operatörünü kullanmalıyız. Düzgün kod şu şekilde olmalıdır: int c = a + b; printf('%d', c);. Bu şekilde, 'a' ve 'b' değerleri toplanarak 'c' değişkenine atanır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:01.300235"
  },
  {
    "question": "Aşağıdaki kodu inceleyin. Hata var, bulun ve düzeltin: float x = 5.5; float y = 2.0; int z = x / y; printf('%d', z);",
    "answer": "Kodda, 'x / y' ifadesinin sonucu bir float değeridir, ancak bu değer int türüne atanıyor. Bu, veri kaybına neden olur. Bu durumu düzeltmek için 'z' değişkeninin türünü float olarak değiştirmeliyiz ya da sonucu int'e dönüştürmeliyiz. Düzgün kod şöyle olmalıdır: float z = x / y; printf('%f', z); veya int z = (int)(x / y); printf('%d', z);.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:01.300295"
  },
  {
    "question": "Aşağıdaki C kodu, iki sayının toplamını hesaplamak için yazılmıştır. Ancak kod hatalı ve beklenmeyen sonuçlar veriyor. Hatanın kaynağını bulun ve düzeltin. Kod: \n\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    int toplam;\n    toplam = a + b;\n    printf(\"Toplam: %d\", toplam);\n    return 0;\n}",
    "answer": "Kodda görünürde bir hata yok. Ancak, eğer toplam değişkenini tanımlamadan önce başka bir yerde tekrar tanımlarsanız, beklenmedik sonuçlarla karşılaşabilirsiniz. \"toplam\" değişkeninin global veya yerel olarak tekrar tanımlanıp tanımlanmadığını kontrol edin. Ayrıca, toplam değerinin doğru bir şekilde yazdırıldığından emin olun. Kodu aşağıdaki gibi düzenleyebilirsiniz:\n\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    int toplam;\n    toplam = a + b;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\nBurada, toplam değişkeninin toplam değeri doğru bir şekilde hesaplanıyor. Ayrıca, printf fonksiyonundaki format dizesinde \"\\n\" ekleyerek çıktıyı daha okunabilir hale getirdik.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:15.806532"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcıdan bir sayı alınıp, bu sayının çift mi tek mi olduğunu kontrol etmek için yazılmıştır. Ancak kod beklenmeyen sonuçlar veriyor. Hatanın kaynağını bulun ve düzeltin. Kod: \n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", sayi);\n    if (sayi % 2 = 0) {\n        printf(\"Sayı çifttir.\");\n    } else {\n        printf(\"Sayı tektir.\");\n    }\n    return 0;\n}",
    "answer": "Kodda iki hata mevcut. İlk olarak, scanf fonksiyonunda, sayi değişkeninin adresini belirtmek için \"&\" operatörünü kullanmalısınız. İkinci hata ise, if koşulundaki eşittir operatörüdür. Burada, \"=\" atama operatörüdür; bunun yerine \"==\" karşılaştırma operatörünü kullanmalısınız. Aşağıda düzeltilmiş kodu bulabilirsiniz:\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (sayi % 2 == 0) {\n        printf(\"Sayı çifttir.\");\n    } else {\n        printf(\"Sayı tektir.\");\n    }\n    return 0;\n}\n\nBu düzeltmeler sonrasında program doğru bir şekilde çalışacak ve kullanıcının girdiği sayının çift mi yoksa tek mi olduğunu doğru bir şekilde belirleyecektir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:15.806671"
  },
  {
    "question": "Aşağıdaki C kodunda '==', '!=' ve '===' operatörleri kullanılarak karşılaştırmalar yapılmıştır. Bu kodun çıktısını tahmin edin ve hatayı düzeltin: \n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 5;\n    if (a === b) {\n        printf(\"Eşitler\\n\");\n    } else if (a != b) {\n        printf(\"Farklılar\\n\");\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda '===' operatörü C dilinde tanımlı bir operatör değildir. C dilinde sadece '==' operatörü kullanılır. '===' operatörü JavaScript'te bulunur. Düzeltmek için '===' yerine '==' yazmalıyız. Ayrıca '!=', '==' operatörleri ile birlikte kullanıldığında mantıklı bir akış sağlanır. Düzgün kod şu şekilde olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 5;\n    if (a == b) {\n        printf(\"Eşitler\\n\");\n    } else if (a != b) {\n        printf(\"Farklılar\\n\");\n    }\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:26.367603"
  },
  {
    "question": "Aşağıdaki kodda bitwise operatörler kullanılarak bir sayı üzerinde işlemler yapılmıştır. Ancak beklenmedik bir çıktı alınıyor. Hata nerede? \n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 5; // 0101\n    int y = 3; // 0011\n    int z = x & y;\n    printf(\"Sonuç: %d\\n\", z);\n    if (z = 3) {\n        printf(\"Z değeri 3'tür\\n\");\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda 'if (z = 3)' ifadesinde bir hata var. Burada bir atama işlemi yapılıyor (z'yi 3'e eşitleme), bu da 'z' değişkenine 3 değerini atar ve if ifadesi her zaman doğru olarak değerlendirilir. Bu, muhtemelen bir karşılaştırma yapılmak istenmiş. Düzeltmek için '==' operatörü kullanılmalıdır. Doğru kod şöyle olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 5; // 0101\n    int y = 3; // 0011\n    int z = x & y;\n    printf(\"Sonuç: %d\\n\", z);\n    if (z == 3) {\n        printf(\"Z değeri 3'tür\\n\");\n    }\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:26.367728"
  },
  {
    "question": "Bir int değişkeninin değerini iki katına çıkarmak için hangi operatörü kullanmalıyım ve nasıl uygulanır?",
    "answer": "C dilinde bir int değişkeninin değerini iki katına çıkarmak için çarpma operatörü (*) kullanılabilir. Örneğin, aşağıdaki gibi bir kod yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 5; // sayi değişkenine 5 atıyoruz\n    sayi = sayi * 2; // sayi değişkenini 2 ile çarpıyoruz\n    printf(\"Yeni değer: %d\\n\", sayi); // Yeni değeri ekrana yazdırıyoruz\n    return 0;\n}\n```\nBu kod çalıştırıldığında, \"Yeni değer: 10\" çıktısını verecektir. Burada, sayi değişkeninin değeri önce 5, sonra 2 ile çarpılarak 10 olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:35.720142"
  },
  {
    "question": "Mantıksal AND (&&) operatörünü bir koşul ifadesinde nasıl kullanabilirim?",
    "answer": "Mantıksal AND (&&) operatörü, iki koşulun da doğru olup olmadığını kontrol etmek için kullanılır. Örneğin, bir kişinin oy kullanabilmesi için 18 yaşında olması ve Türkiye Cumhuriyeti vatandaşı olması gerektiğini varsayalım:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int yas = 20;\n    int vatandas = 1; // 1: evet, 0: hayır\n\n    if (yas >= 18 && vatandas) {\n        printf(\"Oy kullanabilirsiniz.\\n\");\n    } else {\n        printf(\"Oy kullanamazsınız.\\n\");\n    }\n    return 0;\n}\n```\nBurada yas değişkeni 20 ve vatandas değişkeni 1 olduğu için koşul sağlanır ve \"Oy kullanabilirsiniz.\" yazdırılır. Eğer yas 17 olsaydı ya da vatandas 0 olsaydı, \"Oy kullanamazsınız.\" çıktısı alınırdı.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:35.720183"
  },
  {
    "question": "C dilinde bir değişkenin değeri ile toplama ve çıkarma işlemlerini nasıl gerçekleştirebilirim? Örnek bir senaryo ile açıkla.",
    "answer": "C dilinde değişkenler üzerinde toplama ve çıkarma işlemleri yapmak için '+' ve '-' operatörlerini kullanırız. Örneğin, bir kullanıcının birikim miktarını takip eden bir program düşünelim. Kullanıcının başlangıçta 1000 TL'si olsun ve her ay bu miktara 200 TL eklesin. Ayrıca, her ay 50 TL harcama yapsın. Kod örneği aşağıdaki gibidir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int birikim = 1000; // Başlangıç birikimi\n    int ekleme = 200;   // Her ay eklenen miktar\n    int harcama = 50;   // Her ay harcanan miktar\n\n    for(int ay = 1; ay <= 12; ay++) { // 12 ay için döngü\n        birikim = birikim + ekleme; // Toplama işlemi\n        birikim = birikim - harcama; // Çıkarma işlemi\n        printf(\"Ay %d: Birikim = %d TL\\n\", ay, birikim);\n    }\n    return 0;\n}\n```\nBu kodda, her ay birikim miktarı önce 200 TL artırılır, daha sonra 50 TL azaltılır. Böylece her ay sonunda kullanıcının birikim durumu yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:57.656502"
  },
  {
    "question": "C dilinde karşılaştırma operatörlerini kullanarak bir programda nasıl koşullu ifadeler oluşturabilirim? Somut bir örnekle göster.",
    "answer": "C dilinde karşılaştırma operatörleri (==, !=, <, >, <=, >=) ile koşullu ifadeler oluşturabiliriz. Örneğin, bir öğrencinin notunun geçip geçmediğini kontrol eden bir program yazalım. Geçme notu 60 olarak belirlensin. Kod örneği aşağıdaki gibidir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Lütfen notunuzu girin: \");\n    scanf(\"%d\", &not);\n\n    // Koşullu ifadeler\n    if (not >= 60) {\n        printf(\"Tebrikler! Geçtiniz.\\n\");\n    } else {\n        printf(\"Üzgünüm, kaldınız.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, kullanıcıdan not alınmakta ve bu notun 60 veya daha yüksek olup olmadığı kontrol edilmektedir. Eğer not 60 veya daha yüksekse \"Geçtiniz\" mesajı; aksi takdirde \"Kaldınız\" mesajı yazdırılmaktadır. Bu, koşullu ifadelerin nasıl kullanılacağını gösteren basit bir örnektir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:23:57.656552"
  },
  {
    "question": "C dilinde birlikte ve bitwise operatörlerinin kullanımını gösteren bir örnek verin. Bu operatörler arasındaki fark nedir?",
    "answer": "C dilinde birlikte (logical) ve bitwise (bit düzeyinde) operatörler, farklı amaçlar için kullanılır. Örneğin, bitwise operatörler sayının her bir bitini ayrı ayrı işlemek için kullanılırken, birlikte operatörler tüm ifadenin mantıksal sonucunu belirlemek için kullanılır.\n\nÖrnek kod:\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5; // 0101\n    int b = 3; // 0011\n    \n    // Bitwise AND\n    int result_and = a & b; // Sonuç: 0001 (1)\n    // Bitwise OR\n    int result_or = a | b; // Sonuç: 0111 (7)\n    // Bitwise XOR\n    int result_xor = a ^ b; // Sonuç: 0110 (6)\n    \n    // Logical AND\n    if (a > 0 && b > 0) {\n        printf(\"a ve b pozitif.\\n\"); // Çıktı: a ve b pozitif.\n    }\n    \n    printf(\"Bitwise AND sonucu: %d\\n\", result_and);\n    printf(\"Bitwise OR sonucu: %d\\n\", result_or);\n    printf(\"Bitwise XOR sonucu: %d\\n\", result_xor);\n    return 0;\n}\n```\nBu kod parçasında, \n- `&` bitwise AND operatörüdür ve her iki sayının bitlerini karşılaştırır, sadece her iki bit de 1 olduğunda 1 döner.\n- `|` bitwise OR operatörüdür ve en az bir bit 1 olduğunda sonuç 1 olur.\n- `^` bitwise XOR operatörüdür ve bitler farklıysa 1 döner.\n- `&&` ise birlikte AND operatörüdür ve iki koşulun da doğru olması gerektiğini kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:10.286235"
  },
  {
    "question": "C dilinde ternary operatörün (üçlü operatör) kullanımını gösterin. Gerçek bir senaryo ile açıklayın.",
    "answer": "Ternary operatör, bir koşulu kontrol etmek ve bu koşula bağlı olarak iki farklı sonuç döndürmek için kullanılan kısa bir if-else yapısıdır. Bu operatör, kodun daha okunabilir ve kompakt olmasını sağlar.\n\nÖrnek kod:\n```c\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n    \n    // Ternary operatör kullanımı\n    char* result = (age >= 18) ? \"Yetişkin\" : \"Çocuk\";\n    printf(\"Sonuç: %s\\n\", result);\n    return 0;\n}\n```\nBu örnekte, kullanıcıdan yaş girişi alınır ve bu yaşa göre \"Yetişkin\" veya \"Çocuk\" olarak bir sonuç döndürülür. Ternary operatör `(age >= 18) ? \"Yetişkin\" : \"Çocuk\"` ifadesinde, `age` 18 veya daha büyükse \"Yetişkin\" döner, aksi halde \"Çocuk\" döner. Bu yapı, uzun if-else blokları yerine daha okunabilir bir çözüm sunar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:10.286284"
  },
  {
    "question": "Bir kullanıcının yaşını alarak, bu yaşın 18'den büyük olup olmadığını kontrol eden bir program yazın. Eğer kullanıcı 18 yaşından büyükse ekrana 'Reşit' yazdırın, değilse 'Reşit değil' yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı giriniz: \");\n    scanf(\"%d\", &yas);\n\n    // Operatör ile yaş kontrolü yapılıyor\n    if (yas > 18) {\n        printf(\"Reşit\\n\");\n    } else {\n        printf(\"Reşit değil\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir yaş girmesini ister. Girilen yaş, 18'den büyükse 'Reşit', değilse 'Reşit değil' mesajı ekrana yazdırılır. Operatör (>) kullanılarak yaş kontrolü yapılmaktadır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:24.065035"
  },
  {
    "question": "İki sayının toplamını, farkını, çarpımını ve bölümünü hesaplayan bir C programı yazın. Kullanıcıdan iki tam sayı alın ve sonuçları ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İki tam sayı giriniz: \");\n    scanf(\"%d %d\", &sayi1, &sayi2);\n\n    // Operatörler ile matematiksel işlemler yapılıyor\n    int toplam = sayi1 + sayi2;\n    int fark = sayi1 - sayi2;\n    int carpim = sayi1 * sayi2;\n    float bolum = (float)sayi1 / sayi2; // Bölüm işlemi float dönüşümü gerektiriyor\n\n    // Sonuçları ekrana yazdırma\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Fark: %d\\n\", fark);\n    printf(\"Çarpım: %d\\n\", carpim);\n    printf(\"Bölüm: %.2f\\n\", bolum);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan iki tam sayıyı alır ve bu sayılar üzerinde toplama, çıkarma, çarpma ve bölme işlemleri yaparak sonuçları ekrana yazdırır. Operatörler (+, -, *, /) kullanılarak bu işlemler gerçekleştirilmektedir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:24.065102"
  },
  {
    "question": "Bir tamsayının pozitif, negatif veya sıfır olup olmadığını belirleyen bir C programı yaz.",
    "answer": "Aşağıda, bir tamsayının pozitif, negatif veya sıfır olup olmadığını kontrol eden basit bir C programı bulunmaktadır. Bu program, kullanıcıdan bir tamsayı girmesini ister ve ardından koşul operatörlerini kullanarak sayının durumunu belirler.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tam sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"%d pozitif bir sayıdır.\\n\", sayi);\n    } else if (sayi < 0) {\n        printf(\"%d negatif bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"Sayı sıfırdır.\\n\");\n    }\n\n    return 0;\n}\n```\nBu programda, `if` ve `else if` yapıları ile koşul operatörleri (`>`, `<`) kullanılarak sayının durumu belirlenir ve kullanıcıya uygun mesaj verilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:35.443776"
  },
  {
    "question": "Bir öğrencinin notunu alarak geçip geçmediğini kontrol eden bir C programı yaz. Geçme notu 60'tır.",
    "answer": "Aşağıda, bir öğrencinin notunu kontrol eden ve geçip geçmediğini belirten bir C programı bulunmaktadır. Bu program, kullanıcıdan öğrencinin notunu alır ve ternary operatörü kullanarak geçip geçmediğini belirler.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Öğrencinin notunu girin: \");\n    scanf(\"%d\", &not);\n\n    // Ternary operatörü kullanarak geçme durumunu kontrol et\n    printf(\"Öğrenci %s.\\n\", (not >= 60) ? \"geçti\" : \"kaldı\");\n\n    return 0;\n}\n```\nBu programda, kullanıcıdan alınan not, `>=` operatörü ile 60 ile karşılaştırılır ve ternary operatörü sayesinde kısaca 'geçti' veya 'kaldı' mesajı verilir. Bu, hem kodu daha kısa yazmayı sağlar hem de okunabilirliği artırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:35.443823"
  },
  {
    "question": "C dilinde bit düzeyinde (bitwise) operatörleri kullanarak iki sayının maksimumunu bulan bir fonksiyon yazınız ve açıklayınız.",
    "answer": "Bit düzeyinde operatörler, genellikle verilerin düşük seviyeli işlemlerinde kullanılır. İki sayının maksimumunu bulmak için, bitwise operatörlerin değil, aritmetik işlemlerin kullanılacağı bir yöntem geliştireceğiz. Ancak, bitwise operatörler ile bu işlemi yapmanın daha ilginç bir yolu vardır. Önerilen yöntem, (a - b) bitwise işlemini kullanarak, büyük olanı belirlemektir. İşte örnek kod:\n\n```c\n#include <stdio.h>\n\nint max(int a, int b) {\n    return (a ^ ((a ^ b) & -(a < b)));\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Maksimum: %d\\n\", max(x, y));\n    return 0;\n}\n```\n\nAçıklama: Fonksiyon, a ve b'nin bitwise XOR'unu alır ve bu değer ile a'nın b'den küçük olup olmadığını kontrol eden birşey yapar. Eğer b, a'dan büyükse, -(a < b) işlemi 1 (true) olur ve bu durumda bitwise işlemlerle a'nın yerine b'yi döndürür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:56.756049"
  },
  {
    "question": "C dilinde, mantıksal operatörler (&&, ||) kullanarak bir öğrenci notunun geçip geçmediğini kontrol eden bir fonksiyon yazınız. Bu fonksiyon, notun 60'tan büyük veya eşit olup olmadığını ve devamsızlığın %20'den az olup olmadığını kontrol etmelidir.",
    "answer": "Mantıksal operatörler, birden fazla koşulun bir arada değerlendirilmesi için idealdir. Öğrencinin notu ve devamsızlık oranının kontrolü için bu operatörleri kullanarak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nint isPassed(int grade, float attendance) {\n    return (grade >= 60 && attendance < 20);\n}\n\nint main() {\n    int grade = 65;\n    float attendance = 15.0;\n\n    if (isPassed(grade, attendance)) {\n        printf(\"Öğrenci Geçti!\\n\");\n    } else {\n        printf(\"Öğrenci Kaldı!\\n\");\n    }\n\n    return 0;\n}\n```\n\nAçıklama: Fonksiyon, öğrencinin notunu ve devamsızlık oranını alır. Her iki koşulun da sağlanıp sağlanmadığını kontrol eder. Eğer not 60 veya daha büyükse ve devamsızlık oranı %20'den az ise, öğrenci geçer. Bu, mantıksal AND operatörü olan `&&` kullanılarak yapılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:24:56.756135"
  },
  {
    "question": "Aşağıdaki C kodunda, operatörlerin kullanımıyla ilgili bir optimizasyon yapın. Kodda bulunan 'a' ve 'b' değişkenlerini kullanarak toplamlarını kontrol eden bir fonksiyon var. Ancak, gereksiz hesaplamalar yapılıyor. Gerekirse yeniden yazın.",
    "answer": "Kodun mevcut hali şu şekilde olabilir:\n\n```c\n#include <stdio.h>\n\nvoid check_sum(int a, int b) {\n    if (a + b > 10) {\n        printf(\"Toplam 10'dan büyük\\n\");\n    } else {\n        printf(\"Toplam 10 veya daha küçük\\n\");\n    }\n}\n```  \nBu kodda 'a + b' toplamı her durumda yeniden hesaplanıyor. Bunun yerine, toplamı bir değişkene atayıp onu kontrol edebiliriz. Aşağıdaki gibi optimize edebiliriz:\n\n```c\n#include <stdio.h>\n\nvoid check_sum(int a, int b) {\n    int sum = a + b; // Toplamı bir değişkene atıyoruz\n    if (sum > 10) {\n        printf(\"Toplam 10'dan büyük\\n\");\n    } else {\n        printf(\"Toplam 10 veya daha küçük\\n\");\n    }\n}\n```  \nBu sayede toplam her defasında yeniden hesaplanmak yerine sadece bir kez hesaplanıyor, bu da performansı artırabilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:25:07.393775"
  },
  {
    "question": "Aşağıdaki C kodunu inceleyin ve '++' operatörünün kullanımıyla ilgili bir iyileştirme yapın. Kod, bir dizi üzerindeki elemanları artırmak için '++' operatörünü kullanıyor. Ancak, bu kullanımda bir hata var. Düzeltin ve açıklayın.",
    "answer": "Mevcut kod şu şekilde olabilir:\n\n```c\n#include <stdio.h>\n\nvoid increment_array(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        ++arr[i]; // Elemanları artırma\n    }\n}\n```  \nBurada '++arr[i]' operatörü kullanılarak, dizi elemanları artırılmakta. Ancak bu durumda, dizinin elemanlarını artırmak yerine, dizinin kendisine atama yapılmadığı için bu kullanım doğru değil. Tüm elemanlar artırılmak yerine, sadece değişkenin değeri artırılıyor. Aşağıdaki gibi düzeltebiliriz:\n\n```c\n#include <stdio.h>\n\nvoid increment_array(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        arr[i]++; // Elemanları artırma\n    }\n}\n```  \nBu durumda, her elemanın değeri doğru bir şekilde artırılmakta. Ayrıca, 'arr[i]++' ile '++arr[i]' arasında performans açısından bir fark yoktur, ancak daha yaygın bir kullanım olması açısından 'arr[i]++' tercih edilebilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:25:07.393898"
  },
  {
    "question": "C dilinde bit düzeyinde AND (&) ve OR (|) operatörlerini kullanarak bir sayının tek mi çift mi olduğunu kontrol eden bir fonksiyon yazdım. Ancak performansını artırmak için önerileriniz var mı?",
    "answer": "Aşağıdaki kodu incelediğimizde, sayının çift mi yoksa tek mi olduğunu kontrol etmek için bit düzeyinde operatörler kullanmak çok etkili bir yaklaşımdır. Ancak kodun daha okunabilir ve optimize edilmiş bir versiyonunu yazmak her zaman faydalıdır. İşte örnek kod:\n\n```c\n#include <stdio.h>\n\nint is_even(int number) {\n    return !(number & 1);  // Eğer LSB (en düşük bit) 0 ise çift, 1 ise tek\n}\n\nint main() {\n    int num = 5;\n    if (is_even(num)) {\n        printf(\"%d sayısı çifttir.\\n\", num);\n    } else {\n        printf(\"%d sayısı tektir.\\n\", num);\n    }\n    return 0;\n}\n```\n\nYukarıdaki kodda `!` operatörü ile sonucu tersine çevirerek daha okunabilir hale getirdik. Ayrıca, bu yöntem, bit düzeyinde işlemlerle performansı artırırken işlemin mantığını da netleştirir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:25:19.551200"
  },
  {
    "question": "Bir dizi içerisindeki elemanları 1'den 100'e kadar olan sayılarla çarpan bir fonksiyon yazdım. Kodun içinde ternary operatör kullanmam gerekti, fakat bu kullanım hem karmaşık hem de performans açısından zayıf gözüküyor. Nasıl bir iyileştirme yapabilirim?",
    "answer": "Ternary operatör kullanımı bazen kullanılabilir ama fazla karmaşık hale geldiğinde okunabilirliği olumsuz etkileyebilir. İşte dizi elemanlarını 1 ile 100 arasında bir sayıyla çarpan örnek bir kod:\n\n```c\n#include <stdio.h>\n\nvoid multiply_array(int arr[], int length, int multiplier) {\n    for (int i = 0; i < length; i++) {\n        arr[i] = (multiplier >= 1 && multiplier <= 100) ? arr[i] * multiplier : arr[i];\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int length = sizeof(numbers) / sizeof(numbers[0]);\n    multiply_array(numbers, length, 50);\n\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    return 0;\n}\n```\n\nBurada, `ternary` operatörü yerine bir `if` bloğu kullanmak, kodu daha okunabilir yapar. Ayrıca, kontrol şartını fonksiyon içinde doğrudan yönetmek, gereksiz karmaşıklığı ortadan kaldırır. Eğer `multiplier` 1 ile 100 arasında değilse, çarpma işlemi yapılmaz. Bu şekilde, kodun performansı ve okunabilirliği artırılmış olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-05-31T16:25:19.551283"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif mi, negatif mi yoksa sıfır mı olduğunu belirleyen bir C programının eksik kodunu tamamlayın. Kodun başlangıcı aşağıdaki gibidir: \n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n    // Buraya kontrol yapısı ekle\n\n    return 0;\n}",
    "answer": "Eksik kodu tamamlamak için if-else yapısını kullanmalıyız. Kullanıcının girdiği sayı pozitifse, negatifse veya sıfırsa bu durumları kontrol edip uygun mesajı yazdırmalıyız. Kodun tamamı şu şekilde olacaktır:\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n    \n    if (sayi > 0) {\n        printf(\"Girdiğiniz sayı pozitif.\");\n    } else if (sayi < 0) {\n        printf(\"Girdiğiniz sayı negatif.\");\n    } else {\n        printf(\"Girdiğiniz sayı sıfır.\");\n    }\n\n    return 0;\n}\n\nBu programda, kullanıcıdan bir sayı alındıktan sonra if-else yapısıyla sayının durumuna göre uygun mesaj yazdırılır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:32.273621"
  },
  {
    "question": "Bir öğrencinin notunu alarak, not aralığına göre 'Başarılı', 'Geçer' veya 'Başarısız' şeklinde bir değerlendirme yapan bir C programının eksik kısmını tamamlayın. Kodun başlangıcı aşağıdaki gibidir: \n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Öğrenci notunu girin: \");\n    scanf(\"%d\", &not);\n    // Buraya kontrol yapısı ekle\n\n    return 0;\n}",
    "answer": "Bu durumda, öğrencinin notunu belirli aralıklara göre değerlendirmek için if-else if yapısını kullanmalıyız. Not 85 ve üzeri başarılı, 60 ile 84 arası geçer, 59 ve altı ise başarısız olarak değerlendirilebilir. Tamamlanmış kod şu şekildedir:\n\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Öğrenci notunu girin: \");\n    scanf(\"%d\", &not);\n    \n    if (not >= 85) {\n        printf(\"Öğrenci: Başarılı\");\n    } else if (not >= 60) {\n        printf(\"Öğrenci: Geçer\");\n    } else {\n        printf(\"Öğrenci: Başarısız\");\n    }\n\n    return 0;\n}\n\nBu kod, kullanıcıdan alınan not değerine göre öğrenciyi başarı durumuna göre değerlendirir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:32.273733"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, kullanıcıdan bir sayı alıp, bu sayının pozitif, negatif veya sıfır olduğunu belirleyen bir program yazın. Kodun eksik kısmını doldurun.\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Buraya kontrol yapısını ekleyin\n\n    return 0;\n}",
    "answer": "Kodun eksik kısmını şu şekilde tamamlayabiliriz:\n\n    if (sayi > 0) {\n        printf(\"Girilen sayı pozitif.\");\n    } else if (sayi < 0) {\n        printf(\"Girilen sayı negatif.\");\n    } else {\n        printf(\"Girilen sayı sıfır.\");\n    }\n\nBu kod, kullanıcının girdiği sayıyı kontrol eder ve sayının pozitif, negatif veya sıfır olduğunu ekrana yazdırır. 'if' yapısı, verilen koşula bağlı olarak farklı kod bloklarını çalıştırmamıza olanak tanır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:42.654583"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, kullanıcıdan bir harf alıp, bu harfin büyük veya küçük harf olduğunu belirleyen bir program yazın. Kodun eksik kısmını doldurun.\n\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char harf;\n    printf(\"Bir harf girin: \");\n    scanf(\" %c\", &harf);\n\n    // Buraya kontrol yapısını ekleyin\n\n    return 0;\n}",
    "answer": "Kodun eksik kısmını şu şekilde tamamlayabiliriz:\n\n    if (isupper(harf)) {\n        printf(\"Girilen harf büyük harf.\");\n    } else if (islower(harf)) {\n        printf(\"Girilen harf küçük harf.\");\n    } else {\n        printf(\"Girilen karakter harf değil.\");\n    }\n\nBu kod, kullanıcının girdiği harfi kontrol eder ve harfin büyük harf, küçük harf ya da bir harf olmadığını ekrana yazdırır. 'isupper' ve 'islower' fonksiyonları, karakterin büyük mü yoksa küçük mü olduğunu belirlemeye yarar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:42.654686"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olduğunu belirleyen bir C programının eksik kodunu tamamlayın. Aşağıdaki kodda yer alan eksiklikleri düzeltin ve programın tamamını yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Kontrol yapısı\n    if (sayi > 0) {\n        printf(\"Girdiğiniz sayı pozitif.\");\n    } else if (sayi < 0) {\n        printf(\"Girdiğiniz sayı negatif.\");\n    } else {\n        printf(\"Girdiğiniz sayı sıfır.\");\n    }\n\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir sayı alır ve bu sayının pozitif, negatif veya sıfır olup olmadığını kontrol etmek için if-else yapısını kullanır. Sayının durumuna göre uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:54.598198"
  },
  {
    "question": "Bir öğrencinin notuna göre harf notunu belirleyen bir C programının eksik kodunu tamamlayın. Aşağıdaki kodda yer alan eksiklikleri düzeltin ve programın tamamını yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float not;\n    printf(\"Öğrencinin notunu girin: \");\n    scanf(\"%f\", &not);\n\n    // Kontrol yapısı\n    if (not >= 90) {\n        printf(\"A\");\n    } else if (not >= 80) {\n        printf(\"B\");\n    } else if (not >= 70) {\n        printf(\"C\");\n    } else if (not >= 60) {\n        printf(\"D\");\n    } else {\n        printf(\"F\");\n    }\n\n    return 0;\n}\n\n// Açıklama: Bu program, öğrencinin notunu alır ve hangi harf notuna karşılık geldiğini belirlemek için bir dizi if-else if kontrol yapısı kullanır. Not aralıklarına göre uygun harf notunu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:25:54.598332"
  },
  {
    "question": "Aşağıdaki C kodunda bir hata bulunmakta. Hata nedir, nasıl düzeltilir ve nedenini açıkla:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 10;\n    if (x = 5) {\n        printf(\"X eşittir 5\\n\");\n    } else {\n        printf(\"X eşit değildir 5\\n\");\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda bir hata var. 'if (x = 5)' ifadesindeki '=' işareti bir atama operatörüdür. Bu, x'in 5'e atanmasına neden olur ve bu durumda x her zaman 5 olur, dolayısıyla if bloğu her zaman true (doğru) olarak değerlendirilir. Bu durumu düzeltmek için, eşitlik kontrolü yapmak için '==' operatörünü kullanmalıyız. Doğru kod aşağıdaki gibi olmalıdır:\n\n```c\nif (x == 5) {\n```\nBu şekilde, x'in değerinin 5 olup olmadığını doğru bir şekilde kontrol ederiz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:07.292367"
  },
  {
    "question": "Aşağıdaki C kodunda bir hata var. Hata nedir, nasıl düzeltilir ve nedenini açıkla:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 20;\n    int max;\n    if (a > b)\n        max = a;\n    else\n        max = b;\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}\n```",
    "answer": "Bu kodda bir hata yok, ancak kod daha okunabilir hale getirilebilir. Kontrol yapısında bir 'if' ve 'else' bloğunda farklı satırlara yazıldığı için bloklar daha iyi algılanamıyor. Kodu daha okunabilir hale getirmek için, if ve else bloklarını süslü parantezler içinde yazmalıyız. Düzeltilmiş kod şu şekilde olmalıdır:\n\n```c\nif (a > b) {\n    max = a;\n} else {\n    max = b;\n}\n```\nBu değişiklik, kodun yapısını netleştirir ve ileride kodu değiştirirken hata yapma olasılığını azaltır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:07.292463"
  },
  {
    "question": "Aşağıdaki C kodunda bir hata var. Hatanın nedenini bul ve düzelt: \n\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n\n    if (age < 18)\n        printf(\"Reşit değilsiniz.\");\n    else if (age >= 18 && age < 65)\n        printf(\"Reşitsiniz.\");\n    else\n        printf(\"Yaşlısınız.\");\n\n    return 0;\n}",
    "answer": "Kodda bir mantık hatası var. 65 yaş ve üzeri kullanıcılar 'Yaşlısınız.' mesajını alacak ama 65 yaşındaki bir kişi bu kategoride yer alacak. Düzeltmek için 'else if (age >= 65)' şeklinde bir kural eklenmelidir.\n\nDüzeltilmiş kod:\n\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n\n    if (age < 18)\n        printf(\"Reşit değilsiniz.\");\n    else if (age >= 18 && age < 65)\n        printf(\"Reşitsiniz.\");\n    else\n        printf(\"Yaşlısınız.\"); // 65 yaş ve üzeri için doğru mesaj\n\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:22.111716"
  },
  {
    "question": "Aşağıdaki C kodunda bir hata var. Hatanın nedenini bul ve düzelt: \n\n#include <stdio.h>\n\nint main() {\n    int num;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &num);\n\n    if (num % 2 = 0)  // Hatalı atama operatörü\n        printf(\"Sayı çift.\");\n    else\n        printf(\"Sayı tek.\");\n\n    return 0;\n}",
    "answer": "Kodda, % 2 işlemi sonucunu kontrol etmek için atama operatörü '=' yerine karşılaştırma operatörü '==' kullanılmalı. Bu tip hatalar, derleyici hatası vermeden yanlış sonuçlar doğurabilir. Düzeltmek için '=' yerine '==' yazmalısınız.\n\nDüzeltilmiş kod:\n\n#include <stdio.h>\n\nint main() {\n    int num;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &num);\n\n    if (num % 2 == 0)  // Doğru karşılaştırma operatörü\n        printf(\"Sayı çift.\");\n    else\n        printf(\"Sayı tek.\");\n\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:22.111889"
  },
  {
    "question": "Aşağıdaki C kodunda kullanıcıdan alınan bir sayının pozitif mi negatif mi olduğunu kontrol eden bir programda hata bulunmaktadır. Hatanın nedenini bulun ve düzeltin.\n\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Sayı pozitiftir.\");\n    } else if (sayi < 0) {\n        printf(\"Sayı negatiftir.\");\n    } else {\n        printf(\"Sayı sıfırdır.\");\n    }\n    return 0;\n}",
    "answer": "Bu kod doğru çalışıyor gibi görünse de, kullanıcıdan alınan sayıdan önce bir değer girilmezse veya kullanıcı geçersiz bir değer girerse (örneğin harf), scanf fonksiyonu hatalı çalışma gösterebilir. Bu durumda, bir hata kontrolü eklemek önemlidir. Düzgün bir kullanıcı girişi sağlamak için şöyle bir kontrol ekleyebiliriz:\n\n    if (scanf(\"%d\", &sayi) != 1) {\n        printf(\"Geçersiz giriş! Lütfen bir tam sayı girin.\");\n        return 1;\n    }\n\nBu şekilde, kullanıcı geçersiz bir veri girdiğinde program uygun bir hata mesajı verecek ve çalışmayı durduracaktır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:34.618762"
  },
  {
    "question": "Aşağıdaki C kodunda bir kullanıcının yaştan yola çıkarak hangi toplumsal kesim içerisinde bulunduğunu belirleyen bir yapı hatalıdır. Hatanın nedenini bulun ve düzeltin.\n\n#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas < 13) {\n        printf(\"Çocuk\");\n    } else if (yas < 20) {\n        printf(\"Genç\");\n    } else if (yas < 65) {\n        printf(\"Yetişkin\");\n    } else {\n        printf(\"Yaşlı\");\n    }\n    return 0;\n}",
    "answer": "Bu kod, yaş gruplarını doğru bir şekilde ayırıyor gibi görünüyor, ancak sınır değerlerinin kontrolü yeterince açık değil. Örneğin, 13 yaşındaki bir kişi \"Çocuk\" olarak değerlendirilirken, 20 yaşındaki bir kişi \"Genç\" olarak değerlendirilmelidir. Bu durumda, kodda yaş gruplarını daha net belirlemek için kontrol yapısını güncelleyebiliriz. Örneğin:\n\n    if (yas <= 12) {\n        printf(\"Çocuk\");\n    } else if (yas <= 19) {\n        printf(\"Genç\");\n    } else if (yas <= 64) {\n        printf(\"Yetişkin\");\n    } else {\n        printf(\"Yaşlı\");\n    }\n\nBu güncellemelerle, yaş sınırları daha net bir şekilde tanımlanmış olur.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:34.618917"
  },
  {
    "question": "Bir kullanıcının girdiği sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir program nasıl yazılır?",
    "answer": "Bu problemi çözmek için 'if', 'else if' ve 'else' kontrol yapılarından faydalanabiliriz. Öncelikle kullanıcıdan bir sayı girmesini istiyoruz. Daha sonra bu sayıyı kontrol ederek, eğer sayı sıfırdan büyükse 'Pozitif', sıfırdan küçükse 'Negatif' ve eğer sıfıra eşitse 'Sıfır' yazdırıyoruz. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Sayı Pozitif\\n\");\n    } else if (sayi < 0) {\n        printf(\"Sayı Negatif\\n\");\n    } else {\n        printf(\"Sayı Sıfır\\n\");\n    }\n    return 0;\n}\n```\n\nBu kodda, 'if' bloğu pozitif sayıları, 'else if' bloğu negatif sayıları ve 'else' bloğu sıfırı kontrol ediyor.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:43.828134"
  },
  {
    "question": "Bir öğrencinin notuna göre 'Geçti' veya 'Kaldı' mesajı veren bir program nasıl yazılır?",
    "answer": "Bu senaryoda, öğrencinin notunu kullanıcıdan alacağız ve belirli bir eşik değerini (örneğin 50) kullanarak geçip geçmediğini kontrol edeceğiz. Eğer not 50 veya daha yüksekse 'Geçti', aksi halde 'Kaldı' yazdıracağız. Aşağıda bu işlemi gerçekleştiren bir kod örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Öğrencinin notunu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 50) {\n        printf(\"Geçti\\n\");\n    } else {\n        printf(\"Kaldı\\n\");\n    }\n    return 0;\n}\n```\n\nBu kodda, 'if' bloğunda notun 50 veya daha büyük olup olmadığını kontrol ediyoruz. Eğer koşul doğruysa 'Geçti' mesajı, değilse 'Kaldı' mesajı yazdırılıyor.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:43.828182"
  },
  {
    "question": "Bir kullanıcının girdiği notlara göre harf notunu belirleyen bir C programı nasıl yazılır? Not aralıkları A: 90-100, B: 80-89, C: 70-79, D: 60-69, F: 0-59.",
    "answer": "Bu senaryoda, kullanıcının girdiği notun aralığına göre uygun harf notunu belirlemek için if-else yapısını kullanabiliriz. İşte adım adım nasıl yazılacağı: \n1. Kullanıcıdan bir not girmesini isteyin. \n2. 'if' yapısı ile notu kontrol edin. \n3. Not 90'dan büyük veya eşitse 'A' yazdırın. 80-89 aralığında ise 'B', 70-79 aralığında 'C', 60-69 aralığında 'D', ve 0-59 aralığında 'F' yazdırın. \n\nKod örneği: \n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf Notu: A\");\n    } else if (not >= 80) {\n        printf(\"Harf Notu: B\");\n    } else if (not >= 70) {\n        printf(\"Harf Notu: C\");\n    } else if (not >= 60) {\n        printf(\"Harf Notu: D\");\n    } else {\n        printf(\"Harf Notu: F\");\n    }\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:57.920808"
  },
  {
    "question": "Bir programda kullanıcının yaşına göre bir mesaj gösteren bir C kodu nasıl yazılır? 0-12 yaş arası çocuk, 13-19 yaş arası genç, 20-64 yaş arası yetişkin ve 65 ve üzeri yaşlı olarak sınıflandırılacak.",
    "answer": "Bu durumda, kullanıcının yaşını girmesini isteyerek ardından kontrol yapıları ile yaş grubunu belirleyebiliriz. \n1. Kullanıcıdan yaş bilgisini alın. \n2. 'if-else' yapısını kullanarak yaş aralıklarını kontrol edin. \n3. 0-12 yaş aralığında 'Çocuk', 13-19 aralığında 'Genç', 20-64 aralığında 'Yetişkin', ve 65 ve üzeri için 'Yaşlı' mesajlarını yazdırın. \n\nKod örneği: \n```c\n#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas >= 0 && yas <= 12) {\n        printf(\"Mesaj: Çocuk\");\n    } else if (yas >= 13 && yas <= 19) {\n        printf(\"Mesaj: Genç\");\n    } else if (yas >= 20 && yas <= 64) {\n        printf(\"Mesaj: Yetişkin\");\n    } else if (yas >= 65) {\n        printf(\"Mesaj: Yaşlı\");\n    } else {\n        printf(\"Geçersiz yaş girişi\");\n    }\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:26:57.920890"
  },
  {
    "question": "C dilinde bir sayının asal olup olmadığını kontrol eden bir fonksiyon nasıl yazılır?",
    "answer": "Asal sayılar, sadece 1 ve kendisi dışında pozitif böleni olmayan sayılardır. Bir sayının asal olup olmadığını kontrol etmek için, 2'den başlayarak sayının kareköküne kadar olan tüm sayıların bölen olup olmadığını kontrol edebiliriz. Eğer sayının herhangi bir böleni varsa, o sayı asal değildir. Aşağıda bu mantığı uygulayan bir C fonksiyonu verilmiştir:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nint asalMi(int sayi) {\n    if (sayi <= 1) return 0; // 0 ve 1 asal değildir\n    for (int i = 2; i <= sqrt(sayi); i++) {\n        if (sayi % i == 0) return 0; // böleni varsa asal değildir\n    }\n    return 1; // asal\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (asalMi(sayi)) {\n        printf(\"%d bir asal sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d bir asal sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n```\n\nBu fonksiyon, kullanıcıdan bir sayı alır ve `asalMi` fonksiyonu ile sayının asal olup olmadığını kontrol eder. Sonuç olarak kullanıcıya bilgi verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:13.748914"
  },
  {
    "question": "C dilinde bir dizi içindeki en büyük ve en küçük sayıları bulan bir program nasıl yazılır?",
    "answer": "Bir dizideki en büyük ve en küçük sayıları bulmak için, diziyi dolaşarak her elemanı karşılaştırmak gerekir. Başlangıçta en büyük ve en küçük sayıları dizinin ilk elemanı olarak tanımlayabiliriz. Daha sonra dizinin her bir elemanını kontrol ederek bu değerleri güncelleyebiliriz. Aşağıda bu yaklaşımı gösteren bir C programı verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[100];\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Dizinin elemanlarını girin: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    int enBuyuk = dizi[0];\n    int enKucuk = dizi[0];\n\n    for (int i = 1; i < n; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n        if (dizi[i] < enKucuk) {\n            enKucuk = dizi[i];\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n    printf(\"En küçük sayı: %d\\n\", enKucuk);\n    return 0;\n}\n```\n\nBu program, önce kullanıcıdan dizi boyutunu alır ve ardından dizinin elemanlarını toplar. Daha sonra döngü ile dizinin elemanlarını kontrol ederek en büyük ve en küçük sayıları bulur ve ekrana yazar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:13.748959"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Girdiğiniz sayı pozitif.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Girdiğiniz sayı negatif.\\n\");\n    } else {\n        printf(\"Girdiğiniz sayı sıfır.\\n\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir sayı alır ve if-else yapıları kullanarak sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder. Pozitifse 'pozitif', negatifse 'negatif', sıfırsa 'sıfır' mesajı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:25.630046"
  },
  {
    "question": "Kullanıcının girdiği bir notun harf notuna karşılık gelen değerini belirleyen bir C programı yazın. (A, B, C, D, F şeklinde)",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin (0-100): \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf Notu: A\\n\");\n    } else if (not >= 80) {\n        printf(\"Harf Notu: B\\n\");\n    } else if (not >= 70) {\n        printf(\"Harf Notu: C\\n\");\n    } else if (not >= 60) {\n        printf(\"Harf Notu: D\\n\");\n    } else {\n        printf(\"Harf Notu: F\\n\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir not alır ve if-else yapıları kullanarak bu notun hangi harf notuna karşılık geldiğini belirler. Eğer not 90 veya üzerinde ise A, 80-89 arası B, 70-79 arası C, 60-69 arası D, 60'ın altındaysa F notu verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:25.630102"
  },
  {
    "question": "Bir kullanıcıdan alınan bir sayının pozitif, negatif veya sıfır olduğunu belirleyen bir C programı yazın.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan bir sayı alır ve bu sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Sayı pozitif.\");\n    } else if (sayi < 0) {\n        printf(\"Sayı negatif.\");\n    } else {\n        printf(\"Sayı sıfır.\");\n    }\n    \n    return 0;\n}\n```\n\nBu program, `if`, `else if` ve `else` kontrol yapıları ile üç durumu denetler. Kullanıcıdan alınan `sayi` değişkeninin değerine göre uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:36.249084"
  },
  {
    "question": "Bir öğrencinin notuna göre harf notunu belirleyen bir C programı yazın. Not aralıkları: 90-100: A, 80-89: B, 70-79: C, 60-69: D, 0-59: F",
    "answer": "Aşağıdaki C kodu, bir öğrencinin notunu alır ve bu notun aralığına göre harf notunu belirler:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin (0-100 arası): \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90 && not <= 100) {\n        printf(\"Harf notu: A\");\n    } else if (not >= 80 && not < 90) {\n        printf(\"Harf notu: B\");\n    } else if (not >= 70 && not < 80) {\n        printf(\"Harf notu: C\");\n    } else if (not >= 60 && not < 70) {\n        printf(\"Harf notu: D\");\n    } else if (not >= 0 && not < 60) {\n        printf(\"Harf notu: F\");\n    } else {\n        printf(\"Geçersiz not girişi.\");\n    }\n    \n    return 0;\n}\n```\n\nBu programda, `if` ve `else if` yapıları kullanarak notun aralıklarını kontrol ediyoruz. Kullanıcının girdiği nota göre uygun harf notunu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:36.249151"
  },
  {
    "question": "Bir dizi içerisindeki negatif sayıları bulup, pozitif olanlarının toplamını hesaplayacak bir C programı yazın. Negatif sayılar tespit edildiğinde, kullanıcıya bir uyarı mesajı gösterin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10] = {1, -2, 3, -4, 5, -6, 7, 8, -9, 10};\n    int toplam = 0;\n    int negatifSayilariVar = 0;\n\n    for (int i = 0; i < 10; i++) {\n        if (dizi[i] < 0) {\n            negatifSayilariVar = 1;\n            printf(\"Dizide negatif bir sayı bulundu: %d\\n\", dizi[i]);\n        } else {\n            toplam += dizi[i];\n        }\n    }\n\n    if (negatifSayilariVar) {\n        printf(\"Dizide negatif sayılar mevcut.\\n\");\n    }\n    printf(\"Pozitif sayıların toplamı: %d\\n\", toplam);\n\n    return 0;\n}\n\n// Açıklama: Bu program, bir dizi içerisindeki negatif sayıları kontrol eder. Eğer negatif bir sayı bulunursa, kullanıcıya bir mesaj gösterir ve pozitif sayıların toplamını hesaplar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:46.188006"
  },
  {
    "question": "Bir kullanıcının girdiği bir yılı kontrol ederek, bu yılın artık yıl olup olmadığını belirleyecek bir C programı yazın. Eğer yıl artık bir yıl ise kullanıcıya uygun bir mesaj verin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yil;\n    printf(\"Bir yıl girin: \");\n    scanf(\"%d\", &yil);\n\n    // Artık yıl kontrolü\n    if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n        printf(\"%d bir artık yıldır.\\n\", yil);\n    } else {\n        printf(\"%d bir artık yıl değildir.\\n\", yil);\n    }\n\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği yılı kontrol eder ve artık yıl olup olmadığını belirler. Artık yıl, 4'e bölünebilen ancak 100'e tam bölünemeyen veya 400'e tam bölünebilen yıllardır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:27:46.188096"
  },
  {
    "question": "Bir kullanıcının yaşına göre giriş yapma iznini kontrol eden bir program var. Ancak mevcut kontrol yapısı karmaşık ve okunaksız. Aşağıdaki kodu inceleyin ve optimize edin: \n\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n\n    if (age < 0) {\n        printf(\"Geçersiz yaş!\\n\");\n    } else if (age < 18) {\n        printf(\"Giriş izni yok.\\n\");\n    } else if (age >= 18 && age <= 65) {\n        printf(\"Giriş izni var.\\n\");\n    } else {\n        printf(\"Emeklilik yaşında, giriş izni var.\\n\");\n    }\n\n    return 0;\n}",
    "answer": "Bu kod parçasında bazı kontrol yapılarını daha okunabilir hale getirmek için optimize edebiliriz. İlk olarak, yaşları kontrol etmek için bir 'switch' yapısı kullanmak yerine 'if' ifadelerini sade ve okunabilir tutabiliriz. Ayrıca, gereksiz koşulları kaldırarak kodu basitleştirebiliriz. İşte geliştirilmiş versiyonu:\n\n#include <stdio.h>\n\nint main() {\n    int age;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &age);\n\n    if (age < 0) {\n        printf(\"Geçersiz yaş!\\n\");\n    } else if (age < 18) {\n        printf(\"Giriş izni yok.\\n\");\n    } else {\n        printf(\"Giriş izni var.\\n\");\n    }\n\n    return 0;\n}\n\nYukarıdaki örnekte, 65 yaş üzerindeki kullanıcılar için ek bir kontrol yapmaya gerek kalmadığını varsayıyoruz. Bu, kodun okunabilirliğini artırır ve gereksiz karmaşıklıktan kaçınır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:28:02.478289"
  },
  {
    "question": "Bir sıcaklık ölçer programı var ve sıcaklığı Celsius cinsinden alarak Fahrenheit cinsine dönüştürüyor. Ancak dönüşüm işlemi sırasında yapılan kontrol yapısı gereksiz yere karmaşık. Aşağıdaki kodu inceleyin ve iyileştirin:\n\n#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    printf(\"Celsius değerini girin: \");\n    scanf(\"%f\", &celsius);\n\n    if (celsius < -273.15) {\n        printf(\"Geçersiz sıcaklık!\\n\");\n    } else {\n        fahrenheit = (celsius * 9/5) + 32;\n        printf(\"%.2f Celsius = %.2f Fahrenheit\\n\", celsius, fahrenheit);\n    }\n\n    return 0;\n}",
    "answer": "Bu kodda, Celsius sıcaklığının geçerliliğini kontrol etmek için kullanılan 'if' yapısı doğru ancak dönüşüm işlemi daha açık bir şekilde sunulabilir. Ayrıca, dönüşüm işlemi için bir fonksiyon tanımlamak, kodun modularitesini artırır. İşte daha iyi bir versiyonu:\n\n#include <stdio.h>\n\nfloat convertToFahrenheit(float celsius) {\n    return (celsius * 9/5) + 32;\n}\n\nint main() {\n    float celsius, fahrenheit;\n    printf(\"Celsius değerini girin: \");\n    scanf(\"%f\", &celsius);\n\n    if (celsius < -273.15) {\n        printf(\"Geçersiz sıcaklık!\\n\");\n    } else {\n        fahrenheit = convertToFahrenheit(celsius);\n        printf(\"%.2f Celsius = %.2f Fahrenheit\\n\", celsius, fahrenheit);\n    }\n\n    return 0;\n}\n\nBu değişiklikler, dönüşüm işlemini ayrı bir fonksiyona taşıyarak kodun daha anlaşılır olmasını sağlıyor ve gerekirse dönüşüm işlemini başka yerlerde de kullanabilmeyi sağlıyor.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:28:02.478448"
  },
  {
    "question": "Bir C programında kullanıcıdan alınan sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden kod parçasında, kontrol yapılarının etkinliği nasıl artırılabilir?",
    "answer": "Kodda kontrol yapıları daha etkin hale getirilebilir. Örneğin, mevcut kod şöyle olabilir: \n\n```c\nint sayi;\nprintf(\"Bir sayı giriniz: \");\nsscanf(\"%d\", &sayi);\n\nif (sayi > 0) {\n    printf(\"Pozitif\");\n} else if (sayi < 0) {\n    printf(\"Negatif\");\n} else {\n    printf(\"Sıfır\");\n}\n```\nBu kodda, kontrol yapıları doğru bir şekilde kullanılmış. Ancak, if-else yapısında bir optimizasyon yapılabilir. Aşağıdaki gibi bir yapı kullanarak, kodun okunabilirliğini artırabiliriz ve gereksiz else if kontrollerinden kaçınabiliriz:\n\n```c\nint sayi;\nprintf(\"Bir sayı giriniz: \");\nsscanf(\"%d\", &sayi);\n\nif (sayi > 0) {\n    printf(\"Pozitif\");\n    return 0;\n}\n\nif (sayi < 0) {\n    printf(\"Negatif\");\n    return 0;\n}\n\nprintf(\"Sıfır\");\n```\nBu değişiklikle, her durumu kontrol ettikten sonra, gereksiz kontroller azaltılmış ve kod daha temiz bir hale getirilmiş oldu.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:28:16.239853"
  },
  {
    "question": "Bir C programında bir dizi içerisindeki en büyük elemanı bulmak için kullanılan kontrol yapısı etkin bir şekilde nasıl iyileştirilebilir?",
    "answer": "Diyelim ki elimizde aşağıdaki gibi bir kod var:\n\n```c\nint dizi[] = {3, 5, 1, 8, 2};\nint enBuyuk = dizi[0];\n\nfor (int i = 1; i < sizeof(dizi)/sizeof(dizi[0]); i++) {\n    if (dizi[i] > enBuyuk) {\n        enBuyuk = dizi[i];\n    }\n}\nprintf(\"En büyük sayı: %d\\n\", enBuyuk);\n```\nBu kod düzgün çalışıyor, ancak boyutunu dinamik olarak hesaplamak yerine, dizi boyutunu ayrı bir değişkenle saklayarak daha verimli hale getirilebilir. Ayrıca, kontrol yapısını biraz daha sadeleştirebiliriz. Örneğin:\n\n```c\nint dizi[] = {3, 5, 1, 8, 2};\nint enBuyuk = dizi[0];\nint diziBoyutu = sizeof(dizi) / sizeof(dizi[0]);\n\nfor (int i = 1; i < diziBoyutu; i++) {\n    enBuyuk = (dizi[i] > enBuyuk) ? dizi[i] : enBuyuk;\n}\nprintf(\"En büyük sayı: %d\\n\", enBuyuk);\n```\nBurada, ternary operatör kullanarak `if` kontrol yapısını daha kısa ve okunabilir hale getirdik. Ayrıca, dizi boyutunu bir değişkende saklayarak, kodun daha anlaşılır olmasını sağladık.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-05-31T16:28:16.239904"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, verilen iki sayının toplamını döndüren bir fonksiyon yazınız. Fonksiyonun adı 'topla' olmalı. Fonksiyonun prototipi ve çağrısı aşağıda verilmiştir:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b); // Fonksiyon prototipi\n\nint main() {\n    int sayi1 = 5;\n    int sayi2 = 10;\n    int sonuc;\n\n    sonuc = topla(sayi1, sayi2);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}\n```",
    "answer": "Aşağıdaki gibi 'topla' fonksiyonunu tamamlayabiliriz:\n\n```c\nint topla(int a, int b) { \n    return a + b; \n}\n```\n\nBu fonksiyon iki tam sayı alır ve bunların toplamını döndürür. 'main' fonksiyonu içinde bu fonksiyon çağrıldığında, 'sayi1' ve 'sayi2' değişkenlerinin toplamı 'sonuc' değişkenine atanır ve ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:28:26.081627"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, bir sayının karekökünü hesaplayan bir fonksiyon yazınız. Fonksiyonun adı 'karekök' olmalıdır. Fonksiyonun prototipi ve çağrısı aşağıda verilmiştir:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\ndouble karekök(double sayi); // Fonksiyon prototipi\n\nint main() {\n    double sayi = 25.0;\n    double sonuc;\n\n    sonuc = karekök(sayi);\n    printf(\"Karekök: %.2f\\n\", sonuc);\n    return 0;\n}\n```",
    "answer": "Aşağıdaki gibi 'karekök' fonksiyonunu tamamlayabiliriz:\n\n```c\ndouble karekök(double sayi) { \n    return sqrt(sayi); \n}\n```\n\nBu fonksiyon bir double türünde bir sayı alır ve bu sayının karekökünü hesaplayarak döndürür. 'main' fonksiyonu içinde bu fonksiyon çağrıldığında, 'sayi' değişkeninin karekökü 'sonuc' değişkenine atanır ve ekrana yazdırılır. 'math.h' kütüphanesini kullanarak 'sqrt' fonksiyonu ile karekök hesaplanmıştır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:28:26.081753"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak kullanıcıdan bir sayı alıp, bu sayının faktöriyelini hesaplayan bir fonksiyon oluşturun. Eksik kod: \n\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    // Kod buraya gelecek\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}",
    "answer": "Eksik kodu tamamlamak için, faktöriyel hesaplama işlevini uygun şekilde tanımlamamız gerekiyor. Faktöriyel, pozitif bir tam sayının çarpanları olarak hesaplanır. İşte tamamlanmış kod:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0 || n == 1) return 1; // 0! ve 1! = 1\n    return n * faktoriyel(n - 1); // Rekürsif çağrı\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```\nBu kodda, `faktoriyel` fonksiyonu, verilen sayının durumuna göre rekürsif olarak kendisini çağırarak faktöriyeli hesaplıyor. Kullanıcıdan alınan sayı için sonucu ekrana yazdırıyor.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:28:47.345680"
  },
  {
    "question": "Bir dizinin elemanlarını toplamak için bir fonksiyon yazın. Kullanıcının girdiği dizinin uzunluğunu da göz önünde bulundurun. Eksik kod:\n\n#include <stdio.h>\n\nint diziTopla(int dizi[], int uzunluk) {\n    // Kod buraya gelecek\n}\n\nint main() {\n    int n;\n    printf(\"Dizinin uzunluğunu girin: \");\n    scanf(\"%d\", &n);\n    int dizi[n];\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Dizinin toplamı: %d\\n\", diziTopla(dizi, n));\n    return 0;\n}",
    "answer": "Aşağıdaki eksik kodu tamamlayarak dizinin elemanlarının toplamını hesaplayan fonksiyonu oluşturuyoruz:\n\n```c\n#include <stdio.h>\n\nint diziTopla(int dizi[], int uzunluk) {\n    int toplam = 0;\n    for (int i = 0; i < uzunluk; i++) {\n        toplam += dizi[i]; // Elemanları toplama ekle\n    }\n    return toplam;\n}\n\nint main() {\n    int n;\n    printf(\"Dizinin uzunluğunu girin: \");\n    scanf(\"%d\", &n);\n    int dizi[n];\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Dizinin toplamı: %d\\n\", diziTopla(dizi, n));\n    return 0;\n}\n```\nBu kodda `diziTopla` fonksiyonu, verilen dizi ve uzunluğunu alarak, tüm elemanları toplar. Kullanıcıdan alınan dizi elemanları ile toplamı hesaplayıp sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:28:47.345950"
  },
  {
    "question": "Bir dizinin elemanlarını toplamak için bir fonksiyon yazın. Fonksiyon, bir tamsayı dizisi ve dizinin boyutunu almalı.",
    "answer": "#include <stdio.h>\n\n// Dizinin elemanlarını toplamak için fonksiyon tanımı\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = toplam(dizi, boyut);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", sonuc);\n    return 0;\n}\n\n// Açıklama:\n// Bu program, bir tamsayı dizisinin elemanlarını toplamak için 'toplam' adında bir fonksiyon tanımlar.\n// Fonksiyon, diziyi ve boyutunu alır, dizinin her elemanını toplar ve sonucu geri döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:00.524577"
  },
  {
    "question": "Bir dizi içinde belirli bir sayının kaç kez tekrar ettiğini bulan bir fonksiyon yazın. Fonksiyon, bir tamsayı dizisi, dizinin boyutu ve aranacak sayıyı almalıdır.",
    "answer": "#include <stdio.h>\n\n// Dizide bir sayının kaç kez tekrar ettiğini bulan fonksiyon tanımı\nint sayiSayisi(int dizi[], int boyut, int aranacak) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranacak) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 2, 5, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int aranacak = 2;\n    int sonuc = sayiSayisi(dizi, boyut, aranacak);\n    printf(\"%d sayısı dizide %d kez bulunuyor.\\n\", aranacak, sonuc);\n    return 0;\n}\n\n// Açıklama:\n// Bu program, bir dizi içerisinde belirli bir sayının kaç kez tekrar ettiğini bulmak için 'sayiSayisi' adında bir fonksiyon tanımlar.\n// Fonksiyon, diziyi, dizinin boyutunu ve aranacak sayıyı alır. Eğer dizi elemanlarından biri aranacak sayıya eşitse, sayacı bir artırır ve sonunda sayıyı döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:00.524674"
  },
  {
    "question": "Aşağıdaki kodda, fonksiyonun doğru çalışmadığını düşünüyorsunuz. Hatanın kaynağını bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n\nvoid topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sonuc = topla(5, 3);\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}\n```",
    "answer": "Kodda `topla` fonksiyonu bir `void` (boş) türünde tanımlanmış ancak sonuç döndürmeye çalışıyor. C dilinde bir fonksiyonun bir değer döndürmesi için `return` ifadesi kullanılabilmesi için fonksiyonun dönüş türü belirtilmelidir. Aşağıdaki gibi düzeltilmelidir:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sonuc = topla(5, 3);\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}\n}```\n\nBurada `topla` fonksiyonu `int` olarak değiştirildi, böylece toplam değeri dönebilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:12.247358"
  },
  {
    "question": "Aşağıdaki kodu inceleyin. `ortalama` fonksiyonu beklenildiği gibi çalışmıyor. Hatanın sebebini bulun ve çözün.\n\n```c\n#include <stdio.h>\n\nvoid ortalama(int a[], int n) {\n    int toplam = 0;\n    for (int i = 0; i <= n; i++) {\n        toplam += a[i];\n    }\n    printf(\"Ortalama: %d\", toplam / n);\n}\n\nint main() {\n    int sayilar[] = {10, 20, 30, 40};\n    ortalama(sayilar, 4);\n    return 0;\n}\n```",
    "answer": "Kodda `ortalama` fonksiyonunda döngü `i <= n` şeklinde tanımlanmış ki bu, dizinin sınırlarını aşmasına neden olur. C dilinde diziler 0'dan başladığı için `n` değerine kadar (n dahil değil) döngü çalışırken `n`'in kendisi dizinin dışında bir elemana erişmeye çalışır. Bunu düzeltmek için `i < n` olmalıdır. Aşağıdaki gibi düzeltilmelidir:\n\n```c\n#include <stdio.h>\n\nvoid ortalama(int a[], int n) {\n    int toplam = 0;\n    for (int i = 0; i < n; i++) {\n        toplam += a[i];\n    }\n    printf(\"Ortalama: %d\", toplam / n);\n}\n\nint main() {\n    int sayilar[] = {10, 20, 30, 40};\n    ortalama(sayilar, 4);\n    return 0;\n}```\n\nBurada döngü koşulu düzeltildi ve dizinin doğru elemanları toplandı.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:12.247493"
  },
  {
    "question": "Aşağıdaki C kodunda, iki tam sayının toplamını hesaplayan bir fonksiyonu düzeltilmesi gerekiyor. Ancak, fonksiyon sonuç olarak toplama yerine çarpma yapıyor. Hata nerede?",
    "answer": "Kodda aşağıdaki gibi bir fonksiyon tanımlanmış: \n\n```c\nint toplama(int a, int b) {\n    return a * b; // Hata burada, çarpma işlemi yapılmış\n}\n```\nBu fonksiyonda, `return` ifadesi çarpma işlemi yapıyor. Bu durumu düzeltmek için `return a + b;` olarak değiştirilmesi gerekiyor. Doğru hali şu şekilde olmalıdır:\n\n```c\nint toplama(int a, int b) {\n    return a + b; // Doğru işlem toplama\n}\n```\nBöylece fonksiyon, doğru bir şekilde iki sayının toplamını döndürecektir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:24.502107"
  },
  {
    "question": "Aşağıdaki C kodunda, bir dizi elemanlarının toplamını hesaplayan bir fonksiyon var. Ancak, fonksiyon beklenen sonucun altında bir değer döndürüyor. Hatanın kaynağı nedir?",
    "answer": "Verilen kod şu şekilde:\n\n```c\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i <= boyut; i++) { // Hata burada, <= operatörü kullanılmış\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```\nBurada `for` döngüsünde `i <= boyut` ifadesi kullanılmış. Dizi elemanlarına erişirken, dizinin boyutu `boyut` olarak verilmiş olsa da, dizinin son elemanına ulaşmak için `i < boyut` olarak değiştirilmelidir. Düzgün bir döngü aşağıdaki gibi olmalıdır:\n\n```c\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) { // Doğru ifade < olmalı\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```\nBu düzeltme ile fonksiyon, dizinin tüm elemanlarını doğru bir şekilde toplayarak beklenen sonucu verecektir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:29:24.502195"
  },
  {
    "question": "Aşağıdaki C kodu, iki sayıyı çarpan bir fonksiyon içeriyor. Ancak, fonksiyonun sonucu beklenildiği gibi çalışmıyor. Hatanın sebebini bul ve düzelt: \n\n#include <stdio.h>\n\nint carp(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    int sonuc;\n    sonuc = carp(5);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}",
    "answer": "Bu kodda, 'carp' fonksiyonuna yalnızca bir argüman ('5') geçiliyor. Ancak 'carp' fonksiyonu iki argüman alacak şekilde tanımlanmış. Bu durum derleyici hatasına neden olur. Düzeltmek için, 'carp' fonksiyonunu çağırırken iki argüman sağlamalıyız. Aşağıdaki gibi düzenleyin:\n\n```c\nint main() {\n    int sonuc;\n    sonuc = carp(5, 10); // İkinci argüman eklendi\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:09.896904"
  },
  {
    "question": "Aşağıdaki kodda, bir dizinin elemanlarını toplayan bir fonksiyon var. Ancak, toplam sonuç her zaman sıfır çıkıyor. Hatanın sebebini bul ve düzelt: \n\n#include <stdio.h>\n\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i <= boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int sonuc = toplam(dizi, 5);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}",
    "answer": "Bu kodda 'toplam' fonksiyonunda döngü koşulu hatalı. 'i <= boyut' ifadesi, dizinin sonundaki geçerli indeksi aşarak dizinin sınır dışına erişmeye çalışıyor. Bu durum belirsiz bir davranışa neden olur ve toplam her zaman sıfır dönebilir. Düzeltmek için döngü koşulunu 'i < boyut' olarak değiştirmeliyiz. Aşağıdaki gibi düzenleyin:\n\n```c\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) { // <= yerine < kullanıldı\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:09.897229"
  },
  {
    "question": "Bir sayının karesini hesaplamak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir sayının karesini hesaplamak için basit bir fonksiyon oluşturabiliriz. Fonksiyon, bir parametre alır ve bu parametrenin karesini döndürür. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n\nint kareHesapla(int sayi) {\n    return sayi * sayi;\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d sayısının karesi: %d\\n\", sayi, kareHesapla(sayi));\n    return 0;\n}\n```\n\nBu kodda, `kareHesapla` adında bir fonksiyon tanımlıyoruz. Fonksiyon `int` tipinde bir değer alır ve o değerin karesini hesaplayarak geri döndürür. `main` fonksiyonunda kullanıcıdan bir sayı alıyoruz ve bu sayının karesini hesaplamak için `kareHesapla` fonksiyonunu çağırıyoruz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:21.471829"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını bulmak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir dizinin elemanlarının toplamını bulmak için bir fonksiyon yazabiliriz. Bu fonksiyon, bir dizi ve dizinin boyutunu parametre olarak alır. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n\nint diziToplami(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", diziToplami(dizi, boyut));\n    return 0;\n}\n```\n\nBu kodda, `diziToplami` adında bir fonksiyon tanımlıyoruz. Fonksiyon, bir tamsayı dizisi ve bu dizinin boyutunu alarak, dizinin elemanlarını toplar ve sonucu döndürür. `main` fonksiyonunda ise bir dizi oluşturuyoruz ve bu dizinin elemanlarının toplamını bulmak için `diziToplami` fonksiyonunu çağırıyoruz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:21.471888"
  },
  {
    "question": "Bir dizi içerisinde bulunan sayıları toplamak için bir fonksiyon nasıl yazabilirim?",
    "answer": "Dizi içerisindeki sayıların toplamını bulmak için bir 'topla' adlı fonksiyon yazabiliriz. Bu fonksiyon, bir dizi parametresi alacak ve döngü kullanarak dizideki tüm elemanları toplayarak sonucu döndürecektir. Örnek kod aşağıdaki gibidir:\n\n```c\n#include <stdio.h>\n\nint topla(int dizi[], int boyut) {\n    int toplam = 0; // Toplamı tutmak için bir değişken\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i]; // Her bir elemanı toplama ekle\n    }\n    return toplam; // Toplam sonucu döndür\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]); // Dizi boyutunu hesapla\n    int sonuc = topla(sayilar, boyut); // Fonksiyonu çağır\n    printf(\"Toplam: %d\\n\", sonuc); // Sonucu yazdır\n    return 0;\n}\n```\nBu kodda 'topla' fonksiyonu, bir dizi ve boyutunu alarak dizideki tüm elemanların toplamını döndürüyor. 'main' fonksiyonunda ise diziyi tanımlayıp 'topla' fonksiyonunu çağırarak sonucu ekrana yazdırıyoruz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:34.157625"
  },
  {
    "question": "Bir string'in içerisindeki kelimeleri tersine çevirmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir string'in içerisindeki kelimeleri tersine çevirmek için 'kelimeleriTersCevir' adında bir fonksiyon yazabiliriz. Bu fonksiyon, bir string alacak ve her kelimeyi bulup ters çevirerek yeni bir string oluşturacaktır. İşte örnek bir uygulama:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid kelimeleriTersCevir(char *str) {\n    char *kelime = strtok(str, \" \"); // İlk kelimeyi ayır\n    while (kelime != NULL) {\n        // Kelimenin tersini yazdır\n        for (int i = strlen(kelime) - 1; i >= 0; i--) {\n            putchar(kelime[i]);\n        }\n        putchar(' '); // Kelimeler arasında boşluk bırak\n        kelime = strtok(NULL, \" \"); // Sonraki kelimeyi al\n    }\n}\n\nint main() {\n    char metin[] = \"Merhaba Dünya! Nasıl gidiyorsun?\";\n    printf(\"Ters çevrilmiş kelimeler: \");\n    kelimeleriTersCevir(metin); // Fonksiyonu çağır\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kodda 'kelimeleriTersCevir' fonksiyonu, verilen string içerisindeki kelimeleri ters çevirir. 'main' fonksiyonunda ise bir metin tanımlayıp bu metni fonksiyona gönderiyoruz. Sonuçta, kelimeler ters çevrilerek ekrana yazdırılıyor.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:34.157668"
  },
  {
    "question": "C dilinde bir dizinin elemanlarının toplamını ve ortalamasını hesaplayan bir fonksiyon nasıl yazılır? Bu fonksiyonun nasıl çalıştığını açıkla.",
    "answer": "Dizi elemanlarının toplamını ve ortalamasını hesaplamak için bir fonksiyon tanımlamamız gerekiyor. Fonksiyonun iki işlevi olacak: 'toplam' ve 'ortalama'. Fonksiyona bir dizi ve dizinin boyutunu argüman olarak geçeceğiz. İlk olarak, dizinin toplamını bulmak için bir döngü kullanarak tüm elemanları toplayacağız. Ardından, toplamı dizinin eleman sayısına bölerek ortalamayı hesaplayacağız. İşte bir örnek: \n\n```c\n#include <stdio.h>\n\nvoid hesaplaToplamVeOrtalama(int dizi[], int boyut, int *toplam, float *ortalama) {\n    *toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        *toplam += dizi[i];\n    }\n    *ortalama = (float)(*toplam) / boyut;\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int toplam;\n    float ortalama;\n\n    hesaplaToplamVeOrtalama(dizi, boyut, &toplam, &ortalama);\n\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n```\nBu kodda, 'hesaplaToplamVeOrtalama' fonksiyonu, dizinin toplamını ve ortalamasını hesaplamak için kullanılır. Fonksiyon parametreleri olarak diziyi ve boyutunu alır. Toplam ve ortalama, fonksiyonun çağrıldığı yerdeki değişkenlere referans olarak geçilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:58.400019"
  },
  {
    "question": "C dilinde, bir string'e belirli bir karakterin kaç kez geçtiğini sayan bir fonksiyon yaz. Fonksiyonun nasıl çalıştığını ve nasıl kullanıldığını anlat.",
    "answer": "Bir string'de belirli bir karakterin kaç kez geçtiğini saymak için bir fonksiyon yazmamız gerekiyor. Bu fonksiyon, bir string ve bir karakter alacak ve string'de o karakterin kaç kez bulunduğunu döndürecek. Bunun için bir döngü kullanarak string'in her bir karakterini kontrol edeceğiz. İşte bir örnek: \n\n```c\n#include <stdio.h>\n\nint karakterSay(char *str, char karakter) {\n    int sayac = 0;\n    while (*str) {\n        if (*str == karakter) {\n            sayac++;\n        }\n        str++;\n    }\n    return sayac;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    char karakter = 'a';\n    int sonuc = karakterSay(str, karakter);\n\n    printf(\"'%c' karakteri string'de %d kez geçiyor.\\n\", karakter, sonuc);\n    return 0;\n}\n```\nBu kodda, 'karakterSay' fonksiyonu, verilen string'de belirli bir karakterin kaç kez geçtiğini sayar. Fonksiyon, string'in sonuna kadar giderek her karakteri kontrol eder. Eğer karakter eşleşirse, sayacı artırır. Sonuç olarak, ana fonksiyona geri döner ve karakterin sayısını gösterir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:30:58.400076"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarının toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki kod, bir tamsayı dizisinin elemanlarının toplamını hesaplayan bir fonksiyon örneği içermektedir:\n\n```c\n#include <stdio.h>\n\nint toplamHesapla(int dizi[], int boyut) {\n    int toplam = 0; // Toplam değerini tutacak değişken\n    for(int i = 0; i < boyut; i++) {\n        toplam += dizi[i]; // Dizi elemanlarını toplayarak toplamı güncelle\n    }\n    return toplam; // Hesaplanan toplam değeri döndür\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5}; // Örnek bir tamsayı dizisi\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]); // Dizinin boyutunu hesapla\n    int sonuc = toplamHesapla(sayilar, boyut); // Fonksiyonu çağır\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", sonuc); // Sonucu ekrana yazdır\n    return 0;\n}\n```\n\nBu kod parçasında, `toplamHesapla` isimli fonksiyon, verilen dizi ve boyut parametrelerini alarak dizi elemanlarının toplamını hesaplar. `main` fonksiyonu içerisinde ise örnek bir dizi oluşturulmuş ve bu dizi için toplam hesaplanmıştır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:11.049118"
  },
  {
    "question": "Bir tamsayı parametresi alarak bu sayının faktöriyelini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki kod, bir tamsayı için faktöriyel hesaplayan bir fonksiyon örneği sunmaktadır:\n\n```c\n#include <stdio.h>\n\nint faktoriyelHesapla(int n) {\n    if(n < 0) return -1; // Negatif sayılar için geçersiz durum\n    if(n == 0 || n == 1) return 1; // 0! ve 1! her zaman 1'dir\n    int sonuc = 1; // Sonuç değerini tutacak değişken\n    for(int i = 2; i <= n; i++) {\n        sonuc *= i; // Faktöriyel hesaplaması\n    }\n    return sonuc; // Hesaplanan faktöriyel değeri döndür\n}\n\nint main() {\n    int sayi = 5; // Faktöriyeli hesaplanacak sayı\n    int sonuc = faktoriyelHesapla(sayi); // Fonksiyonu çağır\n    if(sonuc != -1) {\n        printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, sonuc); // Sonucu ekrana yazdır\n    } else {\n        printf(\"Geçersiz bir sayı girdiniz!\\n\"); // Hata mesajı\n    }\n    return 0;\n}\n```\n\nBu kodda, `faktoriyelHesapla` isimli fonksiyon, bir tamsayı alarak bu sayının faktöriyelini hesaplar. Eğer sayı negatifse -1 döndürerek geçersiz durumu belirtir. `main` fonksiyonunda ise örnek bir sayı verilerek faktöriyel hesaplanmakta ve sonuç ekrana yazdırılmaktadır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:11.049158"
  },
  {
    "question": "Bir dizi içerisinde verilen bir sayının kaç kere tekrarlandığını bulan bir fonksiyon yazın. Örneğin, {1, 2, 3, 2, 4, 2} dizisinde 2 sayısının tekrar sayısını bulmalısınız.",
    "answer": "#include <stdio.h>\n\nint tekrarSayisi(int dizi[], int boyut, int sayi) {\n    int sayac = 0; // Sayacı sıfırla\n    for (int i = 0; i < boyut; i++) { // Dizi boyunca döngü\n        if (dizi[i] == sayi) { // Eğer dizi elemanı verilen sayıya eşitse\n            sayac++; // Sayacı artır\n        }\n    }\n    return sayac; // Toplam sayıyı döndür\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 2, 4, 2}; // Örnek dizi\n    int boyut = sizeof(dizi) / sizeof(dizi[0]); // Dizinin boyutunu hesapla\n    int sayi = 2; // Aranacak sayı\n    int sonuc = tekrarSayisi(dizi, boyut, sayi); // Fonksiyonu çağır\n    printf(\"%d sayısı dizide %d kez tekrar edildi.\\n\", sayi, sonuc); // Sonucu yazdır\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:22.704200"
  },
  {
    "question": "Verilen bir stringin kelime sayısını bulan bir fonksiyon yazın. Örneğin, 'Merhaba dünya!' ifadesindeki kelime sayısını hesaplayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint kelimeSayisi(const char *str) {\n    int sayac = 0;\n    int uzunluk = strlen(str);\n    int i;\n    int kelimeBaslangici = 0;\n\n    for (i = 0; i < uzunluk; i++) {\n        // Boşluk karakteri veya stringin sonu\n        if (str[i] == ' ' || i == uzunluk - 1) {\n            // Eğer kelime başlangıcında değilse sayacı artır\n            if (kelimeBaslangici) {\n                sayac++;\n                kelimeBaslangici = 0; // Kelime bitti\n            }\n        } else {\n            kelimeBaslangici = 1; // Kelime başlıyor\n        }\n    }\n    // Son kelimeyi de say\n    if (kelimeBaslangici) {\n        sayac++;\n    }\n    return sayac;\n}\n\nint main() {\n    const char *metin = \"Merhaba dünya!\"; // Örnek metin\n    int sonuc = kelimeSayisi(metin); // Fonksiyonu çağır\n    printf(\"Metindeki kelime sayısı: %d\\n\", sonuc); // Sonucu yazdır\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:22.704251"
  },
  {
    "question": "C dilinde bir dizi içindeki elemanların toplamını ve ortalamasını hesaplayan bir fonksiyon yazın. Bu fonksiyon, dizinin boyutunu da parametre olarak almalıdır.",
    "answer": "Aşağıda, verilen bir dizi içindeki elemanların toplamını ve ortalamasını hesaplayan bir C fonksiyonu örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid calculate_sum_and_average(int arr[], int size, int *sum, float *average) {\n    *sum = 0; // Toplamı sıfırla\n    for (int i = 0; i < size; i++) {\n        *sum += arr[i]; // Her bir elemanı toplamaya ekle\n    }\n    *average = (float)(*sum) / size; // Ortalama hesapla\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int sum;\n    float average;\n\n    calculate_sum_and_average(arr, size, &sum, &average);\n\n    printf(\"Toplam: %d\\n\", sum);\n    printf(\"Ortalama: %.2f\\n\", average);\n    return 0;\n}\n```\n\nBu kodda, `calculate_sum_and_average` fonksiyonu iki işaretçi parametre alır; biri toplamı, diğeri ise ortalamayı tutar. `main` fonksiyonu içinde bir dizi tanımlanır, dizinin boyutu hesaplanır ve bu dizi, toplam ve ortalama hesaplamak için fonksiyona geçirilir. Sonuçlar ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:35.678051"
  },
  {
    "question": "C dilinde, bir string içinde belirli bir karakterin kaç kez tekrarlandığını sayan bir fonksiyon yazın. Fonksiyon, hem stringi hem de sayılacak karakteri parametre olarak almalıdır.",
    "answer": "Aşağıda, bir string içinde belirli bir karakterin kaç kez tekrarlandığını sayan bir C fonksiyonu örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint count_character_occurrences(const char *str, char ch) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ch) {\n            count++; // Eğer karakter eşleşiyorsa sayacı artır\n        }\n    }\n    return count; // Sonucu döndür\n}\n\nint main() {\n    const char *text = \"Merhaba dünya! Merhaba!\"\n    char character = 'a';\n    int occurrences;\n\n    occurrences = count_character_occurrences(text, character);\n\n    printf(\"'%c' karakteri '%s' stringinde %d kez bulunuyor.\\n\", character, text, occurrences);\n    return 0;\n}\n```\n\nBu kodda, `count_character_occurrences` fonksiyonu bir string ve bir karakter alır. Fonksiyon, string içindeki her karakteri kontrol eder ve eşleşen karakter için bir sayaç artırır. `main` fonksiyonunda bir string ve sayılacak karakter tanımlanır ve sonuç ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:35.678115"
  },
  {
    "question": "Bir C programında, iki tam sayıyı toplayan bir fonksiyon tanımladım. Fakat performansını artırmak ve kodun okunabilirliğini artırmak için nasıl bir optimizasyon yapabilirim?",
    "answer": "Aşağıdaki gibi bir toplama fonksiyonu yazdığınızı varsayalım:\n\n```c\nint toplama(int a, int b) {\n    return a + b;\n}\n```\nBu fonksiyon basit bir toplama işlemi gerçekleştiriyor. Ancak, büyük projelerde bu fonksiyonun çok sık çağrıldığını düşünelim. Optimize etmek için öncelikle fonksiyonu inline olarak tanımlamayı düşünebilirsiniz. Bu, çağrıldığında fonksiyonun gövdesinin doğrudan çağrıldığı yerde yer almasına olanak tanır:\n\n```c\ninline int toplama(int a, int b) {\n    return a + b;\n}\n```\nBu değişiklik, özellikle fonksiyonun çok sık çağrıldığı durumlarda performansı artırabilir. Ayrıca, fonksiyon isimlerini daha açıklayıcı hale getirmek için, örneğin `topla` gibi bir isim kullanabilirsiniz. Bu da kodun okunabilirliğini artırır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:48.990342"
  },
  {
    "question": "Bir C fonksiyonu, bir karakter dizisindeki sesli harflerin sayısını bulmak için yazıldı. Ancak, kodumda bazı iyileştirmeler yapmam gerektiğini düşünüyorum. Bu fonksiyonu nasıl optimize edebilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazdığınızı varsayalım:\n\n```c\nint sesliHarfSayisi(const char *str) {\n    int sayac = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u' ||\n            str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U') {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n```\nBu fonksiyonda sesli harflerin kontrolünü yapmak için çok sayıda karşılaştırma yapılıyor. Bunun yerine, sesli harfleri bir küme veya dizi içinde tutarak arama işlemini hızlandırabilirsiniz:\n\n```c\nint sesliHarfSayisi(const char *str) {\n    int sayac = 0;\n    const char *sesliHarfler = \"aeiouAEIOU\";\n\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (strchr(sesliHarfler, str[i])) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n```\nBu şekilde, her bir karakter için sesli harfler arasında arama yapmak, okunabilirliği artırır ve aynı zamanda kodu daha düzenli hale getirir. `strchr` fonksiyonu, verilen karakterin dizide olup olmadığını kontrol etmek için optimize edilmiş bir yerleşik fonksiyondur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:31:48.990409"
  },
  {
    "question": "Bir yazılım projesinde, bir dizi tamsayıyı alan ve her bir elemanı belirli bir sayıya bölme işlemi yapan bir fonksiyonum var. Ancak bu fonksiyon her çağrıldığında dizinin kopyasını alıyor, bu da performansı olumsuz etkiliyor. Bu kodu optimize edebilir misin?",
    "answer": "Elbette! Her çağrıldığında dizinin kopyasını almak yerine, diziyi doğrudan geçirerek ve işlemleri orijinal dizi üzerinde gerçekleştirerek bellek kullanımını azaltabiliriz. Ayrıca, bölme işlemi sırasında sıfıra bölme hatalarını önlemek için bir kontrol eklemeliyiz. İşte optimize edilmiş versiyon:\n\n```c\n#include <stdio.h>\n\nvoid divideArray(int* arr, int size, int divisor) {\n    if (divisor == 0) {\n        printf(\"Hata: Sıfıra bölme hatası!\\n\");\n        return;\n    }\n    for (int i = 0; i < size; i++) {\n        arr[i] /= divisor;\n    }\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int divisor = 2;\n    divideArray(arr, size, divisor);\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu şekilde, bellek kullanımını optimize ettiğimiz gibi performansı da artırmış olduk.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:32:05.417859"
  },
  {
    "question": "Bir proje için kullanıcıdan alınan şifrelerin güvenliğini sağlamak amacıyla, bir fonksiyon aracılığıyla şifreleri şifrelemek istiyorum. Ancak mevcut fonksiyonum her çağrıldığında, sabit bir algoritma kullanarak aynı şifreyi aynı şekilde şifreliyor. Bu durum, güvenlik açısından zayıf. Bu durumu nasıl iyileştirebilirim?",
    "answer": "Şifreleme işlemi için statik bir algoritma yerine, her şifre için bir tuz (salt) değeri ekleyerek şifrelerin güvenliğini artırabiliriz. Tuz, şifreleme algoritmasına eklenen rastgele bir değer olup, aynı şifrenin farklı kullanıcılar için farklı hash değerleri üretmesine olanak tanır. İşte bu geliştirmeleri içeren bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nvoid generateSalt(char* salt, size_t length) {\n    const char charset[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    for (size_t i = 0; i < length; i++) {\n        int key = rand() % (int)(sizeof(charset) - 1);\n        salt[i] = charset[key];\n    }\n    salt[length] = '\\0';\n}\n\nvoid hashPassword(const char* password, char* hash, const char* salt) {\n    // Basit bir hash algoritması örneği kullanıyoruz.\n    snprintf(hash, 64, \"%s%s\", password, salt); // Gerçek hash işlemi için daha sağlam bir algoritma kullanılmalı\n}\n\nint main() {\n    srand(time(NULL));\n    char password[] = \"my_secure_password\";\n    char salt[16];\n    char hash[64];\n    generateSalt(salt, sizeof(salt) - 1);\n    hashPassword(password, hash, salt);\n    printf(\"Şifre: %s\\nTuz: %s\\nHash: %s\\n\", password, salt, hash);\n    return 0;\n}\n```\nBu yöntemi kullanarak her şifre için farklı bir tuz olacağından, aynı şifreler bile farklı hash değerlerine sahip olacak ve güvenlik seviyesi artacaktır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-05-31T16:32:05.417951"
  },
  {
    "question": "Aşağıdaki C kodunda eksik olan preprocessor direktifesini tamamlayın ve açıklayın:\n\n#include <stdio.h>\n\n#define PI 3.14\n\nint main() {\n    float alan;\n    float yaricap = 5;\n    alan = ______(PI * yaricap * yaricap);\n    printf(\"Dairenin alanı: %f\\n\", alan);\n    return 0;\n}",
    "answer": "Eksik olan preprocessor direktifi 'round' fonksiyonunu kullanarak tamamlama. Ancak, burada 'round' fonksiyonu kullanılmamalı; doğrudan hesaplamayı yapabiliriz. Doğru hali:\n\nalan = PI * yaricap * yaricap;\n\nBu kod, dairenin alanını hesaplamak için PI sabitini ve yarıçapı kullanır. Preprocessor direktifleri, program derlenmeden önce kodu hazırlamak için kullanılır ve genellikle sabitler tanımlamak için kullanılır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:14.243468"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 'DEBUG' makrosu tanımlıysa ekranda 'Debug modunda çalışılıyor' yazdırın. Aksi takdirde, 'Normal modda çalışılıyor' yazdırın:\n\n#include <stdio.h>\n\n______ DEBUG\n\nint main() {\n    ______\n    return 0;\n}",
    "answer": "Eksik direktif ve makro kullanımını aşağıdaki gibi tamamlayabiliriz:\n\n#define DEBUG\n\nif (DEBUG) {\n    printf(\"Debug modunda çalışılıyor\\n\");\n} else {\n    printf(\"Normal modda çalışılıyor\\n\");\n}\n\nBu durumda, eğer DEBUG makrosu tanımlıysa, program 'Debug modunda çalışılıyor' çıktısını verecektir. Aksi takdirde, normal modda çalıştığını belirten mesajı yazdıracaktır. Preprocessor direktifleri, program akışını koşullara bağlı olarak değiştirmek için oldukça kullanışlıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:14.243547"
  },
  {
    "question": "Aşağıdaki kodda eksik olan makro tanımlamasını tamamlayın ve açıklayın. Kod: \n\n#include <stdio.h>\n\n#define PI 3.14\n\nint main() {\n    float radius = 5.0;\n    float area;\n    // Alan hesaplama işlemi için eksik olan satırı tamamlayın\n    area = ____;\n    printf(\"Dairenin alanı: %f\\n\", area);\n    return 0;\n}",
    "answer": "Eksik olan satırı şöyle tamamlayabilirsiniz: \n\narea = PI * radius * radius;\n\nBu satırda, dairenin alanı hesaplanmaktadır. Alan hesaplama formülü: A = π * r^2 (burada π, Pi sayısıdır ve r dairenin yarıçapıdır). 'PI' makrosu ile Pi sayısını tanımlayarak, kodun okunabilirliğini artırmış oluyoruz. Bu tür makro tanımlamaları, sabit değerleri kod içinde tekrar tekrar kullanmamıza olanak tanır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:24.635348"
  },
  {
    "question": "Aşağıdaki kodda '#ifdef' ve '#endif' direktifleri kullanılarak bir koşullu derleme yapılmıştır. Ancak 'DEBUG' makrosunun tanımlanmasını sağlayacak kod eksik. Kod: \n\n#include <stdio.h>\n\n// DEBUG makrosunun tanımlandığını kontrol etmek için eksik olan satırı tamamlayın\n#ifdef DEBUG\n#define LOG(msg) printf(\"DEBUG: %s\\n\", msg)\n#else\n#define LOG(msg) // Hiçbir şey yapma\n#endif\n\nint main() {\n    LOG(\"Program başladı\");\n    return 0;\n}",
    "answer": "Kodun başına DEBUG makrosunu tanımlamak için şu satırı ekleyebilirsiniz: \n\n#define DEBUG\n\nBu durumda, 'LOG' makrosu aktif olacak ve program \"Program başladı\" mesajını DEBUG formatında yazdıracaktır. Eğer 'DEBUG' makrosunu tanımlamazsanız, 'LOG' makrosu hiçbir şey yapmayacak ve kod çalıştığında herhangi bir çıktı üretmeyecektir. Koşullu derleme, özellikle hata ayıklama sürecinde faydalıdır; bu sayede, geliştirme aşamasında daha fazla bilgi alırken, üretim sürümünde gereksiz çıktıları ortadan kaldırabiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:24.635479"
  },
  {
    "question": "Aşağıda verilen C kodundaki eksik preprocessor direktifelerini tamamlayın ve açıklayın. Kod: \n\n#include <stdio.h>\n\n#define PI 3.14\n\nint main() {\n    float alan;\n    // Alan hesaplaması için eksik direktifi ekleyin\n    alan = PI * radius * radius;\n    printf(\"Daire alanı: %f\\n\", alan);\n    return 0;\n}",
    "answer": "Bu kodda, dairenin alanını hesaplamak için 'radius' isimli bir değişken kullanılıyor, fakat bu değişkenin tanımı yapılmamış. Preprocessor direktifi olarak 'radius' değişkeninin değerini ayarlamak için bir define kullanabiliriz. Bu kodu şu şekilde tamamlayabiliriz:\n\n#define RADIUS 5 \n\nBu durumda alan hesaplamasını şu şekilde güncelleyebiliriz:\n\nalan = PI * RADIUS * RADIUS;\n\nYalnızca RADIUS değişkenini tanımlayarak, alan hesaplaması işlemini gerçekleştirmiş olduk. Bu, kodun daha okunabilir ve değiştirilebilir olmasını sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:39.181446"
  },
  {
    "question": "Aşağıdaki C kodu, bir dosyadan veri okuma işlemi yapmaktadır. Ancak dosya adının değişkenini tanımlamak için preprocessor direktifi eksik. Lütfen eksik kısmı tamamlayın ve açıklayın. Kod:\n\n#include <stdio.h>\n\n// Dosya adı için eksik preprocessor direktifini ekleyin\n\nint main() {\n    FILE *dosya;\n    char ch;\n    dosya = fopen(FILENAME, \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    while ((ch = fgetc(dosya)) != EOF) {\n        printf(\"%c\", ch);\n    }\n    fclose(dosya);\n    return 0;\n}",
    "answer": "Bu kodda, dosya adı için bir preprocessor direktifi tanımlanmamış. Bu durumu düzeltmek için, dosya adını tanımlamak üzere bir define kullanabiliriz. Örneğin, şu şekilde tamamlayabiliriz:\n\n#define FILENAME \"veri.txt\"\n\nEkledikten sonra, dosya açma işlemi 'FILENAME' kullanılarak gerçekleştirilecek. Bu, kodun daha esnek olmasını sağlar; dosya adını değiştirmek istediğimizde yalnızca define satırını güncellememiz yeterli olacaktır. Bu tür preprocessor direktifleri, kodun yönetilebilirliğini artırır ve tekrar kullanılabilirlik sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:39.181604"
  },
  {
    "question": "Aşağıdaki C kodunda, 'MAX' isimli bir preprocessor direktifi tanımlanmış, fakat kullanımında bir hata var. Hatanın sebebini ve düzeltmesini açıkla.\n\n#define MAX 100\n\nint main() {\n    int a = 10;\n    int b = 20;\n    int max_value = MAX a > b ? a : b; // Hatalı satır\n    return 0;\n}",
    "answer": "'max_value' hesaplanırken 'MAX' direktifinin kullanımı hatalıdır. Preprocessor direktifleri, tanımlandıkları değeri doğrudan yerleştirir. Bu durumda, satırda 'MAX' ve 'a' arasında bir operatör eksikliği bulunmaktadır. Doğru kullanım şöyle olmalıdır:\n\nint max_value = (a > b) ? a : MAX;\n\nBu düzeltme ile, 'max_value' değişkenine 'a' ve 'b' karşılaştırması yapılacak ve bu karşılaştırma sonucuna göre en yüksek değeri almış olacağız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:52.565912"
  },
  {
    "question": "Aşağıdaki C kodunda, iki farklı preprocessor direktifi 'DEBUG' ve 'LOGGING' tanımlanmış. Ancak kullanımlarıyla ilgili bir sorun var. Hatanın sebebini ve düzeltmesini açıkla.\n\n#define DEBUG 1\n#define LOGGING\n\nint main() {\n    #ifdef DEBUG\n    printf(\"Debugging mode is ON\");\n    #endif\n\n    #if LOGGING\n    printf(\"Logging enabled\"); // Hatalı satır\n    #endif\n    return 0;\n}",
    "answer": "'LOGGING' direktifi tanımlanmış ama bir değer atanmamış. C dilinde '#if' direktifi, bir sayısal değer kontrol eder. Eğer 'LOGGING' tanımı bir değere sahip değilse, bu ifade her zaman yanlış olarak değerlendirilir. Düzeltmek için, 'LOGGING' direktifine bir değer atamak gerekmektedir:\n\n#define LOGGING 1\n\nBöylece, '#if LOGGING' ifadesi doğru çalışacak ve log mesajı ekrana yazdırılabilecektir. Sonuç olarak, kod şu şekilde olmalıdır:\n\n#if LOGGING\n    printf(\"Logging enabled\");\n#endif",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:32:52.566114"
  },
  {
    "question": "Aşağıdaki C kodunda, 'DEBUG' makrosu tanımlanmadığında hata alıyorum. Bunu düzeltmek için ne yapmalıyım? \n\n```c\n#include <stdio.h>\n\n#define DEBUG\n\nint main() {\n    #ifdef DEBUG\n        printf(\"Debugging mode is ON\\n\");\n    #endif\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```",
    "answer": "Bu durumda, 'DEBUG' makrosu tanımlı değilse debug mesajını bastırmak için 'DEBUG' makrosunun tanımını kaldırmalıyız. Kodda 'DEBUG' tanımlı değilse debug mesajını bastırmak için 'ifdef' kontrolünü aşağıdaki gibi düzenleyelim:\n\n```c\n#include <stdio.h>\n\n// #define DEBUG  // Bu satırı yorumlayarak 'DEBUG' tanımını kaldırdık\n\nint main() {\n    #ifdef DEBUG\n        printf(\"Debugging mode is ON\\n\");\n    #endif\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\nBu şekilde, 'DEBUG' tanımlı değilse program sadece \"Hello, World!\" mesajını gösterecektir. Böylece hata ortadan kalkar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:04.129548"
  },
  {
    "question": "Aşağıdaki C kodunda 'MAX' makrosu kullanıldığında beklenmeyen sonuçlar alıyorum. Bu durumu düzeltmek için ne yapmalıyım? \n\n```c\n#include <stdio.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Maximum: %d\\n\", MAX(x++, y++));\n    return 0;\n}\n```",
    "answer": "Bu kodda 'MAX' makrosunu kullandığımızda, 'x++' ve 'y++' ifadeleri iki kez değerlendirilir. Bu nedenle, sonuç beklenmedik şekilde değişir. 'x' ve 'y' değişkenlerinin değeri, makro içindeki ifadenin değerlendirilmesi sırasında artar. Bunu önlemek için, 'MAX' fonksiyonunu inline bir fonksiyon olarak tanımlamalıyız:\n\n```c\n#include <stdio.h>\n\nstatic inline int MAX(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Maximum: %d\\n\", MAX(x++, y++));\n    return 0;\n}\n```\n\nBu şekilde 'x' ve 'y' değerleri yalnızca bir kez değerlendirilir ve beklenen sonucu alırız. Bu yöntem, makro kullanımındaki yan etkileri ortadan kaldırır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:04.129724"
  },
  {
    "question": "Aşağıdaki C kodunda, 'DEBUG' makrosu tanımlandığında, belirli bir hata mesajının görüntülenmesi bekleniyor. Ancak kod çalıştığında bu hata mesajı görünmüyor. Nedenini ve çözümünü açıkla. \n\n #include <stdio.h> \n #define DEBUG \n \n int main() { \n     int x = 10; \n     #ifdef DEBUG \n         printf(\"Debug Modu: x = %d\\n\", x); \n     #endif \n     return 0; \n }",
    "answer": "Bu kodda, 'DEBUG' makrosu tanımlanmış olduğu için 'printf' satırının çalışması gerekiyor. Ancak burada dikkat edilmesi gereken bir nokta var: Eğer derleyicide DEBUG makrosu tanımlanmamışsa, bu satır tamamen atlanır. Eğer derleme sırasında DEBUG makrosunu tanımlamıyorsanız, 'printf' satırı çalışmaz. Çözüm olarak, derleme komutunuza '-DDEBUG' eklerseniz, bu makro tanımlanır ve 'printf' çalışır. Örneğin: `gcc -DDEBUG program.c -o program`.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:17.698399"
  },
  {
    "question": "Aşağıdaki C kodunda, 'VERSION' makrosunun değeri değiştirilerek, farklı bir sürüm bilgisi görüntülenmesi bekleniyor. Ancak kod değiştirildiğinde beklenen sonuç alınmıyor. Hatayı bul ve düzelt. \n\n #include <stdio.h> \n #define VERSION \"1.0\" \n \n int main() { \n     printf(\"Version: %s\\n\", VERSION); \n     #define VERSION \"2.0\" \n     printf(\"Updated Version: %s\\n\", VERSION); \n     return 0; \n }",
    "answer": "C dilinde, makrolar tanımlandıklarında, tanımlandıkları yerden itibaren geçerli olurlar. Yukarıdaki kodda, 'VERSION' makrosu ilk önce '1.0' olarak tanımlanmış ve 'printf' fonksiyonu bu değeri kullanmıştır. Daha sonra 'VERSION' makrosunu tekrar tanımlamaya çalıştığımızda, bu yeniden tanım sadece bulunduğu blok içinde geçerlidir ancak önceki tanım geçerli olmaya devam eder. Bu nedenle, 'Updated Version' satırında hala eski değeri kullanır. Çözüm olarak, 'VERSION' makrosunu en başta tanımlayıp, sürekli kullanmak yerine, değiştirilebilir bir yapı kullanmak daha iyi olabilir. Örneğin, versiyon bilgisini bir değişken olarak tanımlayabiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:17.698510"
  },
  {
    "question": "C dilinde #define direktifinin ne işe yaradığını ve nasıl kullanıldığını açıklayabilir misin?",
    "answer": "#define direktifi, sabitler veya makrolar tanımlamak için kullanılır. Bu, kodun daha okunabilir olmasını sağlar ve sabit değerleri değiştirmeyi kolaylaştırır. Örneğin, bir programda pi sayısını tanımlamak isteyelim: \n\n```c\n#define PI 3.14\n```\n\nArtık PI ifadesini kullandığımız her yerde 3.14 değeri kullanılacaktır. Örneğin:\n\n```c\n#include <stdio.h>\n\n#define PI 3.14\n\nint main() {\n    float alan = PI * 5 * 5; // Burada PI, 3.14 olarak değiştirilecektir.\n    printf(\"Dairenin alanı: %f\\n\", alan);\n    return 0;\n}\n```\n\nBu şekilde, PI değeri değiştiğinde sadece #define satırını değiştirmek yeterli olur.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:32.517105"
  },
  {
    "question": "#include direktifinin ne amaçla kullanıldığını ve nasıl çalıştığını anlatır mısın?",
    "answer": "#include direktifi, başka bir dosyayı mevcut dosyaya dahil etmek için kullanılır. Bu, kodun modüler olmasını sağlar ve tekrar kullanılabilirliği artırır. İki farklı şekilde kullanılabilir: < > içinde ve \" \" içinde. \n\nÖrneğin, standart kütüphanelerden biri olan stdio.h dosyasını dahil edelim:\n\n```c\n#include <stdio.h>\n```\n\nBu, printf gibi fonksiyonları kullanmamıza olanak tanır. Ayrıca, kendi header dosyamızı da dahil edebiliriz:\n\n```c\n#include \"my_header.h\"\n```\n\nBu durumda, my_header.h dosyasının bulunduğu dizin araştırılır ve içindeki tanımlamalar mevcut dosyaya eklenir. Örneğin:\n\n```c\n#include <stdio.h>\n#include \"my_header.h\"\n\nint main() {\n    myFunction(); // myFunction, my_header.h içinde tanımlı bir fonksiyon olmalı.\n    return 0;\n}\n```\n\nBu şekilde, programımızda farklı fonksiyon ve değişkenleri kullanarak daha düzenli bir yapı elde edebiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:32.517146"
  },
  {
    "question": "C dilinde, #define direktifini kullanarak sabit bir değer nasıl tanımlanır ve bu sabiti bir hesaplama işleminde nasıl kullanırız?",
    "answer": "#define direktifi, bir sabit değer tanımlamak için kullanılır. Örneğin, \"#define PI 3.14\" ile PI adında bir sabit tanımlayabiliriz. Bu sabiti bir hesaplama işleminde kullanmak için, kodun herhangi bir yerinde, yalnızca PI yazarız ve derleyici bunu 3.14 ile değiştirir. Örneğin:\n\n```c\n#include <stdio.h>\n#define PI 3.14\n\nint main() {\n    float radius = 5.0;\n    float area = PI * radius * radius;\n    printf(\"Dairenin alanı: %.2f\\n\", area);\n    return 0;\n}\n```\n\nBu kodda, #define ile tanımlanan PI sabiti, dairenin alanını hesaplamak için kullanılır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:43.936870"
  },
  {
    "question": "C dilinde, koşullu derleme direktifleri (#ifdef, #ifndef, #endif) kullanarak bir modülün derlenip derlenmeyeceğini nasıl kontrol edebiliriz?",
    "answer": "Koşullu derleme direktifleri, belirli koşullar altında kodun derlenip derlenmeyeceğini kontrol etmek için kullanılır. Örneğin, bir modülün sadece belirli bir tanım mevcutsa derlenmesini istiyorsak, #ifdef direktifini kullanabiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n#define DEBUG\n\n#ifdef DEBUG\nvoid debug() {\n    printf(\"Debugging mode is active.\\n\");\n}\n#endif\n\nint main() {\n    #ifdef DEBUG\n    debug();\n    #endif\n    printf(\"Program çalışıyor.\\n\");\n    return 0;\n}\n```\n\nBu örnekte, #define DEBUG ile DEBUG isimli bir tanım oluşturduk. #ifdef DEBUG ile bu tanım kontrol ediliyor. Eğer DEBUG tanımlıysa, debug() fonksiyonu çağrılacak ve \"Debugging mode is active.\" mesajı ekrana yazdırılacak. Eğer #define DEBUG satırını yorum yaparsak, debug() fonksiyonu çağrılmayacak ve yalnızca \"Program çalışıyor.\" mesajı görünecektir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:43.936926"
  },
  {
    "question": "C dilinde #define direktifinin kullanımını açıklayın. Özellikle sabit tanımlama ve makro tanımlama arasındaki farkı örneklerle gösterin.",
    "answer": "#define direktifi, C dilinde sabitler ve makrolar tanımlamak için kullanılır. Bir sabit tanımlarken, genellikle bir değer ile ilişkilendirilmiş bir isim belirleriz. Örneğin: `#define PI 3.14` ifadesi, PI isminin 3.14 değerine karşılık geldiğini belirtir. Bu tanım, kodda PI yazıldığında 3.14 ile değiştirilir. Ayrıca, #define direktifi ile makro tanımlamak da mümkündür. Örneğin: `#define SQUARE(x) ((x) * (x))` ifadesi, bir sayının karesini hesaplamak için kullanılır. Bu durumda, SQUARE(5) ifadesi kodda `((5) * (5))` olarak değiştirir. Sabitler sadece bir değer içerirken, makrolar bir veya daha fazla ifadeyi temsil edebilir. Bu nedenle, makrolar genellikle daha dinamik ve esnek bir yapı sunar. Ancak dikkatli kullanılmadığında, makroların kodun okunabilirliğini azaltabileceği ve hata ayıklamayı zorlaştırabileceği unutulmamalıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:58.138679"
  },
  {
    "question": "C dilinde koşullu derleme (#ifdef, #ifndef, #endif) direktiflerinin nasıl çalıştığını ve ne zaman kullanılması gerektiğini açıklayın.",
    "answer": "Koşullu derleme direktifleri, belirli koşullar altında kod parçalarının derlenip derlenmeyeceğini kontrol etmek için kullanılır. Örneğin, bir .h dosyasında `#ifndef` ve `#define` direktifleri ile bir koruma mekanizması oluşturabiliriz. Örneğin: \n```c\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n// Burada başlık dosyanızın içeriği yer alacak\n\n#endif\n``` \nBu yapı, MY_HEADER_H isimli makronun daha önce tanımlanıp tanımlanmadığını kontrol eder. Eğer tanımlanmamışsa, `MY_HEADER_H` makrosunu tanımlar ve başlık dosyasının içeriğini derler. Böylece, aynı başlık dosyasının birden fazla kez dahil edilmesi durumunda, derleyici hata vermez. `#ifdef` direktifi, belirli bir makronun tanımlı olup olmadığını kontrol etmek için kullanılır. Örneğin, `#ifdef DEBUG` ifadesi ile debug modunda ek mesajlar yazdırabiliriz. Bu direktifler, kodun daha modüler ve bakımı daha kolay hale gelmesine olanak tanır, çünkü yalnızca gerekli kod parçaları derlenir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:33:58.138731"
  },
  {
    "question": "C dilinde bir dosyanın içeriklerini okumadan önce bir makro tanımlayıp, bu makro ile dosya yolunu nasıl belirleyebilirim?",
    "answer": "C dilinde preprocessor direktifleri ile makro tanımlamak için '#define' ifadesini kullanabiliriz. Aşağıdaki örnekte, 'FILE_PATH' adında bir makro tanımlıyoruz ve bu makroyu dosyayı açmak için kullanıyoruz:\n\n```c\n#include <stdio.h>\n\n#define FILE_PATH \"veri.txt\"\n\nint main() {\n    FILE *file;\n    file = fopen(FILE_PATH, \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    // Dosya işlemleri burada yapılır.\n    fclose(file);\n    return 0;\n}\n```\n\nBu örnekte, dosya yolunu değiştirmek istediğimizde sadece 'FILE_PATH' makrosunu güncellememiz yeterli olur. Bu, kodun bakımını kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:05.806779"
  },
  {
    "question": "C dilinde platforma bağımlı kod yazmam gerektiğinde, preprocessor direktiflerini nasıl kullanabilirim?",
    "answer": "Preprocessor direktifleri ile platforma özel kodları ayırmak için '#ifdef', '#else' ve '#endif' ifadelerini kullanabiliriz. Aşağıdaki örnekte, Windows ve Unix tabanlı sistemlere göre farklı kodlar yazıyoruz:\n\n```c\n#include <stdio.h>\n\n#ifdef _WIN32\n#define OS_MSG \"Windows işletim sistemi kullanıyorsunuz.\"\n#else\n#define OS_MSG \"Unix tabanlı bir işletim sistemi kullanıyorsunuz.\"\n#endif\n\nint main() {\n    printf(\"%s\\n\", OS_MSG);\n    return 0;\n}\n```\n\nBu örnekte, derleyici 'WIN32' tanımını bulursa, 'OS_MSG' makrosu Windows'a özel bir mesaj içerirken, aksi takdirde Unix tabanlı bir mesaj içerecektir. Bu sayede aynı kod tabanı üzerinde farklı platformlar için uygun çıktılar elde edebiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:05.806831"
  },
  {
    "question": "C programında bir makro tanımlayarak iki sayı arasındaki maksimum değeri hesaplamak istiyorum. Bunu nasıl yapabilirim?",
    "answer": "C dilinde makro tanımlamak için #define direktifini kullanabiliriz. Aşağıda iki sayı arasındaki maksimum değeri hesaplayan bir makro örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint main() {\n    int x = 5, y = 10;\n    int max_value = MAX(x, y);\n    printf(\"Maksimum değer: %d\\n\", max_value);\n    return 0;\n}\n```\n\nBu kodda, `MAX` makrosu, iki parametre alır ve bu parametrelerin maksimumunu döner. `main` fonksiyonunda `x` ve `y` değişkenlerini tanımlıyoruz ve `MAX` makrosunu kullanarak maksimum değeri hesaplıyoruz. Sonuç olarak, `Maksimum değer: 10` çıktısını alırız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:16.642145"
  },
  {
    "question": "Bir C programında koşullu derleme kullanarak belirli bir platforma özgü kodu nasıl yönetebilirim? Örneğin, Windows ve Linux için farklı başlık dosyaları eklemek istiyorum.",
    "answer": "C dilinde koşullu derleme yapmak için #ifdef, #ifndef, #endif gibi direktifleri kullanabiliriz. Aşağıda Windows ve Linux için farklı başlık dosyalarını ekleyen bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#define PLATFORM \"Windows\"\n#elif __linux__\n#include <unistd.h>\n#define PLATFORM \"Linux\"\n#else\n#define PLATFORM \"Unknown\"\n#endif\n\nint main() {\n    printf(\"Platform: %s\\n\", PLATFORM);\n    return 0;\n}\n```\n\nBu kodda, `#ifdef` ve `#elif` direktifleri kullanarak, derleme ortamına göre platforma özgü başlık dosyalarını ekliyoruz. `_WIN32` makrosu Windows altında tanımlı olduğu için Windows'a özgü başlık dosyası ekleniyor. `__linux__` makrosu ise Linux altında tanımlıdır. Çıktı, çalıştırılan platforma göre \"Platform: Windows\" veya \"Platform: Linux\" şeklinde olacaktır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:16.642206"
  },
  {
    "question": "C dilinde bir proje boyunca farklı hata seviyelerini yönetmek için preprocessor direktifleri kullanarak bir hata raporlama mekanizması nasıl oluşturabilirim?",
    "answer": "C dilinde preprocessor direktifleri ile hata seviyelerini yönetmek için aşağıdaki gibi bir yapı oluşturabiliriz. Öncelikle, hata seviyelerini tanımlamak için bir enum kullanacağız. Daha sonra, bu seviyeleri kullanarak bir makro tanımlayacağız. Bu makro, hata seviyesine göre mesajları yazdıracak. Aşağıdaki örnek kod bu yapıyı göstermektedir:\n\n```c\n#include <stdio.h>\n\n// Hata seviyelerini tanımlıyoruz\ntypedef enum {\n    INFO,\n    WARNING,\n    ERROR\n} LogLevel;\n\n// Hata raporlama makrosu\n#define LOG(level, message) \\\n    do { \\\n        if (level == ERROR) { \\\n            fprintf(stderr, \"[ERROR] %s\\n\", message); \\\n        } else if (level == WARNING) { \\\n            fprintf(stdout, \"[WARNING] %s\\n\", message); \\\n        } else { \\\n            fprintf(stdout, \"[INFO] %s\\n\", message); \\\n        } \\\n    } while(0)\n\nint main() {\n    LOG(INFO, \"Program başlatılıyor...\");\n    LOG(WARNING, \"Bu bir uyarı mesajıdır.\");\n    LOG(ERROR, \"Bir hata oluştu!\");\n    return 0;\n}\n```\nBu örnekte, `LOG` makrosu farklı hata seviyelerine göre mesajları konsola yazdırır. `stderr` ile hata mesajları hata akışına, `stdout` ile diğer mesajlar standart akışa yazdırılır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:31.000704"
  },
  {
    "question": "C dilinde belirli bir platformda veya derleyicide çalışmak üzere kodu koşullandırmak için preprocessor direktiflerini nasıl kullanabilirim?",
    "answer": "C dilinde platforma özgü kod yazmak için `#ifdef`, `#ifndef`, `#else`, `#endif` gibi preprocessor direktiflerini kullanabiliriz. Bu, kodun belirli platformlarda veya derleyicilerde derlenmesini sağlar. Örneğin, aşağıdaki örnek kodda, Windows ve Linux platformları için farklı kod yolları tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\n// Platforma göre derleme\n#ifdef _WIN32\n    #define PLATFORM \"Windows\"\n    void platform_specific_function() {\n        printf(\"Windows platformu için spesifik bir işlem yapılıyor...\\n\");\n    }\n#elif defined(__linux__)\n    #define PLATFORM \"Linux\"\n    void platform_specific_function() {\n        printf(\"Linux platformu için spesifik bir işlem yapılıyor...\\n\");\n    }\n#else\n    #define PLATFORM \"Bilinmeyen\"\n    void platform_specific_function() {\n        printf(\"Bilinmeyen platform...\\n\");\n    }\n#endif\n\nint main() {\n    printf(\"Çalışan platform: %s\\n\", PLATFORM);\n    platform_specific_function();\n    return 0;\n}\n```\nBu kodda, `_WIN32` makrosu Windows ortamında, `__linux__` makrosu ise Linux ortamında tanımlıdır. Derleyici hangi platformda olduğumuzu anlamak için bu makroları kontrol eder ve uygun fonksiyonu çağırır. Bu, kodu çeşitli platformlarda çalıştırmamızı sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:31.000752"
  },
  {
    "question": "Kodu optimize etmek için #define yerine enum kullanmanın avantajları nelerdir? Aşağıdaki kodda #define kullanan bir örnek verin ve bunu enum ile nasıl değiştireceğinizi gösterin.\n\n#define PI 3.14\n\nvoid calculateCircleArea(float radius) {\n    return PI * radius * radius;\n}",
    "answer": "C dilinde sabitler için #define yerine enum kullanmanın birkaç avantajı vardır. Öncelikle, enum tipi derleyici tarafından kontrol edilirken, #define sadece metin yerleştirmesi yapar. Bu nedenle, enum kullanmak hata ayıklamayı kolaylaştırır ve kodun okunabilirliğini artırır. Ayrıca, enum değerleri tür güvenliği sağlar. Aşağıda verdiğiniz örneği enum ile güncelleyelim:\n\n```c\n#include <stdio.h>\n\nenum Constants {\n    PI = 3.14  // PI sabitini enum ile tanımlıyoruz.\n};\n\nvoid calculateCircleArea(float radius) {\n    return PI * radius * radius;\n}\n```\nYukarıdaki değişiklikle, PI artık bir enum sabiti olarak tanımlandı. Bu, kodun daha güvenli ve okunabilir olmasını sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:43.325623"
  },
  {
    "question": "Aşağıdaki kodda kullanılan #ifdef ve #ifndef direktiflerini yeniden yapılandırarak daha iyi bir kullanım örneği oluşturun. Kodun amacı, bir derleme sırasında farklı platformlarda farklı kütüphaneleri dahil etmektir.\n\n#ifdef WINDOWS\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n\nvoid sleepFunction(int seconds) {\n    sleep(seconds);\n}",
    "answer": "Bu kod parçası, platforma bağlı olarak farklı kütüphaneleri dahil etmektedir. Ancak, #ifdef ve #else kullanımı yerine #if ile #elif direktiflerini kullanarak kodu daha okunabilir hale getirebiliriz. Ayrıca, uyku fonksiyonu için her iki platformda da aynı isim kullanılmalıdır. İşte önerilen güncelleme:\n\n```c\n#include <stdio.h>\n\n#if defined(WINDOWS)\n#include <windows.h>\n#define sleepFunction(seconds) Sleep((seconds) * 1000)  // Sleep milisaniye cinsinden çalışır.\n#elif defined(LINUX)\n#include <unistd.h>\n#define sleepFunction(seconds) sleep(seconds)\n#else\n#error \"Desteklenmeyen platform!\"\n#endif\n\nvoid customSleep(int seconds) {\n    sleepFunction(seconds);\n}\n```\nBurada, `#if`, `#elif`, ve `#else` kullanarak daha net bir yapıya kavuşturduk. Ayrıca, `sleepFunction` makrosu ile hem Windows hem de Linux için uyku fonksiyonu tanımlandı. Böylece, her iki platformda da uyku işlevi kullanılabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:43.325723"
  },
  {
    "question": "Kodda, birden fazla dosyada kullanılan ortak bir hata ayıklama makrosu tanımlandı. Ancak bu makro, her dosyada yeniden tanımlanıyor ve bu da kodun tekrarlanmasına yol açıyor. Bu durumu nasıl optimize edebilirim?",
    "answer": "Hata ayıklama makrosunu tek bir dosyada tanımlayıp, diğer dosyalarda bu dosyayı include ederek tekrar tanımlama ihtiyacını ortadan kaldırabilirsiniz. Örneğin, `debug.h` adlı bir dosya oluşturun ve hata ayıklama makrosunu burada tanımlayın. Daha sonra diğer dosyalarda sadece `#include \"debug.h\"` ifadesini kullanarak bu makroyu tanımlayabilirsiniz. Bu, kodunuzu daha okunabilir ve bakımını kolay hale getirir. Örnek: \n\n```c\n// debug.h\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#define DEBUG_PRINT(msg) printf(\"DEBUG: %s\\n\", msg)\n\n#endif // DEBUG_H\n```\n\n```c\n// main.c\n#include \"debug.h\"\n\nint main() {\n    DEBUG_PRINT(\"Program başlıyor...\");\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:55.832353"
  },
  {
    "question": "Bir proje içerisinde çeşitli platformlarda çalışacak olan kod parçaları var. Ancak, platforma özgü kodu yönetmek için kullanılan preprocessor direktifleri karmaşık bir hale geldi. Bu durumu nasıl sadeleştirebiliriz?",
    "answer": "Platforma özgü kod parçalarını yönetirken, `#ifdef` ve `#endif` direktiflerini gruplamak yerine, bir dizi bağlı makro tanımlayabilirsiniz. Örneğin, platformları daha yönetilebilir hale getirmek için bir ana makro tanımlayıp, ona bağlı alt makrolar oluşturabilirsiniz. Bu sayede, ana makroyu kontrol ederek hangi platformun aktif olduğunu belirleyebilirsiniz. Örnek: \n\n```c\n// platform.h\n#ifndef PLATFORM_H\n#define PLATFORM_H\n\n// Platform tanımları\n#ifdef _WIN32\n#define PLATFORM_WINDOWS\n#elif defined(__linux__)\n#define PLATFORM_LINUX\n#else\n#error \"Desteklenmeyen platform!\"\n#endif\n\n#endif // PLATFORM_H\n```\n\n```c\n// main.c\n#include \"platform.h\"\n\nint main() {\n#ifdef PLATFORM_WINDOWS\n    printf(\"Windows platformu çalışıyor.\");\n#elif defined(PLATFORM_LINUX)\n    printf(\"Linux platformu çalışıyor.\");\n#endif\n    return 0;\n}\n``` Bu yöntemle, platforma özgü koşulları yönetmek daha kolay olacak ve kodunuz daha düzenli bir yapıya sahip olacaktır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-05-31T16:34:55.832426"
  },
  {
    "question": "Kullanıcıdan 5 adet tam sayı alarak bunları bir diziye kaydedin ve dizinin elemanlarının toplamını hesaplayın.",
    "answer": "Aşağıdaki kod, kullanıcıdan 5 adet tam sayı alarak bunları bir diziye kaydeder ve ardından bu sayıların toplamını hesaplar:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayilar[5]; // 5 elemanlı bir dizi tanımlıyoruz.\n    int toplam = 0;\n\n    printf(\"5 adet tam sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]); // Kullanıcıdan dizi elemanlarını alıyoruz.\n        toplam += sayilar[i]; // Toplama ekliyoruz.\n    }\n\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kodda, `sayilar` adında bir dizi tanımladık ve `for` döngüsü ile kullanıcıdan değerler alarak toplamını hesapladık. Sonuç, kullanıcıya ekrana yazdırıldı.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:06.114612"
  },
  {
    "question": "Kullanıcıdan alınan 10 adet ondalıklı sayıyı bir diziye kaydedin ve dizinin en büyük elemanını bulun.",
    "answer": "Aşağıdaki kod, kullanıcıdan 10 adet ondalıklı sayı alır ve bu sayıların en büyüğünü bulur:\n\n```c\n#include <stdio.h>\n\nint main() {\n    float sayilar[10]; // 10 elemanlı bir dizi tanımlıyoruz.\n    float enBuyuk; // En büyük sayıyı saklayacağımız değişken.\n\n    printf(\"10 adet ondalıklı sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%f\", &sayilar[i]); // Kullanıcıdan dizi elemanlarını alıyoruz.\n    }\n\n    enBuyuk = sayilar[0]; // İlk elemanı en büyük olarak varsayıyoruz.\n    for (int i = 1; i < 10; i++) {\n        if (sayilar[i] > enBuyuk) {\n            enBuyuk = sayilar[i]; // Yeni en büyük değeri güncelliyoruz.\n        }\n    }\n\n    printf(\"Dizinin en büyük elemanı: %.2f\\n\", enBuyuk);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan sayıları alıyoruz ve bir `for` döngüsü ile dizinin en büyük elemanını bulmak için karşılaştırmalar yapıyoruz. Sonuç, kullanıcıya ekrana yazdırıldı.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:06.114711"
  },
  {
    "question": "Kullanıcının girdiği 10 tam sayıyı tutan bir dizi oluşturun. Ardından bu dizideki sayıların ortalamasını hesaplayacak bir fonksiyon yazın ve sonucu ekrana yazdırın. Eksik kodu tamamlayın:",
    "answer": "#include <stdio.h>\n\nfloat ortalamaHesapla(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int sayilar[10];\n    printf(\"10 tam sayı giriniz:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &sayilar[i]);\n    }\n    float ortalama = ortalamaHesapla(sayilar, 10);\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan 10 tam sayı alır ve bu sayıların ortalamasını hesaplayarak ekrana yazdırır. 'ortalamaHesapla' fonksiyonu, verilen diziyi alır ve toplamını bulduktan sonra ortalamasını döner.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:23.861014"
  },
  {
    "question": "Bir dizi içinde yer alan sayıların kaç tanesinin pozitif, kaç tanesinin negatif olduğunu sayan bir program yazın. Eksik kodu tamamlayın:",
    "answer": "#include <stdio.h>\n\nvoid sayilariSay(int dizi[], int boyut, int *pozitif, int *negatif) {\n    *pozitif = 0;\n    *negatif = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] > 0) {\n            (*pozitif)++;\n        } else if (dizi[i] < 0) {\n            (*negatif)++;\n        }\n    }\n}\n\nint main() {\n    int sayilar[10];\n    printf(\"10 tam sayı giriniz:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &sayilar[i]);\n    }\n    int pozitifSayisi, negatifSayisi;\n    sayilariSay(sayilar, 10, &pozitifSayisi, &negatifSayisi);\n    printf(\"Pozitif Sayılar: %d\\n\", pozitifSayisi);\n    printf(\"Negatif Sayılar: %d\\n\", negatifSayisi);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan 10 tam sayı alır. 'sayilariSay' fonksiyonu, pozitif ve negatif sayıların sayısını belirlemek için diziyi döngü ile kontrol eder ve sonuçları ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:23.861105"
  },
  {
    "question": "Kullanıcıdan alınan bir dizi tam sayının en büyük ve en küçük elemanını bulan bir C programını tamamlayın. Başlangıç kodu: #include <stdio.h>\n\nint main() {\n    int dizi[100], n, enBuyuk, enKucuk;\n    printf(\"Dizinin eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Dizinin elemanlarını girin: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    // Burayı tamamlayın\n    return 0;\n}",
    "answer": "Kodu tamamlamak için en büyük ve en küçük elemanları bulmak için bir döngü kullanmalıyız. İşte tamamlanmış kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[100], n, enBuyuk, enKucuk;\n    printf(\"Dizinin eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Dizinin elemanlarını girin: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    enBuyuk = dizi[0];\n    enKucuk = dizi[0];\n    for (int i = 1; i < n; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n        if (dizi[i] < enKucuk) {\n            enKucuk = dizi[i];\n        }\n    }\n    printf(\"En büyük eleman: %d\\n\", enBuyuk);\n    printf(\"En küçük eleman: %d\\n\", enKucuk);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan alınan dizi elemanları için en büyük ve en küçük değerler bulunuyor. Dizi ilk elemanla başlatılıyor ve daha sonra döngü ile karşılaştırmalar yapılıyor.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:41.622137"
  },
  {
    "question": "Bir kullanıcının girdiği 10 sayıdan çift olanları toplayarak sonucu ekrana yazan bir C programı yazın. Başlangıç kodu: #include <stdio.h>\n\nint main() {\n    int dizi[10];\n    int toplam = 0;\n    printf(\"10 tam sayı girin: \");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    // Burayı tamamlayın\n    printf(\"Çift sayıların toplamı: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Kodu tamamlamak için alınan dizinin her elemanını kontrol edip çift olanları toplamamız gerekiyor. İşte tamamlanmış kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10];\n    int toplam = 0;\n    printf(\"10 tam sayı girin: \");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    for (int i = 0; i < 10; i++) {\n        if (dizi[i] % 2 == 0) {\n            toplam += dizi[i];\n        }\n    }\n    printf(\"Çift sayıların toplamı: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kodda, dizi içerisindeki her elemanı kontrol ediyoruz. Eğer sayı çift ise, bu sayıyı toplam değişkenine ekliyoruz. Sonuçta çift sayıların toplamı ekrana yazdırılıyor.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:41.622262"
  },
  {
    "question": "Aşağıdaki C kodu, bir dizi içindeki sayıların toplamını hesaplamaya çalışıyor ancak hata alıyor. Kodu düzeltin ve hata nedenini açıklayın.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    int sum = 0;\n    for (int i = 0; i <= 5; i++) {\n        sum += arr[i];\n    }\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n```",
    "answer": "Bu kodda dizinin boyutunu aşan bir döngü kullanıldığı için 'segmentation fault' hatası alacaksınız. `for` döngüsündeki koşul `i <= 5` yerine `i < 5` olmalı. Çünkü dizinin indeksleri 0'dan başlar ve 4'e kadar gider (toplamda 5 eleman). Düzgün çalışan kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    int sum = 0;\n    for (int i = 0; i < 5; i++) {\n        sum += arr[i];\n    }\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:54.349077"
  },
  {
    "question": "Aşağıdaki kod, bir dizi içerisindeki en büyük sayıyı bulmaya çalışıyor. Ancak sonuç yanlış çıkıyor. Hatanın nedenini bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {3, 5, 1, 4, 2};\n    int max = arr[0];\n    for (int i = 1; i <= 5; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}\n```",
    "answer": "Bu kodda yine dizinin boyutunu aşan bir döngü kullanıldığı için 'segmentation fault' hatası meydana gelecektir. `for` döngüsündeki koşul `i <= 5` yerine `i < 5` olmalıdır. Ayrıca, dizinin boyutu 5 olduğu için indeksler 0'dan 4'e kadar gitmektedir. Düzgün çalışan kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {3, 5, 1, 4, 2};\n    int max = arr[0];\n    for (int i = 1; i < 5; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:35:54.349219"
  },
  {
    "question": "Aşağıdaki C kodunda bir dizi elemanlarını toplamak için bir fonksiyon tanımlanmıştır. Ancak, program beklenmedik bir sonuç veriyor. Hatanın nedenini bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i <= boyut; i++) { // Hatalı döngü sınırı\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = toplam(dizi, boyut);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}\n```",
    "answer": "Kodda döngü sınırı hatalı. 'for (int i = 0; i <= boyut; i++)' ifadesi ile boyutun sonundaki elemanı kontrol etmeye çalışıyorsunuz. Ancak dizilerin indeksleri 0'dan başladığı için, döngü sınırını 'i < boyut' olarak değiştirmelisiniz. Doğru kod:\n\n```c\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) { // Düzgün döngü sınırı\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:06.716085"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcıdan alınan bir dizi elemanının en büyük sayısını bulmak için bir fonksiyon tanımlanmıştır. Ancak, program en büyük sayıyı doğru bir şekilde bulamıyor. Hatanın nedenini bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i <= boyut; i++) { // Hatalı döngü sınırı\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int dizi[5];\n    printf(\"5 adet sayı girin: \\\n\");\n    for(int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"En büyük sayı: %d\\n\", enBuyuk(dizi, 5));\n    return 0;\n}\n```",
    "answer": "Kodda yine döngü sınırı hatalı. 'for (int i = 1; i <= boyut; i++)' ifadesinde 'i <= boyut' yerine 'i < boyut' olmalıdır. Aksi takdirde, dizinin boyutuna denk gelen indexe erişmeye çalıştığınızda belirsiz bir sonuç alırsınız. Doğru kod:\n\n```c\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) { // Düzgün döngü sınırı\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:06.716288"
  },
  {
    "question": "Aşağıdaki C kodu, kullanıcıdan 5 sayıyı alıp bu sayıların ortalamasını hesaplamaktadır. Ancak ortalama hesaplaması yanlış yapılıyor. Hatanın nedenini bulun ve düzeltin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5];\n    int toplam = 0;\n    float ortalama;\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"Bir sayı girin: \");\n        scanf(\"%d\", &dizi[i]);\n        toplam += dizi[i];\n    }\n\n    ortalama = toplam / 5;\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n\n    return 0;\n}\n```",
    "answer": "Bu kodda ortalama hesaplaması yanlış çünkü `toplam` değişkeni tam sayı (int) olarak tanımlanmış. Tam sayılarla yapılan bölme işlemi, sonucu tam sayı olarak verecektir. Bu yüzden sonucu float olarak elde edemiyoruz. Düzeltmek için aşağıdaki gibi bir değişiklik yapmalıyız:\n\n```c\n    ortalama = toplam / 5.0;\n```\n\nYa da `toplam`'ı float türünde tanımlayabiliriz:\n\n```c\n    float toplam = 0;\n```\n\nBu değişikliklerden birini yaparak ortalama doğru bir şekilde hesaplanır. Örneğin, `5` ve `9` gibi sayılar girildiğinde sonuç `7.00` olarak beklenir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:22.096037"
  },
  {
    "question": "Aşağıdaki kod, kullanıcıdan alınan sayılarla bir dizi oluşturmakta, ardından bu diziyi tersten yazdırmaktadır. Ancak dizi elemanlarını yazdırırken beklenmedik bir sonuç alıyorsunuz. Hatanın nedenini bulun ve düzeltin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10];\n\n    for (int i = 0; i < 10; i++) {\n        printf(\"Bir sayı girin: \");\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 10; i >= 0; i--) {\n        printf(\"%d \", dizi[i]);\n    }\n\n    return 0;\n}\n```",
    "answer": "Bu kodda, diziyi tersten yazdırırken döngü `i >= 0` koşulu ile başlatılmış ve `i` değeri `10` olarak tanımlanmıştır. Ancak dizinin son elemanı `dizi[9]` olmalıdır. Yani dizinin geçerli indeksleri `0` ile `9` arasındadır. Bu nedenle `i` değeri `10` olduğunda geçersiz bir bellek erişimi yapılıyor. Düzeltmek için döngü koşulu `i >= 0` yerine `i > 0` olmalı ve başlangıç değeri `9` olmalıdır:\n\n```c\n    for (int i = 9; i >= 0; i--) {\n```\n\nBu değişiklikle birlikte, kullanıcıdan alınan sayılar doğru bir şekilde tersten yazdırılacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:22.096293"
  },
  {
    "question": "Bir dizi tanımlayıp, içinde 5 adet tam sayı saklayacak şekilde nasıl doldurabilirim?",
    "answer": "C dilinde bir dizi tanımlamak için öncelikle dizinin tipini ve boyutunu belirtmemiz gerekiyor. Örneğin, 5 adet tam sayı saklayacak bir dizi tanımlamak için aşağıdaki gibi bir kod yazabiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayilar[5]; // 5 elemanlı bir tam sayı dizisi tanımlıyoruz\n\n    // Diziyi doldurmak için kullanıcıdan değer alıyoruz\n    for(int i = 0; i < 5; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]); // Kullanıcının girdiği değeri diziye atıyoruz\n    }\n\n    // Dizinin elemanlarını ekrana yazdırıyoruz\n    printf(\"Dizi elemanları: \");\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    return 0;\n}\n```\nBu kodda önce `sayilar` adında bir dizi tanımlıyoruz. Daha sonra bir döngü ile kullanıcıdan değerler alıp bu değerleri diziye yerleştiriyoruz. En son olarak dizinin elemanlarını ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:34.508066"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını nasıl hesaplayabilirim?",
    "answer": "Dizinin elemanlarının toplamını hesaplamak için öncelikle diziyi tanımlayıp, ardından bir döngü kullanarak tüm elemanları toplamak gerekir. Aşağıdaki örnekte, 4 elemanlı bir tam sayı dizisinin toplamını nasıl hesaplayacağımızı gösteriyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayilar[4] = {10, 20, 30, 40}; // 4 elemanlı dizi tanımlıyoruz\n    int toplam = 0; // Toplam için bir değişken tanımlıyoruz\n\n    // Dizinin elemanlarını toplayan döngü\n    for(int i = 0; i < 4; i++) {\n        toplam += sayilar[i]; // Her elemanı toplam değişkenine ekliyoruz\n    }\n\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam); // Sonucu ekrana yazdırıyoruz\n    return 0;\n}\n```\nBu kodda `sayilar` adında bir dizi ve `toplam` adında bir değişken tanımlıyoruz. Daha sonra bir döngü ile dizinin tüm elemanlarını dolaşıp, her bir elemanı `toplam` değişkenine ekliyoruz. Sonuç olarak, dizinin elemanlarının toplamını ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:34.508118"
  },
  {
    "question": "Bir dizi içindeki pozitif ve negatif sayıları ayırmak için nasıl bir C programı yazabilirim?",
    "answer": "Pozitif ve negatif sayıları ayırmak için, önce bir dizi tanımlayıp kullanıcıdan bu dizinin elemanlarını girmesini isteyebiliriz. Daha sonra elemanları kontrol ederek pozitif ve negatif sayıları ayrı dizilere atayabiliriz. Aşağıda örnek bir kod bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10];\n    int pozitif[10];\n    int negatif[10];\n    int pozitifSayisi = 0, negatifSayisi = 0;\n\n    // Kullanıcıdan dizi elemanlarını alma\n    printf(\"10 adet sayı girin:\\n\");\n    for(int i = 0; i < 10; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Pozitif ve negatif sayıları ayırma\n    for(int i = 0; i < 10; i++) {\n        if(dizi[i] >= 0) {\n            pozitif[pozitifSayisi++] = dizi[i];\n        } else {\n            negatif[negatifSayisi++] = dizi[i];\n        }\n    }\n\n    // Sonuçları ekrana yazdırma\n    printf(\"Pozitif sayılar:\\n\");\n    for(int i = 0; i < pozitifSayisi; i++) {\n        printf(\"%d \", pozitif[i]);\n    }\n    printf(\"\\nNegatif sayılar:\\n\");\n    for(int i = 0; i < negatifSayisi; i++) {\n        printf(\"%d \", negatif[i]);\n    }\n    return 0;\n}\n```\nBu program, kullanıcıdan 10 sayı alır ve bu sayıları pozitif ve negatif olarak iki ayrı diziye ayırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:47.131905"
  },
  {
    "question": "Bir dizi içerisindeki elemanların toplamını ve ortalamasını nasıl hesaplayabilirim?",
    "answer": "Bir dizi içerisindeki elemanların toplamını ve ortalamasını hesaplamak için, önce bir dizi tanımlayıp ardından kullanıcıdan bu dizinin elemanlarını girmesini istiyoruz. Elemanları toplamak için bir döngü kullanırız. Toplamı bulduktan sonra ortalamayı hesaplamak için toplamı eleman sayısına bölmeliyiz. Aşağıda örnek bir kod bulabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5];\n    int toplam = 0;\n    float ortalama;\n\n    // Kullanıcıdan dizi elemanlarını alma\n    printf(\"5 adet sayı girin:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Toplama işlemi\n    for(int i = 0; i < 5; i++) {\n        toplam += dizi[i];\n    }\n\n    // Ortalama hesaplama\n    ortalama = toplam / 5.0;\n\n    // Sonuçları ekrana yazdırma\n    printf(\"Toplam: %d\\n\", toplam);\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n```\nBu program, kullanıcıdan 5 sayı alır, bu sayıların toplamını hesaplar ve ardından ortalamasını ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:36:47.131945"
  },
  {
    "question": "Bir dizi içerisindeki tekrar eden öğeleri bulmak ve sadece bir kez göstermek için nasıl bir algoritma geliştirebiliriz?",
    "answer": "Bu soruda, bir dizi içerisindeki tekrar eden öğeleri bulup sadece bir kez göstermek için bir algoritma geliştireceğiz. İlk olarak, bir dizi oluşturacağız ve daha sonra tekrar eden öğeleri bulmak için iki döngü kullanacağız. Bu döngülerden ilki, dizinin her bir öğesini kontrol ederken, ikincisi ise mevcut öğenin daha önce dizinin diğer kısmında olup olmadığını kontrol edecektir. Eğer öğe daha önce bulunmamışsa, bir sonuç dizisine ekleyeceğiz. İşte bu işlemi gerçekleştiren bir C kodu örneği:\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 100\n\nint main() {\n    int dizi[MAX_SIZE] = {1, 2, 3, 2, 4, 1, 5, 3};\n    int boyut = 8;\n    int tekrarEden[MAX_SIZE];\n    int tekrarIndex = 0;\n\n    for (int i = 0; i < boyut; i++) {\n        int varMi = 0;\n        for (int j = 0; j < tekrarIndex; j++) {\n            if (dizi[i] == tekrarEden[j]) {\n                varMi = 1;\n                break;\n            }\n        }\n        if (!varMi) {\n            tekrarEden[tekrarIndex++] = dizi[i];\n        }\n    }\n\n    printf(\"Tekrar etmeyen öğeler: \");\n    for (int k = 0; k < tekrarIndex; k++) {\n        printf(\"%d \", tekrarEden[k]);\n    }\n    return 0;\n}\n```\n\nBu kodda, `dizi` adında bir dizi tanımlıyoruz ve öğeleri kontrol etmek için iç içe iki döngü kullanıyoruz. `tekrarEden` dizisi, tekrar etmeyen öğeleri saklamak için kullanılıyor. Sonuç olarak, tekrar etmeyen öğeleri ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:02.941145"
  },
  {
    "question": "Bir dizideki en yüksek ve en düşük değeri bulmak için nasıl bir fonksiyon yazabiliriz?",
    "answer": "Bu soruda, bir dizideki en yüksek ve en düşük değerleri bulmak için bir fonksiyon yazacağız. Fonksiyon, dizi ve dizinin boyutunu parametre olarak alacak ve en büyük ve en küçük değerleri döndürecektir. Bu işlemi gerçekleştirmek için bir döngü kullanarak dizinin her bir öğesini kontrol edeceğiz. İşte bu işlemi gerçekleştiren bir C kodu örneği:\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 100\n\nvoid enBuyukEnKucukBul(int dizi[], int boyut, int *enBuyuk, int *enKucuk) {\n    *enBuyuk = dizi[0];\n    *enKucuk = dizi[0];\n\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > *enBuyuk) {\n            *enBuyuk = dizi[i];\n        }\n        if (dizi[i] < *enKucuk) {\n            *enKucuk = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {12, 7, 45, 2, 34, 22};\n    int boyut = 6;\n    int enBuyuk, enKucuk;\n\n    enBuyukEnKucukBul(dizi, boyut, &enBuyuk, &enKucuk);\n    printf(\"En buyuk deger: %d\\n\", enBuyuk);\n    printf(\"En kucuk deger: %d\\n\", enKucuk);\n    return 0;\n}\n```\n\nBu kodda, `enBuyukEnKucukBul` adında bir fonksiyon tanımlıyoruz. Bu fonksiyon, diziyi gezip en büyük ve en küçük değerleri buluyor. `main` fonksiyonunda, dizi tanımlanıyor ve fonksiyon çağrılarak sonuç ekrana yazdırılıyor. Bu yöntem, dizinin boyutu bilinmediğinde de kullanılabilir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:02.941188"
  },
  {
    "question": "Bir tamsayı dizisi içinde en büyük sayıyı bulan bir C programı yazın.",
    "answer": "Aşağıda verilen C kodu, bir tamsayı dizisi içerisindeki en büyük sayıyı bulmaktadır. Öncelikle dizinin elemanlarını tanımlayıp ardından en büyük sayıyı bulmak için bir döngü kullanıyoruz.\n\n```c\n#include <stdio.h>\n#define DIZI_BOYUTU 5\n\nint main() {\n    int dizi[DIZI_BOYUTU] = {2, 5, 1, 8, 3}; // Tamsayı dizisi tanımlandı\n    int enBuyuk = dizi[0]; // İlk elemanı en büyük olarak varsayıyoruz\n\n    // Dizinin elemanları arasında en büyük değeri bulmak için döngü\n    for (int i = 1; i < DIZI_BOYUTU; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i]; // Eğer mevcut eleman, en büyükten büyükse güncellenir\n        }\n    }\n\n    printf(\"Dizideki en büyük sayı: %d\\n\", enBuyuk); // Sonucu yazdırıyoruz\n    return 0;\n}\n```\n\nBu programda, ilk önce bir diziyi tanımlayıp ilk elemanı en büyük olarak ayarlıyoruz. Ardından döngü ile diğer elemanları kontrol ederek en büyük değeri buluyoruz. Sonuç olarak en büyük sayıyı konsola yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:17.557636"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını tersten yazdıran bir C programı yazın.",
    "answer": "Aşağıda verilen C kodu, bir tamsayı dizisinin elemanlarını tersten yazdırmaktadır. Dizinin elemanlarını tanımladıktan sonra, diziyi geri döndürmek için bir döngü kullanıyoruz.\n\n```c\n#include <stdio.h>\n#define DIZI_BOYUTU 5\n\nint main() {\n    int dizi[DIZI_BOYUTU] = {10, 20, 30, 40, 50}; // Tamsayı dizisi tanımlandı\n\n    printf(\"Dizinin elemanları tersten: \");\n    // Dizinin elemanlarını ters sırada yazdırmak için döngü\n    for (int i = DIZI_BOYUTU - 1; i >= 0; i--) {\n        printf(\"%d \", dizi[i]); // Elemanlar tersten yazdırılır\n    }\n    printf(\"\\n\"); // Yeni satır ekliyoruz\n    return 0;\n}\n```\n\nBu program, öncelikle bir dizi tanımlar ve ardından dizinin son elemanından başlayarak ilk elemanına kadar döngü ile ilerleyerek elemanları tersten yazdırır. Kullanıcıya dizinin elemanlarını ters sırada göstermek için printf fonksiyonunu kullanıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:17.557673"
  },
  {
    "question": "Bir dizi içerisinde bulunan pozitif tam sayıların toplamını ve ortalamasını hesaplayan bir C programı yazın.",
    "answer": "Aşağıda verilen C programı, kullanıcının girdiği pozitif tam sayılardan oluşan bir dizi alır ve bu dizinin toplamını ve ortalamasını hesaplar:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int n;\n    printf(\"Kaç pozitif tam sayı gireceksiniz? \");\n    scanf(\"%d\", &n);\n\n    int dizi[n];\n    int toplam = 0;\n\n    // Kullanıcıdan diziyi doldurmasını istiyoruz.\n    for(int i = 0; i < n; i++) {\n        printf(\"%d. pozitif tam sayıyı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n        toplam += dizi[i]; // Her sayıyı toplam değişkenine ekliyoruz.\n    }\n\n    float ortalama = (float)toplam / n; // Toplamı eleman sayısına bölerek ortalamayı hesaplıyoruz.\n    printf(\"Toplam: %d, Ortalama: %.2f\\n\", toplam, ortalama);\n\n    return 0;\n}\n```\nBu programda önce kullanıcıdan dizinin boyutu isteniyor. Ardından, kullanıcıdan pozitif tam sayılar alınıyor ve bu sayılar toplanıyor. Son olarak toplam ve ortalama ekrana yazdırılıyor.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:33.165339"
  },
  {
    "question": "Verilen bir dizideki en büyük ve en küçük elemanı bulan bir C fonksiyonu yazın. Fonksiyon, dizinin boyutunu ve diziyi parametre olarak almalıdır.",
    "answer": "Aşağıdaki C programı, bir dizinin en büyük ve en küçük elemanını bulan bir fonksiyon içerir:\n\n```c\n#include <stdio.h>\n\nvoid enBuyukVeEnKucuk(int dizi[], int boyut, int *enBuyuk, int *enKucuk) {\n    *enBuyuk = dizi[0];\n    *enKucuk = dizi[0];\n    for(int i = 1; i < boyut; i++) {\n        if(dizi[i] > *enBuyuk) {\n            *enBuyuk = dizi[i];\n        }\n        if(dizi[i] < *enKucuk) {\n            *enKucuk = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 12, 7, 3, 18, 1};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int enBuyuk, enKucuk;\n\n    enBuyukVeEnKucuk(dizi, boyut, &enBuyuk, &enKucuk);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk);\n    printf(\"En küçük eleman: %d\\n\", enKucuk);\n\n    return 0;\n}\n```\nBu programda, `enBuyukVeEnKucuk` isimli bir fonksiyon oluşturulmuştur. Bu fonksiyon, verilen diziyi döngü ile kontrol ederek en büyük ve en küçük değerleri bulur. `main` fonksiyonunda ise bir dizi tanımlanır ve bu dizinin boyutu hesaplanarak fonksiyona gönderilir. Son olarak bulunan değerler ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:33.165427"
  },
  {
    "question": "Bir dizi içindeki tekrar eden elemanları bulmak için bir algoritma yazın. Dizi elemanlarının sıklığını hesaplayarak hangi elemanların kaç kez tekrarlandığını gösterin.",
    "answer": "Bu problemi çözmek için bir `int` dizisi ve bir `int` frekans dizisi kullanarak sayım yapabiliriz. İlk olarak, dizinin elemanlarını döngü ile gezip her elemanın sıklığını frekans dizisinde güncelleyeceğiz. Örnek kod aşağıda verilmiştir:\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 100\n\nvoid countFrequencies(int arr[], int n) {\n    int frequency[MAX_SIZE] = {0};\n    for (int i = 0; i < n; i++) {\n        frequency[arr[i]]++;\n    }\n    printf(\"Elemanlar ve frekansları:\\n\");\n    for (int i = 0; i < MAX_SIZE; i++) {\n        if (frequency[i] > 0) {\n            printf(\"%d: %d kez\\n\", i, frequency[i]);\n        }\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 2, 3, 4, 4, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    countFrequencies(arr, n);\n    return 0;\n}\n```\nBu kodda, `countFrequencies` fonksiyonu, girdi dizisini alır ve her elemanın frekansını bulur. Her bir elemanın kaç kez geçtiğini ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:45.304646"
  },
  {
    "question": "Bir diziyi tersine çeviren bir algoritma yazın. Dizi elemanları, bellek kullanımını optimize etmek için bir döngü ile değiştirilmelidir.",
    "answer": "Bir diziyi tersine çevirmek için, dizinin başlangıç ve bitiş indekslerini kullanarak yer değiştirme işlemi yapabiliriz. Bu yöntem, dizinin elemanlarını iki kez geçmemizi sağlar ve ek bellek kullanımı gerektirmez. Aşağıda örnek bir kod verilmiştir:\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 100\n\nvoid reverseArray(int arr[], int n) {\n    for (int i = 0; i < n / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[n - i - 1];\n        arr[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    int arr[MAX_SIZE];\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Dizi elemanlarını girin:\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    reverseArray(arr, n);\n    printf(\"Ters çevrilmiş dizi:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kodda, `reverseArray` fonksiyonu, dizinin her iki ucundan başlayarak elemanları yer değiştirir. Bu sayede diziyi tersine çevirmiş oluruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:37:45.304699"
  },
  {
    "question": "Bir dizi içerisindeki sayıların toplamını hesaplamak için yazılmış bir fonksiyonu inceleyin. Fonksiyon aşağıdaki gibi: \n\nint sum(int arr[], int size) {\n    int total = 0;\n    for (int i = 0; i < size; i++) {\n        total += arr[i];\n    }\n    return total;\n}\n\nBu fonksiyonda bir iyileştirme öneriniz var mı?",
    "answer": "Bu fonksiyon temel olarak doğru çalışıyor, ancak birkaç iyileştirme önerisi var: \n1. 'size' parametresinin dizinin boyutunu belirtmesi gerektiğinden emin olun. Eğer boyut bilinmiyorsa, diziyi sonlandıran bir değer kullanmak daha iyi olabilir (örneğin, 'NULL' ile sonlandırılmış bir dizi). \n2. Toplamı hesaplarken, daha güvenli bir şekilde dizinin sınırlarını kontrol etmek faydalı olabilir. Örneğin, 'size' negatif bir değer alabilir. \n3. Ayrıca, toplam değişkenini bir tür 'long long' olarak değiştirerek daha büyük sayıların toplanmasını sağlamak mümkündür. \n\nSonuç olarak, fonksiyonu aşağıdaki gibi güncelleyebiliriz:\n\nlong long sum(const int arr[], int size) {\n    if (size <= 0) return 0; // Hatalı boyut kontrolü\n    long long total = 0;\n    for (int i = 0; i < size; i++) {\n        total += arr[i];\n    }\n    return total;\n}",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:38:00.617751"
  },
  {
    "question": "Aşağıdaki kod parçası, bir dizi içerisindeki en büyük sayıyı bulmaktadır. \n\nint find_max(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nBu kodu gözden geçirip geliştirme önerisinde bulunabilir misiniz?",
    "answer": "Bu kod, bir dizi içindeki en büyük sayıyı bulmak için doğru bir yaklaşım sergiliyor. Ancak, aşağıdaki noktaları göz önünde bulundurmak iyileştirme sağlayabilir: \n1. Dizi boyutunun 0 veya negatif olması durumunda bir hata yönetimi eklemek iyi bir uygulama olacaktır. \n2. Fonksiyonun başlangıcında en büyük değeri dizinin ilk elemanından almak yerine, dizinin ilk elemanının geçerli bir değer olup olmadığını kontrol etmek daha güvenli bir yaklaşımdır. \n3. Fonksiyonu daha okunabilir hale getirmek için, 'max' değişkeninin ilk değerini 'arr[0]' yerine bir 'for' döngüsü ile belirlemek daha iyi olabilir. \n\nGeliştirilmiş versiyon şu şekilde olabilir:\n\nint find_max(const int arr[], int size) {\n    if (size <= 0) return -1; // Hatalı boyut kontrolü\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:38:00.617859"
  },
  {
    "question": "Bir tek boyutlu dizi üzerinden belirli bir aralıkta en yüksek ve en düşük değerleri bulmak için yazılmış olan aşağıdaki kodu inceleyin ve iyileştirme önerilerinde bulunun. Kod: \n\nvoid findMinMax(int arr[], int size, int *min, int *max) {\n    *min = arr[0];\n    *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        }\n        if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}",
    "answer": "Kodun genel yapısı doğru olsa da, performans açısından bazı iyileştirmeler yapılabilir. Özellikle, en düşük ve en yüksek değerleri bulmak için iki ayrı koşul kullanmak yerine, tek bir koşul ile her iki değeri de güncelleyebiliriz. Ayrıca, dizinin boyutu 0 veya negatif olduğunda bir hata kontrolü eklemek de önemlidir. Güncellenmiş kod: \n\nvoid findMinMax(int arr[], int size, int *min, int *max) {\n    if (size <= 0) return; // Hata kontrolü ekledik\n    *min = *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        } else if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:38:14.560958"
  },
  {
    "question": "Aşağıdaki kod, bir dizi içerisindeki negatif sayıları yok etmek için yazılmıştır. Kodun performansını ve okunabilirliğini artırmak için hangi değişiklikler yapılabilir? Kod: \n\nvoid removeNegatives(int arr[], int *size) {\n    for (int i = 0; i < *size; i++) {\n        if (arr[i] < 0) {\n            for (int j = i; j < *size - 1; j++) {\n                arr[j] = arr[j + 1];\n            }\n            (*size)--;\n            i--;\n        }\n    }\n}",
    "answer": "Kod, negatif sayıları diziden yok etmeye çalışırken, her bir negatif sayıyı bulduğunda dizinin kalanını kaydırarak oldukça verimsiz bir şekilde çalışmaktadır. Bu, O(n^2) zaman karmaşıklığına yol açar. Bunun yerine, yeni bir dizi kullanarak yalnızca pozitif sayıları kopyalamak daha verimli olacaktır. Yeni önerilen kod: \n\nvoid removeNegatives(int arr[], int *size) {\n    int newSize = 0;\n    for (int i = 0; i < *size; i++) {\n        if (arr[i] >= 0) {\n            arr[newSize++] = arr[i];\n        }\n    }\n    *size = newSize;\n}",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-05-31T16:38:14.561104"
  },
  {
    "question": "Bir 3x3 matris oluşturan ve kullanıcıdan bu matrise elemanlarını alarak ekrana yazdıran C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int i, j;\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"3x3 matrisin elemanlarını girin:\\n\");\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            printf(\"matris[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Matris elemanlarını yazdırma\n    printf(\"Girdiğiniz matris:\\n\");\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan 3x3 boyutunda bir matrisin elemanlarını alır ve ardından bu matrisi ekrana yazdırır. 'matris' adında bir 2 boyutlu dizi tanımlanır. Kullanıcıdan her eleman için döngü ile veri alınır ve sonrasında yine döngü ile matris ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:30.280529"
  },
  {
    "question": "Bir öğrenci notlarını tutan 5 öğrencinin 3 dersten notlarını içeren 2 boyutlu bir dizi oluşturun ve bu notların ortalamasını hesaplayarak ekrana yazdıran C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int notlar[5][3];\n    float ortalama;\n    int i, j;\n\n    // Kullanıcıdan notları alma\n    printf(\"5 öğrencinin 3 dersten notlarını girin:\\n\");\n    for(i = 0; i < 5; i++) {\n        for(j = 0; j < 3; j++) {\n            printf(\"Öğrenci %d, Ders %d notunu girin: \", i + 1, j + 1);\n            scanf(\"%d\", &notlar[i][j]);\n        }\n    }\n\n    // Notların ortalamasını hesaplama ve yazdırma\n    printf(\"Öğrencilerin not ortalamaları:\\n\");\n    for(i = 0; i < 5; i++) {\n        int toplam = 0;\n        for(j = 0; j < 3; j++) {\n            toplam += notlar[i][j];\n        }\n        ortalama = toplam / 3.0;\n        printf(\"Öğrenci %d: %.2f\\n\", i + 1, ortalama);\n    }\n    return 0;\n}\n\n// Bu program, 5 öğrencinin 3 dersten aldığı notları kullanıcının girmesini sağlar. Her öğrencinin ders notları bir 2D dizi olan 'notlar' içerisine alınır. Daha sonra her öğrencinin notları toplanır ve ortalaması hesaplanarak ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:30.280629"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayarak, kullanıcıdan alınan 3x3'lük bir matrisin transpozunu hesaplayan bir C programı yazın. Kodun tamamı şu şekilde: \n\n#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int i, j;\n    printf(\"3x3'lük bir matris girin:\\n\");\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    int transpoz[3][3];\n\n    // Eksik kısım burası\n\n    printf(\"Matrisin Transpozu:\\n\");\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            printf(\"%d \", transpoz[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "answer": "Eksik kısmı tamamlamak için, transpoz matrisini hesaplamamız gerekiyor. Bunun için iç içe döngü kullanarak mevcut matrisin elemanlarını transpoz matrisine atayacağız. Kodun eksik kısmı şu şekilde tamamlanmalıdır:\n\nfor(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n        transpoz[j][i] = matris[i][j];\n    }\n}\n\nBu döngü, matrisin satır ve sütun indekslerini değiştirerek transpozunu elde eder. Sonuç olarak, matris[i][j] elemanını transpoz[j][i] elemanına atarız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:43.247586"
  },
  {
    "question": "Aşağıdaki kodda, kullanıcıdan 2x3 boyutunda bir dizi girmesi isteniyor. Kullanıcının girdiği dizinin elemanlarını toplamak için eksik kısmı tamamlayın:\n\n#include <stdio.h>\n\nint main() {\n    int dizi[2][3];\n    int toplam = 0;\n    printf(\"2x3'lük bir matris girin:\\n\");\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 3; j++) {\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n\n    // Eksik kısım burası\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Eksik kısmı tamamlamak için, dizinin tüm elemanlarını toplamak üzere bir döngü eklemeliyiz. Bunun için iki iç içe döngü kullanarak toplam değişkenini güncelleyebiliriz. Kodun eksik kısmı şu şekilde tamamlanmalıdır:\n\nfor(int i = 0; i < 2; i++) {\n    for(int j = 0; j < 3; j++) {\n        toplam += dizi[i][j];\n    }\n}\n\nBu döngü, dizinin her bir elemanını alarak toplam değişkenine ekler. Sonuç olarak, kullanıcıdan alınan dizinin tüm elemanlarının toplamını hesaplamış oluruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:43.247827"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak, 3x3 boyutlu bir matrisin transpozunu hesaplayın. Kodun içindeki eksik yerleri doldurun.",
    "answer": "#include <stdio.h>\n\n#define N 3\n\nvoid transpose(int mat[N][N], int trans[N][N]) {\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            trans[j][i] = mat[i][j];\n        }\n    }\n}\n\nint main() {\n    int mat[N][N] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int trans[N][N];\n\n    transpose(mat, trans);\n\n    printf(\"Transpoze Matris:\\n\");\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            printf(\"%d \", trans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu kod, 3x3 boyutlu bir matrisin transpozunu hesaplamak için bir fonksiyon tanımlar. 'transpose' fonksiyonu, verilen matrisin transpozunu 'trans' matrisine atar. 'main' fonksiyonu ise başlangıçta bir matris tanımlar, transpozunu hesaplar ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:54.679185"
  },
  {
    "question": "Aşağıdaki kodda verilen 2 boyutlu dizideki en büyük sayıyı bulmak için kodun eksik kısmını tamamlayın. Kodun eksik yerlerini doldurun.",
    "answer": "#include <stdio.h>\n\n#define ROWS 4\n#define COLS 5\n\nint main() {\n    int arr[ROWS][COLS] = {\n        {1, 2, 3, 4, 5},\n        {6, 7, 8, 9, 10},\n        {11, 12, 13, 14, 15},\n        {16, 17, 18, 19, 20}\n    };\n    int max = arr[0][0];\n\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            if(arr[i][j] > max) {\n                max = arr[i][j];\n            }\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}\n\n// Açıklama: Bu kod, 4x5 boyutunda bir matris tanımlar ve bu matris içindeki en büyük sayıyı bulur. 'max' değişkeni başlangıçta ilk elemanla atanır ve döngüler aracılığıyla dizi içindeki her eleman kontrol edilerek en büyük değer güncellenir. Son olarak en büyük sayı ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:38:54.679264"
  },
  {
    "question": "Aşağıdaki C kodu, 2 boyutlu bir dizi içinde sayıları toplamak için yazılmıştır. Ancak kod çalıştığında beklenen sonucu vermiyor. Hatanın nedenini bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nint main() {\n    int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int sum = 0;\n\n    for (int i = 0; i <= 3; i++) { // Hata burada\n        for (int j = 0; j < 3; j++) {\n            sum += arr[i][j];\n        }\n    }\n\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}",
    "answer": "Kodda hata, dıştaki for döngüsündeki koşul ifadesindedir. 'i <= 3' ifadesi, dizinin sınırlarının dışına çıkmasına neden olur. Dizi, 3 elemanlı dizilerin toplamından oluştuğu için, 'i' değerinin 0 ile 2 arasında olması gerekir. Düzeltmek için 'i < 3' olarak değiştirin. İşte düzeltilmiş kod:\n\n#include <stdio.h>\n\nint main() {\n    int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int sum = 0;\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            sum += arr[i][j];\n        }\n    }\n\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:39:07.766836"
  },
  {
    "question": "Aşağıdaki C kodunda, 2 boyutlu bir dizideki en büyük sayıyı bulmaya çalışıyoruz. Ancak kod beklenmeyen bir çıktıya sahip. Hatanın nedenini bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nint main() {\n    int arr[2][4] = {{5, 3, 7, 1}, {2, 8, 6, 4}};\n    int max = arr[0][0];\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j <= 4; j++) { // Hata burada\n            if (arr[i][j] > max) {\n                max = arr[i][j];\n            }\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}",
    "answer": "Kodda hata, içteki for döngüsündeki koşul ifadesindedir. 'j <= 4' ifadesi, dizinin sınırlarının dışına çıkmasına neden olur. Dizinin her satırında sadece 4 eleman bulunur (0 ile 3 arasında). Düzeltmek için 'j < 4' olarak değiştirin. İşte düzeltilmiş kod:\n\n#include <stdio.h>\n\nint main() {\n    int arr[2][4] = {{5, 3, 7, 1}, {2, 8, 6, 4}};\n    int max = arr[0][0];\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (arr[i][j] > max) {\n                max = arr[i][j];\n            }\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:39:07.767017"
  },
  {
    "question": "Bir 2D dizi kullanarak bir matrisin transpozesini almak istiyorum. Aşağıdaki kodda bir hata var. Hatanın nedenini bul ve düzelt.",
    "answer": "Kodunuzu inceleyelim. Aşağıdaki kodda bir hata var:\n\n```c\n#include <stdio.h>\n#define N 3\n#define M 3\n\nvoid transpose(int mat[N][M]) {\n    int trans[M][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            trans[j][i] = mat[i][j];\n        }\n    }\n}\n\nint main() {\n    int mat[N][M] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    transpose(mat);\n    return 0;\n}\n```\n\nHata: Dönüşüm dizisi `trans` ana fonksiyona döndürülmüyor veya yazdırılmıyor. Bu nedenle transpoz işleminin sonuçlarını göremeyeceksiniz. Düzeltmek için sonucu döndürmeli veya doğrudan yazdırmalısınız. Aşağıdaki gibi düzenleyin:\n\n```c\n#include <stdio.h>\n#define N 3\n#define M 3\n\nvoid transpose(int mat[N][M]) {\n    int trans[M][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            trans[j][i] = mat[i][j];\n        }\n    }\n    // Transpoze matrisini yazdırma\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"%d \", trans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n```\n\nBu şekilde transpoze matrisini görebileceksiniz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:03.086046"
  },
  {
    "question": "Aşağıdaki kod, 3 boyutlu bir dizi kullanarak bir küpün elemanlarını tanımlıyor. Ancak dizi elemanlarına erişim sırasında bir hata alıyorum. Hatanın nedenini bul ve düzelt.",
    "answer": "Kodunuzu inceleyelim. İşte orijinal kod:\n\n```c\n#include <stdio.h>\n#define X 3\n#define Y 3\n#define Z 3\n\nint main() {\n    int cube[X][Y][Z];\n    for (int i = 0; i < X; i++) {\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                cube[i][j][k] = i + j + k;\n            }\n        }\n    }\n    // Elemanları yazdırma\n    for (int i = 0; i <= X; i++) { // Hatalı kullanımdır.\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                printf(\"%d \", cube[i][j][k]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n```\n\nHata: Son döngüdeki `i <= X` ifadesi, dizinin sınırlarını aşıyor. Dizinin indeksleri 0'dan `X - 1`'e kadar olmalıdır. Düzeltmek için `i < X` kullanmalısınız. Aşağıdaki gibi düzenleyin:\n\n```c\n#include <stdio.h>\n#define X 3\n#define Y 3\n#define Z 3\n\nint main() {\n    int cube[X][Y][Z];\n    for (int i = 0; i < X; i++) {\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                cube[i][j][k] = i + j + k;\n            }\n        }\n    }\n    // Elemanları yazdırma\n    for (int i = 0; i < X; i++) { // Doğru kullanım\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                printf(\"%d \", cube[i][j][k]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n```\n\nBu değişiklikle birlikte kodunuz düzgün çalışacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:03.086115"
  },
  {
    "question": "Çok boyutlu bir dizi kullanarak 3x3'lük bir matris oluşturmak istiyorum. Ancak, matrisin elemanlarını topladığımda beklenmedik bir sonuç alıyorum. Kodum şöyle: \n\n```c\n#include <stdio.h>\n\nint main() {\n    int matris[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int toplam = 0;\n    for (int i = 0; i <= 3; i++) {\n        for (int j = 0; j <= 3; j++) {\n            toplam += matris[i][j];\n        }\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n``` \nBu kodu çalıştırdığımda 'segmentation fault' hatası alıyorum. Sorun nedir?",
    "answer": "Burada sorun, diziyi dolaşırken döngü sınırlarının yanlış ayarlanmasıdır. C dilinde diziler 0'dan başlar ve 'matris[3][3]' dizisi 0, 1 ve 2 indekslerine sahiptir. Yani döngü sınırları 'i < 3' ve 'j < 3' şeklinde olmalıdır. Doğru kod şu şekilde olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matris[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int toplam = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            toplam += matris[i][j];\n        }\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n``` \nBu değişiklikle birlikte artık toplam 45 doğru bir şekilde hesaplanacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:18.781711"
  },
  {
    "question": "Bir 2 boyutlu dizideki her satırın toplamını bulmak istiyorum. Ancak, kodumun çıktısı beklediğim gibi değil. Aşağıdaki kodu incelediğinizde sorunu görebilir misiniz?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int satirToplam[2];\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j <= 3; j++) {\n            satirToplam[i] += dizi[i][j];\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        printf(\"Satır %d toplam: %d\\n\", i + 1, satirToplam[i]);\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda, iç içe döngüde yine bir sınır hatası bulunmaktadır. 'dizi[2][3]' dizisinin satırları 0 ve 1, sütunları 0, 1 ve 2 indekslerine sahiptir. Yani, 'j' değişkeninin döngü koşulu 'j < 3' olmalıdır. Ayrıca, 'satirToplam' dizisi kullanılmadan önce sıfırlanmalıdır. Aksi takdirde, başlangıç değeri belirsiz olur. Düzgün bir kod aşağıdaki gibi olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int satirToplam[2] = {0}; // Sıfırlama\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            satirToplam[i] += dizi[i][j];\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        printf(\"Satır %d toplam: %d\\n\", i + 1, satirToplam[i]);\n    }\n    return 0;\n}\n``` \nBu değişiklikle satır toplamları doğru bir şekilde hesaplanacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:18.781891"
  },
  {
    "question": "İki boyutlu bir dizi nasıl tanımlanır ve elemanlarına nasıl erişilir?",
    "answer": "İki boyutlu diziler, bir tablo gibi düşünülür ve satır-sütun yapısında verileri saklamak için kullanılır. Örneğin, 3 satır ve 4 sütundan oluşan bir dizi tanımlamak için aşağıdaki gibi bir kod yazabiliriz:\n\n```c\nint dizi[3][4];\n```\nBu diziyi tanımladıktan sonra, belirli bir elemana erişmek için dizinin satır ve sütun indeksini kullanırız. Örneğin, ilk satır ve ikinci sütundaki elemana erişmek için `dizi[0][1]` yazmalıyız. Dizinin elemanlarını atamak için ise şu şekilde bir kullanım yapılabilir:\n\n```c\ndizi[0][0] = 1;\ndizi[0][1] = 2;\ndizi[1][0] = 3;\ndizi[2][3] = 4;\n```\nBu kod ile dizinin bazı elemanlarını atamış olduk. Dizi elemanlarını döngü ile de gezip yazdırabiliriz:\n\n```c\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 4; j++) {\n        printf(\"%d \", dizi[i][j]);\n    }\n    printf(\"\\n\");\n}\n```\nBu döngü, dizinin tüm elemanlarını satır satır yazdıracaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:32.341863"
  },
  {
    "question": "Bir matrisin transpozesini almak için çok boyutlu dizi nasıl kullanılır?",
    "answer": "Matrisin transpozesini almak, matrisin satırları ile sütunlarını yer değiştirmek anlamına gelir. Örneğin, 2x3 boyutunda bir matrisimiz olduğunu düşünelim. Bu matrisin transpozesini almak için 3x2 boyutunda yeni bir dizi tanımlamamız gerekir:\n\n```c\nint matris[2][3] = {{1, 2, 3}, {4, 5, 6}};\nint transpoze[3][2];\n```\nYukarıdaki kodda, `matris` isimli bir 2x3 matris tanımladık ve elemanlarını atadık. Şimdi transpoze almak için aşağıdaki döngüyü kullanabiliriz:\n\n```c\nfor (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 3; j++) {\n        transpoze[j][i] = matris[i][j];\n    }\n}\n```\nBu döngü ile `matris` dizisinin elemanlarını alıp `transpoze` dizisinde uygun yere yerleştiriyoruz. Transpoze matrisimizi yazdırmak için de şöyle bir döngü kullanabiliriz:\n\n```c\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 2; j++) {\n        printf(\"%d \", transpoze[i][j]);\n    }\n    printf(\"\\n\");\n}\n```\nBu döngü, transpoze matrisimizi satır satır yazdıracaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:40:32.341902"
  },
  {
    "question": "İki boyutlu bir diziyi kullanarak bir matrisin transpozunu nasıl alabilirim? Örnek bir kod parçası verir misin?",
    "answer": "İki boyutlu diziler, genellikle satır ve sütunları temsil eder. Matrisin transpozunu almak, satırları sütunlara ve sütunları satırlara dönüştürmek anlamına gelir. Aşağıda, bir matrisin transpozunu almayı gösteren bir C kodu örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\n#define ROW 3\n#define COL 4\n\nint main() {\n    int matrix[ROW][COL] = {{1, 2, 3, 4},\n                             {5, 6, 7, 8},\n                             {9, 10, 11, 12}};\n    int transpose[COL][ROW]; // Transpozu almak için yeni bir dizi oluşturuyoruz.\n\n    // Transpoz alma işlemi\n    for (int i = 0; i < ROW; i++) {\n        for (int j = 0; j < COL; j++) {\n            transpose[j][i] = matrix[i][j];\n        }\n    }\n\n    // Transpoz matrisini yazdırma\n    printf(\"Transpoze Matris:\\n\");\n    for (int i = 0; i < COL; i++) {\n        for (int j = 0; j < ROW; j++) {\n            printf(\"%d \", transpose[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\nBu kodda, `matrix` adında bir 3x4 boyutunda iki boyutlu dizi oluşturulmuştur. `transpose` ise 4x3 boyutunda ve transpoze matrisini depolamak için kullanılır. Dıştaki döngü, satırları dönerken, içteki döngü sütunları döner. Böylece her bir eleman, transpoz dizisine uygun şekilde yerleştirilmiş olur. Son olarak, transpoze matrisini ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:24.392468"
  },
  {
    "question": "Üç boyutlu bir dizi kullanarak bir 3D uzayda noktaların koordinatlarını nasıl saklayabilirim? Bir örnek ile açıklar mısın?",
    "answer": "Üç boyutlu diziler, genellikle uzaydaki noktaların x, y ve z koordinatlarını saklamak için kullanılır. Aşağıda, bir 3D uzayda 5 noktayı temsil eden bir dizi tanımlayan ve bu noktaları yazdıran bir C kodu örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\n#define POINTS 5\n\nint main() {\n    int coordinates[POINTS][3] = {{1, 2, 3},\n                                    {4, 5, 6},\n                                    {7, 8, 9},\n                                    {10, 11, 12},\n                                    {13, 14, 15}};\n\n    // Noktaların koordinatlarını yazdırma\n    printf(\"3D Noktaların Koordinatları:\\n\");\n    for (int i = 0; i < POINTS; i++) {\n        printf(\"Nokta %d: (%d, %d, %d)\\n\", i + 1, coordinates[i][0], coordinates[i][1], coordinates[i][2]);\n    }\n\n    return 0;\n}\n```\n\nBu kodda, `coordinates` adında bir 5x3 boyutunda üç boyutlu dizi tanımlanmıştır. Her bir satır, bir noktanın x, y ve z koordinatlarını temsil eder. Daha sonra, bir döngü kullanarak her noktanın koordinatlarını ekrana yazdırıyoruz. Bu, üç boyutlu uzayda noktaların saklanması ve görüntülenmesi için pratik bir yöntemdir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:24.392518"
  },
  {
    "question": "Bir 3D dizide (üç boyutlu dizi) satır, sütun ve derinlik elemanlarını nasıl tanımlayıp kullanabilirim? Örnek bir uygulama ile gösterin.",
    "answer": "3D diziler, genellikle oyun programlama veya grafik uygulamalarında kullanılır. C dilinde bir 3D dizi tanımlamak için aşağıdaki gibi bir yapı kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[3][4][5]; // 3 derinlik, 4 satır, 5 sütun\n\n    // Diziye değer atama\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            for (int k = 0; k < 5; k++) {\n                dizi[i][j][k] = i + j + k; // Örnek olarak, her elemana i+j+k değerini atıyoruz\n            }\n        }\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            for (int k = 0; k < 5; k++) {\n                printf(\"dizi[%d][%d][%d] = %d\\n\", i, j, k, dizi[i][j][k]);\n            }\n        }\n    }\n\n    return 0;\n}\n```\nBu örnekte, 3 derinlik, 4 satır ve 5 sütundan oluşan bir dizi tanımladık. Her bir elemanına, bulunduğu konumun toplamı olan bir değer atadık ve ardından tüm elemanları yazdırdık.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:37.871729"
  },
  {
    "question": "Bir 2D diziyi (iki boyutlu dizi) kullanarak bir matrisin transpozunu nasıl alabilirim? Örnek bir uygulama ile gösterin.",
    "answer": "İki boyutlu diziler, matrisleri temsil etmek için yaygın olarak kullanılır. Aşağıdaki örnekte bir matrisin transpozunu almayı göstereceğim:\n\n```c\n#include <stdio.h>\n#define SATIR 3\n#define SUTUN 4\n\nint main() {\n    int matris[SATIR][SUTUN] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n    int transpoz[SUTUN][SATIR]; // Transpoz matris için dizi\n\n    // Transpoz alma işlemi\n    for (int i = 0; i < SATIR; i++) {\n        for (int j = 0; j < SUTUN; j++) {\n            transpoz[j][i] = matris[i][j];\n        }\n    }\n\n    // Transpoz matrisini yazdırma\n    printf(\"Transpoz Matris:\\n\");\n    for (int i = 0; i < SUTUN; i++) {\n        for (int j = 0; j < SATIR; j++) {\n            printf(\"%d \", transpoz[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\nBu örnekte, 3x4 boyutunda bir matris tanımladık ve daha sonra transpoze işlemini gerçekleştirdik. Transpoze matrisini oluşturduktan sonra, elemanları yazdırdık. Bu işlemde, matrisin satırları transpoze matrisin sütunları haline gelir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:37.871806"
  },
  {
    "question": "Bir sınıfın notlarını tutan 2 boyutlu bir dizi oluşturun ve her öğrencinin not ortalamasını hesaplayın.",
    "answer": "Aşağıda, her öğrencinin 3 farklı dersten notlarını tutan bir 2 boyutlu dizi oluşturduk. Daha sonra, her öğrencinin not ortalamasını hesaplamak için bir döngü kullandık.\n\n```c\n#include <stdio.h>\n\n#define STUDENT_COUNT 5\n#define SUBJECT_COUNT 3\n\nint main() {\n    // 2 boyutlu dizi öğrencilerin notlarını tutar\n    float grades[STUDENT_COUNT][SUBJECT_COUNT] = {\n        {85.5, 90.0, 78.0},  // Öğrenci 1\n        {88.0, 76.5, 90.0},  // Öğrenci 2\n        {92.0, 85.5, 80.0},  // Öğrenci 3\n        {75.0, 80.0, 70.0},   // Öğrenci 4\n        {89.0, 91.5, 94.0}   // Öğrenci 5\n    };\n\n    for (int i = 0; i < STUDENT_COUNT; i++) {\n        float total = 0;\n        for (int j = 0; j < SUBJECT_COUNT; j++) {\n            total += grades[i][j];\n        }\n        float average = total / SUBJECT_COUNT;\n        printf(\"Öğrenci %d not ortalaması: %.2f\\n\", i + 1, average);\n    }\n\n    return 0;\n}\n```\nBu kodda, her öğrencinin 3 dersten aldığı notlar tutuluyor. İç içe döngü kullanarak her öğrencinin notları toplanıyor ve not ortalaması hesaplanıyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:51.497287"
  },
  {
    "question": "Bir 3 boyutlu dizi kullanarak bir küp içinde bulunan noktalara değer atayın ve bu değerleri yazdırın.",
    "answer": "Aşağıdaki örnekte, 3 boyutlu bir dizi kullanarak bir 3x3x3'lük küp oluşturuyoruz. Bu küp içindeki her noktaya bir tam sayı değeri atıyoruz ve daha sonra bu değerleri yazdırıyoruz.\n\n```c\n#include <stdio.h>\n\n#define SIZE 3\n\nint main() {\n    // 3 boyutlu dizi küpü temsil eder\n    int cube[SIZE][SIZE][SIZE];\n\n    // Küp içindeki her noktaya değer atama\n    int value = 1;\n    for (int x = 0; x < SIZE; x++) {\n        for (int y = 0; y < SIZE; y++) {\n            for (int z = 0; z < SIZE; z++) {\n                cube[x][y][z] = value++;\n            }\n        }\n    }\n\n    // Küp içindeki değerleri yazdırma\n    for (int x = 0; x < SIZE; x++) {\n        for (int y = 0; y < SIZE; y++) {\n            for (int z = 0; z < SIZE; z++) {\n                printf(\"cube[%d][%d][%d] = %d\\n\", x, y, z, cube[x][y][z]);\n            }\n        }\n    }\n\n    return 0;\n}\n```\nBu kodda, 3 boyutlu bir dizi kullanarak 3x3x3'lük bir küp tanımladık. Her noktaya artan değerler atandı ve ardından bu değerler küpün koordinatlarıyla birlikte yazdırıldı.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:41:51.497333"
  },
  {
    "question": "Bir 3x3 matrisin transpozesini hesaplayan C kodunu yazın ve açıklayın.",
    "answer": "Aşağıdaki C kodu, 3x3 boyutunda bir matrisin transpozesini hesaplamaktadır. Transpoze, bir matrisin satırlarını sütunlarına dönüştüren işlemdir.\n\n```c\n#include <stdio.h>\n\n#define SIZE 3\n\nvoid transposeMatrix(int matrix[SIZE][SIZE], int transposed[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\nint main() {\n    int matrix[SIZE][SIZE] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int transposed[SIZE][SIZE];\n\n    transposeMatrix(matrix, transposed);\n\n    printf(\"Transpoze Matris:\\n\");\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            printf(\"%d \", transposed[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\nBu kodda, önce 3x3 boyutunda bir matris tanımlıyoruz. Ardından, `transposeMatrix` fonksiyonu ile matrisin transpozesini hesaplıyoruz. Dıştaki döngü satırları, içteki döngü ise sütunları temsil eder. Transpoze işleminde elemanlar yer değiştirir. Son olarak, transpoze edilen matris ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:07.001055"
  },
  {
    "question": "Bir 2D dizide belirli bir değerin kaç kere geçtiğini sayan C programını yazın.",
    "answer": "Aşağıdaki C kodu, 2D bir dizide belirli bir değerin kaç kez bulunduğunu saymaktadır. Bu tür bir işlem, veri analizi veya arama algoritmaları için oldukça yararlıdır.\n\n```c\n#include <stdio.h>\n\n#define ROWS 4\n#define COLS 5\n\nint countOccurrences(int array[ROWS][COLS], int value) {\n    int count = 0;\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            if (array[i][j] == value) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int array[ROWS][COLS] = {{1, 2, 3, 4, 5}, {6, 2, 8, 2, 10}, {11, 12, 2, 14, 15}, {16, 17, 18, 19, 20}};\n    int value = 2;\n\n    int occurrences = countOccurrences(array, value);\n    printf(\"%d sayısı dizide %d kere geçiyor.\\n\", value, occurrences);\n\n    return 0;\n}\n```\nBu kodda, `countOccurrences` fonksiyonu 2D dizide belirli bir değerin sayısını bulur. Dıştaki döngü dizinin satırlarını, içteki döngü ise sütunlarını kontrol eder. Eğer eleman verilen değerle eşleşiyorsa, `count` değişkenini artırır. Sonuç olarak, `main` fonksiyonu kullanıcıya verilen değerinin dizideki sayısını ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:07.001099"
  },
  {
    "question": "Bir 3D matris (dizi) içinde belirli bir değeri arayan ve bu değerin bulunduğu koordinatları döndüren bir C fonksiyonu yazın.",
    "answer": "Aşağıdaki C kodu, 3D bir matris içinde belirtilen bir değeri arar ve bu değerin bulunduğu tüm koordinatları döndürür. Fonksiyon, 3D dizinin boyutlarını ve aranan değeri alır. Eğer değer bulunursa, koordinatları ekrana yazdırır.\n\n```c\n#include <stdio.h>\n\nvoid findValueIn3DArray(int arr[3][3][3], int value) {\n    int found = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (arr[i][j][k] == value) {\n                    printf(\"Değer %d bulundu: [%%d, %%d, %%d]\\n\", i, j, k);\n                    found = 1;\n                }\n            }\n        }\n    }\n    if (!found) {\n        printf(\"Değer bulunamadı.\");\n    }\n}\n\nint main() {\n    int arr[3][3][3] = {\n        {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n        {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}},\n        {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}\n    };\n    findValueIn3DArray(arr, 15);\n    return 0;\n}\n```\n\nBu örnekte, `findValueIn3DArray` fonksiyonu 3D dizideki her elemanı kontrol eder ve aranan değeri bulursa, o koordinatları yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:24.767441"
  },
  {
    "question": "Bir 2D matrisin transpozunu hesaplayan bir C fonksiyonu yazın. Bu fonksiyon, matrisin boyutlarını (satır ve sütun sayısı) almalı ve transpoze matrisini ekrana yazdırmalıdır.",
    "answer": "Aşağıdaki C kodu, bir 2D matrisin transpozunu hesaplar. Fonksiyon, matrisin satır ve sütun sayısını ve matrisin kendisini parametre olarak alır. Transpoz matris, satır ve sütunların yer değiştirmesi ile oluşturulur.\n\n```c\n#include <stdio.h>\n\nvoid transposeMatrix(int mat[3][3], int row, int col) {\n    int transposed[3][3]; // Transpoze matris için yer ayırma\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            transposed[j][i] = mat[i][j]; // Satır ve sütun yer değiştiriliyor\n        }\n    }\n    printf(\"Transpoze Matris:\\n\");\n    for (int i = 0; i < col; i++) {\n        for (int j = 0; j < row; j++) {\n            printf(\"%%d \", transposed[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int mat[3][3] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    transposeMatrix(mat, 3, 3);\n    return 0;\n}\n```\n\nBu örnekte, `transposeMatrix` fonksiyonu verilen bir 2D matrisin transpozunu hesaplar ve sonucu ekrana yazdırır. Bu tür bir işlem, matris hesaplamaları ve lineer cebir uygulamalarında yaygın olarak kullanılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:24.767534"
  },
  {
    "question": "Bir 2D dizi kullanarak bir matrisin transpozunu almak için yazılmış olan şu kodu inceleyin ve iyileştirme önerileri sunun: \n\n```c\n#include <stdio.h>\n#define ROWS 3\n#define COLS 3\n\nvoid transpose(int matrix[ROWS][COLS]) {\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = i; j < COLS; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n}\n\nint main() {\n    int matrix[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    transpose(matrix);\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```",
    "answer": "Kod aslında bir matrisin transpozunu almak için doğru bir yöntem kullanıyor. Ancak, bazı iyileştirmeler yapılabilir: \n1. **Sabit boyutları kullanmak yerine parametre olarak almak:** Fonksiyonun daha esnek olabilmesi için 'ROWS' ve 'COLS' değerlerini fonksiyon parametresi olarak almak daha iyi olur. \n2. **Daha az değişken kullanmak:** Transpoz alma işlemi sırasında gereksiz yere 'temp' değişkeni kullanılıyor. Eğer sadece iki değişken değiştirilecekse, doğrudan atama yapılabilir. Ancak bu durumda 'temp' kullanımı doğrudur çünkü yine de iki değerin yer değiştirmesi gerekiyor. \n3. **Daha iyi bir çıktı formatı:** Matris çıktısının daha okunabilir olması için her satırdan sonra yeni bir satır yazılmalı. Örnek kod:\n```c\nvoid transpose(int matrix[ROWS][COLS], int rows, int cols) {\n    for(int i = 0; i < rows; i++) {\n        for(int j = i; j < cols; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n}\n```\nFonksiyonu çağırırken: \n```c\ntranspose(matrix, ROWS, COLS);\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:46.946259"
  },
  {
    "question": "Aşağıdaki kod, 3D bir dizide rastgele sayılar oluşturarak her düzlemdeki maksimum değeri bulmayı amaçlıyor. Ancak performans ve okunabilirlik açısından önerilerde bulunun: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define X 2\n#define Y 2\n#define Z 2\n\nvoid find_max_in_3D(int array[X][Y][Z]) {\n    for (int i = 0; i < X; i++) {\n        int max = array[i][0][0];\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                if (array[i][j][k] > max) {\n                    max = array[i][j][k];\n                }\n            }\n        }\n        printf(\"Düzlem %d maksimum: %d\\n\", i, max);\n    }\n}\n\nint main() {\n    srand(time(NULL));\n    int array[X][Y][Z];\n    for (int i = 0; i < X; i++) {\n        for (int j = 0; j < Y; j++) {\n            for (int k = 0; k < Z; k++) {\n                array[i][j][k] = rand() % 100;\n            }\n        }\n    }\n    find_max_in_3D(array);\n    return 0;\n}\n```",
    "answer": "Kod, 3D bir dizide maksimum değeri bulma işlevini doğru bir şekilde gerçekleştiriyor. Ancak, aşağıdaki iyileştirmeler önerilebilir: \n1. **Daha az global tanım:** 'X', 'Y' ve 'Z' sabitleri global olarak tanımlanmış. Bunun yerine, boyutları fonksiyon parametreleri olarak almak, fonksiyonun daha esnek olmasını sağlar. \n2. **Daha etkin maksimum bulma:** Her düzlem için maksimum değeri bulma sırasında 'max' değerinin ilk elemandan alınması yerine, ilk elemanı kontrol ettikten sonra diğer elemanlarla karşılaştırmak daha performanslıdır. Örnek olarak:\n```c\nint max = array[i][0][0];\nfor (int j = 0; j < Y; j++) {\n    for (int k = 0; k < Z; k++) {\n        if (array[i][j][k] > max) {\n            max = array[i][j][k];\n        }\n    }\n}\n``` \n3. **Yazdırma işlevi:** Yazdırma işlevini ayırmak, kodun okunabilirliğini artırır. Örneğin:\n```c\nvoid print_max(int plane, int max) {\n    printf(\"Düzlem %d maksimum: %d\\n\", plane, max);\n}\n``` \nBütün bu değişikliklerle beraber kodun daha okunabilir ve sürdürülebilir hale geleceği aşikardır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:42:46.946707"
  },
  {
    "question": "Aşağıdaki çok boyutlu dizi kodunda bellek yönetimi açısından bir sorun var. Bunun nedenini açıklayabilir misiniz ve kodu nasıl iyileştirirsiniz?",
    "answer": "Kod örneği:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int **array;\n    int rows = 5, cols = 5;\n    array = (int **)malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        array[i] = (int *)malloc(cols * sizeof(int));\n    }\n    // Kullanım kodları...\n    return 0;\n}\n```\n\nAçıklama: Bu kodda, çok boyutlu dizinin bellekte yönetimi doğru şekilde yapılmamış. `malloc` kullanarak bellek ayırdık ama `free` ile serbest bırakmayı unuttuk. Bu, bellekte sızıntılara yol açabilir. İyileştirme önerim, dizinin kullanımı bittikten sonra `free` ile belleği serbest bırakmak. Ayrıca, diziyi daha güvenli hale getirmek için, hatalı bellek ayırma durumlarını kontrol etmek önemlidir. Önerilen güncellenmiş kod:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int **array;\n    int rows = 5, cols = 5;\n    array = (int **)malloc(rows * sizeof(int *));\n    if (array == NULL) return -1; // Hatalı ayırma kontrolü\n    for (int i = 0; i < rows; i++) {\n        array[i] = (int *)malloc(cols * sizeof(int));\n        if (array[i] == NULL) return -1; // Hatalı ayırma kontrolü\n    }\n    // Kullanım kodları...\n\n    // Belleği serbest bırakma\n    for (int i = 0; i < rows; i++) {\n        free(array[i]);\n    }\n    free(array);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:43:01.860385"
  },
  {
    "question": "Aşağıdaki çok boyutlu dizi kodunun okunabilirliği ve bakımı açısından iyileştirilmesi gereken noktalar var. Bunları belirtip, kodu nasıl daha modüler hale getirebilirsiniz?",
    "answer": "Kod örneği:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int array[3][4] = {\n        {1, 2, 3, 4},\n        {5, 6, 7, 8},\n        {9, 10, 11, 12}\n    };\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", array[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\nAçıklama: Bu kod, basit bir çok boyutlu diziyi tanımlıyor fakat okunabilirliği ve bakımı zor durumda. Kodun modülerliğini artırmak için, diziyi dolduran, yazdıran ve bellek kontrolü yapan ayrı fonksiyonlar oluşturabiliriz. Bu, kodun daha anlaşılır ve sürdürülebilir olmasını sağlar. Önerilen güncellenmiş kod:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ROWS 3\n#define COLS 4\n\nvoid fillArray(int arr[ROWS][COLS]) {\n    int value = 1;\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            arr[i][j] = value++;\n        }\n    }\n}\n\nvoid printArray(int arr[ROWS][COLS]) {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"%d \", arr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int array[ROWS][COLS];\n    fillArray(array);\n    printArray(array);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-05-31T16:43:01.860442"
  },
  {
    "question": "Kullanıcının girdiği bir ismi ekrana yazdıran C kodunu tamamlayın. Kod eksik: #include <stdio.h>\n\nint main() {\n    char name[50];\n    printf(\"İsminizi girin: \");\n    scanf(\"%s\", name);\n    // Eksik kod buraya gelecek...\n    return 0;\n}",
    "answer": "#include <stdio.h>\n\nint main() {\n    char name[50];\n    printf(\"İsminizi girin: \");\n    scanf(\"%s\", name);\n    printf(\"Merhaba, %s!\\n\", name); // Kullanıcının ismini ekrana yazdırıyoruz\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir isim alır ve ardından bu ismi ekrana \"Merhaba, [isim]!\" şeklinde yazar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:10.299793"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki karakter sayısını bulan C kodunu tamamlayın. Kod eksik: #include <stdio.h>\n\nint main() {\n    char sentence[100];\n    printf(\"Bir cümle girin: \");\n    scanf(\"%[^\n]\", sentence);\n    // Eksik kod buraya gelecek...\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char sentence[100];\n    printf(\"Bir cümle girin: \");\n    scanf(\"%[^\n]\", sentence);\n    int length = strlen(sentence); // cümledeki karakter sayısını buluyoruz\n    printf(\"Cümlenizdeki karakter sayısı: %d\\n\", length); // sonucu ekrana yazdırıyoruz\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir cümle alır ve strlen() fonksiyonunu kullanarak cümledeki toplam karakter sayısını hesaplar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:10.299943"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcının girdiği bir cümledeki kelimeleri sayan eksik kısmı tamamlayın. Kodu tamamlayın:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    int kelimeSayisi = 0;\n\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    // Eksik kısmı tamamlayın...\n\n    printf(\"Kelime sayısı: %d\\n\", kelimeSayisi);\n    return 0;\n}",
    "answer": "Eksik kısmı tamamlamak için, cümledeki boşlukları kontrol ederek kelimeleri sayabiliriz. Aşağıdaki kodu ekleyebilirsiniz:\n\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == ' ' && (i == 0 || str[i-1] != ' ')) {\n            kelimeSayisi++;\n        }\n    }\n    // Cümlede en az bir kelime varsa, kelime sayısını 1 artırmalıyız.\n    if (strlen(str) > 0 && str[0] != ' ') {\n        kelimeSayisi++;\n    }\n\nBu kod, cümledeki boşlukları kontrol eder ve her boşluktan sonra bir kelime olduğunu varsayarak kelime sayısını artırır. Ayrıca, ilk kelimeyi saymak için ekstra bir kontrol eklenmiştir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:22.919885"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcının girdiği bir ismin sonuna ' Bey' veya ' Hanım' eklemek için eksik kısmı tamamlayın. Kodu tamamlayın:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[50];\n    char cinsiyet;\n\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin);\n\n    printf(\"Cinsiyetinizi girin (E/K): \");\n    scanf(\" %c\", &cinsiyet);\n\n    // Eksik kısmı tamamlayın...\n\n    printf(\"Tam ad: %s\\n\", isim);\n    return 0;\n}",
    "answer": "Eksik kısmı tamamlamak için cinsiyet kontrolü yaparak isim sonunda uygun ekleri ekleyebiliriz. Aşağıdaki kodu ekleyebilirsiniz:\n\n    if (cinsiyet == 'E' || cinsiyet == 'e') {\n        strcat(isim, \" Bey\");\n    } else if (cinsiyet == 'K' || cinsiyet == 'k') {\n        strcat(isim, \" Hanım\");\n    }\n\nBu kod, kullanıcının cinsiyetine göre ismin sonuna ya 'Bey' ya da 'Hanım' ekler. 'strcat' işlevi, iki stringi birleştirmek için kullanılır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:22.920046"
  },
  {
    "question": "Kullanıcıdan bir cümle alın ve bu cümledeki kelimelerin sayısını hesaplamak için eksik kodu tamamlayın. Cümledeki kelimeler arasındaki boşlukları dikkate alarak doğru sayımı yapmalısınız.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[256];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n\n    int kelimeSayisi = 0;\n    char *token = strtok(cumle, \" \\\\n\"); // Boşluk ve yeni satır karakterine göre ayır\n\n    while (token != NULL) {\n        kelimeSayisi++;\n        token = strtok(NULL, \" \\\\n\");\n    }\n\n    printf(\"Cümledeki kelime sayısı: %d\\n\", kelimeSayisi);\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir cümle alır ve strtok fonksiyonunu kullanarak cümleyi boşluk karakterine göre kelimelerine ayırır. Her kelime bulunduğunda kelime sayısını bir arttırır. Boşluklar ve yeni satır karakterleri kelime sayımında dikkate alınır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:34.728457"
  },
  {
    "question": "Bir string değişkeni alarak, o stringin içindeki her karakterin tekrar sayısını hesaplayacak bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid karakterSayisi(char *str) {\n    int harfSayilari[256] = {0}; // ASCII karakterleri için\n\n    for (int i = 0; str[i] != '\\0'; i++) {\n        harfSayilari[(unsigned char)str[i]]++;\n    }\n\n    printf(\"Karakter sayıları:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (harfSayilari[i] > 0) {\n            printf(\"'%c' karakteri: %d kez\\n\", i, harfSayilari[i]);\n        }\n    }\n}\n\nint main() {\n    char metin[256];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    karakterSayisi(metin);\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir metin alır ve karakterSayisi fonksiyonu kullanarak metindeki her bir karakterin kaç kez tekrarlandığını sayar. ASCII değerleri kullanılarak bir dizi oluşturulur ve her karakterin sayısı bu dizide saklanır. Sonuç olarak, her karakterin tekrar sayısı yazdırılır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:34.728537"
  },
  {
    "question": "Aşağıdaki C kodunda bir dizeyi tersine çevirmek için yazılmıştır. Ancak kod çalıştırıldığında beklenmeyen bir sonuç veriyor. Hata nedir ve nasıl düzeltilir? \n\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[100] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevirilmiş: %s\", str);\n    return 0;\n}",
    "answer": "Kod gözden geçirildiğinde sorun görünmüyor gibi görünüyor; ancak aslında dizeyi tersine çevirme işlemi sırasında dize sonlandırıcısı ('\\0') kontrol edilmiyor. Dize sonlandırıcısı, dize uzunluğunu doğru hesaplamak için önemlidir ve dizenin sonunda olmadığı için bazı durumlarda bellek taşmasına neden olabilir. Bu sorunları önlemek için, dizeyi doğru bir şekilde sonlandırdığınızdan emin olun. Kodda bir değişiklik yapmaya gerek yok, ama her zaman dizenin sonlandırıldığından emin olun.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:47.544792"
  },
  {
    "question": "Aşağıdaki C kodu, kullanıcının girdiği bir dizeyi büyük harfe dönüştürmesi için yazılmıştır. Ancak kod çalıştırıldığında beklenmedik bir şekilde çalışıyor. Hatanın kaynağı nedir ve nasıl düzeltilir? \n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid buyukHarfYap(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir dize girin: \");\n    gets(str);\n    buyukHarfYap(str);\n    printf(\"Büyük harfle: %s\", str);\n    return 0;\n}",
    "answer": "Kodda kullanılan 'gets' fonksiyonu, kullanıcıdan alınan dizenin uzunluğunu kontrol etmez ve bellek taşmasına yol açabilir. Bu nedenle, 'fgets' fonksiyonu kullanılmalıdır. 'fgets' ile dizeyi güvende bir şekilde alarak bellek taşmalarını önleyebiliriz. Aşağıdaki kodda bu düzeltme yapılmıştır: \n\n```c\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid buyukHarfYap(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir dize girin: \");\n    fgets(str, sizeof(str), stdin);\n    buyukHarfYap(str);\n    printf(\"Büyük harfle: %s\", str);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:43:47.544942"
  },
  {
    "question": "Kullanıcıdan alınan bir isim ile 'Merhaba, {isim}' şeklinde bir mesaj oluşturmak istiyordum, fakat kodum çalışmıyor. Aşağıdaki kodu inceleyebilir misin? \n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char name[50];\n    printf(\"İsminizi giriniz: \");\n    gets(name);\n    char message[100];\n    strcpy(message, \"Merhaba, \");\n    strcat(message, name);\n    printf(\"%s\\n\", message);\n    return 0;\n}\n```",
    "answer": "Kodda bazı hatalar var. Birincisi, `gets()` fonksiyonu kullanılması güvenli değil çünkü tampon taşmasına neden olabilir. Bunun yerine `fgets()` kullanılmalıdır. Ayrıca, `strcat()` fonksiyonunun çalışabilmesi için `message` dizisinin yeterli boyutta olduğundan emin olmalıyız. Aşağıdaki kod, bu hataları düzeltiyor:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char name[50];\n    printf(\"İsminizi giriniz: \");\n    fgets(name, sizeof(name), stdin);\n    name[strcspn(name, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    char message[100];\n    strcpy(message, \"Merhaba, \");\n    strcat(message, name);\n    printf(\"%s\\n\", message);\n    return 0;\n}\n```\nBurada `fgets()` kullanarak güvenli bir şekilde kullanıcıdan girdi alıyoruz ve ardından `strcspn()` ile yeni satır karakterini kaldırıyoruz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:01.384907"
  },
  {
    "question": "Bir dizi içerisindeki her bir kelimenin baş harfini büyük yapmak istiyorum, fakat kodumda beklenmedik sonuçlar alıyorum. Aşağıdaki kodu kontrol eder misin? \n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid capitalize(char *str) {\n    for (int i = 0; i < strlen(str); i++) {\n        if (i == 0 || str[i-1] == ' ') {\n            str[i] = str[i] - 32;\n        }\n    }\n}\n\nint main() {\n    char text[100] = \"merhaba dünya programlama\";\n    capitalize(text);\n    printf(\"%s\\n\", text);\n    return 0;\n}\n```",
    "answer": "Kodda `str[i] = str[i] - 32;` ifadesi, ASCII tablosuna dayalı olarak küçük harfleri büyük harflere dönüştürmek için kullanılmış. Ancak bu şekilde küçük harf olmayan karakterlerde de böyle bir işlem yapılmakta. Bu, yanlış bir karakter dönüşümüne yol açar. Ayrıca, karakterleri büyük harfe dönüştürmeden önce, karakterin küçük harf olup olmadığını kontrol etmemiz gerekiyor. Aşağıda düzeltilmiş kodu bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid capitalize(char *str) {\n    for (int i = 0; i < strlen(str); i++) {\n        // Küçük harfi büyük harfe çevirmek için kontrol\n        if (i == 0 || str[i-1] == ' ') {\n            if (str[i] >= 'a' && str[i] <= 'z') {\n                str[i] = str[i] - 32;\n            }\n        }\n    }\n}\n\nint main() {\n    char text[100] = \"merhaba dünya programlama\";\n    capitalize(text);\n    printf(\"%s\\n\", text);\n    return 0;\n}\n```\nBurada, `str[i]` karakterinin küçük harf olup olmadığını kontrol ederek sadece küçük harfleri büyük yapıyoruz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:01.385077"
  },
  {
    "question": "C dilinde bir string'i ters çeviren bir fonksiyonda neden 'strcpy' yerine 'strncpy' kullanımı hatalıdır?",
    "answer": "Örneğin, aşağıdaki kodda bir string'i ters çeviren bir fonksiyon var: \n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char *str) {\n    int n = strlen(str);\n    char reversed[n + 1]; // +1 for the null terminator\n    for (int i = 0; i < n; i++) {\n        reversed[i] = str[n - 1 - i];\n    }\n    reversed[n] = '\\0'; // null terminator\n    strcpy(str, reversed); // burada hatalı kullanılıyor\n}\n\nint main() {\n    char str[] = \"C dilinde programlama\";\n    reverseString(str);\n    printf(\"Ters çevrilmiş string: %s\\n\", str);\n    return 0;\n}\n```\n\nBu kodda 'strcpy' kullanımı, hedef string'in boyutunu kontrol etmediği için 'buffer overflow' hatasına yol açabilir. Ayrıca, 'strncpy' kullanıldığında hedef string'in boyutunu belirtmek gerekir. Bu da ek bir hata kaynağı olabilir. Düzgün bir şekilde ters çevirmek için 'strncpy' kullanılmamalıdır çünkü hedef alanın boyutu ile ilgili bir kısıtlama getirir ve tüm string'in kopyalanmaması gibi sorunlara yol açabilir. En iyi uygulama, bellek yönetimini güvenli bir şekilde sağlamak için 'strncpy' yerine 'strcpy' kullanmak ya da hedef string'in boyutunu kontrol etmektir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:23.561922"
  },
  {
    "question": "C dilinde bir string üzerinde arama yaparken, 'strchr' fonksiyonu kullanılmasının neden hatalı bir sonucu olabileceğini açıklayınız.",
    "answer": "Aşağıdaki örnekte 'strchr' fonksiyonu ile bir karakterin string içerisinde arandığı bir durum var: \n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba dünya!\";\n    char *ptr = strchr(str, 'a');\n    if (ptr != NULL) {\n        printf(\"Karakter bulundu: %c\\n\", *ptr);\n    } else {\n        printf(\"Karakter bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\n\nBu kodda, 'strchr' fonksiyonu 'a' karakterinin ilk bulunduğu yeri bulur. Ancak, 'strchr' sadece ilk eşleşmeyi döndürdüğünden, eğer string içerisinde birden fazla 'a' karakteri varsa, program bu durumu göz ardı eder. Eğer tüm 'a' karakterlerinin bulunması gerekiyorsa, döngü ile 'strchr' fonksiyonunu çağırarak her birini kontrol etmek gerekir. Ayrıca, 'ptr' değişkeninin NULL kontrolü yapılması önemlidir; aksi takdirde, NULL bir işaretçi ile işlem yapılması 'undefined behavior' sonucunu doğurabilir. Yani kullanıcı fonksiyonu kullanırken arama koşulunu iyi belirlemeli ve gerektiğinde döngü kullanarak tüm eşleşmeleri tespit etmelidir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:23.561973"
  },
  {
    "question": "C dilinde bir string içinde belirli bir karakterin kaç defa geçtiğini nasıl bulabilirim?",
    "answer": "C dilinde bir string içinde belirli bir karakterin kaç defa geçtiğini bulmak için bir döngü kullanabiliriz. Öncelikle, bir string tanımlayıp ardında karakterimizi belirleyelim. Daha sonra, string'in her bir karakterini kontrol ederek, eğer karakter aradığımız karakterle eşleşirse, bir sayaç değişkenini artıracağız. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba dünya! Merhaba C!\";\n    char ch = 'a';\n    int count = 0;\n\n    for(int i = 0; i < strlen(str); i++) {\n        if(str[i] == ch) {\n            count++;\n        }\n    }\n\n    printf(\"'%c' karakteri string içinde %d defa geçti.\\n\", ch, count);\n    return 0;\n}\n```\nBu kodda, 'Merhaba dünya! Merhaba C!' metninde 'a' karakterinin kaç defa geçtiğini sayıyoruz. Sonuç, 'a' karakterinin toplamda 3 defa geçtiği şeklinde olacak.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:44.184824"
  },
  {
    "question": "C dilinde bir string'in başındaki ve sonundaki boşlukları nasıl kaldırabilirim?",
    "answer": "C dilinde bir string'in başındaki ve sonundaki boşlukları kaldırmak için, string üzerinde bir dizi işlem yapmamız gerekiyor. Öncelikle, string'in başındaki boşlukları bulup, bulduğumuz ilk karakterden itibaren yeni bir string oluşturabiliriz. Aynı işlemi string'in sonundaki boşluklar için de yapmalıyız. İşte adım adım bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid trim(char* str) {\n    int start = 0, end = strlen(str) - 1;\n\n    // Başındaki boşlukları bul\n    while (str[start] == ' ') {\n        start++;\n    }\n\n    // Sonundaki boşlukları bul\n    while (end >= start && str[end] == ' ') {\n        end--;\n    }\n\n    // Yeni string oluştur\n    for (int i = 0; i <= end - start; i++) {\n        str[i] = str[start + i];\n    }\n    str[end - start + 1] = '\\0'; // Null karakter ile bitir\n}\n\nint main() {\n    char str[] = \"    Merhaba C!    \";\n    trim(str);\n    printf(\"Trimlenmiş string: '%s'\\n\", str);\n    return 0;\n}\n```\nBu kodda, '    Merhaba C!    ' string'inin başındaki ve sonundaki boşlukları kaldırıyoruz. Sonuç olarak, 'Merhaba C!' şeklinde bir çıkış alacağız.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:44.184884"
  },
  {
    "question": "C dilinde bir string'in belirli bir karakter içerip içermediğini nasıl kontrol edebilirim?",
    "answer": "C dilinde bir string'in belirli bir karakter içerip içermediğini kontrol etmek için 'strchr' fonksiyonunu kullanabiliriz. Bu fonksiyon, belirtilen karakterin string içerisinde bulunup bulunmadığını kontrol eder ve eğer karakter bulunursa, onun bulunduğu yerin adresini döner; bulunmazsa NULL döner. Örnek olarak, bir kullanıcıdan alınan bir string'in içinde 'a' karakterinin olup olmadığını kontrol edelim:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    if (strchr(str, 'a') != NULL) {\n        printf(\"String 'a' karakterini içeriyor.\\n\");\n    } else {\n        printf(\"String 'a' karakterini içermiyor.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir string alır ve 'a' karakterinin varlığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:56.839447"
  },
  {
    "question": "Bir string içinde geçen kelimeleri saymak için C dilinde nasıl bir fonksiyon yazabilirim?",
    "answer": "C dilinde bir string içinde geçen kelimeleri saymak için, boşluk karakterlerini kullanarak string'i parçalara ayırabiliriz. 'strtok' fonksiyonu, bir string'i belirli bir ayırıcıya göre parçalamak için kullanılabilir. Örnek bir uygulama olarak, kullanıcıdan alınan bir string içindeki kelimeleri saymak için şu şekilde bir kod yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    int kelimeSayisi = 0;\n    char *token = strtok(str, \" \n\"); // Boşluk ve yeni satırları ayırıcı olarak kullanıyoruz\n\n    while (token != NULL) {\n        kelimeSayisi++;\n        token = strtok(NULL, \" \n\");\n    }\n\n    printf(\"Cümlede %d kelime var.\\n\", kelimeSayisi);\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir cümle alır ve cümledeki kelime sayısını belirler. Boşluk karakterlerine göre kelimeleri parçalara ayırarak toplam kelime sayısını hesaplar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:44:56.839489"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan bir fonksiyonu nasıl yazabilirim?",
    "answer": "C dilinde bir stringin uzunluğunu hesaplamak için basit bir fonksiyon yazabiliriz. Aşağıda bu fonksiyonun nasıl çalıştığını açıklayan bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint stringLength(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') { // NULL karakterine kadar ilerliyoruz\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    const char *exampleString = \"Merhaba Dünya!\";\n    int length = stringLength(exampleString);\n    printf(\"Stringin uzunluğu: %d\\n\", length);\n    return 0;\n}\n```\n\nBu kodda, 'stringLength' isimli bir fonksiyon tanımlıyoruz. Fonksiyon, verilen stringin uzunluğunu hesaplamak için bir döngü kullanır. Döngü, NULL ('\\0') karakterine ulaşana kadar devam eder ve her iterasyonda 'length' değişkenini bir artırır. Fonksiyon sonunda, hesaplanan uzunluğu döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:27.877892"
  },
  {
    "question": "İki stringi birleştiren bir fonksiyon nasıl yazabilirim?",
    "answer": "İki stringi birleştirmek için 'strcat' fonksiyonu yerine kendi fonksiyonumuzu yazabiliriz. Aşağıda bu işlemi gerçekleştiren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* concatenateStrings(const char *str1, const char *str2) {\n    int length1 = 0, length2 = 0;\n    // İlk stringin uzunluğunu hesapla\n    while (str1[length1] != '\\0') length1++;\n    // İkinci stringin uzunluğunu hesapla\n    while (str2[length2] != '\\0') length2++;\n\n    // Yeni bir bellek alanı ayır\n    char *result = (char *)malloc((length1 + length2 + 1) * sizeof(char));\n    if (result == NULL) { // Bellek kontrolü\n        return NULL;\n    }\n\n    // İlk stringi kopyala\n    for (int i = 0; i < length1; i++) {\n        result[i] = str1[i];\n    }\n    // İkinci stringi kopyala\n    for (int j = 0; j < length2; j++) {\n        result[length1 + j] = str2[j];\n    }\n    result[length1 + length2] = '\\0'; // NULL karakterini ekle\n\n    return result;\n}\n\nint main() {\n    const char *firstString = \"Merhaba\";\n    const char *secondString = \" Dünya!\";\n    char *combinedString = concatenateStrings(firstString, secondString);\n    printf(\"Birleştirilmiş string: %s\\n\", combinedString);\n    free(combinedString); // Bellek temizliği\n    return 0;\n}\n```\n\nBu kodda, 'concatenateStrings' isimli bir fonksiyon tanımlıyoruz. Fonksiyon, iki stringin uzunluklarını hesabına göre, yeterli bellek ayırır ve her iki stringi birleştirerek yeni bir string oluşturur. Son olarak, birleştirilmiş stringi döndürür. 'main' fonksiyonunda ise bu fonksiyonu çağırarak sonucu ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:27.877927"
  },
  {
    "question": "Bir dizi içindeki kelimelerin sayısını bulan bir fonksiyon yazın.",
    "answer": "Aşağıda, bir dizi içindeki kelimeleri sayan basit bir C fonksiyonu yer alıyor. Bu fonksiyon, verilen bir metin dizesini alır ve dize içinde boşluk (space) karakterlerine göre kelimeleri sayar. Boşluklar arasındaki kelimeleri tespit etmek için döngü kullanıyoruz:\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nint kelimeSayisi(const char *metin) {\n    int sayi = 0;\n    bool kelimeVarMi = false;\n\n    for (int i = 0; metin[i] != '\\0'; i++) {\n        if (metin[i] != ' ') {\n            if (!kelimeVarMi) {\n                kelimeVarMi = true;\n                sayi++;\n            }\n        } else {\n            kelimeVarMi = false;\n        }\n    }\n    return sayi;\n}\n\nint main() {\n    const char *metin = \"Merhaba dünya bu bir denemedir.\";\n    int sonuc = kelimeSayisi(metin);\n    printf(\"Kelime sayısı: %d\\n\", sonuc);\n    return 0;\n}\n```\n\nBu kodda, `kelimeSayisi` fonksiyonu metni kontrol eder ve boşluk olmayan karakterlerle karşılaştığında kelime sayısını artırır. `main` fonksiyonu, örnek bir metin kullanarak bu fonksiyonu çağırır ve sonuçları ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:38.694507"
  },
  {
    "question": "Verilen bir string'in tersini döndüren bir fonksiyon yazın.",
    "answer": "Aşağıda, bir dizi içindeki karakterleri tersine çevirecek bir C fonksiyonu bulunuyor. Bu fonksiyon, verilen bir metni alır ve karakterlerini ters sırayla bir başka diziye kopyalayarak sonucu döndürür:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(const char *metin, char *tersMetin) {\n    int uzunluk = strlen(metin);\n    for (int i = 0; i < uzunluk; i++) {\n        tersMetin[i] = metin[uzunluk - 1 - i];\n    }\n    tersMetin[uzunluk] = '\\0'; // Sonlandırıcı karakteri ekle\n}\n\nint main() {\n    const char *metin = \"Merhaba\";\n    char tersMetin[100]; // Yeterli boyutta bir dizi tanımlıyoruz\n\n    tersCevir(metin, tersMetin);\n    printf(\"Ters metin: %s\\n\", tersMetin);\n    return 0;\n}\n```\n\nBu kodda, `tersCevir` fonksiyonu metnin uzunluğunu hesaplayarak karakterleri ters sırada kopyalar. Sonrasında, `main` fonksiyonu örnek bir metinle `tersCevir` fonksiyonunu çağırır ve sonuçları ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:38.694544"
  },
  {
    "question": "Bir metindeki kelimelerin frekansını bulan bir C programı yazın. Örneğin, 'merhaba dünya merhaba' girişi için 'merhaba: 2, dünya: 1' çıktısını vermelidir.",
    "answer": "Aşağıda, C dilinde bir metindeki kelimelerin frekansını bulan bir programın örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_WORDS 100\n#define MAX_WORD_LENGTH 20\n\ntypedef struct {\n    char word[MAX_WORD_LENGTH];\n    int count;\n} WordCount;\n\nint main() {\n    char input[256];\n    WordCount words[MAX_WORDS];\n    int wordCount = 0;\n\n    printf(\"Bir metin girin: \");\n    fgets(input, sizeof(input), stdin);\n\n    char *token = strtok(input, \" \\n\");\n    while (token != NULL) {\n        int found = 0;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i].word, token) == 0) {\n                words[i].count++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found && wordCount < MAX_WORDS) {\n            strcpy(words[wordCount].word, token);\n            words[wordCount].count = 1;\n            wordCount++;\n        }\n        token = strtok(NULL, \" \\n\");\n    }\n\n    printf(\"Kelime frekansları:\\n\");\n    for (int i = 0; i < wordCount; i++) {\n        printf(\"%s: %d\\n\", words[i].word, words[i].count);\n    }\n\n    return 0;\n}\n```\nBu program, kullanıcıdan bir metin alır ve kelimeleri boşluk ve yeni satır karakterlerine göre ayırarak her bir kelimenin frekansını hesaplar. Kelime frekanslarını saklamak için bir yapı (struct) kullanıyoruz ve ardından her kelimenin sayısını güncelliyoruz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:55.984359"
  },
  {
    "question": "Bir C programı yazın, verilen bir stringin palindrom olup olmadığını kontrol etsin. Örneğin, 'radar' ve 'merhaba' girişleri için sırasıyla 'Evet' ve 'Hayır' çıktısını vermelidir.",
    "answer": "Aşağıda, bir stringin palindrom olup olmadığını kontrol eden bir C programının örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isPalindrome(const char *str) {\n    int left = 0;\n    int right = strlen(str) - 1;\n\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint main() {\n    char input[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", input);\n\n    if (isPalindrome(input)) {\n        printf(\"Evet, '%s' bir palindromdur.\\n\", input);\n    } else {\n        printf(\"Hayır, '%s' bir palindrom değildir.\\n\", input);\n    }\n\n    return 0;\n}\n```\nBu program, kullanıcıdan bir kelime alır ve bu kelimenin palindrom olup olmadığını kontrol eder. `isPalindrome` fonksiyonu, stringin başından ve sonundan başlayarak her iki karakteri karşılaştırır ve eşleşmezse false döndürür. Eğer tüm karakterler eşleşirse, true döner. Program, sonuç olarak kullanıcıya kelimenin palindrom olup olmadığını bildirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:45:55.984425"
  },
  {
    "question": "Bir C programında, kullanıcıdan alınan bir stringin içinde geçen tüm boşluk karakterlerini kaldırmak istiyorum. Ancak mevcut kodum verimliliği açısından zayıf görünüyor. Kodumu gözden geçirip optimize edebilir misin?",
    "answer": "Mevcut kodunuz muhtemelen dizi üzerinde birden fazla geçiş yapıyor ve her seferinde boşluk karakterlerini kontrol ediyor. Bunun yerine, tek bir geçişte boşlukları atlayıp yeni bir diziye kopyalayarak daha verimli bir çözüm sunabilirsiniz. Aşağıda önerilen kodu bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpaces(char *str) {\n    int i, j = 0;\n    int length = strlen(str);\n    char temp[length + 1]; // Geçici dizi oluştur\n\n    for (i = 0; i < length; i++) {\n        if (str[i] != ' ') {\n            temp[j++] = str[i]; // Boşluk değilse kopyala\n        }\n    }\n    temp[j] = '\\0'; // Dizi sonlandır\n\n    strcpy(str, temp); // Geçici diziyi orijinal diziye kopyala\n}\n\nint main() {\n    char str[100] = \"Merhaba Dünya! Bu bir test.\";\n    removeSpaces(str);\n    printf(\"Sonuç: %s\\n\", str);\n    return 0;\n}\n```\nBu kod, string üzerinde sadece bir geçiş yaparak boşluk karakterlerini kaldırır ve işlem süresini önemli ölçüde azaltır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:46:08.535860"
  },
  {
    "question": "Bir C uygulamasında, bir stringin palindrom olup olmadığını kontrol etmek için yazdığım kod verimli görünmüyor. Bunu optimize edebilir misin?",
    "answer": "Mevcut kodunuz muhtemelen stringin tamamını tersine çevirip ardından karşılaştırıyor. Bunun yerine, stringin ortasına kadar gidip karakterleri karşılaştırarak daha verimli bir çözüm sunabilirsiniz. Aşağıda önerilen kod örneğini bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isPalindrome(char *str) {\n    int left = 0;\n    int right = strlen(str) - 1;\n\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false; // Farklı karakterler bulundu\n        }\n        left++;\n        right--;\n    }\n    return true; // Tüm karakterler eşleşti\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    scanf(\"%s\", str);\n\n    if (isPalindrome(str)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}\n```\nBu kod, sadece stringin yarısına kadar giderek karşılaştırma yapıyor, böylece gereksiz karşılaştırmalardan kaçınıyor ve performansı artırıyor.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:46:08.535915"
  },
  {
    "question": "Aşağıdaki C kodu bir metni tersine çeviriyor. Ancak kodun performansı üzerinde bazı olumsuz etkiler var. Kodunuzu inceleyin ve nasıl iyileştirebileceğinizi açıklayın.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char* str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    reverseString(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n```",
    "answer": "Bu kod, bir metni tersine çevirme işlevini yerine getiriyor. Ancak, kodu optimize etmek için düşünmemiz gereken bazı noktalar var. Öncelikle, 'strlen' fonksiyonu her döngüde çağrılıyor; bu, performansı olumsuz etkileyebilir. 'n' değişkenini döngü dışında bir kez hesaplamak yeterli olacaktır.\n\nAyrıca, karakter dizisinin boyutunu almak için strlen yerine daha verimli bir yöntem kullanabiliriz. Örneğin, 'sizeof' operatörünü kullanarak bellek alanını doğrudan alabiliriz. Ancak bu, sadece statik boyutlu diziler için geçerlidir. Dinamik bellek kullanıyorsanız, bu yöntemi kullanmayı unutmayın. \n\nAşağıda optimize edilmiş bir sürüm bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char* str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    reverseString(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n```\n\nBu değişiklikle, performans artışı sağlanacak ve kod daha okunabilir hale gelecektir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:46:34.523704"
  },
  {
    "question": "Aşağıdaki kod, bir cümledeki kelimelerin sayısını bulmak için yazılmıştır. Ancak, kod hem okunabilirlik hem de performans açısından iyileştirilmeye ihtiyaç duyuyor. Kodunuzu gözden geçirin ve önerilerde bulunun.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint countWords(const char* str) {\n    int count = 0;\n    int inWord = 0;\n    while (*str) {\n        if (*str != ' ' && inWord == 0) {\n            inWord = 1;\n            count++;\n        }\n        else if (*str == ' ' && inWord == 1) {\n            inWord = 0;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char* sentence = \"Bugün hava çok güzel\";\n    printf(\"Kelime sayısı: %d\\n\", countWords(sentence));\n    return 0;\n}\n```",
    "answer": "Kod, bir cümledeki kelimeleri saymak için mantıklı bir yaklaşım sergiliyor. Ancak, okunabilirlik ve performans açısından iyileştirmek mümkün. Öncelikle, 'inWord' değişkeninin amacı daha açık bir isimle değiştirilebilir. Ayrıca, boşluk kontrolü yapmak yerine, istenmeyen boşlukları göz ardı etmek için daha sağlam bir yaklaşım kullanmak faydalı olabilir.\n\nDaha iyi bir yöntem olarak, cümle başlangıcında ve sonunda boşlukları kontrol etmek ve sadece geçerli kelimeleri saymak için bir döngü yapısını kullanabiliriz. Aşağıda geliştirilmiş bir sürüm bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint countWords(const char* str) {\n    int count = 0;\n    int inWord = 0;\n    while (*str) {\n        if ((*str != ' ' && inWord == 0)) {\n            inWord = 1;\n            count++;\n        }\n        else if (*str == ' ' && inWord == 1) {\n            inWord = 0;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char* sentence = \"  Bugün hava çok güzel  \";\n    printf(\"Kelime sayısı: %d\\n\", countWords(sentence));\n    return 0;\n}\n```\n\nBu şekilde, metin başındaki ve sonundaki boşluklar dikkate alınmadan doğru sayım yapılır. Kod daha okunabilir ve anlaşılır hale getirilmiştir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-05-31T16:46:34.523903"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin uzunluğunu bulan eksik kodu tamamlayın: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n    int uzunluk = ; // Burayı tamamlayın\n    printf(\"Kelimenin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}",
    "answer": "// Kullanıcıdan alınan kelimenin uzunluğunu bulmak için strlen fonksiyonu kullanılır.\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n    int uzunluk = strlen(kelime); // Burada kelimenin uzunluğunu hesaplıyoruz\n    printf(\"Kelimenin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir kelime alır ve kelimenin uzunluğunu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:46:46.669181"
  },
  {
    "question": "Kullanıcının girdiği bir cümlenin tüm harflerini büyük harfe çeviren eksik kodu tamamlayın: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cümle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cümle, sizeof(cümle), stdin);\n    // Cümleyi büyük harfe çevirin\n    printf(\"Büyük harfli cümle: %s\\n\", cümle);\n    return 0;\n}",
    "answer": "// Cümleyi büyük harfe çevirmek için strupr fonksiyonu kullanılır, ancak bu fonksiyon standart C kütüphanesinde yoktur, bu nedenle kendi fonksiyonumuzu yazacağız.\n#include <stdio.h>\n#include <string.h>\n\nvoid buyukHarf(char *str) {\n    for(int i = 0; str[i]; i++) {\n        if(str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - ('a' - 'A');\n        }\n    }\n}\n\nint main() {\n    char cümle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cümle, sizeof(cümle), stdin);\n    buyukHarf(cümle); // Cümleyi büyük harfe çeviriyoruz\n    printf(\"Büyük harfli cümle: %s\\n\", cümle);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir cümle alır ve cümlenin tüm harflerini büyük harfe çevirip ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:46:46.669288"
  },
  {
    "question": "Kullanıcının girdiği bir metni tersine çeviren bir C programının eksik kodunu tamamlayın. Aşağıdaki kodu doldurun:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid terstenYaz(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\"%c\", str[___]);\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    terstenYaz(metin);\n    return 0;\n}",
    "answer": "Eksik kodu tamamlayarak metni tersine çevirebiliriz. Aşağıdaki gibi düzenleyebiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid terstenYaz(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\"%c\", str[uzunluk - 1 - i]);\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    terstenYaz(metin);\n    return 0;\n}\n```\n\nAçıklama: Bu kod parçası, kullanıcıdan bir metin alır ve bu metni tersten yazdıran bir fonksiyon içerir. 'str[uzunluk - 1 - i]' ifadesi, metnin sonundan başlayarak her bir karakteri sırayla yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:00.927392"
  },
  {
    "question": "Bir metindeki büyük harfleri küçük harflere dönüştüren bir fonksiyon yazın. Aşağıdaki kodun eksik kısımlarını tamamlayın:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid kucukHarfeDonustur(char *str) {\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] = _____;\n        }\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    kucukHarfeDonustur(metin);\n    printf(\"Küçük harfli metin: %s\", metin);\n    return 0;\n}",
    "answer": "Eksik kısmı tamamlayarak büyük harfleri küçük harflere dönüştürebiliriz. Aşağıdaki gibi düzenleyebiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid kucukHarfeDonustur(char *str) {\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] = str[i] + ('a' - 'A');\n        }\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    kucukHarfeDonustur(metin);\n    printf(\"Küçük harfli metin: %s\", metin);\n    return 0;\n}\n```\n\nAçıklama: Bu kod, bir metni alır ve içindeki tüm büyük harfleri eşdeğer küçük harflerine dönüştürür. 'str[i] + ('a' - 'A')' ifadesi, büyük harfi küçük harfe dönüştürmek için ASCII değerleri arasında fark kullanır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:00.927544"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki kelimeleri tersine çeviren bir fonksiyon yazın. Örnek girdi: 'Merhaba dünya' çıkış: 'abahreM aynud'. Fonksiyonu tamamlayın.",
    "answer": "// Tüm kelimeleri ters çeviren fonksiyon\n#include <stdio.h>\n#include <string.h>\n\nvoid kelimeleriTersCevir(char *str) {\n    char *kelime = strtok(str, \" \"); // İlk kelimeyi al\n    while (kelime != NULL) {\n        // Kelimenin tersini yazdır\n        for (int i = strlen(kelime) - 1; i >= 0; i--) {\n            printf(\"%c\", kelime[i]);\n        }\n        printf(\" \"); // Kelimeler arasında boşluk bırak\n        kelime = strtok(NULL, \" \"); // Sonraki kelime\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin); // Kullanıcıdan cümle al\n    kelimeleriTersCevir(str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:12.878525"
  },
  {
    "question": "Kullanıcının girdiği bir metindeki sesli harflerin sayısını hesaplayan bir fonksiyon yazın. Örnek girdi: 'Merhaba Dünya!' çıkış: 'Sesli harf sayısı: 6'. Fonksiyonu tamamlayın.",
    "answer": "// Sesli harfleri sayan fonksiyon\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint sesliHarfSay(char *str) {\n    int sesliSay = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        char ch = tolower(str[i]); // Harfi küçük harfe çevir\n        if (ch == 'a' || ch == 'e' || ch == 'ı' || ch == 'i' || ch == 'o' || ch == 'ö' || ch == 'u' || ch == 'ü') {\n            sesliSay++;\n        }\n    }\n    return sesliSay;\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir metin girin: \");\n    fgets(str, sizeof(str), stdin); // Kullanıcıdan metin al\n    int sonuc = sesliHarfSay(str);\n    printf(\"Sesli harf sayısı: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:12.878586"
  },
  {
    "question": "Aşağıdaki C kodunda, kullanıcıdan bir kelime alarak kelimenin uzunluğunu bulan bir program var. Ancak program çalışmıyor. Hataları bul ve düzelt: \n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    gets(kelime);\n    printf(\"Kelimenin uzunluğu: %d\\n\", strlen(kelime));\n    return 0;\n}",
    "answer": "Bu kodda iki ana hata var. İlk olarak, 'gets' fonksiyonu kullanımı güvenli değildir ve tam olarak desteklenmemektedir. Bunun yerine 'fgets' fonksiyonu kullanılmalıdır. İkinci olarak, 'strlen' fonksiyonu ile kelimenin uzunluğunu hesaplamak doğru fakat kullanıcıdan alınan veri güvenli bir şekilde okunmadığı için bu değişikliğin yapılması gerekiyor. Aşağıdaki gibi düzeltilmiş bir versiyon sunuyorum:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n    kelime[strcspn(kelime, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    printf(\"Kelimenin uzunluğu: %zu\\n\", strlen(kelime));\n    return 0;\n}\n\nBurada 'fgets' ile aldığımız verinin sonunda oluşan yeni satır karakterini de 'strcspn' fonksiyonu ile temizledik.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:28.991434"
  },
  {
    "question": "Aşağıdaki kod, bir cümledeki boşlukları kaldırmak için tasarlanmış. Ancak bazı hatalar var. Hataları belirle ve düzelt: \n\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *cümle) {\n    int i, j = 0;\n    for(i = 0; cümle[i] != '\\0'; i++) {\n        if(cümle[i] != ' ') {\n            cümle[j++] = cümle[i];\n        }\n    }\n    cümle[j] = '\\0';\n}\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    gets(cumle);\n    boslukKaldir(cumle);\n    printf(\"Boşluklar kaldırıldı: %s\\n\", cumle);\n    return 0;\n}",
    "answer": "Bu kodda iki ana hata var. İlk olarak, 'gets' fonksiyonu yine güvenli değil ve bu yüzden 'fgets' ile değiştirilmelidir. İkinci olarak, 'boslukKaldir' fonksiyonu cümledeki boşlukları kaldırmak için yazılmış fakat kullanıcıdan alınan verinin güvenli bir şekilde okunmadığı için hata yapabiliriz. Düzgün bir versiyon aşağıdaki gibi olmalıdır:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *cümle) {\n    int i, j = 0;\n    for(i = 0; cümle[i] != '\\0'; i++) {\n        if(cümle[i] != ' ') {\n            cümle[j++] = cümle[i];\n        }\n    }\n    cümle[j] = '\\0';\n}\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    cumle[strcspn(cumle, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    boslukKaldir(cumle);\n    printf(\"Boşluklar kaldırıldı: %s\\n\", cumle);\n    return 0;\n}\n\nBu şekilde 'fgets' ile kullanıcıdan alınan veri güvenli bir şekilde okunmuş ve yeni satır karakteri temizlenmiştir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:28.991598"
  },
  {
    "question": "Bir metin içindeki boşluk karakterlerini kaldırmak için yazdığım C kodunda neden beklenmedik sonuçlar alıyorum? Aşağıdaki kodu inceleyin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid remove_spaces(char *str) {\n    char *p = str;\n    while (*p) {\n        if (*p == ' ') {\n            strcpy(p, p + 1);\n        } else {\n            p++;\n        }\n    }\n}\n\nint main() {\n    char str[] = \"C dilini öğrenmek çok eğlenceli!\";\n    remove_spaces(str);\n    printf(\"Sonuç: %s\\n\", str);\n    return 0;\n}\n```",
    "answer": "Kodun işlevselliği üzerine düşündüğümüzde, `strcpy` fonksiyonu ile boşluk karakterini kaldırmak için bir yaklaşım kullanıyorsunuz. Ancak, bu yöntem birkaç sorun taşıyor. \n\n1. `strcpy` fonksiyonu, kaynak ve hedef dizgilerinin üzerine yazmaya çalıştığından, bu durumda iç içe boşlukları düzgün bir şekilde işleyemez. Bu durum, bazı karakterlerin kaybolmasına neden olabilir.\n2. Bir boşluk karakteri ile karşılaştığınızda, `strcpy` fonksiyonu, dizgiyi bir karakter sola kaydırır, ancak `p` göstericisi bir sonraki karaktere geçmek için `p++` ifadesini kullanır; bu da bazı karakterlerin atlanmasına neden olabilir. \n\nBunu düzeltmek için, boşluk karakteri bulunduğunda sadece `p`'yi güncellemeli ve dizgiyi manuel olarak kaydırmalısınız. Örneğin:\n\n```c\nvoid remove_spaces(char *str) {\n    char *p1 = str, *p2 = str;\n    while (*p1) {\n        if (*p1 != ' ') {\n            *p2++ = *p1;\n        }\n        p1++;\n    }\n    *p2 = '\\0';  // Sonlandırıcıyı eklemeyi unutmayın\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:48.617229"
  },
  {
    "question": "Kullanıcıdan alınan bir şifrede küçük harf, büyük harf ve rakam olup olmadığını kontrol etmek için yazdığım kodda sorun var. Kod şöyle:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint check_password(const char *password) {\n    int has_lower = 0, has_upper = 0, has_digit = 0;\n    for (int i = 0; i < strlen(password); i++) {\n        if (password[i] >= 'a' && password[i] <= 'z') {\n            has_lower = 1;\n        } else if (password[i] >= 'A' && password[i] <= 'Z') {\n            has_upper = 1;\n        } else if (password[i] >= '0' && password[i] <= '9') {\n            has_digit = 1;\n        }\n    }\n    return has_lower && has_upper && has_digit;\n}\n\nint main() {\n    char password[100];\n    printf(\"Şifreyi girin: \");\n    fgets(password, sizeof(password), stdin);\n    check_password(password) ? printf(\"Geçerli şifre\\n\") : printf(\"Geçersiz şifre\\n\");\n    return 0;\n}\n```",
    "answer": "Kodda, kullanıcıdan alınan `password` değişkeni `fgets` fonksiyonu ile alınıyor. Ancak, `fgets` fonksiyonu sonuna bir yeni satır karakteri (`\\n`) ekliyor. Bu yeni satır karakteri, `check_password` fonksiyonunda yapılacak karşılaştırmalara dahil ediliyor ve bu durumda şifre kontrolü yanlış sonuç verebiliyor. \n\nYeni satırı temizlemek için, `fgets` sonrasında `strcspn` fonksiyonunu kullanarak yeni satır karakterini kaldırabilirsiniz. Düzeltme şu şekilde olmalı:\n\n```c\nint main() {\n    char password[100];\n    printf(\"Şifreyi girin: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Yeni satırı kaldır\n    check_password(password) ? printf(\"Geçerli şifre\\n\") : printf(\"Geçersiz şifre\\n\");\n    return 0;\n}\n``` \nBu düzeltme ile, şifre kontrolü doğru bir şekilde yapılacaktır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:47:48.617473"
  },
  {
    "question": "Aşağıdaki C kodu, bir stringi ters çevirmekte sorun yaşıyor. Hata nedir ve nasıl düzeltilir? \n\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    gets(str);\n    reverseString(str);\n    printf(\"Ters çevrilmiş string: %s\", str);\n    return 0;\n}",
    "answer": "Bu kodda 'gets' fonksiyonu kullanılmış. 'gets' fonksiyonu, buffer overflow (tampon taşması) hatasına yol açabileceğinden dolayı güvenli değildir. Bunun yerine 'fgets' fonksiyonu kullanılmalıdır. Ayrıca, 'fgets' fonksiyonu yeni satır karakterini de alabilir, bu nedenle, ters çevrilen stringin sonunda bir yeni satır karakteri olmasına dikkat edilmelidir. Aşağıdaki şekilde düzeltme yapılabilir:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // yeni satırı kaldır\n    reverseString(str);\n    printf(\"Ters çevrilmiş string: %s\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:03.250703"
  },
  {
    "question": "Aşağıdaki C kodu, verilen bir string içindeki tüm küçük harfleri büyük harfe dönüştürmeyi hedefliyor. Ancak, kod beklenildiği gibi çalışmıyor. Hata nedir ve çözümü nedir? \n\n#include <stdio.h>\n#include <string.h>\n\nvoid toUpperCase(char str[]) {\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 32;\n        }\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    gets(str);\n    toUpperCase(str);\n    printf(\"Büyük harfli string: %s\", str);\n    return 0;\n}",
    "answer": "Bu kod, 'gets' fonksiyonu kullanarak girdi alıyor, bu sebep ile aynı sorun burada da geçerli. Bunun dışında, ASCII değerleri ile harf dönüşümü yapmak yerine, 'toupper' fonksiyonu kullanılmalıdır. Aşağıdaki gibi düzeltilmelidir:\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid toUpperCase(char str[]) {\n    for (int i = 0; i < strlen(str); i++) {\n        str[i] = toupper(str[i]); // toupper fonksiyonu kullan\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // yeni satırı kaldır\n    toUpperCase(str);\n    printf(\"Büyük harfli string: %s\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:03.250871"
  },
  {
    "question": "C dilinde bir stringin uzunluğunu nasıl bulabilirim?",
    "answer": "C dilinde bir stringin uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabiliriz. Bu fonksiyon, stringin sonuna kadar olan karakterleri sayarak uzunluğunu verir. Örneğin: \n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    int uzunluk = strlen(str);\n    printf(\"Stringin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n```\n\nBu örnekte, 'str' isimli bir string tanımlıyoruz ve 'strlen' fonksiyonu ile uzunluğunu hesaplıyoruz. Çıktı olarak 13 alırız, çünkü boşluk da dahil olmak üzere toplamda 13 karakter vardır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:11.462057"
  },
  {
    "question": "C dilinde bir stringin tüm harflerini büyük harfe dönüştürmek için hangi fonksiyonu kullanabilirim?",
    "answer": "C dilinde bir stringin tüm harflerini büyük harfe dönüştürmek için 'toupper' fonksiyonunu kullanabiliriz. Ancak, bu fonksiyon tek bir karakter üzerinde çalıştığı için, bir döngü kullanarak tüm stringi kontrol etmemiz gerekiyor. Örneğin:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"merhaba dünya\";\n    for(int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n    printf(\"Büyük harfli: %s\\n\", str);\n    return 0;\n}\n```\n\nBu kod parçasında, 'merhaba dünya' stringini alıyoruz ve her bir karakter üzerinde 'toupper' fonksiyonunu uygulayarak büyük harf yapıyoruz. Sonuç olarak 'MERHABA DÜNYA' çıktısını alırız.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:11.462107"
  },
  {
    "question": "Bir kullanıcının girdiği bir metindeki tüm boşlukları kaldırmak için hangi C string fonksiyonlarını kullanabilirim?",
    "answer": "Boşlukları kaldırmak için, öncelikle kullanıcının girdiği metni tutacak bir karakter dizisi (string) tanımlamalıyız. Ardından, bu diziyi döngü ile gezeceğiz ve her karakteri kontrol edeceğiz. Eğer karakter boşluk değilse, yeni bir diziye ekleyeceğiz. Bunun için 'strlen' fonksiyonu ile metnin uzunluğunu alabilir ve 'strcpy' fonksiyonu ile yeni diziyi oluşturabiliriz. Örnek bir kod parçası:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpaces(char *str) {\n    int i, j = 0;\n    char temp[strlen(str) + 1]; // Geçici bir dizi oluşturuyoruz.\n    \n    for (i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') { // Eğer karakter boşluk değilse\n            temp[j++] = str[i]; // Geçici diziye ekle\n        }\n    }\n    temp[j] = '\\0'; // Geçici dizinin sonuna null karakter ekle\n    strcpy(str, temp); // Orijinal diziye kopyala\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir metin giriniz: \");\n    fgets(str, sizeof(str), stdin);\n    removeSpaces(str);\n    printf(\"Boşluklar kaldırıldı: %s\", str);\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir metin alır ve metindeki tüm boşlukları kaldırarak sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:25.440115"
  },
  {
    "question": "Bir metindeki tüm harflerin büyük harfe dönüştürülmesi için C dilinde hangi yöntemleri kullanabilirim?",
    "answer": "Bütün harfleri büyük harfe dönüştürmek için 'toupper' fonksiyonunu kullanabiliriz. Bu fonksiyon, bir karakteri alır ve eğer bu karakter bir küçük harf ise büyük harfine dönüştürür. Öncelikle metni döngü ile gezecek ve her karakteri 'toupper' fonksiyonu ile kontrol edeceğiz. Örnek olarak aşağıdaki gibi bir kod yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid toUpperCase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]); // Her karakteri büyük harfe dönüştür\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir metin giriniz: \");\n    fgets(str, sizeof(str), stdin);\n    toUpperCase(str);\n    printf(\"Büyük harflerle: %s\", str);\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir metin alır ve tüm harflerini büyük harfe dönüştürerek sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:25.440182"
  },
  {
    "question": "C dilinde bir string içinde belirli bir karakterin kaç kez tekrar ettiğini nasıl bulabilirim?",
    "answer": "C dilinde bir string içinde belirli bir karakterin kaç kez tekrar ettiğini bulmak için önce string'in her bir karakterini döngü ile kontrol etmemiz gerekiyor. Örnek bir kod parçası ile açıklayalım:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"programlama\";\n    char ch = 'a';\n    int count = 0;\n\n    // String'in uzunluğunu bul\n    int length = strlen(str);\n\n    // Her bir karakteri kontrol et\n    for (int i = 0; i < length; i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n\n    printf(\"'%c' karakteri %d kez tekrar ediyor.\\n\", ch, count);\n    return 0;\n}\n```\n\nYukarıdaki kodda, 'programlama' isimli bir string tanımlıyoruz ve içinde 'a' karakterinin kaç kez bulunduğunu kontrol ediyoruz. 'strlen' fonksiyonu ile string'in uzunluğunu alıp, bir döngü içinde her bir karakteri kontrol ederek, 'a' karakteri ile eşleşenlerin sayısını 'count' değişkeninde topluyoruz. Sonuç olarak, karakterin tekrar sayısını ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:37.256636"
  },
  {
    "question": "C dilinde bir string içerisindeki tüm boşluk karakterlerini nasıl kaldırabilirim?",
    "answer": "C dilinde bir string içerisindeki tüm boşluk karakterlerini kaldırmak için, yeni bir string oluşturarak boşluk olmayan karakterleri bu yeni string'e kopyalamamız gerekiyor. Aşağıda bu işlemi gerçekleştiren bir örnek kod bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"C dilinde boşlukları kaldırmak\";\n    char result[100]; // Sonucu tutacak yeni string\n    int j = 0;\n\n    // Her bir karakteri kontrol et\n    for (int i = 0; str[i] != '\\0'; i++) {\n        // Eğer karakter boşluk değilse, yeni string'e kopyala\n        if (str[i] != ' ') {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0'; // Yeni string'in sonuna null karakter ekle\n\n    printf(\"Sonuç: '%s'\\n\", result);\n    return 0;\n}\n```\n\nBu kodda, \"C dilinde boşlukları kaldırmak\" string'ini alıyoruz ve içindeki tüm boşlukları kaldırıyoruz. 'result' isimli yeni bir string oluşturuyoruz ve orijinal string'in her bir karakterini kontrol ederek boşluk olmayan karakterleri bu yeni string'e kopyalıyoruz. Son olarak, yeni string'i ekrana yazdırıyoruz. Bu yöntemle orijinal string'deki tüm boşluk karakterlerini kaldırmış oluyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:37.256700"
  },
  {
    "question": "Kullanıcının girdiği bir metni tersten yazdıran bir C fonksiyonu nasıl yazılır?",
    "answer": "Aşağıda, kullanıcının girdiği bir metni tersten yazdıran bir C fonksiyonu örneği verilmiştir. Bu fonksiyon, bir string alır ve tersten yazdırmak için bir döngü kullanır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid terstenYazdir(char *metin) {\n    int uzunluk = strlen(metin);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(metin[i]);\n    }\n    putchar('\\n'); // Yeni satır eklemek için\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin); // Kullanıcıdan metin al\n    terstenYazdir(metin);\n    return 0;\n}\n```\nBu kodda, önce `fgets` fonksiyonu ile kullanıcıdan bir metin alıyoruz. Ardından, `terstenYazdir` fonksiyonu çağrılarak metin tersten yazdırılıyor. `strlen` fonksiyonu, metnin uzunluğunu hesaplamak için kullanılıyor.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:47.273119"
  },
  {
    "question": "Verilen bir kelimenin içinde belirli bir karakterin kaç defa geçtiğini sayan bir C fonksiyonu yazınız.",
    "answer": "Aşağıda, verilen bir string içindeki belirli bir karakterin kaç kez bulunduğunu sayan bir C fonksiyonu örneği bulunmaktadır. Bu fonksiyon, metni ve sayılacak karakteri parametre olarak alır ve sonucu döndürür.\n\n```c\n#include <stdio.h>\n\nint karakterSay(char *metin, char karakter) {\n    int sayac = 0;\n    for (int i = 0; metin[i] != '\\0'; i++) {\n        if (metin[i] == karakter) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char metin[100];\n    char karakter;\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"Hangi karakteri saymak istersiniz? \");\n    scanf(\"%c\", &karakter);\n    int sonuc = karakterSay(metin, karakter);\n    printf(\"Karakter '%%c' metinde %d defa bulunuyor.\\n\", karakter, sonuc);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan bir metin ve sayılacak bir karakter alınıyor. Ardından, `karakterSay` fonksiyonu çağrılarak, karakterin metindeki sayısı hesaplanıyor. `metin[i] != '\\0'` koşulu, metnin sonuna kadar döngünün devam etmesini sağlıyor.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:48:47.273166"
  },
  {
    "question": "Bir string içerisindeki tüm boşlukları kaldırarak yeni bir string döndüren bir fonksiyon nasıl yazılır?",
    "answer": "C dilinde bir string içerisindeki tüm boşlukları kaldırmak için bir fonksiyon yazabiliriz. Bu fonksiyon, iki pointer kullanarak mevcut stringi tarayacak ve boşluk olmayan karakterleri yeni bir stringe kopyalayacak. Aşağıda bu fonksiyonun bir örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid remove_spaces(const char *input, char *output) {\n    int j = 0;\n    for (int i = 0; input[i] != '\\0'; i++) {\n        if (input[i] != ' ') {\n            output[j++] = input[i];\n        }\n    }\n    output[j] = '\\0'; // Yeni stringi sonlandır\n}\n\nint main() {\n    const char *str = \"Merhaba Dünya! C dilinde programlama.\";\n    char result[100]; // Sonuç için yeterli boyutta bir dizi\n    remove_spaces(str, result);\n    printf(\"Boşluksuz string: %s\\n\", result);\n    return 0;\n}\n```\nBu kodda, `remove_spaces` fonksiyonu, verilen `input` stringindeki boşlukları kaldırır ve sonucu `output` stringine yazar. `main` fonksiyonunda ise örnek bir string kullanılarak fonksiyon çağrılır ve sonuç ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:06.324947"
  },
  {
    "question": "Bir stringin palindrom olup olmadığını kontrol eden bir fonksiyon nasıl yazılır?",
    "answer": "Palindrom, tersten okunuşunun da aynı olduğu kelimelerdir. Örneğin, 'radar' bir palindromdur. C dilinde bir stringin palindrom olup olmadığını kontrol etmek için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint is_palindrome(const char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0; // Palindrom değil\n        }\n    }\n    return 1; // Palindrom\n}\n\nint main() {\n    const char *word = \"radar\";\n    if (is_palindrome(word)) {\n        printf(\"'%s' bir palindromdur.\\n\", word);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", word);\n    }\n    return 0;\n}\n```\nBu örnekte, `is_palindrome` fonksiyonu verilen stringin palindrom olup olmadığını kontrol eder. Fonksiyon, stringin uzunluğunun yarısı kadar döngü çalıştırarak her iki uçtaki karakterleri karşılaştırır. Eğer herhangi bir eşleşme yoksa `0` döner; aksi takdirde `1` döner.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:06.325021"
  },
  {
    "question": "C dilinde verilen bir string'in içindeki tüm sesli harfleri sayan bir fonksiyon yazın.",
    "answer": "Aşağıda, verilen bir string'in içindeki sesli harfleri sayan bir fonksiyonun implementasyonu yer almaktadır. Sesli harfler 'a', 'e', 'i', 'o', 'u' ve büyük harfleri olan 'A', 'E', 'I', 'O', 'U' olarak kabul edilmektedir. Bu fonksiyon, string'i karakter karakter dolaşır ve sesli harfleri sayar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint sesliHarfSay(const char *str) {\n    int sayac = 0;\n    const char *sesli = \"aeiouAEIOU\";\n    for(int i = 0; i < strlen(str); i++) {\n        if(strchr(sesli, str[i])) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    const char *metin = \"Merhaba Dünya!\";\n    int sonuc = sesliHarfSay(metin);\n    printf(\"Sesli harf sayısı: %d\\n\", sonuc);\n    return 0;\n}\n```\n\nBu kod, \"Merhaba Dünya!\" string'indeki sesli harflerin sayısını hesaplar ve sonucu ekrana yazdırır. `strchr` fonksiyonu, belirtilen karakterin string içinde olup olmadığını kontrol etmek için kullanılır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:19.228681"
  },
  {
    "question": "C dilinde iki string'in kesişim kümesini bulan bir fonksiyon yazın. Kesinlikle ortak karakterler içermelidir.",
    "answer": "Aşağıda, iki string'in kesişim kümesini bulan bir fonksiyonun implementasyonu bulunmaktadır. Bu fonksiyon, iki string'i karşılaştırarak ortak karakterleri bulur ve bu karakterleri yeni bir string olarak döner. Ortak karakterlerin tekrarı yok sayılacaktır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nchar* kesisimKumesi(const char *str1, const char *str2) {\n    static char sonuc[256]; // Sonuç string'i için sabit boyut\n    int index = 0;\n    for(int i = 0; i < strlen(str1); i++) {\n        if(strchr(str2, str1[i]) && !strchr(sonuc, str1[i])) {\n            sonuc[index++] = str1[i];\n        }\n    }\n    sonuc[index] = '\\0'; // Sonlandırıcı ekle\n    return sonuc;\n}\n\nint main() {\n    const char *str1 = \"abcdefg\";\n    const char *str2 = \"cdefghij\";\n    char *sonuc = kesisimKumesi(str1, str2);\n    printf(\"Kesişim kümesi: %s\\n\", sonuc);\n    return 0;\n}\n```\n\nBu kodda, `abcdefg` ve `cdefghij` string'leri arasındaki ortak karakterler bulunur. `strchr` fonksiyonu, bir karakterin ikinci string içinde olup olmadığını kontrol eder ve `!strchr(sonuc, str1[i])` ile sonuç string'inde daha önce eklenip eklenmediğini kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:19.228729"
  },
  {
    "question": "Bir dizi içinde, verilen bir karakter dizisinin geçip geçmediğini kontrol eden bir fonksiyon yazdım. Ancak, mevcut implementasyonum çok sayıda döngü içeriyor ve yeterince optimize edilmiş değil. Bunu nasıl iyileştirebilirim?",
    "answer": "Mevcut implementasyonunuzda, dizinin her bir karakterini kontrol etmek için birden fazla döngü kullanıyorsanız, bu durumu optimize etmek için strncmp gibi standart kütüphane fonksiyonlarını kullanabilirsiniz. Örnek bir fonksiyon şöyle olabilir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint contains_substring(const char *str, const char *substr) {\n    return strstr(str, substr) != NULL;\n}\n\nint main() {\n    const char *haystack = \"Merhaba Dünya\";\n    const char *needle = \"Dünya\";\n    if (contains_substring(haystack, needle)) {\n        printf(\"Dizi, alt dizeyi içeriyor.\");\n    } else {\n        printf(\"Dizi, alt dizeyi içermiyor.\");\n    }\n    return 0;\n}\n```\nBurada `strstr` fonksiyonu, verilen dizinin içinde aranan alt dizinin varlığını kontrol eder. Bu, daha okunabilir ve performanslı bir çözüm sunar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:29.757440"
  },
  {
    "question": "Bir metin dosyasını okuyup, içindeki tüm boşlukları kaldıran bir fonksiyon yazdım. Ancak, bellekte fazladan yer kullanımına neden olan geçici bir dizi oluşturuyorum. Bu durumu nasıl iyileştirebilirim?",
    "answer": "Bellek kullanımını optimize etmek için, geçici bir dizi oluşturmadan doğrudan bellek alanında işlemleri gerçekleştirebilirsiniz. Örneğin, mevcut dizi üzerinde işlemler yaparak bellek kopyalamadan kaçınabilirsiniz. Aşağıda bu yaklaşımı göstermektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid remove_spaces(char *str) {\n    char *dst = str;\n    while (*str) {\n        if (*str != ' ') {\n            *dst++ = *str;\n        }\n        str++;\n    }\n    *dst = '\\0';  // Null terminator ekle\n}\n\nint main() {\n    char str[] = \"Merhaba   Dünya\";\n    remove_spaces(str);\n    printf(\"Sonuç: %s\\n\", str);\n    return 0;\n}\n```\nBu fonksiyon, verilen dizinin her bir karakterini kontrol eder ve boş olmayan karakterleri doğrudan aynı dizi içinde saklar. Bu sayede bellek kullanımını azaltır ve daha etkin bir çözüm sunar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:29.757509"
  },
  {
    "question": "Bir dizi içindeki stringleri birleştirirken, bellek yönetimini optimize etmek için hangi yöntemleri kullanabiliriz? Örnek bir kod ile gösteriniz.",
    "answer": "Stringleri birleştirirken, her bir birleştirme işleminde yeni bir string oluşturmak yerine mevcut bellek alanını kullanmak önemlidir. C dilinde, `strcat` fonksiyonu kullanarak dikkatli bir şekilde birleştirme yapabiliriz. Aşağıdaki örnekte, dizi içindeki stringleri birleştirirken belleği optimize etmek için gereken adımları görebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LENGTH 100\n\nvoid concatenateStrings(char result[], char *strings[], int count) {\n    result[0] = '\\0'; // Başlangıçta boş string\n    for (int i = 0; i < count; i++) {\n        strcat(result, strings[i]);\n        if (i < count - 1) {\n            strcat(result, \" \"); // Stringler arasında boşluk ekleniyor\n        }\n    }\n}\n\nint main() {\n    char *words[] = {\"Merhaba\", \"Dünya\", \"Nasıl\", \"Gidiyor?\"};\n    char result[MAX_LENGTH];\n    concatenateStrings(result, words, 4);\n    printf(\"Sonuç: %s\\n\", result);\n    return 0;\n}\n```\nBu kodda, `strcat` fonksiyonu ile her seferinde mevcut stringin sonuna yeni bir string ekleniyor. Ancak bu, `result` dizisinin yeterli uzunlukta olduğundan emin olunduğunda kullanılmalıdır. Ayrıca, bu yöntem bellek kullanımı açısından etkilidir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:44.985677"
  },
  {
    "question": "Bir stringin içindeki tüm boşlukları kaldırmak istiyoruz. Bunun için daha verimli bir yöntem öneriniz ve örnek bir uygulama gösteriniz.",
    "answer": "Boşlukları kaldırmak için mevcut string üzerinde iterasyon yaparak yeni bir string oluşturmak daha verimli bir yaklaşım olacaktır. Bu sayede her bir karakteri kontrol edebiliriz ve boşluk olmayan karakterleri yeni bir diziye kopyalayabiliriz. Aşağıda bu yöntemi gösteren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpaces(const char *input, char *output) {\n    while (*input) {\n        if (*input != ' ') {\n            *output++ = *input; // Boşluk olmayan karakteri kopyala\n        }\n        input++;\n    }\n    *output = '\\0'; // Sonlandırıcı ekle\n}\n\nint main() {\n    const char original[] = \"C dilinde stringler ile çalışmak çok eğlenceli!\";\n    char result[100];\n    removeSpaces(original, result);\n    printf(\"Sonuç: %s\\n\", result);\n    return 0;\n}\n```\nBu örnekte, `removeSpaces` fonksiyonu, girdi stringini karakter karakter tarar ve boşluk olmayan karakterleri `output` dizisine kopyalar. Bu yöntem, bellek kopyalama işlemlerini minimize ederek daha verimli bir çözüm sunmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-05-31T16:49:44.985729"
  },
  {
    "question": "Kullanıcının girdiği bir isim ve soyismi birleştirip ekrana yazdıran bir C programının eksik kısmını tamamlayın. Kullanıcıdan isim ve soyisim girdisi alın. İsim ve soyisimi birleştirip bir karakter dizisine atayın ve ekrana yazdırın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[50];\n    char soyisim[50];\n    char tamIsim[100];\n\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    printf(\"Soyisminizi girin: \");\n    fgets(soyisim, sizeof(soyisim), stdin);\n\n    // Soyisimdeki yeni satırı kaldırmak için\n    soyisim[strcspn(soyisim, \"\\n\")] = 0;\n\n    // İsim ve soyisimi birleştiriyoruz\n    strcpy(tamIsim, isim);\n    strcat(tamIsim, soyisim);\n\n    printf(\"Tam isminiz: %s\", tamIsim);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan isim ve soyisim alıyoruz. 'fgets' fonksiyonu ile girdi alırken yeni satır karakterini de almış oluyoruz, bu yüzden soyisimdeki yeni satırı kaldırıyoruz. Sonrasında 'strcpy' ile isim dizisini 'tamIsim' dizisine kopyalıyoruz ve 'strcat' ile soyismi ekliyoruz. Son olarak birleştirilmiş ismi ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:49:57.939434"
  },
  {
    "question": "Bir kullanıcıdan bir cümle alıp, cümlede geçen kelime sayısını hesaplayan C programının eksik yerlerini tamamlayın. Cümledeki boşlukları kullanarak kelimeleri sayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[256];\n    int kelimeSayisi = 0;\n    int i;\n\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n\n    // Cümledeki kelime sayısını hesaplama\n    for (i = 0; i < strlen(cumle); i++) {\n        if (cumle[i] == ' ' || cumle[i] == '\\n') {\n            kelimeSayisi++;\n        }\n    }\n\n    // Son kelimeyi de saymak için\n    kelimeSayisi++;\n\n    printf(\"Cümledeki kelime sayısı: %d\\n\", kelimeSayisi);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan bir cümle alıyoruz. Cümlenin uzunluğunu 'strlen' ile öğrenip, boşluk veya yeni satır karakteri gördüğümüz her seferde kelime sayısını artırıyoruz. En son olarak, son kelimeyi de sayabilmek için 'kelimeSayisi' değişkenine bir ekleme yapıyoruz ve sonucu ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:49:57.939519"
  },
  {
    "question": "Kullanıcının girdiği bir metindeki tüm küçük harfleri büyük harfe dönüştüren bir C programının eksik kodunu tamamlayın. Aşağıdaki kodda eksik olan bölümü yazın:",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir metin girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    for(int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]); // burada küçük harfleri büyük harfe çeviriyoruz\n    }\n\n    printf(\"Büyük harfli metin: %s\", str);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir metin alır ve her karakteri kontrol ederek küçük harfleri büyük harfe dönüştürür. 'toupper' fonksiyonu, her karakteri büyük harfe çevirmek için kullanılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:06.447691"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin palindrom olup olmadığını kontrol eden bir C programının eksik kodunu tamamlayın. Aşağıdaki kodda eksik olan bölümü yazın:",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir kelime girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    int len = strlen(str);\n    int isPalindrome = 1; // başlangıçta palindrom olarak varsayıyoruz\n\n    for(int i = 0; i < len / 2; i++) {\n        if(str[i] != str[len - i - 2]) { // son karakterin '\n' olduğunu unutmamalıyız\n            isPalindrome = 0; // eğer eşleşmiyorsa palindrom değil\n            break;\n        }\n    }\n\n    if(isPalindrome)\n        printf(\"%s palindromdur.\\n\", str);\n    else\n        printf(\"%s palindrom değildir.\\n\", str);\n    return 0;\n}\n\n// Açıklama: Bu program, bir kelime alır ve kelimenin palindrom olup olmadığını kontrol eder. Palindrom, tersten okunduğunda da aynı olan kelimelerdir. Karakterler arasında '\n' karakterini göz önünde bulundurmak önemlidir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:06.447746"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak, verilen bir karakter dizisindeki benzersiz karakterlerin sayısını bulan bir fonksiyon yazın. Kodda eksik kısımlar bulunmaktadır.\n\n#include <stdio.h>\n#include <string.h>\n\nint benzersizKarakterSayisi(char *dizi) {\n    int sayac[256] = {0};\n    int benzersizSayisi = 0;\n    // Burada eksik kısımları tamamlayın\n\n    return benzersizSayisi;\n}\n\nint main() {\n    char dizi[] = \"programlama\";\n    int sonuc = benzersizKarakterSayisi(dizi);\n    printf(\"Benzersiz karakter sayisi: %d\\n\", sonuc);\n    return 0;\n}",
    "answer": "Verilen C kodunu tamamlamak için, her karakterin sayac dizisinde sayısını kontrol edip, eğer bu sayı 0 ise benzersiz sayısını artırmalıyız. Aşağıda eksik kısımlar tamamlanmış hali bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint benzersizKarakterSayisi(char *dizi) {\n    int sayac[256] = {0};\n    int benzersizSayisi = 0;\n    for (int i = 0; i < strlen(dizi); i++) {\n        sayac[(int)dizi[i]]++;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (sayac[i] > 0) {\n            benzersizSayisi++;\n        }\n    }\n    return benzersizSayisi;\n}\n\nint main() {\n    char dizi[] = \"programlama\";\n    int sonuc = benzersizKarakterSayisi(dizi);\n    printf(\"Benzersiz karakter sayisi: %d\\n\", sonuc);\n    return 0;\n}\n```\n\nBu kodda `benzersizKarakterSayisi` fonksiyonu, verilen dizi içindeki karakterleri kontrol eder ve `sayac` dizisini kullanarak kaç benzersiz karakter olduğunu hesaplar. İlk döngü dizi içindeki her karakterin sayısını artırırken, ikinci döngü ise bu sayılar üzerinden benzersiz karakterlerin sayısını bulur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:21.343849"
  },
  {
    "question": "Aşağıdaki karakter dizisinin içindeki boşlukları kaldıran bir fonksiyon yazın. Eksik kısımlar aşağıdaki gibi verilmiştir.\n\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *dizi) {\n    // Burada eksik kısımları tamamlayın\n}\n\nint main() {\n    char dizi[] = \" C programlama dili \";\n    boslukKaldir(dizi);\n    printf(\"Sonuç: '%s'\\n\", dizi);\n    return 0;\n}",
    "answer": "Boşlukları kaldırmak için, diziyi baştan sona iterken boşluk olmayan karakterleri yeni bir konuma atmamız gerekiyor. Eksik kısımlar aşağıdaki gibi tamamlanabilir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *dizi) {\n    int i, j = 0;\n    for (i = 0; dizi[i]; i++) {\n        if (dizi[i] != ' ') {\n            dizi[j++] = dizi[i];\n        }\n    }\n    dizi[j] = '\\0'; // Dizinin sonuna null karakter ekle\n}\n\nint main() {\n    char dizi[] = \" C programlama dili \";\n    boslukKaldir(dizi);\n    printf(\"Sonuç: '%s'\\n\", dizi);\n    return 0;\n}\n```\n\nBu kodda `boslukKaldir` fonksiyonu, verilen diziyi kontrol eder ve boş olmayan karakterleri dizinin başına yazarken, sonunda null karakter ekleyerek diziyi düzgün bir şekilde sonlandırır. Böylece, baştaki ve sondaki boşluklar ile aradaki boşluklar kaldırılmış olur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:21.344044"
  },
  {
    "question": "Aşağıdaki C kodunda, bir karakter dizisinin uzunluğunu hesaplamak için kullanılan fonksiyonda bir hata var. Hatanın nedenini bulup düzeltin.\n\n```c\n#include <stdio.h>\n\nint string_length(char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    char myString[] = 'Hello, World!';\n    printf('Length of myString: %d', string_length(myString));\n    return 0;\n}\n```",
    "answer": "Bu kodda, 'myString' karakter dizisi tanımlanırken çift tırnak ('') yerine tek tırnak ('') kullanılmış. Tek tırnak bir karakteri ifade etmek için kullanılırken, çift tırnak bir dizi oluşturmak için kullanılır. Düzeltmek için 'myString' dizisini şu şekilde tanımlamalıyız:\n\n```c\nchar myString[] = \"Hello, World!\";\n``` \nBunu yaptıktan sonra, program doğru bir şekilde çalışacak ve dizinin uzunluğunu hesaplayacaktır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:30.871356"
  },
  {
    "question": "Aşağıdaki C kodunda, bir karakter dizisinin tüm karakterlerini küçük harfe dönüştüren bir fonksiyonda hata var. Hatanın nedenini bulup düzeltin.\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid to_lowercase(char *str) {\n    for (int i = 0; i <= str[i]; i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\nint main() {\n    char myString[] = \"HELLO, WORLD!\";\n    to_lowercase(myString);\n    printf('%s', myString);\n    return 0;\n}\n```",
    "answer": "Bu kodda, döngü koşulunda 'i <= str[i]' ifadesi hatalı. Burada, 'i' dizinin uzunluğu ile karşılaştırılmamalıdır. Bunun yerine, str[i] karakteri null karakter ('\\0') olana kadar döngü devam etmelidir. Düzeltmek için döngü koşulunu şu şekilde değiştirmeliyiz:\n\n```c\nfor (int i = 0; str[i] != '\\0'; i++) {\n``` \nBu düzeltme ile program, 'myString' dizisindeki tüm harfleri küçük harfe dönüştürecek ve doğru bir çıktı verecektir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:30.871489"
  },
  {
    "question": "C dilinde bir karakter dizisi ile çalışırken, 'strcpy' fonksiyonunu kullanarak bir diziyi diğerine kopyalarken programım beklenmedik bir şekilde çöküyor. Kodu nasıl düzeltebilirim?",
    "answer": "Bu tür bir sorun genellikle hedef dizinin yeterli bellek alanına sahip olmamasından kaynaklanır. Aşağıda bir örnek ile durumu açıklayalım:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char source[] = \"Bu bir test dizisidir.\";\n    char dest[10]; // Yetersiz bellek alanı\n\n    strcpy(dest, source); // Burada çökme oluşabilir\n    printf(\"Kopyalanan: %s\\n\", dest);\n    return 0;\n}\n```\n\nYukarıdaki kodda, 'dest' dizisi sadece 10 karakter kapasitesine sahip ama 'source' dizisi 24 karakter uzunluğunda. Bu nedenle 'strcpy' fonksiyonu hedef dizinin sınırlarını aşmaya çalışacak ve bellek hatasına sebep olacaktır. Bunu düzeltmek için 'dest' dizisinin boyutunu artırmalısınız:\n\n```c\nchar dest[50]; // Yeterli bellek alanı\n```",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:57.161207"
  },
  {
    "question": "C dilinde bir karakter dizisinin içinde belirli bir karakterin sayısını bulmaya çalışıyorum. Ancak fonksiyonum doğru sonuç vermiyor. Kodumda hangi hatalar olabilir?",
    "answer": "Bu tür bir hata, dizinin sonunu kontrol etmemek veya döngü değişkeninin yanlış kullanılmasından kaynaklanabilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint karakterSayisi(char *dizi, char karakter) {\n    int sayac = 0;\n    while (*dizi != '\\0') { // Dizi sonunu kontrol et\n        if (*dizi == karakter) {\n            sayac++;\n        }\n        dizi++; // Dizi elemanlarını kontrol et\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dünya\";\n    char karakter = 'a';\n    int sonuc = karakterSayisi(dizi, karakter);\n    printf(\"Karakter '%c' sayısı: %d\\n\", karakter, sonuc);\n    return 0;\n}\n```\n\nEğer döngünüz 'while' yerine 'for' ile yazılmışsa veya 'dizi++' kısmı eklenmemişse, kontrol edilen elemanlar atlanabilir. Yukarıdaki kodda doğru bir şekilde dizinin sonuna kadar gidilip, her eleman kontrol ediliyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:50:57.161312"
  },
  {
    "question": "Bir kullanıcıdan alınan metni tersine çevirmek için nasıl bir program yazabilirim?",
    "answer": "C dilinde bir karakter dizisini tersine çevirmek için bir döngü kullanarak metni ters sırada yazdırabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char metin[100];\n    printf(\"Lütfen bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin); // Kullanıcıdan metin alma\n    int uzunluk = strlen(metin);\n\n    printf(\"Ters metin: \");\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(metin[i]); // Ters sırada karakter yazdırma\n    }\n    return 0;\n}\n```\nBu program, kullanıcıdan bir metin alır ve ardından metni ters sırada ekrana yazdırır. Örneğin, \"Merhaba\" girildiğinde çıktı \"abahraM\" olacaktır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:08.123499"
  },
  {
    "question": "Bir karakter dizisindeki belirli bir karakterin kaç kez tekrar ettiğini nasıl bulabilirim?",
    "answer": "Belirli bir karakterin bir dizide kaç kez geçtiğini saymak için döngü ve koşul ifadeleri kullanabiliriz. Aşağıda bir örnek bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char metin[100];\n    char karakter;\n    int sayac = 0;\n\n    printf(\"Lütfen bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin); // Kullanıcıdan metin alma\n    printf(\"Hangi karakterin sayısını bulmak istersiniz? \");\n    scanf(\"%c\", &karakter); // Kullanıcıdan karakter alma\n\n    for (int i = 0; i < strlen(metin); i++) {\n        if (metin[i] == karakter) {\n            sayac++; // Eğer karakter eşleşirse sayacı artır\n        }\n    }\n\n    printf(\"'%c' karakteri metinde %d kez geçiyor.\\n\", karakter, sayac);\n    return 0;\n}\n```\nBu program, kullanıcıdan bir metin ve bir karakter alır ve ardından bu karakterin metinde kaç kez geçtiğini sayar. Örneğin, \"merhaba\" metni için 'a' karakterinin sayısını sorduğumuzda sonuç 2 olacaktır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:08.123562"
  },
  {
    "question": "C dilinde bir karakter dizisinde geçerli bir e-posta adresinin olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir e-posta adresinin geçerliliğini kontrol etmek için belirli kuralları izlemeliyiz. Genelde bir e-posta adresi '@' sembolü ve ardından '.' (nokta) içermelidir. Aşağıdaki C kodu bu kontrolü yapmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint isValidEmail(const char* email) {\n    // '@' ve '.' karakterlerinin dizideki indekslerini bulma\n    char* atSign = strchr(email, '@');\n    char* dotSign = strrchr(email, '.');\n\n    // '@' ve '.' var mı kontrol et\n    if (atSign == NULL || dotSign == NULL) return 0;\n\n    // '@' işareti, '.' işaretinden önce mi kontrol et\n    if (atSign > dotSign) return 0;\n\n    // E-posta geçerli\n    return 1;\n}\n\nint main() {\n    const char* email = \"example@domain.com\";\n    if (isValidEmail(email)) {\n        printf(\"Geçerli e-posta: %s\\n\", email);\n    } else {\n        printf(\"Geçersiz e-posta: %s\\n\", email);\n    }\n    return 0;\n}\n```\nBu kodda `strchr` ve `strrchr` fonksiyonlarını kullanarak '@' ve '.' karakterlerinin yerini buluyoruz. Eğer '@' işareti '.' işaretinden sonra geliyorsa veya e-posta adresinde bu karakterler yoksa, adres geçersiz olarak kabul ediliyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:20.183593"
  },
  {
    "question": "C dilinde bir karakter dizisinin uzunluğunu kendi yazdığım bir fonksiyonla nasıl bulabilirim?",
    "answer": "C dilinde dizilerin uzunluğunu bulmak için `strlen` fonksiyonu sıkça kullanılır. Ancak kendi fonksiyonumuzu yazarak bunu gerçekleştirebiliriz. Aşağıda bir karakter dizisinin uzunluğunu hesaplayan bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint myStrLen(const char* str) {\n    int length = 0;\n    while (*str != '\\0') { // Null terminatörüne kadar git\n        length++;\n        str++;\n    }\n    return length;\n}\n\nint main() {\n    const char* myString = \"Merhaba Dünya!\";\n    int length = myStrLen(myString);\n    printf(\"Dizinin uzunluğu: %d\\n\", length);\n    return 0;\n}\n```\nBu kodda `myStrLen` adlı bir fonksiyon tanımlıyoruz. Fonksiyon, karakter dizisini alır ve her karakteri sayar. Null terminatörüne (`\\0`) ulaştığında döngü sona erer ve toplam uzunluğu döner. Bu şekilde, karakter dizimizin uzunluğunu kendi fonksiyonumuz ile hesaplayabiliriz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:20.183636"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine çevirmek için hangi yöntemleri kullanabiliriz? Örnek bir kod ile gösteriniz.",
    "answer": "Bir karakter dizisini tersine çevirmek için birkaç farklı yöntem kullanabiliriz. En yaygın yöntemlerden biri döngü kullanarak son karakterden başlayarak başa doğru yeni bir dizi oluşturmaktır. Aşağıda bu yöntemi gösteren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *dizi) {\n    int uzunluk = strlen(dizi);\n    char temp;\n    for (int i = 0; i < uzunluk / 2; i++) {\n        // Değiştirilecek karakterlerin yerlerini değiştiriyoruz\n        temp = dizi[i];\n        dizi[i] = dizi[uzunluk - 1 - i];\n        dizi[uzunluk - 1 - i] = temp;\n    }\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dünya\";\n    printf(\"Orijinal Dizi: %s\\n\", dizi);\n    tersCevir(dizi);\n    printf(\"Tersine Çevrilmiş Dizi: %s\\n\", dizi);\n    return 0;\n}\n```\n\nBu kod, karakter dizisini tersine çevirmek için bir döngü kullanır. `strlen` fonksiyonu dizinin uzunluğunu bulur ve ardından döngü ile dizinin başından ve sonundan karakterler değiştirilerek ters bir dizi elde edilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:33.818041"
  },
  {
    "question": "Bir C programında, iki karakter dizisinin birbirine eşit olup olmadığını kontrol etmenin en verimli yolu nedir? Örnek veriniz.",
    "answer": "İki karakter dizisinin birbirine eşit olup olmadığını kontrol etmek için `strcmp` fonksiyonunu kullanmak en verimli yollardan biridir. `strcmp` fonksiyonu, iki diziyi karşılaştırır ve eğer diziler eşitse 0 değerini döner. Aşağıda bu işlemi gerçekleştiren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char dizi1[] = \"C Programlama\";\n    char dizi2[] = \"C Programlama\";\n\n    // İki diziyi karşılaştır\n    if (strcmp(dizi1, dizi2) == 0) {\n        printf(\"Diziler eşit.\\n\");\n    } else {\n        printf(\"Diziler eşit değil.\\n\");\n    }\n    return 0;\n}\n```\n\nBu kod, `strcmp` fonksiyonu ile iki diziyi karşılaştırır. Eğer diziler eşitse, program \"Diziler eşit.\" mesajını yazdırır; aksi takdirde \"Diziler eşit değil.\" mesajını verir. `strcmp` fonksiyonu, karşılaştırma işlemini lexikografik sıraya göre yapar, yani dizilerdeki karakterlerin ASCII değerlerine göre karşılaştırma yapar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:33.818096"
  },
  {
    "question": "Bir karakter dizisinin uzunluğunu hesaplayan bir C fonksiyonu yazın.",
    "answer": "Aşağıda, bir karakter dizisinin uzunluğunu hesaplamak için kullanılan basit bir C fonksiyonu bulunmaktadır. Bu fonksiyon, karakter dizisinin sonundaki null karakterini (\\0) bulana kadar döngü devam eder ve her karakter için bir sayacı artırarak dizinin uzunluğunu hesaplar.\n\n```c\n#include <stdio.h>\n\nint string_length(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {  // Null karakterine kadar döngü devam eder.\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    const char *myString = \"Merhaba, Dünya!\";\n    int length = string_length(myString);\n    printf(\"Dizinin uzunluğu: %d\\n\", length);\n    return 0;\n}\n```\n\nBu kodu çalıştırdığınızda, 'Merhaba, Dünya!' dizisinin uzunluğu 15 olarak hesaplanacaktır. Fonksiyon, karakter dizisinin her bir karakterini kontrol ederek dizinin toplam uzunluğunu bulur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:46.697335"
  },
  {
    "question": "Verilen bir karakter dizisini tersten yazan bir C fonksiyonu yazın.",
    "answer": "Aşağıdaki örnekte, bir karakter dizisini tersten yazmak için basit bir C fonksiyonu bulunmaktadır. Bu fonksiyon, dizinin uzunluğunu bulduktan sonra, son karakterden başlayarak her bir karakteri yeni bir diziye atar ve tersten yazılmış diziyi oluşturur.\n\n```c\n#include <stdio.h>\n\nvoid reverse_string(const char *str, char *reversed) {\n    int length = 0;\n    while (str[length] != '\\0') {  // Uzunluğu bulmak için döngü\n        length++;\n    }\n    for (int i = 0; i < length; i++) {\n        reversed[i] = str[length - 1 - i];  // Ters yazma işlemi\n    }\n    reversed[length] = '\\0';  // Null karakterini ekle.\n}\n\nint main() {\n    const char *myString = \"Merhaba\";\n    char reversed[100];  // Yeterli alanı ayırın.\n    reverse_string(myString, reversed);\n    printf(\"Ters dizin: %s\\n\", reversed);\n    return 0;\n}\n```\n\nBu kod çalıştırıldığında, 'Merhaba' dizisi 'abahreM' olarak ters yazılır. Fonksiyon, ilk önce dizinin uzunluğunu bulur ve ardından tersine yazma işlemini gerçekleştirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:46.697373"
  },
  {
    "question": "Bir karakter dizisinde, verilen bir karakterin kaç kez tekrarlandığını bulan bir C fonksiyonu yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir karakter dizisinde belirli bir karakterin kaç kez tekrarlandığını sayan bir fonksiyon içermektedir:\n\n```c\n#include <stdio.h>\n\nint karakterSay(char *dizi, char karakter) {\n    int sayac = 0;\n    while (*dizi) {\n        if (*dizi == karakter) {\n            sayac++;\n        }\n        dizi++;\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"merhaba dünya\";\n    char karakter = 'a';\n    int sonuc = karakterSay(dizi, karakter);\n    printf(\"Karakter '%c' dizide %d kez bulunuyor.\\n\", karakter, sonuc);\n    return 0;\n}\n```\n\nBu kodda, `karakterSay` fonksiyonu bir karakter dizisi ve bir karakter alır. Dizi sonuna gelene kadar karakterleri kontrol eder ve verilen karakterin sayısını artırır. Sonuç olarak, bu fonksiyon verilen karakterin dizi içindeki tekrar sayısını döner. `main` fonksiyonu örnek bir diziyi ve aranan karakteri tanımlar ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:57.847196"
  },
  {
    "question": "Bir karakter dizisini tersine çeviren bir C fonksiyonu yazın. Bu fonksiyon, girdi olarak bir karakter dizisi almalı ve sonuç olarak ters çevrilmiş diziyi yazdırmalıdır.",
    "answer": "Aşağıdaki C kodu, verilen bir karakter dizisini tersine çeviren bir fonksiyon içermektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = dizi[i];\n        dizi[i] = dizi[uzunluk - i - 1];\n        dizi[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char dizi[] = \"merhaba\";\n    printf(\"Orijinal Dizi: %s\\n\", dizi);\n    tersCevir(dizi);\n    printf(\"Ters Dizi: %s\\n\", dizi);\n    return 0;\n}\n```\n\nBu kodda, `tersCevir` fonksiyonu bir karakter dizisini alıp onu tersine çeviriyor. Dizi uzunluğunu hesapladıktan sonra, dizinin ilk yarısını ve son yarısını değiştirerek ters çevirme işlemini gerçekleştirir. `main` fonksiyonu ise örnek bir dizi tanımlar, orijinal diziyi ekrana yazdırır ve ardından `tersCevir` fonksiyonunu çağırarak ters çevrilmiş diziyi gösterir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:51:57.847328"
  },
  {
    "question": "Bir karakter dizisinde yer alan kelimeleri ters sırayla yazdıran bir C programı nasıl yazılır?",
    "answer": "Bu işlemi gerçekleştirmek için önce dizideki kelimeleri ayırmamız gerekir. Her kelimeyi ters çevirmek için bir döngü kullanabiliriz. Aşağıda bu işlemi gerçekleştiren bir C programı örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseWord(char* start, char* end) {\n    char temp;\n    while (start < end) {\n        temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\nvoid reverseSentence(char* str) {\n    char* word_start = NULL;\n    char* temp = str;  // temp ve str aynı diziyi işaret eder.\n\n    // Tüm kelimeleri ters çevir\n    while (*temp) {\n        if ((word_start == NULL) && (*temp != ' ')) {\n            word_start = temp;\n        }\n        if (word_start && (*(temp + 1) == ' ' || *(temp + 1) == '\\0')) {\n            reverseWord(word_start, temp);\n            word_start = NULL;\n        }\n        temp++;\n    }\n    // Tüm cümleyi ters çevir\n    reverseWord(str, temp - 1);\n}\n\nint main() {\n    char str[] = \"Merhaba dünya bu bir denemedir\";\n    reverseSentence(str);\n    printf(\"Ters sırayla kelimeler: %s\\n\", str);\n    return 0;\n}\n```\nYukarıdaki kod, önce her kelimeyi ters çevirir, ardından tüm cümleyi ters çevirerek kelimelerin ters sırayla yazılmasını sağlar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:52:15.031628"
  },
  {
    "question": "Bir karakter dizisindeki tüm benzersiz karakterleri bulan bir C fonksiyonu nasıl yazılır?",
    "answer": "Benzersiz karakterleri bulmak için, karakterlerin görülme sıklığını takip edebileceğimiz bir dizi oluşturabiliriz. Aşağıda bu işlemi gerçekleştiren bir C programı örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid findUniqueCharacters(char* str) {\n    int charCount[256] = {0}; // ASCII karakter seti için yeterli\n    int length = strlen(str);\n\n    // Karakterlerin sayısını say\n    for (int i = 0; i < length; i++) {\n        charCount[(unsigned char)str[i]]++;\n    }\n\n    printf(\"Benzersiz karakterler: \");\n    for (int i = 0; i < length; i++) {\n        if (charCount[(unsigned char)str[i]] == 1) {\n            printf(\"%c \", str[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char str[] = \"programming\";\n    findUniqueCharacters(str);\n    return 0;\n}\n```\nBu kod, her karakterin ne kadar sık görüldüğünü takip eder ve sadece bir kez görülen karakterleri yazdırır. Örneğin, \"programming\" kelimesinde benzersiz karakterler 'p', 'o', 'a' ve 'n' olacaktır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:52:15.031671"
  },
  {
    "question": "Aşağıdaki C kodu, bir karakter dizisinin belirli bir karakterle kaç kez eşleştiğini sayıyor. Ancak, bu kodun verimliliğini artırmak için ne gibi iyileştirmeler yapabiliriz?",
    "answer": "Mevcut kod şu şekilde olabilir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint count_char(const char *str, char ch) {\n    int count = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"example string\";\n    char character = 'e';\n    int result = count_char(text, character);\n    printf(\"Character '%c' appears %d times.\\n\", character, result);\n    return 0;\n}\n```\n\nİyileştirme önerisi:\n1. `strlen` fonksiyonu her döngüde çağrıldığı için zaman karmaşıklığı O(n^2) olur. Bunun yerine, string uzunluğunu döngü başlamadan önce bir değişkene atayarak O(n) karmaşıklığına düşürebiliriz. \n2. `const char *str` parametresini daha anlamlı hale getirmek için `const char *` yerine `const char *const str` olarak değiştirmek daha iyi olabilir. Bu, string'in değiştirilmediğini belirtir ve kod okunabilirliğini artırır.\n\nGeliştirilmiş kod:\n```c\n#include <stdio.h>\n#include <string.h>\n\nint count_char(const char *const str, char ch) {\n    int count = 0;\n    size_t len = strlen(str);\n    for (size_t i = 0; i < len; i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:52:50.423924"
  },
  {
    "question": "Aşağıdaki kod parçası, bir karakter dizisini tersine çevirmektedir. Ancak, bellek verimliliği açısından bazı iyileştirmelere ihtiyacı var. Ne önerirsiniz?",
    "answer": "Kod şu şekildedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Hello World!\";\n    reverse_string(str);\n    printf(\"Reversed string: %s\\n\", str);\n    return 0;\n}\n```\n\nİyileştirme önerileri:\n1. Fonksiyon, dizi uzunluğunu her iterasyonda tekrar hesaplamak yerine, bu değeri bir değişkende saklayabiliriz. Bu, döngü içi hesaplamaları azaltır.\n2. `char temp` değişkenini bir işaretçi ile değiştirmek, bellek kullanımı açısından daha verimli olabilir, özellikle büyük dizilerde. Ancak, burada bellek üzerinde doğrudan işlem yapıldığı için bu öneri çok büyük bir fark yaratmayabilir.\n\nGeliştirilmiş kod:\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    size_t len = strlen(str);\n    for (size_t i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n    }\n}\n```\n\nBu değişiklikler, kodun okunabilirliğini artırırken performansı da iyileştirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-05-31T16:52:50.423997"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayın. Bir tam sayı değişkeninin adresini bir pointer değişkenine atayıp, bu pointer ile değişkenin değerini ekrana yazdırın.\n\n#include <stdio.h>\n\nint main() {\n    int sayi = 10;\n    int *pointer;\n\n    // Pointer'ı tamamlayın\n    pointer = ;\n\n    // Pointer ile değeri yazdırın\n    printf(\"Değer: %d\", );\n    return 0;\n}",
    "answer": "Kodun tamamlanmış hali aşağıdaki gibidir:\n\n#include <stdio.h>\n\nint main() {\n    int sayi = 10;\n    int *pointer;\n\n    // Pointer'ı tamamlayın\n    pointer = &sayi;\n\n    // Pointer ile değeri yazdırın\n    printf(\"Değer: %d\", *pointer);\n    return 0;\n}\n\nAçıklama: Bu kodda, 'sayi' isimli tam sayı değişkeninin adresi 'pointer' isimli pointer değişkenine atanıyor. '&' operatörü, bir değişkenin bellekteki adresini alır. Daha sonra '*pointer' ile bu adresteki değeri ekrana yazdırıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:55:36.787961"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayın. Kullanıcıdan bir dizi boyutu alıp, bu boyutta bir dizi oluşturun ve tüm elemanlarını kullanıcıdan alarak bir pointer kullanarak ekrana yazdırın.\n\n#include <stdio.h>\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    // Dizi oluşturma kodunu tamamlayın\n    int *dizi;\n    dizi = ;\n\n    // Dizi elemanlarını alıp yazdırma kodunu tamamlayın\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Eleman %d: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", );\n    }\n    return 0;\n}",
    "answer": "Kodun tamamlanmış hali aşağıdaki gibidir:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    // Dizi oluşturma kodunu tamamlayın\n    int *dizi;\n    dizi = (int *)malloc(boyut * sizeof(int));\n\n    // Dizi elemanlarını alıp yazdırma kodunu tamamlayın\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Eleman %d: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    free(dizi); // Bellek temizliği\n    return 0;\n}\n\nAçıklama: Bu kodda, kullanıcının girdiği boyutta bir dizi için bellekte yer açıyoruz. 'malloc' fonksiyonu bellekte dinamik olarak yer ayırıyor. Kullanıcıdan dizi elemanlarını alıyoruz ve ardından bu elemanları yazdırıyoruz. 'free(dizi)' ifadesi ile de ayrılan bellek temizleniyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:55:36.788146"
  },
  {
    "question": "Aşağıda verilen kodda bir dizi tanımlanmış. Bu dizinin elemanlarını bir fonksiyon kullanarak toplamak istiyoruz. Eksik kodu tamamlayın ve fonksiyonu yazın.",
    "answer": "#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for(int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int sonuc = toplam(sayilar, boyut);\n    printf(\"Dizinin toplamı: %d\\n\", sonuc);\n    return 0;\n}\n\n// Açıklama: 'toplam' fonksiyonu bir pointer alarak dizi elemanlarını toplar. Dizi elemanları için döngü kullanarak her bir elemanı toplar ve sonucu döndürür.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:55:44.682096"
  },
  {
    "question": "Aşağıdaki kodda bir stringin uzunluğunu hesaplamak için bir fonksiyon tanımlanmıştır. Ancak, fonksiyon eksik. Fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint stringUzunlugu(char *str) {\n    int uzunluk = 0;\n    while(*str != '\\0') {\n        uzunluk++;\n        str++;\n    }\n    return uzunluk;\n}\n\nint main() {\n    char metin[] = \"Merhaba Dünya\";\n    int uzunluk = stringUzunlugu(metin);\n    printf(\"String uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n\n// Açıklama: 'stringUzunlugu' fonksiyonu bir char pointer alır ve bu pointer'ı kullanarak stringin sonuna kadar gidip karakter sayısını hesaplar. Her karakter için döngüde pointer ilerletilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:55:44.682146"
  },
  {
    "question": "Aşağıdaki C kodunda verilen eksik kısmı tamamlayarak, bir dizi elemanlarının toplamını işaretçiler kullanarak hesaplayın. Kodun tamamını yazın ve açıklamalar ekleyin.\\n\\n#include <stdio.h>\\n\\nvoid diziToplam(int *dizi, int boyut) {\\n    int toplam = 0;\\n    // TODO: Burada toplamı hesaplamak için döngü yazın.\\n    printf(\"Dizinin toplamı: %d\\n\", toplam);\\n} \\n\\nint main() {\\n    int sayilar[] = {1, 2, 3, 4, 5};\\n    diziToplam(sayilar, 5);\\n    return 0;\\n}",
    "answer": "Aşağıdaki kod, verilen eksik kısmı tamamlayarak bir dizinin elemanlarının toplamını hesaplamaktadır.\\n\\n#include <stdio.h>\\n\\nvoid diziToplam(int *dizi, int boyut) {\\n    int toplam = 0;\\n    for (int i = 0; i < boyut; i++) { // Dizi boyutuna göre döngü başlatıyoruz.\\n        toplam += *(dizi + i); // Pointer aritmetiği kullanarak her elemanı topluyoruz.\\n    }\\n    printf(\"Dizinin toplamı: %d\\n\", toplam);\\n} \\n\\nint main() {\\n    int sayilar[] = {1, 2, 3, 4, 5};\\n    diziToplam(sayilar, 5);\\n    return 0;\\n}\\n\\nAçıklama: Burada, diziToplam fonksiyonu bir tam sayı dizisi ve boyutunu alır. Pointer aritmetiği sayesinde dizinin her elemanına erişiyoruz. 'dizi + i' ifadesi ile i. elemanın adresine ulaşıyoruz ve değeri toplam değişkenine ekliyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:56:11.269565"
  },
  {
    "question": "Verilen bir karakter dizisini işaretçiler kullanarak ters çeviren bir fonksiyon yazın. Aşağıdaki kodun eksik kısmını tamamlayın ve açıklamalar ekleyin.\\n\\n#include <stdio.h>\\n\\nvoid tersCevir(char *str) {\\n    // TODO: Ters çevirme işlemi için gerekli kodu buraya ekleyin.\\n} \\n\\nint main() {\\n    char metin[] = \"Merhaba Dünya\";\\n    tersCevir(metin);\\n    printf(\"Ters çevrilmiş metin: %s\\n\", metin);\\n    return 0;\\n}",
    "answer": "Aşağıdaki kod, verilen eksik kısmı tamamlayarak bir karakter dizisini tersiyle değiştirmektedir.\\n\\n#include <stdio.h>\\n\\nvoid tersCevir(char *str) {\\n    char *baslangic = str; // Başlangıç adresini kaydet.\\n    char *son = str;\\n    // Son karaktere kadar ilerle.\\n    while (*son != '\\0') {\\n        son++; // Son karaktere ulaşana kadar ilerliyoruz.\\n    }\\n    son--; // Son karakterin üzerine gelmemek için geri dönüyoruz.\\n    char temp;\\n    // Dizi tersine çevrilene kadar döngü.\\n    while (baslangic < son) {\\n        temp = *baslangic; // Başlangıçtaki değeri geçici değişkene al.\\n        *baslangic = *son; // Son elemanı başa koy.\\n        *son = temp; // Geçici değişkeni sona yerleştir.\\n        baslangic++; // Başlangıç işaretçisini ilerlet.\\n        son--; // Son işaretçisini geri al.\\n    }\\n} \\n\\nint main() {\\n    char metin[] = \"Merhaba Dünya\";\\n    tersCevir(metin);\\n    printf(\"Ters çevrilmiş metin: %s\\n\", metin);\\n    return 0;\\n}\\n\\nAçıklama: Bu fonksiyon, başlangıç ve son işaretçilerini kullanarak karakter dizisini tersine çevirmektedir. Başlangıç işaretçisi dizinin başında, son işaretçisi ise dizinin sonundadır. İki işaretçinin yerleri değiştirildikçe, dizi tersine çevrilmektedir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:56:11.269762"
  },
  {
    "question": "Aşağıdaki kodda bir işaretçi kullanarak bir tam sayıyı artırmaya çalıştım, ancak beklenmedik bir sonuç alıyorum. Hata nerede ve nasıl düzeltebilirim?\n\n```c\n#include <stdio.h>\n\nvoid increase(int *num) {\n    num++;\n    *num = *num + 1;\n}\n\nint main() {\n    int value = 5;\n    increase(&value);\n    printf(\"Değer: %d\\n\", value);\n    return 0;\n}\n```",
    "answer": "Kodda, `increase` fonksiyonu içindeki `num++` ifadesi işaretçiyi bir sonraki bellek adresine kaydırıyor. Bu, işaretçinin gösterdiği tam sayının adresini değiştiriyor ve bu nedenle `*num = *num + 1;` ifadesi beklenmeyen bir bellek alanına erişiyor. Doğru bir şekilde artırmak için `num++` ifadesini kaldırmalısınız. Ayrıca, `*num` ifadesiyle doğru bir şekilde değeri artırmak için sadece `*num += 1;` şeklinde değiştirin. İşte düzeltilmiş kod:\n\n```c\n#include <stdio.h>\n\nvoid increase(int *num) {\n    *num += 1;\n}\n\nint main() {\n    int value = 5;\n    increase(&value);\n    printf(\"Değer: %d\\n\", value);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:56:22.184131"
  },
  {
    "question": "Aşağıdaki kodda bir dizi ve işaretçi kullanarak dizinin elemanlarını yazdırmaya çalıştım ancak hiçbir şey görüntülenmiyor. Sorun nedir ve nasıl düzeltirim?\n\n```c\n#include <stdio.h>\n\nvoid printArray(int *arr, int size) {\n    for (int i = 0; i <= size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    printArray(numbers, 5);\n    return 0;\n}\n```",
    "answer": "Kodda, `printArray` fonksiyonundaki döngüde `i <= size` ifadesi hatalı. Bu ifade, dizinin boyutundan bir fazla olan bir indekse erişim sağlıyor. C dilinde dizinin indeksi, 0'dan başlayarak `size-1`'e kadar uzanır. Bu nedenle `i < size` şeklinde değiştirmeniz gerekiyor. İşte düzeltme ile birlikte kod:\n\n```c\n#include <stdio.h>\n\nvoid printArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    printArray(numbers, 5);\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:56:22.184333"
  },
  {
    "question": "Aşağıdaki C kodunda bir dizinin elemanlarını tersine çevirme işlemi yapılmak isteniyor. Ancak kod çalıştırıldığında beklenmeyen sonuçlar alınıyor. Hata nerede ve nasıl düzeltilir?",
    "answer": "Kod şu şekilde: \n```c\n#include <stdio.h>\n\nvoid reverseArray(int *arr, int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - i - 1];\n        arr[size - i - 1] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, size);\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu kod hatasız görünüyor. Ancak, eğer `reverseArray` fonksiyonuna geçilen `arr` dizisi bir işaretçi ile değil de doğrudan dizinin kendisi olarak geçilirse, beklenmedik sonuçlar alınabilir. Bunu düzeltmek için dizinin boyutunu doğru hesapladığınızdan emin olun ve dizinin işaretçisini geçirmek için `&arr[0]` kullanarak bunu düzeltin. Ancak burada `arr` dizisi zaten bir işaretçi olduğundan doğrudan geçiş de doğrudur.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:57:50.859521"
  },
  {
    "question": "Aşağıdaki C kodunda dinamik bellek tahsisi yapılarak bir dizi oluşturulmak isteniyor. Ancak programın sonunda bellek sızıntısı meydana geliyor. Hata nerede ve nasıl düzeltilir?",
    "answer": "Kod şu şekilde: \n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr;\n    int size;\n    printf(\"Dizinin boyutunu girin: \");\n    scanf(\"%d\", &size);\n    arr = (int *)malloc(size * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return 1;\n    }\n    for (int i = 0; i < size; i++) {\n        arr[i] = i + 1;\n    }\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    // Bellek serbest bırakılmıyor\n    return 0;\n}\n```\nBu kodda dinamik olarak tahsis edilen bellek serbest bırakılmadığı için bellek sızıntısı oluşuyor. Hatanın nedeni, `malloc` ile tahsis edilen belleğin kullanılmadıktan sonra `free(arr);` ile serbest bırakılmamasıdır. Düzeltmek için kodun sonuna `free(arr);` ifadesini ekleyerek bellek alanını serbest bırakmalısınız. Böylece bellek sızıntısını önlemiş olursunuz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:57:50.859582"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısı var. Hatanın nedeni nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid allocate_memory() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 10;\n    // Bellek sızıntısı burada oluşuyor, ptr serbest bırakılmıyor.\n}\n\nint main() {\n    allocate_memory();\n    return 0;\n}\n```",
    "answer": "Bu kodda bellek sızıntısının nedeni, malloc ile ayrılan belleğin serbest bırakılmamasıdır. allocate_memory fonksiyonu, dinamik bellek ayırıyor ancak ptr'nin adresini geri döndürmüyor veya serbest bırakmıyor. Bellek sızıntısını önlemek için, malloc'dan dönen pointer'i bir değişkende saklamalı ve kullanım tamamlandığında free() ile serbest bırakmalıyız. Düzeltme şöyle yapılabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* allocate_memory() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 10;\n    return ptr;  // Pointer'i geri döndürüyoruz.\n}\n\nint main() {\n    int *myPtr = allocate_memory();\n    printf(\"Değer: %d\\n\", *myPtr);\n    free(myPtr);  // Belleği serbest bırakıyoruz.\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:03.569250"
  },
  {
    "question": "Aşağıdaki kodda null pointer dereferencing hatası var. Hatanın nedeni nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_value(int *ptr) {\n    printf(\"Değer: %d\\n\", *ptr);  // Eğer ptr null ise burada hata alınır.\n}\n\nint main() {\n    int *value = NULL;\n    print_value(value);  // Null pointer gönderiliyor.\n    return 0;\n}\n```",
    "answer": "Bu kodda null pointer dereferencing hatası, print_value fonksiyonuna null bir pointer gönderildiğinde meydana gelir. Eğer ptr null ise dereferans yapmaya çalıştığımızda program çöker. Bu durumu önlemek için, fonksiyon içinde ptr'nin null olup olmadığını kontrol etmeliyiz. Düzeltme şöyle yapılabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_value(int *ptr) {\n    if (ptr == NULL) {\n        printf(\"Hata: Pointer null!\\n\");\n        return;\n    }\n    printf(\"Değer: %d\\n\", *ptr);\n}\n\nint main() {\n    int *value = NULL;\n    print_value(value);  // Null pointer gönderiliyor, ama kontrol var.\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:03.569363"
  },
  {
    "question": "C dilinde bir değişkenin adresini nasıl alabilirim ve bu adresi nasıl kullanabilirim?",
    "answer": "C dilinde bir değişkenin adresini almak için & (ampersand) operatörünü kullanırız. Örneğin, 'int sayi = 10;' ifadesi ile bir 'sayi' değişkeni tanımladıysak, bu değişkenin adresini almak için '&sayi' yazabiliriz. Bu adresi bir pointer değişkenine atayabiliriz. Örnek: \n\n```c\nint sayi = 10;\nint *pointer = &sayi; // sayi'nin adresini pointer'a atadık\nprintf(\"Sayı: %d\\n\", *pointer); // pointer ile sayi'ye erişim sağlıyoruz\n```\nBu kodda, '&sayi' ile 'sayi' değişkeninin adresini alıyoruz ve bu adresi 'pointer' isimli pointer değişkenine atıyoruz. 'printf' fonksiyonu içinde '*pointer' kullanarak, 'pointer' ile gösterilen adresteki değişkenin değerini alıyoruz ve ekrana yazdırıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:12.682098"
  },
  {
    "question": "Pointer'lar ile dizilere nasıl erişim sağlayabilirim?",
    "answer": "C dilinde diziler ile pointer'lar arasında sıkı bir ilişki vardır. Bir dizinin adı, dizinin ilk elemanının adresini temsil eder. Örneğin, 'int dizi[5] = {1, 2, 3, 4, 5};' ifadesinde 'dizi' ismi ile dizinin ilk elemanının adresine erişebiliriz. Dizinin elemanlarına pointer ile erişmek için şu şekilde bir örnek verebiliriz: \n\n```c\nint dizi[5] = {1, 2, 3, 4, 5};\nint *pointer = dizi; // dizi'nin adresini pointer'a atıyoruz\nfor(int i = 0; i < 5; i++) {\n    printf(\"Dizi elemanı %d: %d\\n\", i, *(pointer + i)); // pointer ile dizinin elemanlarına erişiyoruz\n}\n```\nBu örnekte, 'pointer' dizinin ilk elemanına işaret ediyor. Döngü içinde '(pointer + i)' ile dizinin her bir elemanına erişiyoruz ve 'printf' ile bu elemanların değerlerini ekrana yazdırıyoruz. Bu yöntem, diziler üzerinde işlem yaparken oldukça kullanışlıdır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:12.682134"
  },
  {
    "question": "Bir fonksiyona pointer ile bir dizi gönderdiğimde, dizinin içeriğini nasıl değiştirebilirim?",
    "answer": "C dilinde diziler, bir işaretçi (pointer) olarak işlev görür. Eğer bir dizi gönderirseniz, aslında dizinin ilk elemanının adresini göndermiş olursunuz. Bu durumda, dizinin elemanlarını değiştirmek için fonksiyon içinde diziyi işaret eden pointer'ı kullanarak doğrudan dizinin elemanlarına erişebilir ve değiştirebilirsiniz. Örnek olarak:\n\n```c\n#include <stdio.h>\n\nvoid diziDegistir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] += 1;  // Her elemanı 1 artırma\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n\n    diziDegistir(sayilar, boyut);\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);  // 2 3 4 5 6 yazdırır\n    }\n    return 0;\n}\n```\nBu örnekte, `diziDegistir` fonksiyonu bir dizi alıyor ve her elemanını 1 artırarak dizinin içeriğini değiştiriyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:25.575070"
  },
  {
    "question": "Pointerların kullanımı ile dinamik bellek yönetimini nasıl gerçekleştirebilirim?",
    "answer": "Dinamik bellek yönetimi, C dilinde `malloc`, `calloc`, `realloc` ve `free` fonksiyonları yardımıyla yapılır. Pointerlar, dinamik olarak tahsis edilen bellek bloklarına erişmek için kullanılır. Örneğin, bir dizi oluşturmak ve elemanlarını dinamik olarak yönetmek için şöyle bir kod yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int*)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return 1;\n    }\n\n    // Dizi elemanlarını doldur\n    for (int i = 0; i < n; i++) {\n        dizi[i] = i + 1;  // 1'den n'e kadar doldurma\n    }\n\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n\n    // Bellek boşaltma\n    free(dizi);\n    return 0;\n}\n```\nBu örnekte, kullanıcıdan alınan `n` değeri kadar bir dizi için bellek dinamik olarak tahsis ediliyor. Diziye değerler atandıktan sonra, `free` fonksiyonu ile tahsis edilen bellek serbest bırakılıyor. Bu, bellek sızıntılarını önlemek için önemlidir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:25.575109"
  },
  {
    "question": "Bir fonksiyona pointer ile dizi gönderdiğimde neden dizinin tamamını kopyalamadan sadece adresini gönderiyorum?",
    "answer": "C dilinde diziler, bellek üzerinde ardışık elemanlar olarak yer kaplar. Bir diziyi bir fonksiyona gönderdiğimizde, dizinin kendisini değil, ilk elemanının adresini gönderiyoruz. Bu, bellekte daha az yer kaplar ve fonksiyon içerisinde dizinin orijinal elemanları üzerinde işlem yapmamıza olanak tanır. Örneğin, bir tamsayı dizisinin elemanlarını artırmak için bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nvoid incrementArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        arr[i]++;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    incrementArray(numbers, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]); // Çıktı: 2 3 4 5 6\n    }\n    return 0;\n}\n```\nBu örnekte, `incrementArray` fonksiyonuna dizinin adresini gönderiyoruz. Böylece, fonksiyon dizinin elemanlarını doğrudan etkileyebilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:38.117039"
  },
  {
    "question": "Pointer'lar ile bellek yönetimi yaparken dikkat etmem gereken temel hususlar nelerdir?",
    "answer": "C dilinde pointer kullanarak bellek yönetimi yaparken birkaç önemli hususa dikkat etmemiz gerekir. Öncelikle, dinamik bellek tahsisi yapılırken `malloc`, `calloc` veya `realloc` gibi fonksiyonlar kullanıyoruz. Bu tür bellek tahsisleri yaptıktan sonra, işlemlerimizi tamamladıktan sonra `free` ile tahsis edilen belleği serbest bırakmalıyız. Aksi takdirde, bellek sızıntısı (memory leak) oluşur. Aşağıdaki örnekte, bir tamsayı dizisi için dinamik bellek tahsisi yaparak bu kavramı gösterelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int size;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &size);\n\n    // Dinamik bellek tahsisi\n    int *arr = (int*)malloc(size * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Dizi elemanlarını doldur\n    for (int i = 0; i < size; i++) {\n        arr[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    // Belleği serbest bırak\n    free(arr);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan bir dizi boyutu alıyoruz ve bu boyutta bir tamsayı dizisi için dinamik bellek tahsisi yapıyoruz. Belleği serbest bırakmayı unutmazsak, programımız belleği etkin kullanmamış olur.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:38.117082"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını yazdırmak için bir pointer kullanarak bir fonksiyon yazın.",
    "answer": "Aşağıda, bir tamsayı dizisinin elemanlarını yazdırmak için bir pointer kullanan bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid yazdir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i)); // Pointer kullanarak dizinin elemanlarını yazdırıyoruz\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int sayilar[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    yazdir(sayilar, boyut); // Fonksiyonu çağırıyoruz\n    return 0;\n}\n```\n\nBu programda, `yazdir` fonksiyonu bir tamsayı pointer'ı alır ve bu pointer üzerinden dizinin elemanlarını yazdırır. Pointer ile dizinin her bir elemanına erişmek için `*(dizi + i)` ifadesini kullanıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:51.865181"
  },
  {
    "question": "Bir floating point değerin adresini bir pointer aracılığıyla güncelleyen bir fonksiyon yazın.",
    "answer": "Aşağıda, bir floating point değerin adresini güncelleyen bir C programı örneği yer almaktadır:\n\n```c\n#include <stdio.h>\n\nvoid guncelle(float *deger) {\n    *deger = 25.5; // Pointer aracılığıyla değeri güncelliyoruz\n}\n\nint main() {\n    float sayi = 10.0;\n    printf(\"Güncellemeye kadar: %.2f\\n\", sayi);\n    guncelle(&sayi); // Değerin adresini gönderiyoruz\n    printf(\"Güncellemden sonra: %.2f\\n\", sayi);\n    return 0;\n}\n```\n\nBu programda, `guncelle` fonksiyonu bir floating point pointer'ı alır ve bu pointer'ı kullanarak ilgili değeri günceller. `main` fonksiyonu içinde, `sayi` değişkeninin adresini `guncelle` fonksiyonuna gönderiyoruz ve bu işlem sonucunda `sayi` değişkeninin değeri güncelleniyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:58:51.865222"
  },
  {
    "question": "Bir dizi elemanlarının toplamını hesaplamak için bir fonksiyon yazın. Fonksiyon, dizinin başlangıç adresini ve dizinin boyutunu almalıdır.",
    "answer": "Aşağıda verilen C kodu, bir dizinin elemanlarının toplamını hesaplamak için bir fonksiyon örneğidir. Fonksiyon, dizinin başlangıç adresini ve boyutunu parametre olarak alır. \n\n```c\n#include <stdio.h>\n\nint diziToplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int sonuc = diziToplam(sayilar, boyut);\n    printf(\"Dizinin toplamı: %d\\n\", sonuc);\n    return 0;\n}\n```\n\nYukarıdaki kodda, `diziToplam` fonksiyonu bir tamsayı dizisi alır ve dizinin elemanlarının toplamını döner. `main` fonksiyonu, örnek bir dizi oluşturur ve bu dizinin toplamını hesaplamak için `diziToplam` fonksiyonunu çağırır. Sonuç konsola yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:03.416065"
  },
  {
    "question": "Kullanıcıdan alınan iki sayının yerlerini değiştiren bir fonksiyon yazın. Fonksiyon, iki sayının adreslerini parametre olarak almalıdır.",
    "answer": "Aşağıda, iki sayının yerlerini değiştiren bir fonksiyon örneği verilmiştir. Bu fonksiyon, iki tamsayının adreslerini alarak bu sayıların yerlerini değiştirir.\n\n```c\n#include <stdio.h>\n\nvoid yerDegistir(int *a, int *b) {\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Önce: x = %d, y = %d\\n\", x, y);\n    yerDegistir(&x, &y);\n    printf(\"Sonra: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```\n\nBu kodda `yerDegistir` fonksiyonu, iki tamsayı adresi alır ve bu sayıları yer değiştirir. `main` fonksiyonu, iki tamsayı `x` ve `y` oluşturur, bu değerleri yer değiştirmek için `yerDegistir` fonksiyonuna gönderir. Programın çıktısı, sayının yerlerinin değiştiğini gösterir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:03.416114"
  },
  {
    "question": "Dinamik bir dizi oluşturan ve kullanıcının girdiği değerleri bu diziye ekleyen bir fonksiyon yazın. Fonksiyon, dizi boyutunu ve dizinin başlangıç adresini parametre olarak almalıdır. Kullanıcıdan değerler alındıkça dizi boyutunu dinamik olarak artırmalısınız.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid diziOlustur(int **dizi, int *boyut) {\n    *boyut = 0;\n    *dizi = NULL;\n    int yeniDeger;\n    while (1) {\n        printf(\"Bir değer girin (çıkmak için -1 girin): \");\n        scanf(\"%d\", &yeniDeger);\n        if (yeniDeger == -1) break;\n        *dizi = realloc(*dizi, (*boyut + 1) * sizeof(int));\n        (*dizi)[*boyut] = yeniDeger;\n        (*boyut)++;\n    }\n}\n\nint main() {\n    int *dizi;\n    int boyut;\n    diziOlustur(&dizi, &boyut);\n\n    printf(\"Girdiğiniz değerler:\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n    free(dizi);\n    return 0;\n}\n\n/* Açıklama: Bu program, dinamik bellek kullanarak kullanıcıdan değerleri toplayan bir diziyi oluşturur. realloc fonksiyonu, dizinin boyutunu artırmak için kullanılır. Kullanıcı -1 girene kadar değerler alınır ve diziye eklenir. Bellek sızıntısını önlemek için, dizinin sonunda free fonksiyonu ile bellek serbest bırakılır. */",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:18.433737"
  },
  {
    "question": "Verilen bir tam sayı dizisinin elemanlarının toplamını hesaplayan bir fonksiyon yazın. Bu fonksiyon, dizinin başlangıç adresini ve dizinin boyutunu almalıdır. Ayrıca, toplamı hesaplamak için bir pointer kullanmalısınız.",
    "answer": "#include <stdio.h>\n\nvoid toplamHesapla(int *dizi, int boyut, int *toplam) {\n    *toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        *toplam += dizi[i];\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int toplam;\n\n    toplamHesapla(dizi, boyut, &toplam);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n/* Açıklama: Bu program, bir tam sayı dizisinin toplamını hesaplamak için bir fonksiyon kullanır. Fonksiyon, dizinin başlangıç adresini ve boyutunu alır. Hesaplama için toplam değişkenine bir pointer ile erişilir. Bu sayede, toplam değeri fonksiyon dışında güncellenir. */",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:18.433806"
  },
  {
    "question": "Bir dizi elemanlarını tersine çevirmek için bir fonksiyon yazmak istiyorum. Dizi ve boyutunu işaretçi kullanarak nasıl yapabilirim? Kod örneğinle birlikte açıklama yap.",
    "answer": "Aşağıda bir dizinin elemanlarını tersine çevirmek için gerekli olan C kodu bulunmaktadır. İşaretçi kullanarak dizinin elemanlarına erişiyoruz ve iki uç noktayı değiştirerek işlemi gerçekleştiriyoruz.\n\n```c\n#include <stdio.h>\n\nvoid tersCevir(int* dizi, int boyut) {\n    int i, temp;\n    for(i = 0; i < boyut / 2; i++) {\n        // Uçtaki elemanları değiştiriyoruz\n        temp = dizi[i];\n        dizi[i] = dizi[boyut - 1 - i];\n        dizi[boyut - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    tersCevir(dizi, boyut);\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\n\nBu kodda, `tersCevir` fonksiyonu bir işaretçi alarak dizinin elemanlarını tersine çeviriyor. Fonksiyon, dizinin yarısına kadar gidip her iki uç noktadaki elemanları değiştirerek işlemi gerçekleştiriyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:38.074782"
  },
  {
    "question": "Dinamik bellek tahsisi kullanarak bir tamsayı dizisi oluşturmak istiyorum. Dizi boyutunu kullanıcıdan alıp, ardından bu dizideki elemanları toplamak için bir fonksiyon yazmalıyım. İşaretçilerle bunu nasıl yapabilirim?",
    "answer": "Aşağıda dinamik bellek tahsisi kullanarak kullanıcıdan alınan boyutta bir dizi oluşturan ve bu dizinin elemanlarını toplayan bir kod örneği bulunmaktadır. İşaretçiler sayesinde dizinin elemanlarına erişim sağlıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint toplamBul(int* dizi, int boyut) {\n    int toplam = 0;\n    for(int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    // Dinamik bellek tahsisi\n    int* dizi = (int*)malloc(boyut * sizeof(int));\n    if(dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız.\");\n        return 1;\n    }\n\n    // Kullanıcıdan dizi elemanlarını al\n    for(int i = 0; i < boyut; i++) {\n        printf(\"Dizi[%d]: \", i);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    int toplam = toplamBul(dizi, boyut);\n    printf(\"Dizinin toplamı: %d\\n\", toplam);\n\n    // Belleği serbest bırak\n    free(dizi);\n    return 0;\n}\n```\n\nBu kodda, önce kullanıcıdan dizinin boyutunu alıyoruz. Ardından `malloc` ile dinamik olarak bellek tahsis ediyoruz. Kullanıcıdan dizi elemanlarını topladıktan sonra, `toplamBul` fonksiyonu ile dizinin elemanlarının toplamını hesaplıyoruz. En son olarak, `free` ile tahsis edilen belleği serbest bırakmayı unutmuyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:38.074864"
  },
  {
    "question": "Bir dizi içerisindeki en büyük sayıyı bulmak için bir fonksiyon yazdım. Ancak, işlevsellik yerine bellek yönetimi konusunda bazı hatalar yaptım. Aşağıdaki kodu inceleyin ve iyileştirmeler önerin. \n\n```c\n#include <stdio.h>\n\nint findMax(int *arr, int size) {\n    int max = *arr;\n    for (int i = 1; i < size; i++) {\n        if (*(arr + i) > max) {\n            max = *(arr + i);\n        }\n    }\n    return max;\n}\n\nint main() {\n    int numbers[] = {3, 5, 1, 8, 2};\n    int max = findMax(numbers, 5);\n    printf(\"En büyük sayı: %d\\n\", max);\n    return 0;\n}\n```",
    "answer": "Kod genel olarak iyi, ancak bazı iyileştirme ve optimizasyon önerilerim var:\n\n1. **Fonksiyon Parametreleri**: Fonksiyona bir `const` işareti eklemek, gelen dizinin değiştirilmediğini belirtir. Bu, daha iyi bir bellek yönetimi sağlar.\n\n   ```c\n   int findMax(const int *arr, int size) {\n   ```\n\n2. **Başlangıç Değerinin Atanması**: `max` değişkenini `*arr` yerine `arr[0]` ile başlatmak daha okunabilir bir kod sağlar.\n\n   ```c\n   int max = arr[0];\n   ```\n\n3. **Döngü Başlangıcı**: `for` döngüsünde `i = 1` yerine `i = 0` ile başlatılabilir ve `max` ile karşılaştırma döngü içinde yapılabilir. Ancak burada bu mantıkla değişiklik yapmadım çünkü mevcut mantık doğru çalışıyor.\n\nSon hali:\n```c\n#include <stdio.h>\n\nint findMax(const int *arr, int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:56.521998"
  },
  {
    "question": "Aşağıdaki kodda iki tam sayıyı takas etmek için pointer kullandım, fakat kodun okunabilirliği ve verimliliği konusunda bazı sorunlar var. Lütfen inceleyip önerilerde bulunun. \n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x: %d, y: %d\\n\", x, y);\n    return 0;\n}\n```",
    "answer": "Kod işlevsel olarak doğru çalışıyor, ancak birkaç iyileştirme yapılabilir:\n\n1. **Fonksiyon İsimlendirmesi**: Takas işlemi için daha açıklayıcı bir isim kullanmak, kodun okunabilirliğini artıracaktır. Örneğin `swapValues` gibi bir isim kullanabilirsiniz.\n\n   ```c\n   void swapValues(int *a, int *b) {\n   ```\n\n2. **Temp Değişkenini Kullanma**: `temp` değişkeninin kullanılması yerine XOR bit işlemi ile takas yapmak, ekstra bir değişken kullanmadan işlemi gerçekleştirebilir. Ancak bu, kodun okunabilirliğini azaltabilir. \n\n   ```c\n   *a = *a ^ *b;\n   *b = *a ^ *b;\n   *a = *a ^ *b;\n   ```\n\n3. **Sabit (const)**: Fonksiyona gönderilen parametrelerin sabit olup olmayacağına dair bir yorum eklemek, fonksiyonun işlevini daha iyi anlamayı sağlar. Eğer değiştirilmeyecekse `const` eklenebilir.\n\nSon hali:\n```c\n#include <stdio.h>\n\nvoid swapValues(int *a, int *b) {\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-05-31T16:59:56.522132"
  },
  {
    "question": "Kullanıcının girdiği sayıda tamsayıyı saklamak için dinamik bellek kullanarak bir dizi oluşturun ve bu dizinin elemanlarını toplama işlemi yapın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Kaç tamsayı gireceksiniz? \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayrımı\n    int *numbers = (int *)malloc(n * sizeof(int));\n\n    if (numbers == NULL) {\n        printf(\"Hata: Bellek ayrılamadı!\");\n        return 1;\n    }\n\n    // Kullanıcıdan sayı almak\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    // Toplama işlemi\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n\n    printf(\"Toplam: %d\\n\", sum);\n\n    // Bellek boşaltma\n    free(numbers);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir sayı alır ve bu sayıda tamsayılar için dinamik bellek ayırır. Kullanıcıdan bu sayıları alıp toplar ve sonucu ekrana yazdırır. Bellek kullanımı sonrası 'free' ile ayrılan bellek geri verilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:11.259946"
  },
  {
    "question": "Bir kullanıcının girdiği isimleri dinamik bellek kullanarak saklayın ve ardından bu isimleri ekrana yazdırın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int count;\n    printf(\"Kaç isim gireceksiniz? \");\n    scanf(\"%d\", &count);\n\n    // Dinamik bellek ayrımı (her isim için 50 karakterlik bir alan ayırıyoruz)\n    char **names = (char **)malloc(count * sizeof(char *));\n    for (int i = 0; i < count; i++) {\n        names[i] = (char *)malloc(50 * sizeof(char));\n    }\n\n    // Kullanıcıdan isim almak\n    for (int i = 0; i < count; i++) {\n        printf(\"%d. ismi girin: \", i + 1);\n        scanf(\"%s\", names[i]);\n    }\n\n    // İsimleri yazdırma\n    printf(\"Girilen İsimler:\\n\");\n    for (int i = 0; i < count; i++) {\n        printf(\"%s\\n\", names[i]);\n    }\n\n    // Bellek boşaltma\n    for (int i = 0; i < count; i++) {\n        free(names[i]);\n    }\n    free(names);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan isim sayısını alır ve her bir isim için dinamik bellek ayırarak isimleri saklar. Kullanıcıdan alınan isimler daha sonra ekrana yazdırılır ve bellek temizliği yapılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:11.260026"
  },
  {
    "question": "Bir dizi içerisindeki tam sayıların ortalamasını hesaplamak için dinamik bellek kullanarak bir fonksiyon yazın. Kullanıcının dizi boyutunu belirtmesini sağlamak ve bellek tahsisini dinamik olarak gerçekleştirin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat ortalamaHesapla(int *dizi, int boyut) {\n    int toplam = 0;\n    for(int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    int *dizi = (int *)malloc(boyut * sizeof(int)); // Dinamik bellek tahsisi\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\");\n        return 1;\n    }\n\n    printf(\"Dizi elemanlarını girin:\\n\");\n    for(int i = 0; i < boyut; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    float ortalama = ortalamaHesapla(dizi, boyut);\n    printf(\"Dizinin ortalaması: %.2f\\n\", ortalama);\n\n    free(dizi); // Belleği serbest bırak\n    return 0;\n}\n\n// Bu program, kullanıcıdan dizi boyutunu alır ve ardından dizi elemanlarını toplar. Dinamik bellek kullanarak bellekte yer tahsis edilir ve işlem sonunda bellek serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:29.490971"
  },
  {
    "question": "Bir metin dosyasındaki kelimeleri sayan bir C programı yazın. Kullanıcının girdiği dosya ismini alarak dosyayı açın ve dosyadaki kelimeleri saymak için dinamik bellek yöneticisi kullanın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint kelimeSayisiBul(char *dosyaAdi) {\n    FILE *dosya = fopen(dosyaAdi, \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return -1;\n    }\n\n    char *kelime = (char *)malloc(100 * sizeof(char)); // Dinamik bellek tahsisi\n    if (kelime == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        fclose(dosya);\n        return -1;\n    }\n\n    int kelimeSayisi = 0;\n    while (fscanf(dosya, \"%99s\", kelime) != EOF) { // Dosyadan kelimeleri oku\n        kelimeSayisi++;\n    }\n\n    free(kelime); // Belleği serbest bırak\n    fclose(dosya);\n    return kelimeSayisi;\n}\n\nint main() {\n    char dosyaAdi[100];\n    printf(\"Kelime sayısını bulmak için dosya adını girin: \");\n    scanf(\"%s\", dosyaAdi);\n\n    int sayi = kelimeSayisiBul(dosyaAdi);\n    if (sayi != -1) {\n        printf(\"Dosyadaki kelime sayısı: %d\\n\", sayi);\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir dosya ismi alarak dosyayı açar ve içindeki kelimeleri sayar. Dinamik bellek kullanarak bir kelime için bellek tahsis edilir, işlem sonunda bellek serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:29.491082"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak bir dizi oluşturun ve kullanıcıdan bu dizinin elemanlarını alarak toplamını hesaplayın. Kodun eksik kısmını doldurun: \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizinin eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int));\n    // Eksik kısım burada.\n    free(dizi);\n    return 0;\n}",
    "answer": "Eksik kısım, kullanıcıdan dizinin elemanlarını almak ve toplamını hesaplamak için bir döngü eklemeyi içerir. Tamamlanmış kod şöyle olmalıdır:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizinin eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Hata: Bellek ayırma başarısız.\");\n        return 1;\n    }\n\n    int toplam = 0;\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n        toplam += dizi[i];\n    }\n\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam);\n    free(dizi);\n    return 0;\n}\n\nBu kodda, kullanıcıdan dizinin eleman sayısı alındıktan sonra dinamik bir dizi oluşturuluyor. Eğer bellek ayırma başarısız olursa hata mesajı veriliyor. Kullanıcıdan dizi elemanları alınıp toplamları hesaplanıyor ve sonuç ekrana yazdırılıyor.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:46.370602"
  },
  {
    "question": "Bir C programında kullanıcıdan bir string (karakter dizisi) alarak dinamik bellek kullanarak bu string’in tersini yazdırmak için eksik kodu tamamlayın. Eksik kısmı doldurun: \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str;\n    int uzunluk;\n    printf(\"String'in uzunluğunu giriniz: \");\n    scanf(\"%d\", &uzunluk);\n    // Eksik kısım burada.\n    free(str);\n    return 0;\n}",
    "answer": "Eksik kısım, kullanıcıdan string almayı ve bu string’in tersini yazdırmayı içerir. Tamamlanmış kod şöyle olmalıdır:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str;\n    int uzunluk;\n    printf(\"String'in uzunluğunu giriniz: \");\n    scanf(\"%d\", &uzunluk);\n    str = (char *)malloc((uzunluk + 1) * sizeof(char)); // +1, NULL terminatör için\n    if (str == NULL) {\n        printf(\"Hata: Bellek ayırma başarısız.\");\n        return 1;\n    }\n\n    printf(\"String'i giriniz: \");\n    scanf(\"%s\", str);\n\n    // String'in tersini yazdırma\n    printf(\"Ters string: \");\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n\n    free(str);\n    return 0;\n}\n\nBu kodda, kullanıcıdan bir string’in uzunluğu alınıyor ve dinamik olarak bu kadar bellek ayırılıyor. Kullanıcıdan alınan string, ters sırayla ekrana yazdırılıyor. Bellek kullanımı sonrası 'free' fonksiyonu ile bellek serbest bırakılıyor.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:00:46.370802"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısı (memory leak) sorunu var. Hatanın nedenini bulun ve düzeltin:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(10 * sizeof(int));\n    // Array initialization\n    for(int i = 0; i < 10; i++) {\n        arr[i] = i;\n    }\n    // Burada arr kullanılıyor ama bellek serbest bırakılmıyor\n    return 0;\n}",
    "answer": "Kodda bellek sızıntısı var çünkü malloc ile ayırdığımız bellek, programın sonunda free ile serbest bırakılmıyor. Bu, programın çalıştığı süre boyunca bellek alanının boşuna kaplanmasına neden olur. Düzeltmek için, programın sonunda 'free(arr);' ifadesini ekleyerek belleği serbest bırakmalıyız:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(10 * sizeof(int));\n    for(int i = 0; i < 10; i++) {\n        arr[i] = i;\n    }\n    // Belleği serbest bırakıyoruz\n    free(arr);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:02.357512"
  },
  {
    "question": "Aşağıdaki kodda işaretçi (pointer) kullanımı ile ilgili bir hata var. Hatanın nedenini belirleyin ve düzeltin:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid setValue(int *ptr) {\n    *ptr = 5;\n}\n\nint main() {\n    int *value;\n    setValue(value);\n    printf(\"Value: %d\\n\", *value);\n    return 0;\n}",
    "answer": "Kodda 'value' işaretçisi bir bellek alanına işaret etmiyor (NULL veya tanımsız bir işaretçi). Bu nedenle, setValue fonksiyonu içinde dereference (gösterim) işlemi yaptığımızda belirsiz bir bellek alanına yazmaya çalışıyoruz, bu da programın çökmesine neden olur. Düzeltmek için, 'value' işaretçisini malloc ile bellek ayırarak başlatmalıyız:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid setValue(int *ptr) {\n    *ptr = 5;\n}\n\nint main() {\n    int *value = (int*)malloc(sizeof(int)); // Bellek ayırıyoruz\n    setValue(value);\n    printf(\"Value: %d\\n\", *value);\n    free(value); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:02.357611"
  },
  {
    "question": "Dinamik bellekten tahsis edilen bir diziye erişmeye çalıştığımda 'Segmentation fault' hatası alıyorum. Neden olabilir?",
    "answer": "Bu hatanın nedeni, dinamik bellekle tahsis ettiğiniz dizinin boyutunu belirtmeden erişmeye çalışmanız olabilir. Örneğin, aşağıdaki kodda bellek tahsisi doğru bir şekilde yapılmadı:\n\n```c\nint *dizi;\ndizi = (int *)malloc(5 * sizeof(int));\n// Burada dizi boyutunu 5 olarak tahsis ettik.\n\nfor (int i = 0; i <= 5; i++) { // Hata burada, dizi boyutu 5, fakat 0'dan 5'e kadar gidiyoruz.\n    dizi[i] = i;\n}\n```\nDüzgün erişim için döngüyü şu şekilde değiştirmelisiniz:\n\n```c\nfor (int i = 0; i < 5; i++) {\n    dizi[i] = i;\n}\n```\nBu şekilde, dizinin geçerli olan indeksleri 0'dan 4'e kadar erişilebilir. Ayrıca, her zaman dinamik bellek kullanımdan sonra `free()` ile serbest bırakmayı unutmayın.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:12.337522"
  },
  {
    "question": "Dinamik bellek tahsisi yaptıktan sonra belleği serbest bırakmazsam ne olur? Örnek ile açıklayabilir misiniz?",
    "answer": "Dinamik bellek tahsisi yapıp serbest bırakmadığınızda, bellekte 'memory leak' (bellek sızıntısı) oluşur. Bu durum, özellikle uzun süre çalışan programlarda bellek kullanımını artırarak sistemin kaynaklarını tüketebilir. Aşağıdaki örnekte, bellek tahsisi yapıp serbest bırakmamak durumunu inceleyelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr = (int *)malloc(10 * sizeof(int)); // Bellekten 10 int'lik alan tahsis ediliyor.\n    // Belleği serbest bırakmıyoruz.\n    return 0;\n}\n```\nBu durumda, `ptr` göstericisi ile tahsis edilmiş bellek alanı program sonlandığında serbest bırakılmamış olur. Eğer bu durum program sürekli çalışıyorsa, zamanla daha fazla bellek tahsis edilirse sistemin belleği dolacak ve performans kaybına yol açacaktır. İyi bir uygulama olarak, bellek tahsisinden sonra `free(ptr);` kullanarak belleği serbest bırakmalısınız:\n\n```c\nfree(ptr);\n```\nBu şekilde, hem bellekte sızıntı yaşamazsınız hem de kaynakları verimli kullanmış olursunuz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:12.337590"
  },
  {
    "question": "Dinamik olarak alloc edilen bir diziye eleman eklemek için bir fonksiyon yazdım, ancak programım çalışırken bellek hatası alıyorum. Sorun ne olabilir?",
    "answer": "Bu hatanın nedeni, dinamik olarak alloc edilen dizinin boyutunu artırmadan ekleme yapmaya çalışmanızdır. C dilinde, bir dizinin boyutunu değiştirmek için 'realloc' fonksiyonunu kullanmalısınız. 'malloc' ile oluşturulan dizi boyutu sabittir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid ekle(int **dizi, int *boyut, int yeniEleman) {\n    // Mevcut boyutu bir artırıyoruz\n    (*boyut)++;\n    // Yeni boyut için realloc yapıyoruz\n    *dizi = realloc(*dizi, (*boyut) * sizeof(int));\n    if (*dizi == NULL) {\n        // realloc başarısız olursa hata ver\n        fprintf(stderr, \"Bellek tahsisinde hata!\");\n        exit(1);\n    }\n    // Yeni eleman ekleniyor\n    (*dizi)[*boyut - 1] = yeniEleman;\n}\n\nint main() {\n    int *dizi = malloc(sizeof(int));\n    int boyut = 0;\n    ekle(&dizi, &boyut, 5);\n    ekle(&dizi, &boyut, 10);\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    free(dizi);\n    return 0;\n}\n```\n\nBu fonksiyon, mevcut diziye yeni bir eleman eklemek için önce dizinin boyutunu artırır ve ardından 'realloc' ile bellekte yeni yer açar. Eğer 'realloc' işlemi başarısız olursa, program hata mesajı vererek güvenli bir şekilde sonlanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:38.506129"
  },
  {
    "question": "Dinamik bellek kullanarak bir yapı dizisi oluşturdum, ancak belleği serbest bırakmayı unuttum. Bu durumun uzun vadeli etkileri neler olabilir?",
    "answer": "Belleği serbest bırakmamak, 'memory leak' (bellek sızıntısı) sorununa yol açar. Program çalıştıkça, her dinamik bellek tahsisi sonucu kullanılan bellek alanı geri alınmadığında, sistemde kullanılabilir bellek azalır ve sonunda program çökebilir. Özellikle uzun süre çalışan uygulamalarda bu sorun daha belirgin hale gelir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char isim[20];\n} Kisi;\n\nint main() {\n    int n;\n    printf(\"Kaç kişi gireceksiniz? \");\n    scanf(\"%d\", &n);\n    Kisi *kisiler = malloc(n * sizeof(Kisi));\n\n    for (int i = 0; i < n; i++) {\n        kisiler[i].id = i + 1;\n        snprintf(kisiler[i].isim, sizeof(kisiler[i].isim), \"Kişi %d\", kisiler[i].id);\n    }\n\n    // Burada kisiler dizisini kullanıyoruz, ancak belleği serbest bırakmayı unuttuk.\n\n    // free(kisiler); // Belleği serbest bırakmayı unutursak, her çalıştırmada sızıntı olur.\n    return 0;\n}\n```\n\nEğer `free(kisiler);` satırını eklemezseniz, program her çalıştığında, önceki çalışmalardan kalan bellek alanları geriye alınmadığı için bellek sızıntısı oluşur. Uzun vadede, bu durum sistemde bellek tükenmesine ve performans düşüklüğüne yol açabilir. Bu tür bellek yönetimi sorunlarını önlemek için, her dinamik bellek tahsisinden sonra bellek serbest bırakma işlemi yapılmalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:38.506180"
  },
  {
    "question": "C dilinde dinamik bellek yönetimi nedir ve neden kullanılır?",
    "answer": "C dilinde dinamik bellek yönetimi, programın çalıştığı süre boyunca bellek tahsisi ve serbest bırakma işlemlerini ifade eder. 'malloc', 'calloc', 'realloc' ve 'free' gibi fonksiyonlar kullanılarak gerçekleştirilir. Dinamik bellek yönetimi, programın bellek ihtiyacının runtime (çalışma zamanı) esnasında belirlenmesine olanak sağlar. Örneğin, bir kullanıcıdan bilgi alındığında ve bu bilginin boyutunun önceden bilinmediği durumlarda kullanışlıdır. Bu sayede, bellek israfını önleyebiliriz ve bellek ihtiyacını tam olarak karşılayabiliriz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:51.243671"
  },
  {
    "question": "Dinamik bellek tahsisi nasıl yapılır ve bir örnek ile açıklayabilir misiniz?",
    "answer": "Dinamik bellek tahsisi, 'malloc' fonksiyonu ile yapılır. Bu fonksiyon, istenen boyutta bellek tahsis eder ve bu bellek bloğunun başlangıç adresini döner. Örneğin, bir tamsayı dizisi oluşturmak istediğimizi düşünelim. Kullanıcıdan dizi boyutunu alıp uygun bellek tahsisi yapabiliriz. Aşağıdaki örnekte, kullanıcıdan alınan bir boyutta tamsayı dizisi oluşturulmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, i;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Dizi elemanlarını doldurma\n    for (i = 0; i < n; i++) {\n        dizi[i] = i + 1; // 1'den n'e kadar olan sayılar\n    }\n\n    // Dizi elemanlarını yazdırma\n    printf(\"Dizi elemanları: \");\n    for (i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}\n```\nBu örnekte, kullanıcıdan bir dizi boyutu alıyoruz, ardından 'malloc' ile bu boyutta bellek tahsis ediyoruz. Eğer tahsis işlemi başarılıysa, dizinin elemanlarını doldurup yazdırıyoruz. En son olarak, 'free' fonksiyonu ile tahsis edilen belleği serbest bırakıyoruz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:01:51.243710"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir dizi oluşturmanın avantajları nelerdir?",
    "answer": "Dinamik bellek yönetiminin en büyük avantajlarından biri, programın çalışma zamanında ihtiyaç duyulan bellek miktarını daha esnek bir şekilde yönetebilmesidir. Örneğin, kullanıcıdan alınan bir veri sayısına bağlı olarak bir dizi oluşturmak istiyoruz. Eğer diziyi sabit bir boyutla tanımlarsak, gereksiz bellek kullanımı veya yetersizlik gibi problemlerle karşılaşabiliriz. C dilinde malloc fonksiyonu ile dinamik olarak bellek ayırabiliriz. Örneğin:\n\n```c\nint n;\nprintf(\"Dizi boyutunu girin: \");\nscanf(\"%d\", &n);\nint *dizi = (int*)malloc(n * sizeof(int));\nif (dizi == NULL) {\n    fprintf(stderr, \"Bellek tahsis edilemedi!\");\n    return 1;\n}\n```\n\nYukarıdaki kodda, kullanıcıdan dizi boyutunu alıyoruz ve malloc ile gerektiği kadar bellek tahsis ediyoruz. Bu şekilde, programımızın çalıştığı süre boyunca esnek bir bellek yönetimi sağlıyoruz. Unutulmaması gereken önemli bir nokta ise, malloc ile tahsis edilen belleği daha sonra free fonksiyonu ile serbest bırakmamız gerektiğidir:",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:08.024700"
  },
  {
    "question": "C dilinde bir linked list oluştururken dinamik bellek yönetiminin nasıl kullanıldığını açıklayınız.",
    "answer": "Linked list, düğümlerden oluşan bir veri yapısıdır ve her düğüm, veriyi ve bir sonraki düğümün adresini tutar. Dinamik bellek yönetimi, linked list oluştururken oldukça faydalıdır çünkü her düğüm için gerekli olan bellek sadece ihtiyaç olduğunda tahsis edilir. Örnek olarak, basit bir linked list düğümü tanımlayalım:\n\n```c\ntypedef struct Düğüm {\n    int veri;\n    struct Düğüm *sonraki;\n} Düğüm;\n```\n\nBu yapıyı kullanarak, bir düğüm oluşturmak için dinamik bellek tahsisi yapabiliriz:\n\n```c\nDüğüm *yeniDüğüm = (Düğüm*)malloc(sizeof(Düğüm));\nif (yeniDüğüm == NULL) {\n    fprintf(stderr, \"Bellek tahsis edilemedi!\");\n    return 1;\n}\n\nyeniDüğüm->veri = 5;\nnewDüğüm->sonraki = NULL;\n```\n\nYukarıdaki kodda, yeni bir düğüm oluşturuyoruz ve veri alanına 5 atıyoruz. Eğer bellek tahsisi başarısız olursa, program hata mesajı veriyor. Linked list'in her bir düğümünü bu şekilde oluşturarak zincirleme bir yapı oluşturabiliriz. Düğümlerin bellek alanlarını serbest bırakmak için ise, her düğümün serbest bırakılmasını sağlamak önemlidir ki bu da bağlı listemiz üzerinde doğru bir bellek yönetimi yapılmasını sağlar. Bu nedenle, linked list kullanımı dinamik bellek yönetimi açısından oldukça etkilidir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:08.024744"
  },
  {
    "question": "C dilinde dinamik bellek yönetimi ile bir dizi oluşturmak için malloc() fonksiyonunu kullanırken, bellek tahsisinin başarılı olup olmadığını nasıl kontrol edebilirim?",
    "answer": "C dilinde dinamik bellek yönetimi için malloc() fonksiyonu kullanıldığında, bellek tahsisi başarılı olup olmadığını kontrol etmek çok önemlidir. malloc() fonksiyonu, başarılı bir şekilde bellek tahsis ederse, tahsis edilen bellek bloğunun adresini döner. Eğer bellek tahsisi başarısız olursa, NULL döner. Aşağıdaki örnek kodda, işlenmekte olan bir dizi için dinamik bellek tahsisi yapılmıştır ve tahsisin başarılı olup olmadığı kontrol edilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *dizi;\n    int boyut;\n\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    dizi = (int*)malloc(boyut * sizeof(int));\n\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Bellek tahsisinin başarılı olduğu durumda diziyi kullan\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Dizi[%d] = %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırak\n    free(dizi);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:22.795149"
  },
  {
    "question": "C dilinde dinamik bellek tahsisi sırasında bellek sızıntısını önlemek için neler yapmalıyım?",
    "answer": "Bellek sızıntıları, dinamik bellek yönetiminde en yaygın hatalardan biridir ve bellek kaynaklarının düzgün bir şekilde yönetilmemesi sonucunda ortaya çıkar. C dilinde, dinamik bellek tahsisi yaptığınızda, tahsis edilen belleği kullanmayı bitirdiğinizde free() fonksiyonu ile serbest bırakmalısınız. Aşağıdaki örnek, bellek sızıntısını önlemek için dikkat edilmesi gerekenleri göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid bellek_tahsis_et(int **dizi, int boyut) {\n    *dizi = (int*)malloc(boyut * sizeof(int));\n    if (*dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        exit(1);\n    }\n}\n\nint main() {\n    int *dizi;\n    int boyut = 10;\n\n    bellek_tahsis_et(&dizi, boyut);\n\n    // Dizi elemanlarını doldur\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Dizi[%d] = %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırak\n    free(dizi);\n    dizi = NULL; // Bellek sızıntısını önlemek için göstericiyi NULL yapıyoruz\n    return 0;\n}\n``` \nBu kodda, dinamik olarak tahsis edilen bellek kullanıldıktan sonra free() ile serbest bırakılır ve ardından gösterici NULL yapılarak bellek sızıntılarını önlemeye yardımcı olunur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:22.795212"
  },
  {
    "question": "Kullanıcının girdiği bir dizi tamsayıyı dinamik olarak belleğe alarak toplamını hesaplayan bir C programı yazınız.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan bir dizi tamsayı alır ve bu dizinin toplamını hesaplar.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, i, sum = 0;\n    int *arr;\n\n    printf(\"Dizinin eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    arr = (int *)malloc(n * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek ayırma hatası!\\n\");\n        return 1;\n    }\n\n    // Kullanıcıdan dizi elemanlarını alma\n    printf(\"Dizi elemanlarını girin:\\n\");\n    for (i = 0; i < n; i++) {\n        printf(\"Eleman %%d: \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    // Toplama işlemi\n    for (i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n\n    printf(\"Dizinin elemanlarının toplamı: %%d\\n\", sum);\n\n    // Belleği serbest bırakma\n    free(arr);\n    return 0;\n}\n```\n\nBu programda, önce kullanıcıdan dizi uzunluğu alınır ve `malloc` fonksiyonu ile dinamik bellek oluşturulur. Eğer bellek tahsisi başarısız olursa hata mesajı gösterilir. Kullanıcının girdiği elemanlar bir döngü ile alınır ve toplam hesaplanır. Son olarak, kullanılan bellek `free` ile serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:38.603486"
  },
  {
    "question": "Kullanıcının girdiği isimleri dinamik olarak belleğe alarak bu isimleri tersten yazdıran bir C programı yazınız.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan bir isim sayısı alır ve bu isimleri dinamik olarak saklar. Ardından, isimleri tersten yazdırır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n, i;\n    char **names;\n\n    printf(\"Kaç isim gireceksiniz?: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    names = (char **)malloc(n * sizeof(char *));\n    for (i = 0; i < n; i++) {\n        names[i] = (char *)malloc(100 * sizeof(char)); // Her isim için 100 karakterlik bellek ayırma\n    }\n\n    // Kullanıcıdan isimleri alma\n    printf(\"İsimleri girin:\\n\");\n    for (i = 0; i < n; i++) {\n        printf(\"İsim %%d: \", i + 1);\n        scanf(\"%s\", names[i]);\n    }\n\n    // İsimleri tersten yazdırma\n    printf(\"Girilen isimler (tersten):\\n\");\n    for (i = n - 1; i >= 0; i--) {\n        printf(\"%%s\\n\", names[i]);\n    }\n\n    // Belleği serbest bırakma\n    for (i = 0; i < n; i++) {\n        free(names[i]);\n    }\n    free(names);\n    return 0;\n}\n```\n\nBu programda, kullanıcıdan isimlerin sayısı alınır ve `malloc` ile dinamik olarak isimler için bellek tahsis edilir. Her isim en fazla 100 karakter olabileceği için bu kadar bellek ayrılır. Kullanıcıdan isimler alındıktan sonra, isimler tersten yazdırılır. Son olarak, her bir isim için ayrılan bellek ve ana isimler dizisi için ayrılan bellek `free` ile serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:02:38.603529"
  },
  {
    "question": "Bir fonksiyon içinde dinamik olarak oluşturulan bir dizi ile çalışıyorum. Ancak, dizinin boyutunu ihtiyaç duyduğumda güncelleyemiyorum. Kodum şöyle: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid updateArray(int **arr, int *size) {\n    *size += 5; // Yeni boyutun belirlenmesi\n    *arr = realloc(*arr, (*size) * sizeof(int)); // Bellek yeniden tahsisi\n    if (*arr == NULL) {\n        perror(\"Bellek tahsis edilemedi\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    int *array = malloc(5 * sizeof(int));\n    int size = 5;\n    updateArray(&array, &size);\n    free(array);\n    return 0;\n}\n```\nBu kodda, dinamik bellek yönetimi ile ilgili hangi potansiyel sorunlar var ve nasıl iyileştirebiliriz?",
    "answer": "Kodda bazı iyileştirme noktaları var. Öncelikle, `realloc` kullanımında dikkat edilmesi gereken bir nokta, belleğin tahsisi başarısız olursa eski bellek alanının kaybolmamasıdır. Şu şekilde güncelleyebiliriz:\n\n```c\nvoid updateArray(int **arr, int *size) {\n    int *tmp = realloc(*arr, (*size + 5) * sizeof(int)); // Geçici değişken kullan\n    if (tmp == NULL) {\n        perror(\"Bellek tahsis edilemedi\");\n        free(*arr); // Eski bellek alanını serbest bırak\n        exit(EXIT_FAILURE);\n    }\n    *arr = tmp; // Yeni pointer'ı güncelle\n    *size += 5;\n}\n```\nBu değişiklik, `realloc` başarısız olursa programın çökmesini önler ve bellekteki mevcut verileri kaybetmemizi engeller.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:03:55.313992"
  },
  {
    "question": "Bir yapıyı dinamik olarak oluşturduktan sonra, onu serbest bırakmayı unuttuğum için bellek sızıntısı yaşıyorum. Kodum aşağıdaki gibi:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nstruct Node* createNode(int value) {\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    struct Node *head = createNode(10);\n    head->next = createNode(20);\n    // Burada head yapısını serbest bırakmayı unuttuk\n    return 0;\n}\n```\nBu kodda bellek sızıntısını önlemek için ne yapmalıyım?",
    "answer": "Kodda bellek sızıntısını önlemek için, oluşturduğunuz her düğümü serbest bırakmanız gerekiyor. Ayrıca, bellek sızıntısını önlemek için bir fonksiyon oluşturarak tüm bağlı listeyi temizleyebilirsiniz. Aşağıdaki gibi bir `freeList` fonksiyonu tanımlayabiliriz:\n\n```c\nvoid freeList(struct Node *head) {\n    struct Node *temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp); // Her düğümü serbest bırak\n    }\n}\n```\nBunu `main` fonksiyonunun sonunda çağırarak bellek sızıntısını önleyebilirsiniz:\n\n```c\nint main() {\n    struct Node *head = createNode(10);\n    head->next = createNode(20);\n    freeList(head); // Belleği serbest bırak\n    return 0;\n}\n```\nBu şekilde, dinamik olarak tahsis edilen belleği düzgün bir şekilde yönetmiş olursunuz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:03:55.314279"
  },
  {
    "question": "Dinamik bellek tahsisi yaparken bir dizi oluşturuyorum. Ancak, dizinin boyutunu değiştirmem gerektiğinde, mevcut diziyi kopyalayıp yeni bir dizi oluşturdum. Bu yaklaşımda sorunlar olabilir mi? Daha iyi bir yöntem önerir misin?",
    "answer": "Evet, mevcut diziyi kopyalayıp yeni bir dizi oluşturmak bazı sorunlara yol açabilir. Özellikle, mevcut diziyi serbest bırakmadığınız durumlarda bellek sızıntısına neden olabilir. Ayrıca, bu işlem zaman alıcıdır ve performansı etkileyebilir. Bunun yerine, `realloc` fonksiyonunu kullanarak mevcut belleği yeniden boyutlandırabilirsiniz. Bu, mevcut verileri koruyarak daha fazla veya daha az bellek tahsis etmenizi sağlar. İşte bir örnek:\n\n```c\nint *dizi = (int *)malloc(10 * sizeof(int)); // Başlangıçta 10 elemanlı bir dizi oluşturun.\n// ... 10 elemanın içeriğini doldurun.\n\ndizi = (int *)realloc(dizi, 20 * sizeof(int)); // Dizi boyutunu 20 yapın.\nif (dizi == NULL) {\n    // realloc başarısız olursa eski diziye erişimi kaybetmemek için uygun hata yönetimi yapın.\n    perror(\"Bellek tahsisi hatası\");\n    exit(EXIT_FAILURE);\n}\n// Yeni elemanları kullanabiliriz.\n```\nBu şekilde, bellek sızıntısından kaçınır ve performansı artırırsınız.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:04:12.454674"
  },
  {
    "question": "Bir yapının içinde dinamik olarak tahsis edilmiş bir dizi tutuyorum. Ancak, bu yapıyı kullandıktan sonra belleği serbest bırakmayı unuttum. Bu durumda ne gibi sorunlar ortaya çıkabilir ve bu durumu nasıl önleyebilirim?",
    "answer": "Belleği serbest bırakmayı unuttuğunuzda, bellek sızıntısı meydana gelir. Bu, uygulamanızın çalıştığı sürece bellek kullanımının artmasına ve nihayetinde sistemin yavaşlamasına veya çökmesine neden olabilir. Bu durumu önlemek için, her dinamik tahsisattan sonra bellek serbest bırakmayı unutmamalısınız. Ayrıca, bu bellek yönetim işlemlerini daha güvenilir hale getirmek için, bellek sızıntılarını tespit etmek için araçlar (örneğin, Valgrind) kullanabilirsiniz. Örnek bir yapı:\n\n```c\ntypedef struct {\n    int *dizi;\n    size_t boyut;\n} Yapı;\n\nYapı *yeniYapı(size_t boyut) {\n    Yapı *yapı = (Yapı *)malloc(sizeof(Yapı));\n    yapı->dizi = (int *)malloc(boyut * sizeof(int));\n    yapı->boyut = boyut;\n    return yapı;\n}\n\nvoid yokEt(Yapı *yapı) {\n    if (yapı) {\n        free(yapı->dizi); // Önce içindeki diziyi serbest bırakın.\n        free(yapı); // Ardından yapıyı serbest bırakın.\n    }\n}\n```\nBu şekilde, `yokEt` fonksiyonu kullanılarak yapının belleği güvenli bir şekilde serbest bırakılmış olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-05-31T17:04:12.454744"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan kısmı tamamlayın. Kullanıcıdan alınan bir dizi elemanının toplamını hesaplamak için pointer aritmetiği kullanarak 'sum' değişkenini güncelleyin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int sum = 0;\n    printf(\"5 adet sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    for (int i = 0; i < 5; i++) {\n        sum += *(arr + i); // Pointer aritmetiği kullanarak dizinin elemanlarına erişiyoruz.\n    }\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n\n/* Açıklama: Bu kodda, kullanıcıdan 5 adet sayı alıyoruz ve bunları bir diziye kaydediyoruz. Daha sonra, pointer aritmetiği kullanarak dizinin elemanlarına erişip toplamlarını hesaplıyoruz. 'arr + i' ifadesi, dizinin i'inci elemanına işaret eden bir pointer döner. */",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:04:23.909949"
  },
  {
    "question": "Aşağıdaki kodda, bir karakter dizisinin uzunluğunu pointer aritmetiği kullanarak bulun. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n\n    int length = 0;\n    char *ptr = str; // Pointer başlangıçta dizinin ilk elemanına işaret ediyor.\n    while (*ptr != '\\0') {\n        length++; // Pointer ile karakterleri sayıyoruz.\n        ptr++; // Pointer'ı bir sonraki karaktere ilerletiyoruz.\n    }\n    printf(\"Cümlenin uzunluğu: %d\\n\", length);\n    return 0;\n}\n\n/* Açıklama: Bu kodda, kullanıcıdan bir cümle alıyoruz ve ardından pointer aritmetiği kullanarak dizinin sonuna kadar gidip karakter sayısını hesaplıyoruz. 'ptr' değişkeni, 'str' dizisinin elemanlarını gezmek için kullanılıyor. */",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:04:23.910013"
  },
  {
    "question": "Aşağıdaki kod parçasının eksik kısmını tamamlayarak, bir tamsayı dizisinin toplamını hesaplayacak bir fonksiyon yazın. Fonksiyonu pointer aritmetiği kullanarak tamamlayın. \n\n```c\n#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    // Eksik kısım buraya gelecek\n    return toplam;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    printf(\"Toplam: %d\", toplam(sayilar, boyut));\n    return 0;\n}\n```",
    "answer": "Eksik kısmı tamamlamak için pointer aritmetiği kullanarak dizinin elemanlarına erişebiliriz. Bu durumda, dizi pointer'ı ile döngü oluşturacak ve her bir elemanın değerini toplamak için pointer'ı artırarak ilerleyeceğiz. Aşağıdaki şekilde tamamlayabiliriz:\n\n```c\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği ile dizi elemanına erişim\n    }\n    return toplam;\n}\n```\n\nBurada `*(dizi + i)` ifadesi ile dizinin i. elemanına erişiyoruz. Pointer aritmetiği sayesinde, `dizi` pointer'ının üzerine `i` kadar ilerleyip o elemanın değerini alıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:04:40.529170"
  },
  {
    "question": "Aşağıdaki kod parçasının eksik kısmını tamamlayarak bir karakter dizisinin uzunluğunu bulacak bir fonksiyon yazın. Pointer aritmetiği kullanarak bu işlemi gerçekleştirin. \n\n```c\n#include <stdio.h>\n\nint strlen_custom(char *str) {\n    int uzunluk = 0;\n    // Eksik kısım buraya gelecek\n    return uzunluk;\n}\n\nint main() {\n    char metin[] = \"Merhaba Dünya\";\n    printf(\"Uzunluk: %d\", strlen_custom(metin));\n    return 0;\n}\n```",
    "answer": "Bu kodu tamamlamak için, `str` pointer'ını kullanarak karakter dizisinin sonuna kadar gitmemiz gerekiyor. Her bir karakterin adresini artırarak uzunluğu hesaplayabiliriz. Aşağıdaki gibi tamamlayabiliriz:\n\n```c\nint strlen_custom(char *str) {\n    int uzunluk = 0;\n    while (*(str + uzunluk) != '\\0') { // Null terminatör kontrolü\n        uzunluk++; // Her karakter için uzunluğu artır\n    }\n    return uzunluk;\n}\n```\n\nBurada `*(str + uzunluk)` ifadesi ile `str` pointer'ının üzerine `uzunluk` kadar ekleyip o karakteri kontrol ediyoruz. Eğer karakter `\\0` (null terminatör) değilse, uzunluğu artırmaya devam ediyoruz. Bu sayede dizinin uzunluğunu doğru bir şekilde hesaplıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:04:40.529290"
  },
  {
    "question": "Aşağıdaki C kodunun eksik kısmını tamamlayarak, bir dizi içinde en büyük sayıyı bulan fonksiyonu yazınız. Fonksiyon, dizi ve boyut parametrelerini almalıdır. Ayrıca, pointer aritmetiğini kullanarak dizinin elemanlarına erişmelisiniz. Kodun eksik kısmını doldurunuz.",
    "answer": "#include <stdio.h>\n\nint enBüyük(int *dizi, int boyut) {\n    int max = *dizi; // İlk elemanı max olarak al\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > max) { // Pointer aritmetiği ile dizinin elemanlarına erişim\n            max = *(dizi + i);\n        }\n    }\n    return max;\n}\n\nint main() {\n    int sayilar[] = {3, 5, 1, 8, 2};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int enBuyukSayi = enBüyük(sayilar, boyut);\n    printf(\"En büyük sayı: %d\\n\", enBuyukSayi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:20.388664"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, bir tamsayı dizisini tersine çeviren bir fonksiyon yazın. Fonksiyonda pointer aritmetiği kullanarak dizinin elemanlarını değiştirmelisiniz. Kodun eksik kısmını doldurunuz.",
    "answer": "#include <stdio.h>\n\nvoid tersCevir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = *(dizi + i); // İlk elemanı geçici bir değişkende sakla\n        *(dizi + i) = *(dizi + (boyut - 1 - i)); // Son elemanı ilk eleman ile değiştir\n        *(dizi + (boyut - 1 - i)) = temp; // Geçici değişkandaki değeri son elemana ata\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    tersCevir(sayilar, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:20.388745"
  },
  {
    "question": "Aşağıdaki C kodunda bir dizi elemanına erişim hatalı. Hatanın nedenini ve düzeltmesini açıklayınız.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n    printf(\"Dizi elemanı: %d\\n\", ptr[5]); // Hata burada\n    return 0;\n}\n```",
    "answer": "Yukarıdaki kodda `ptr[5]` ifadesi bir hata içermektedir. C dilinde diziler sıfırdan başlayarak numaralandırılır, bu nedenle `ptr[5]` ifadesi dizinin 6. elemanını ifade eder ki bu da tanımlı bir eleman değildir. Kod çalıştırıldığında belirsiz bir davranış sergileyebilir veya program çökebilir. Bu hatayı düzeltmek için `ptr[4]` kullanmalıyız ki bu da dizinin son elemanıdır.\n\nDüzeltme:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[5] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n    printf(\"Dizi elemanı: %d\\n\", ptr[4]); // Düzeltildi\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:39.746391"
  },
  {
    "question": "Aşağıdaki C kodunda bir karakter dizisine erişim hatalı. Hatanın nedenini ve düzeltmesini açıklayınız.\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    char *ptr = str;\n    printf(\"Karakter: %c\\n\", *(ptr + 7)); // Hata burada\n    return 0;\n}\n```",
    "answer": "Kodda `*(ptr + 7)` ifadesi bir hata içermektedir. `str` dizisi `\"Merhaba\"` ifadesiyle 7 karakter (6 harf + 1 null terminatör) içerir, fakat dizideki geçerli indeksler 0 ile 6 arasındadır. `ptr + 7` ifadesi geçersiz bir bellek alanına erişmeye çalışır ve bu da belirsiz bir davranışa yol açabilir. Bu hatayı düzeltmek için `*(ptr + 6)` kullanmalıyız, bu da dizinin son elemanı olan null terminatörü ifade eder.\n\nDüzeltme:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    char *ptr = str;\n    printf(\"Karakter: %c\\n\", *(ptr + 6)); // Düzeltildi\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:39.746543"
  },
  {
    "question": "Aşağıdaki C kodunda bir dizi elemanlarını iki katına çıkarmak için pointer aritmetiği kullanılmıştır. Ancak kod çalıştığında beklenmedik sonuçlar veriyor. Hataları bul ve düzelt: \n\n#include <stdio.h>\n\nvoid doubleArray(int *arr, int size) {\n    for (int i = 0; i <= size; i++) {\n        *(arr + i) *= 2;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    doubleArray(numbers, 5);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    return 0;\n}",
    "answer": "Kodda döngü koşulunda 'i <= size' kullanılmış. Bu, dizinin boyutunun bir fazlasına erişmeye çalıştığı için bellek hatasına yol açar. Düzgün çalışması için 'i < size' olmalıdır. Düzeltme: `for (int i = 0; i < size; i++)` şeklinde olmalı. İşte düzeltilmiş kod: \n\n#include <stdio.h>\n\nvoid doubleArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        *(arr + i) *= 2;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    doubleArray(numbers, 5);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:58.131530"
  },
  {
    "question": "Aşağıdaki C kodu, bir stringin karakterlerini tersine çevirmeye çalışıyor. Ancak kod çalıştığında beklenilen sonuç alınamıyor. Hataları bul ve düzelt:\n\n#include <stdio.h>\n\nvoid reverseString(char *str) {\n    char *start = str;\n    char *end = str + strlen(str) - 1;\n    while (start < end) {\n        char temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    char str[] = \"hello\";\n    reverseString(str);\n    printf(\"Ters: %s\", str);\n    return 0;\n}",
    "answer": "Kodda 'strlen' fonksiyonu kullanılmasına rağmen, 'string.h' kütüphanesi dahil edilmemiş. Bu, derleme hatasına neden olur. Kodun en üstüne '#include <string.h>' eklenmeli. Düzeltme sonrasında kod şu şekilde görünmelidir:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char *str) {\n    char *start = str;\n    char *end = str + strlen(str) - 1;\n    while (start < end) {\n        char temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    char str[] = \"hello\";\n    reverseString(str);\n    printf(\"Ters: %s\", str);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:05:58.131781"
  },
  {
    "question": "Aşağıdaki kodda bir dizinin toplamını hesaplamak için bir fonksiyon tanımlandı. Ancak kod çalıştığında beklenmedik bir sonuç veriyor. Hatanın nedenini bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nvoid toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for(int i = 0; i <= boyut; i++) { // Hatalı döngü sınırı\n        toplam += *(dizi + i);\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    toplam(dizi, 5);\n    return 0;\n}",
    "answer": "Kodda, toplam fonksiyonu içindeki for döngüsünde 'i <= boyut' ifadesi kullanılmış. Ancak dizinin indeksi 0'dan başladığı için, 'boyut' değişkenin değeri 5 olduğunda, döngü 0'dan 5'e kadar dönecek ve dizinin 5. indeksine (yani dizi[5]) erişmeye çalışacak. Bu işlem, dizinin sınırlarını aşmakta ve tanımsız davranışa yol açmaktadır. Düzeltmek için döngü sınırını 'i < boyut' şeklinde değiştirmek gerekmektedir:\n\nfor(int i = 0; i < boyut; i++) {\n    toplam += *(dizi + i);\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:14.683452"
  },
  {
    "question": "Aşağıdaki C kodu, bir dizi elemanlarının tersini döndürmek için tasarlanmış. Ancak, dizinin son hali beklenenden farklı. Hatanın nedenini bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nvoid tersCevir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = *(dizi + i);\n        *(dizi + i) = *(dizi + boyut - 1 - i);\n        *(dizi + boyut - 1 - i) = temp;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    tersCevir(dizi, 5);\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}",
    "answer": "Bu kod doğru çalışıyor. Ancak, dizinin elemanlarını tersine çevirmek için 'boyut / 2' kullanılması yeterli. Bu durumda hata yok. Ancak dizinin değişim sürecinin yanlış olduğunu düşünüyorsanız, dizi değiştikten sonra çıktıyı kontrol edebilirsiniz. Ayrıca, dizinin eleman sayısını doğru girmeyi unutmayın. Eğer dizinin boyutu yanlış verilirse, beklenmedik sonuçlar alabilirsiniz. Kod çalıştığında '5 4 3 2 1' şeklinde olması gerekir. Herhangi bir hata yoksa, kodu gözden geçirerek kontrol edin.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:14.683746"
  },
  {
    "question": "Bir dizi içerisindeki elemanların toplamını bulmak için pointer aritmetiği nasıl kullanılabilir?",
    "answer": "Pointer aritmetiği, dizinin elemanlarına kolay erişim sağlamak için oldukça kullanışlıdır. Aşağıda basit bir örnek üzerinden açıklayalım:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int toplam = 0;\n    int *ptr = dizi; // Pointer, dizinin ilk elemanını işaret ediyor\n    for (int i = 0; i < 5; i++) {\n        toplam += *(ptr + i); // Pointer aritmetiği ile dizinin i'nci elemanına erişiyoruz\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu örnekte, `ptr` pointer'ı dizinin ilk elemanını işaret ediyor. Döngüde `*(ptr + i)` ifadesi, her iterasyonda `ptr`'ın gösterdiği bellek adresinden i kadar ileri giderek dizinin i'inci elemanına erişim sağlıyor. Bu şekilde dizi elemanlarını topluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:24.513473"
  },
  {
    "question": "Bir karakter dizisi (string) içindeki her karakteri bir pointer ile nasıl yazdırabiliriz?",
    "answer": "Pointer aritmetiği, karakter dizileri üzerinde işlem yapmak için de oldukça etkilidir. Aşağıdaki örnek, bir karakter dizisinin her bir karakterini pointer kullanarak nasıl yazdırabileceğimizi gösterir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    char *ptr = str; // Pointer, karakter dizisinin ilk elemanını işaret ediyor\n    while (*ptr != '\\0') { // Null karaktere (string sonunu belirten) kadar devam et\n        printf(\"%c \", *ptr); // Pointer ile gösterilen karakteri yazdır\n        ptr++; // Pointer'ı bir sonraki karaktere ilerlet\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu örnekte, `ptr` pointer'ı `str` dizisinin ilk karakterini işaret eder. `while` döngüsü, `*ptr` değeri null karaktere ulaşana kadar devam eder. Her iterasyonda `*ptr` ile o anki karakter yazdırılır ve `ptr++` ile pointer bir sonraki karaktere geçer. Bu şekilde karakter dizisinin tüm elemanları yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:24.513517"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını toplamak için bir pointer kullanarak nasıl bir çözüm geliştirebiliriz?",
    "answer": "Tamsayı dizisindeki elemanları toplamak için pointer aritmetiğinden yararlanabiliriz. Öncelikle bir tamsayı dizisi oluşturacağız ve bir pointer ile dizinin ilk elemanına işaret edeceğiz. Pointer'ı her adımda bir artırarak dizinin sonuna kadar gideceğiz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int *ptr = dizi;  // Pointer'ı dizinin ilk elemanına atıyoruz.\n    int toplam = 0;\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);  // Dizinin boyutunu hesaplıyoruz.\n\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(ptr + i);  // Pointer aritmetiği ile elemanları topluyoruz.\n    }\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\n\nBu kodda, `ptr` pointer'ı dizinin elemanlarını işaret eder ve `*(ptr + i)` ifadesi ile dizinin i. elemanına erişiyoruz. Bu şekilde, pointer aritmetiği ile dizinin elemanlarını topluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:41.991162"
  },
  {
    "question": "Bir karakter dizisinde belirli bir karakterin kaç kez geçtiğini bulmak için pointer aritmetiğinden nasıl yararlanabiliriz?",
    "answer": "Karakter dizisi üzerinde işlem yaparken, pointer aritmetiğini kullanarak belirli bir karakterin kaç kez geçtiğini hesaplayabiliriz. Aşağıdaki örnek, bir karakter dizisinde 'a' karakterinin sayısını bulmayı göstermektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char dizi[] = \"banana\";\n    char *ptr = dizi;  // Pointer'ı dizinin ilk elemanına atıyoruz.\n    int sayac = 0;\n\n    while (*ptr != '\\0') {  // Null karaktere kadar devam ediyoruz.\n        if (*ptr == 'a') {\n            sayac++;  // Eğer karakter 'a' ise sayacı artırıyoruz.\n        }\n        ptr++;  // Pointer'ı bir sonraki karaktere kaydırıyoruz.\n    }\n\n    printf(\"Karakter 'a' %d kez bulundu.\\n\", sayac);\n    return 0;\n}\n```\n\nBu kodda, `ptr` karakter dizisini işaret eder ve `*ptr` ile dizinin o anki karakterine erişiriz. `ptr++` ile pointer'ı bir sonraki karaktere kaydırarak döngü devam eder. Bu sayede, 'a' karakterinin toplam sayısını bulmuş oluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:41.991210"
  },
  {
    "question": "C dilinde bir dizi içindeki elemanların toplamını hesaplamak için pointer aritmetiğini nasıl kullanabilirim?",
    "answer": "Pointer aritmetiği ile bir dizinin elemanlarına erişmek için, dizinin başlangıç adresini tutan bir pointer kullanabiliriz. Örneğin, int türünden bir dizi tanımlayalım: \n\n```c\nint dizi[] = {1, 2, 3, 4, 5};\nint *ptr = dizi; // dizi'nin başlangıç adresini tutar\nint toplam = 0;\n\nfor (int i = 0; i < 5; i++) {\n    toplam += *(ptr + i); // Pointer aritmetiği ile elemanlara erişim\n}\n\nprintf(\"Toplam: %d\\n\", toplam);\n```\n\nBu kodda, `ptr` pointer'ı 'dizi' dizisinin başlangıç adresini tutar. `*(ptr + i)` ifadesi, dizi elemanlarına erişim sağlar. Bu, pointer aritmetiğinin temel kullanımını gösterir. Sonuç olarak toplam 15 olacaktır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:53.548099"
  },
  {
    "question": "Bir bağlı listeyi (linked list) oluştururken ve üzerinde işlem yaparken pointer aritmetiği nasıl kullanılır?",
    "answer": "Bağlı liste yapısında her düğüm (node), bir veri ve sonraki düğümün adresini tutar. Pointer aritmetiği burada dolaylı erişim için kullanılır. Örneğin basit bir bağlı liste yapısını ele alalım:\n\n```c\nstruct Node {\n    int veri;\n    struct Node *sonraki; // Sonraki düğümün adresini tutar\n};\n\nstruct Node* yeniDugum(int veri) {\n    struct Node* yeni = (struct Node*)malloc(sizeof(struct Node));\n    yeni->veri = veri;\n    yeni->sonraki = NULL;\n    return yeni;\n}\n\nvoid listeyiYazdir(struct Node *bas) {\n    struct Node *gecici = bas;\n    while (gecici != NULL) {\n        printf(\"%d \", gecici->veri);\n        gecici = gecici->sonraki; // Pointer aritmetiği ile sonraki düğüme geçiş\n    }\n}\n```\n\nYukarıdaki kodda `Node` yapısı, bir tamsayı veri ve bir sonraki düğümün adresini içerir. `listeyiYazdir` fonksiyonu, bağlı listedeki her düğümün verisini yazdırmak için `gecici` pointer'ını kullanır. `gecici = gecici->sonraki;` ifadesi, pointer aritmetiği ile bir sonraki düğüme geçişi sağlar. Bu, bağlı liste işlemlerinde pointer aritmetiğinin nasıl kullanıldığını gösterir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:06:53.548144"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını toplamak için bir fonksiyon yazın. Pointer aritmetiği kullanarak dizinin her bir elemanına erişin.",
    "answer": "#include <stdio.h>\n\nint diziTopla(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği ile dizi elemanına erişim\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int toplam = diziTopla(dizi, boyut);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n// Açıklama: Bu kodda 'diziTopla' fonksiyonu bir dizi ve boyutunu alır. Pointer aritmetiği kullanarak dizi elemanlarına erişilir ve toplam hesaplanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:05.777288"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için bir fonksiyon yazın. Pointer aritmetiği kullanarak dizinin elemanlarına erişin.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = *(str + i); // Pointer aritmetiği ile dizinin başlangıcından eleman al\n        *(str + i) = *(str + (uzunluk - 1 - i)); // Dizinin sonundan eleman al\n        *(str + (uzunluk - 1 - i)) = temp; // Geçici değişkeni kullanarak yer değiştir\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevrilmiş dizi: %s\\n\", str);\n    return 0;\n}\n\n// Açıklama: Bu kod da 'tersCevir' fonksiyonu bir karakter dizisini alır ve pointer aritmetiği ile dizinin elemanlarına erişerek diziyi ters çevirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:05.777336"
  },
  {
    "question": "Bir tamsayı dizisi oluşturun ve bu dizinin elemanlarını pointer aritmetiği kullanarak toplayın. Sonucu ekrana yazdırın.",
    "answer": "Aşağıdaki kod, bir tamsayı dizisi tanımlayıp, pointer aritmetiği ile bu dizinin elemanlarını toplamakta kullanılmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int toplam = 0;\n    int *ptr = dizi; // Dizi başlangıcına işaret eden pointer\n    \n    for (int i = 0; i < 5; i++) {\n        toplam += *(ptr + i); // Pointer aritmetiği ile elemanlara erişim\n    }\n    \n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", toplam);\n    return 0;\n}\n```\n\nBu kodda, `ptr` pointer'ı dizinin başlangıcını işaret ediyor. `*(ptr + i)` ifadesi ile `ptr` üzerinden dizinin elemanlarına erişiyoruz. Bu şekilde pointer aritmetiği kullanarak dizinin elemanlarını topluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:20.451976"
  },
  {
    "question": "Bir karakter dizisindeki harfleri tersine çeviren bir fonksiyon yazın. Pointer aritmetiği kullanarak karakterleri değiştirilmiş diziyi ekrana yazdırın.",
    "answer": "Aşağıdaki kod, bir karakter dizisini tersine çevirmek için bir fonksiyon kullanmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    char *baslangic = str;\n    char *son = str + uzunluk - 1;\n    char temp;\n    \n    while (baslangic < son) {\n        // Pointer aritmetiği ile karakterleri değiştir\n        temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    printf(\"Orijinal: %s\\n\", str);\n    tersCevir(str);\n    printf(\"Ters çevrilmiş: %s\\n\", str);\n    return 0;\n}\n```\n\nBu kodda, `tersCevir` fonksiyonu, verilen karakter dizisinin ilk ve son karakterlerinden başlayarak, bu karakterleri değiştirir. `baslangic` ve `son` pointer'ları ile dizinin başından ve sonundan elemanları döngü içinde değiştirerek, diziyi tersine çevirmiş oluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:20.452052"
  },
  {
    "question": "Bir tamsayı dizisinin en küçük ve en büyük elemanlarını bulan bir fonksiyon yazın. Pointer aritmetiğini kullanarak dizinin elemanlarına erişin.",
    "answer": "#include <stdio.h>\n#include <limits.h>\n\nvoid findMinMax(int *arr, int size, int *min, int *max) {\n    *min = INT_MAX;  // Başlangıçta en küçük sayı olarak en büyük int atanır\n    *max = INT_MIN;  // Başlangıçta en büyük sayı olarak en küçük int atanır\n    \n    for (int i = 0; i < size; i++) {\n        if (*(arr + i) < *min) {\n            *min = *(arr + i);  // Pointer aritmetiği ile dizi elemanına erişim\n        }\n        if (*(arr + i) > *max) {\n            *max = *(arr + i);\n        }\n    }\n}\n\nint main() {\n    int numbers[] = {5, 3, 8, 1, 4};\n    int min, max;\n    findMinMax(numbers, 5, &min, &max);\n    printf(\"En küçük: %d, En büyük: %d\\n\", min, max);\n    return 0;\n}\n\n// Açıklama: Bu kodda, tamsayı dizisinin en küçük ve en büyük elemanlarını bulmak için bir fonksiyon tanımlıyoruz. Pointer aritmetiği kullanarak dizinin elemanlarına erişiyoruz. Fonksiyon başlangıçta en küçük ve en büyük değerleri tanımlayıp, dizi içindeki elemanları kontrol ederek bu değerleri güncelliyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:31.280645"
  },
  {
    "question": "Bir karakter dizisinin içindeki tüm büyük harfleri küçük harflere dönüştüren bir fonksiyon yazın. Pointer aritmetiği ile dizinin elemanlarına erişin ve işlemi gerçekleştirin.",
    "answer": "#include <stdio.h>\n\nvoid toLowerCase(char *str) {\n    for (char *p = str; *p != '\\0'; p++) {\n        if (*p >= 'A' && *p <= 'Z') {\n            *p += 32;  // ASCII değerini kullanarak büyük harfi küçük harfe çevirme\n        }\n    }\n}\n\nint main() {\n    char str[] = \"HELLO WORLD\";\n    toLowerCase(str);\n    printf(\"Küçük harf: %s\\n\", str);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir karakter dizisindeki büyük harfleri küçük harflere dönüştürmek için bir fonksiyon kullanır. Pointer aritmetiği ile dizinin elemanlarına erişerek her bir karakter üzerinde işlem yapıyoruz. ASCII değerlerini kullanarak, büyük harfleri küçük harflere çeviriyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:31.280707"
  },
  {
    "question": "Bir dizi içerisindeki en büyük elemanı bulmak için yazılmış bir C fonksiyonu var. Ancak fonksiyon, dizinin elemanlarını geçerken pointer aritmetiğini verimsiz kullanıyor. Bu kodu inceleyip iyileştirmelerini önerir misiniz?",
    "answer": "Aşağıdaki C kodunu ele alalım:\n\n```c\nint find_max(int *array, int size) {\n    int max = *array;\n    for (int i = 1; i < size; i++) {\n        if (*(array + i) > max) {\n            max = *(array + i);\n        }\n    }\n    return max;\n}\n```\n\nBu kodda pointer aritmetiği kullanılarak dizi elemanlarına erişim sağlanıyor, ancak daha okunaklı ve verimli bir yöntemle optimize edilebilir. İşte iyileştirilmiş hali:\n\n```c\nint find_max(int *array, int size) {\n    int max = array[0]; // İlk elemanı al\n    for (int i = 1; i < size; i++) {\n        if (array[i] > max) { // Diziye doğrudan indeksle erişim\n            max = array[i];\n        }\n    }\n    return max;\n}\n```\n\nBu değişiklikle, kod daha anlaşılır hale gelir ve derleyicinin dizinin elemanlarına erişimi optimize etmesine olanak tanır. Ayrıca, dizinin ilk elemanını doğrudan erişimle alarak gereksiz pointer aritmetiğinden kaçınılmış olur.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:47.624131"
  },
  {
    "question": "Bir string içerisindeki karakterlerin sırasını tersine çevirmek için yazılmış bir C fonksiyonu mevcut. Ancak, pointer aritmetiği ile yapılırken hatalı bir şekilde çalışıyor. Kodun düzeltilmesi için önerilerde bulunur musunuz?",
    "answer": "Aşağıdaki C kodunu değerlendirelim:\n\n```c\nvoid reverse_string(char *str) {\n    char *start = str;\n    char *end = str;\n    while (*end != '\\0') {  // sonuna kadar git\n        end++;\n    }\n    end--;  // Null karakterden bir önceki konuma gel\n    while (start < end) {\n        char temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n```\n\nBu kod stringin sonuna kadar gidecek ve ardından karakterleri değiştirecektir. Ancak, bu işlem sırasında start ve end pointer'larının doğru şekilde yönetildiğinden emin olunmalıdır. İşte optimize edilmiş ve daha güvenli bir versiyon:\n\n```c\nvoid reverse_string(char *str) {\n    char *start = str;\n    char *end = str;\n    while (*end != '\\0') {  // sonuna kadar git\n        end++;\n    }\n    end--;  // Null karakterden bir önceki konuma gel\n    while (start < end) {\n        // Geçici karakter değişimi\n        char temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n```\n\nBurada, başlangıç ve bitiş pointer'larını doğru bir şekilde kullanarak dizinin her iki ucunu da kontrol edebiliyoruz. Bununla birlikte, kodun akışını daha iyi anlamak için yorum satırları eklemek de mantıklıdır. Kodun işleyişi daha anlaşılır hale gelir ve geliştiriciler için daha kolay takip edilebilir olur.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:07:47.624324"
  },
  {
    "question": "Bir dizinin elemanlarını tersine çeviren C dilinde pointer aritmetiği kullanan bir fonksiyon yazdım. Kodum aşağıdaki gibi: \n\n```c\nvoid reverseArray(int *arr, int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = *(arr + i);\n        *(arr + i) = *(arr + (size - i - 1));\n        *(arr + (size - i - 1)) = temp;\n    }\n}\n```\nBu kodun performansı ve okunabilirliği hakkında ne düşünüyorsunuz? Optimize etme önerileriniz var mı?",
    "answer": "Kodunuz genel hatlarıyla doğru ve işlevsel. Ancak, okunabilirlik açısından bazı iyileştirmeler yapılabilir. Öncelikle, pointer aritmetiği yerine dizinin doğrudan index'leri kullanmak, kodun daha anlaşılır olmasını sağlar. Ayrıca, bazı compiler'lar pointer aritmetiği kullanıldığında daha fazla optimizasyon yapabilir, ancak modern C derleyicileri genellikle bu tarz işlemleri optimize edebilir. \n\nAşağıdaki şekilde kodu güncelleyebilirsiniz:\n\n```c\nvoid reverseArray(int *arr, int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - i - 1];\n        arr[size - i - 1] = temp;\n    }\n}\n```\nBu güncelleme ile kod daha okunabilir hale geldi. Eğer performans önemliyse, `size` değeri bir kere hesaplandıktan sonra, sonsuz döngülerde `size`'i tekrar hesaplamaktan kaçınmak için `size - i - 1` ifadesini bir değişkene atayabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:08:06.866296"
  },
  {
    "question": "Bir C programında iki farklı dizi arasındaki ortak elemanları bulmak için bir fonksiyon yazdım. Fonksiyonum şu şekilde:\n\n```c\nvoid findCommonElements(int *arr1, int *arr2, int size1, int size2) {\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            if (*(arr1 + i) == *(arr2 + j)) {\n                printf(\"Common Element: %d\\n\", *(arr1 + i));\n            }\n        }\n    }\n}\n```\nBu kodda performans açısından bir sorun var mı? Nasıl optimize edebilirim?",
    "answer": "Kodunuzda iki iç içe döngü kullanarak dizilerdeki ortak elemanları buluyorsunuz. Bu, O(n*m) karmaşıklığa sahip ve büyük diziler için performans sorunlarına yol açabilir. Eğer diziler sıralı değilse, bu yaklaşım kaçınılmazdır, ancak daha iyi bir performans için başka yollar düşünebilirsiniz. \n\nÖrneğin, bir diziyi bir hash set'e ekleyerek, diğer dizideki elemanları daha hızlı bulabilirsiniz. İşte bu yaklaşımı gösteren bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid findCommonElements(int *arr1, int *arr2, int size1, int size2) {\n    bool *hashTable = (bool *)calloc(1000, sizeof(bool)); // Eleman aralığına göre boyut ayarlayın\n\n    for (int i = 0; i < size1; i++) {\n        hashTable[arr1[i]] = true; // Elemanları hash'le\n    }\n\n    for (int j = 0; j < size2; j++) {\n        if (hashTable[arr2[j]]) {\n            printf(\"Common Element: %d\\n\", arr2[j]);\n        }\n    }\n\n    free(hashTable); // Belleği serbest bırakın\n}\n```\nBu kodda, ilk diziyi bir hash table'a ekleyip, ikinci dizideki elemanların bu hash table'da bulunup bulunmadığını kontrol ediyoruz. Bu, O(n+m) karmaşıklığına sahip olup, daha verimli bir çözüm sunuyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-05-31T17:08:06.866444"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak iki sayının toplanmasını sağlayan bir işlev işaretçisi oluşturun.",
    "answer": "#include <stdio.h>\n\n// Toplama işlemini gerçekleştiren fonksiyon\nint topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    // Fonksiyon işaretçisi tanımlıyoruz\n    int (*islem)(int, int);\n    // Fonksiyon işaretçisini topla fonksiyonuna atıyoruz\n    islem = topla;\n    int sonuc = islem(3, 5); // Burada fonksiyon işaretçisini kullanıyoruz\n    printf(\"Sonuç: %d\\n\", sonuc); // Sonucu ekrana yazdırıyoruz\n    return 0;\n}\n\n// Açıklama: Bu kod, topla fonksiyonunu işaretçi olarak kullanarak iki sayıyı toplar. Fonksiyon işaretçileri, fonksiyonları değişken gibi kullanmamıza olanak tanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:17.774442"
  },
  {
    "question": "Aşağıdaki eksik kodda, verilen bir sayının karesini hesaplayan bir fonksiyon tanımlayarak fonksiyon işaretçisini kullanın.",
    "answer": "#include <stdio.h>\n\n// Karekök hesaplayan fonksiyon\nint kare(int x) {\n    return x * x;\n}\n\nint main() {\n    // Fonksiyon işaretçisi tanımlıyoruz\n    int (*islem)(int);\n    // Fonksiyon işaretçisini kare fonksiyonuna atıyoruz\n    islem = kare;\n\n    int sayi = 7;\n    int sonuc = islem(sayi); // Fonksiyon işaretçisini kullanarak sayının karesini hesaplıyoruz\n    printf(\"%d sayısının karesi: %d\\n\", sayi, sonuc); // Sonucu ekrana yazdırıyoruz\n    return 0;\n}\n\n// Açıklama: Bu kod, kare fonksiyonunu kullanarak bir sayının karesini hesaplar. Fonksiyon işaretçileri sayesinde fonksiyonları daha esnek bir şekilde kullanabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:17.774490"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, bir matematik işlemi yapmak için fonksiyon işaretçilerini kullanın. Verilen iki sayının toplamını ve farkını hesaplayan fonksiyonlar tanımlayın. Ana fonksiyonda bu fonksiyonları çağırarak sonuçları yazdırın.",
    "answer": "#include <stdio.h>\n\n// Toplama işlemi\nint toplama(int a, int b) {\n    return a + b;\n}\n\n// Çıkarma işlemi\nint cikarma(int a, int b) {\n    return a - b;\n}\n\nint main() {\n    // Fonksiyon işaretçisi tanımı\n    int (*islem)(int, int);\n    int a = 10, b = 5;\n\n    // Toplama işlemi için işaretçiyi ayarlama\n    islem = toplama;\n    printf(\"Toplam: %d\\n\", islem(a, b));\n\n    // Çıkarma işlemi için işaretçiyi ayarlama\n    islem = cikarma;\n    printf(\"Fark: %d\\n\", islem(a, b));\n\n    return 0;\n}\n\n// Açıklama: Bu kodda, iki farklı matematik işlemi (toplama ve çıkarma) gerçekleştiren iki fonksiyon tanımlanmıştır. Fonksiyon işaretçisi kullanılarak, her iki işlem de ana fonksiyonda çağrılmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:31.574676"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak, bir dizi üzerinde farklı işlemler gerçekleştiren fonksiyon işaretçilerini kullanın. Dizi elemanlarını iki katına çıkaran ve dizi elemanlarının toplamını hesaplayan fonksiyonları tanımlayın. Bu fonksiyonları ana fonksiyonda çağırarak sonuçları gösterin.",
    "answer": "#include <stdio.h>\n\n// Dizi elemanlarını iki katına çıkarma\nvoid ikiKatina(double *dizi, int boyut) {\n    for(int i = 0; i < boyut; i++) {\n        dizi[i] *= 2;\n    }\n}\n\n// Dizi elemanlarının toplamını hesaplama\ndouble toplam(double *dizi, int boyut) {\n    double toplam = 0;\n    for(int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    double sayilar[] = {1.0, 2.0, 3.0, 4.0};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n\n    // Fonksiyon işaretçisi tanımı\n    void (*diziIslemi)(double *, int);\n    double (*toplamIslemi)(double *, int);\n\n    // Dizi elemanlarını iki katına çıkarma\n    diziIslemi = ikiKatina;\n    diziIslemi(sayilar, boyut);\n\n    // Dizi elemanlarının toplamını hesaplama\n    toplamIslemi = toplam;\n    double sonuc = toplamIslemi(sayilar, boyut);\n\n    printf(\"Dizinin elemanlarının toplamı: %f\\n\", sonuc);\n\n    return 0;\n}\n\n// Açıklama: Bu kodda bir dizi üzerinde işlem yapan iki fonksiyon tanımlanmıştır. Fonksiyon işaretçileri, dizinin elemanlarını iki katına çıkarma ve toplamını hesaplama işlemlerini gerçekleştirmek için kullanılmıştır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:31.574761"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak bir dizi üzerinde farklı matematiksel işlemleri gerçekleştiren bir işlev işaretçisi uygulayın. İşlev işaretçisi kullanarak toplama, çıkarma ve çarpma işlemlerinin nasıl gerçekleştirileceğini gösterin.",
    "answer": "#include <stdio.h>\n\n// İşlev türü tanımı\ntypedef int (*math_func)(int, int);\n\n// Toplama işlemi\nint add(int a, int b) {\n    return a + b;\n}\n\n// Çıkarma işlemi\nint subtract(int a, int b) {\n    return a - b;\n}\n\n// Çarpma işlemi\nint multiply(int a, int b) {\n    return a * b;\n}\n\n// İşlev işaretçilerini kullanarak işlemleri gerçekleştiren fonksiyon\nvoid perform_operations(int a, int b, math_func operation) {\n    printf(\"Sonuç: %d\\n\", operation(a, b));\n}\n\nint main() {\n    int x = 10, y = 5;\n    perform_operations(x, y, add);        // Toplama\n    perform_operations(x, y, subtract);   // Çıkarma\n    perform_operations(x, y, multiply);   // Çarpma\n    return 0;\n}\n\n// Açıklama: Yukarıdaki kodda, fonksiyon işaretçileri sayesinde farklı matematiksel işlemler tanımlanmış ve bu işlemler perform_operations fonksiyonu aracılığıyla çağrılmıştır. Bu yaklaşım, kodun daha modüler ve esnek olmasını sağlar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:51.541243"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak bir C programı oluşturun. Bu program, verilen bir dizi üzerinde işlev işaretçileri kullanarak sıralama işlemleri (bubble sort ve selection sort) gerçekleştirsin. Kullanıcıdan hangi sıralama yönteminin kullanılacağına dair seçim alın.",
    "answer": "#include <stdio.h>\n\n// İşlev türü tanımı\ntypedef void (*sort_func)(int[], int);\n\n// Bubble Sort algoritması\nvoid bubble_sort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\n// Selection Sort algoritması\nvoid selection_sort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\n// Sıralama işlemini gerçekleştiren fonksiyon\nvoid sort_array(int arr[], int n, sort_func sort_method) {\n    sort_method(arr, n);\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int choice;\n\n    printf(\"Sıralama yöntemi seçin (1 = Bubble Sort, 2 = Selection Sort): \");\n    scanf(\"%d\", &choice);\n\n    if (choice == 1) {\n        sort_array(arr, n, bubble_sort);\n    } else if (choice == 2) {\n        sort_array(arr, n, selection_sort);\n    } else {\n        printf(\"Geçersiz seçim!\\n\");\n        return 1;\n    }\n\n    printf(\"Sıralanmış dizi: \\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu kodda, kullanıcıdan hangi sıralama algoritmasının kullanılacağına dair bir seçim alınıyor. İşlev işaretçileri sayesinde, farklı sıralama algoritmaları dinamik olarak çağrılarak uygulanabiliyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:08:51.541324"
  },
  {
    "question": "Bir işlev işaretçisi tanımlandı, ancak işlev çağrısında geçersiz bir işlev işaretçisi kullanıldı. Kodum şöyle: \n\n```c\n#include <stdio.h>\n\nvoid toplama(int a, int b) {\n    printf(\"Toplam: %d\\n\", a + b);\n}\n\nint main() {\n    void (*islevPtr)(int, int);\n    islevPtr = NULL; // İşlev işaretçisi NULL olarak ayarlandı\n    islevPtr(5, 10); // Bu satırda hata çıkacak\n    return 0;\n}\n``` \nBu hatayı nasıl düzeltebilirim?",
    "answer": "Kodda işlev işaretçisi 'islevPtr' NULL olarak ayarlandığı için işlev çağrısı sırasında geçersiz bir işlev işaretçisi kullanılmış oluyor. Bu durumda, işlev işaretçisini geçerli bir işlevle ilişkilendirmemiz gerekiyor. Aşağıdaki gibi düzeltebilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid toplama(int a, int b) {\n    printf(\"Toplam: %d\\n\", a + b);\n}\n\nint main() {\n    void (*islevPtr)(int, int);\n    islevPtr = toplama; // İşlev işaretçisi toplama işlevine atanıyor\n    islevPtr(5, 10); // Artık işlev çağrısı geçerli\n    return 0;\n}\n```\nBöylece, islevPtr artık toplama işlevine işaret eder ve çağrıldığında beklenen sonucu verecektir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:05.326095"
  },
  {
    "question": "Aşağıdaki kodda işlev işaretçisinin yanlış kullanımı nedeniyle beklenmeyen bir çıktı alıyorum:\n\n```c\n#include <stdio.h>\n\nvoid carpma(int a, int b) {\n    printf(\"Çarpım: %d\\n\", a * b);\n}\n\nvoid islemYap(void (*islev)(int, int), int x, int y) {\n    islev(x, y);\n}\n\nint main() {\n    islemYap(carpma, 5); // Burada sadece bir argüman veriliyor\n    return 0;\n}\n``` \nBu hatayı nasıl düzeltebilirim?",
    "answer": "Kodda 'islemYap' fonksiyonuna işlev işaretçisi olarak 'carpma' veriliyor, ancak 'carpma' işlevi iki argüman alıyor ve 'islemYap' fonksiyonu da iki argüman alıyor. Ancak 'main' fonksiyonunda 'islemYap' çağrısında yalnızca bir argüman (5) veriliyor. Bu durum bir hata oluşturuyor. Aşağıdaki gibi düzeltebilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid carpma(int a, int b) {\n    printf(\"Çarpım: %d\\n\", a * b);\n}\n\nvoid islemYap(void (*islev)(int, int), int x, int y) {\n    islev(x, y);\n}\n\nint main() {\n    islemYap(carpma, 5, 10); // İki argüman verildi\n    return 0;\n}\n```\nArtık 'islemYap' fonksiyonu 'carpma' işlevini doğru bir şekilde çağıracak ve beklenen çıktıyı verecektir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:05.326223"
  },
  {
    "question": "Aşağıdaki C kodunda bir hata var. Hatanın kaynağını bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nvoid add(int a, int b) {\n    printf(\"Toplam: %d\\n\", a + b);\n}\n\nvoid subtract(int a, int b) {\n    printf(\"Fark: %d\\n\", a - b);\n}\n\nint main() {\n    void (*operation)(int, int);\n    operation = add;\n    operation(5, 3);\n    operation = subtract;\n    operation(5, 3);\n    return 0;\n}",
    "answer": "Bu kodda görünürde bir hata yok, ancak kodda işlev işaretçisinin nasıl çalıştığını anlamak önemli. İşlev işaretçisini tanımladıktan sonra, işlev atamasını yapmamız gerekiyor. Kod doğru çalışıyor ve \"Toplam: 8\" ve \"Fark: 2\" çıktısını veriyor. Ancak, işlev işaretçisini kullanmayı öğrenmek için daha karmaşık bir senaryo ekleyebiliriz. Örneğin, kullanıcıdan hangi işlemi gerçekleştirmek istediğini sorabiliriz ve buna göre işlev işaretçisini atayabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:18.482912"
  },
  {
    "question": "Aşağıdaki C kodunda işlev işaretçileri kullanarak bir dizi üzerinde işlem yapmaya çalıştım, fakat kod hata veriyor. Hatanın sebebini bul ve düzelt. Kod: \n\n#include <stdio.h>\n\nvoid doubleValue(int *n) {\n    *n *= 2;\n}\n\nvoid squareValue(int *n) {\n    *n *= *n;\n}\n\nint main() {\n    void (*funcPtr)(int *);\n    int array[3] = {1, 2, 3};\n\n    for(int i = 0; i < 3; i++) {\n        funcPtr = doubleValue;\n        funcPtr(&array[i]);\n        funcPtr = squareValue;\n        funcPtr(&array[i]);\n    }\n\n    for(int j = 0; j < 3; j++) {\n        printf(\"%d \", array[j]);\n    }\n    return 0;\n}",
    "answer": "Bu kodda, işlev işaretçisinin her iki işlev için sırasıyla atanması yapılıyor, ancak her döngü iterasyonunda her iki işlev de aynı değişken üzerinde çalıştığı için beklenmeyen sonuçlar elde ediliyor. Örneğin, ilk başta sayı 1 iken önce iki katı alınıp daha sonra karesi alındığında sonuç 4 olacaktır. Bu işlem her döngüde değişkenin önce iki katına çıkmasına ve ardından karesine neden olur. Çözüm olarak, işlev işaretçisinin atamasını döngü içinde yapmamak ve her bir işlevi ayrı bir döngüde çağırmak daha iyi olacaktır. Örneğin: \n\nfor (int i = 0; i < 3; i++) {\n    funcPtr = doubleValue;\n    funcPtr(&array[i]);\n}\n\nfor (int i = 0; i < 3; i++) {\n    funcPtr = squareValue;\n    funcPtr(&array[i]);\n} \n\nBu şekilde her işlevin sonucu net bir şekilde elde edilecektir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:18.483112"
  },
  {
    "question": "Aşağıdaki kodda, function pointer kullanılarak iki sayının toplamını döndüren bir işlev tanımlanmıştır. Ancak kod çalışmıyor. Hata nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int (*func_ptr)(int, int);\n    func_ptr = add;\n    int result = func_ptr(5);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda, `func_ptr` işlev göstergesi tanımlanmış ve `add` işlevi ile ilişkilendirilmiştir. Ancak, `func_ptr(5)` çağrısında ikinci bir argüman verilmemiştir. `add` işlevi iki argüman alırken, burada yalnızca bir tanesi sağlanıyor. Bu nedenle, doğru çağrı `func_ptr(5, 10)` şeklinde olmalıdır. Düzgün bir şekilde çalışması için şu şekilde düzeltilmelidir:\n\n```c\nint result = func_ptr(5, 10);\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:30.236470"
  },
  {
    "question": "Aşağıdaki C koduyla ilgili bir hata bulunmakta. Kodun amacı, iki sayıyı çarpan bir işlev tanımlayıp, function pointer ile bu işlevi çağırmaktır. Ancak kod çalışmadığında beklenen sonucu veremiyor. Hata nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint multiply(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    int (*func_ptr)(int, int);\n    int result;\n    func_ptr = multiply;\n    result = func_ptr(4);\n    printf(\"Çarpım: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda, `func_ptr` işlev göstergesi `multiply` işlevine atanmış. Ancak, `result = func_ptr(4);` satırında yalnızca bir argüman verilmiş ve `multiply` işlevi iki sayıyı çarpan bir fonksiyondur. Bu durumda, iki argümanı da sağlamamız gerekiyor. Doğru çağrı `result = func_ptr(4, 5);` şeklinde olmalıdır. İşte düzeltilmiş hali:\n\n```c\nresult = func_ptr(4, 5);\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:30.236614"
  },
  {
    "question": "Function pointer nedir ve neden kullanılır?",
    "answer": "Function pointer, C dilinde bir fonksiyonun adresini tutan bir işaretçidir. Fonksiyon işaretçileri, belirli bir fonksiyonu çağırmak için kullanılabilir. Örneğin, bir dizi içinde birden fazla fonksiyonun adreslerini tutarak, daha dinamik ve esnek bir yapı kurabiliriz. Ayrıca, callback fonksiyonları için de kullanışlıdır. Örneğin, bir sort fonksiyonuna farklı karşılaştırma fonksiyonları geçirebilmek için kullanabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:41.515452"
  },
  {
    "question": "Fonksiyon işaretçilerini kullanarak basit bir hesap makinesi uygulaması nasıl yapılır?",
    "answer": "Fonksiyon işaretçileri ile basit bir hesap makinesi yapmak için, önce toplama, çıkarma, çarpma ve bölme işlemleri için fonksiyonlar tanımlayabiliriz. Ardından, bu fonksiyonların adreslerini bir işaretçi dizisinde saklayarak kullanıcıdan hangi işlemi yapmak istediğini sorabiliriz. Aşağıda basit bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\n// Fonksiyon tanımları\nint toplama(int a, int b) { return a + b; }\nint cikarma(int a, int b) { return a - b; }\nint carpma(int a, int b) { return a * b; }\nint bolme(int a, int b) { return a / b; }\n\nint main() {\n    // Fonksiyon işaretçileri için bir dizi\n    int (*islem[4])(int, int) = {toplama, cikarma, carpma, bolme};\n    int a, b, secim;\n\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    printf(\"Yapmak istediğiniz işlemi seçin (0: Toplama, 1: Çıkarma, 2: Çarpma, 3: Bölme): \");\n    scanf(\"%d\", &secim);\n\n    // Fonksiyonu çağırma\n    int sonuc = islem[secim](a, b);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\n\nBu örnekte, kullanıcı iki sayı ve bir işlem seçiyor. Fonksiyon işaretçileri sayesinde, seçilen işleme uygun fonksiyon dinamik olarak çağrılıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:41.515495"
  },
  {
    "question": "Function pointerlar ile bir dizi içerisindeki sayıların toplamını hesaplayan bir fonksiyon nasıl yazılır?",
    "answer": "Öncelikle, bir fonksiyon göstergesi (function pointer) tanımlamamız gerekiyor. Bu gösterge, belirli bir fonksiyonun adresini tutacak. Örneğin, toplam işlemi için bir fonksiyon tanımlayalım:\n\n```c\n#include <stdio.h>\n\nint toplam(int a, int b) {\n    return a + b;\n}\n```\nSonrasında, bu fonksiyonun adresini tutacak bir gösterge tanımlayalım:\n```c\nint (*functionPointer)(int, int);\n```\nŞimdi, işlev göstericimizi toplam fonksiyonuna atayalım:\n```c\nfunctionPointer = toplam;\n```\nArtık, bir dizi içerisindeki tüm sayıların toplamını hesaplamak için bu göstericiyi kullanabiliriz. İşte bir örnek:\n\n```c\nvoid diziToplam(int *dizi, int boyut, int (*topla)(int, int)) {\n    int toplamSonuc = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplamSonuc = topla(toplamSonuc, dizi[i]);\n    }\n    printf(\"Toplam: %d\\n\", toplamSonuc);\n}\n```\nBurada, diziToplam fonksiyonu bir diziyi ve dizinin boyutunu alır, ardından her bir elemanı toplam fonksiyonunu kullanarak toplar. Örneği birleştirirsek:\n\n```c\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    functionPointer = toplam;\n    diziToplam(dizi, boyut, functionPointer);\n    return 0;\n}\n```\nBu kod parçası, dizi içerisindeki sayıların toplamını hesaplar ve ekrana yazdırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:58.502618"
  },
  {
    "question": "Birden fazla matematiksel işlemi gerçekleştiren bir programda function pointerlar nasıl kullanılır?",
    "answer": "Matematiksel işlemleri gerçekleştiren bir program yazmak için, çeşitli işlemler (toplama, çıkarma, çarpma vb.) için fonksiyonlar tanımlayabiliriz. Daha sonra, bu fonksiyonların adreslerini tutacak bir fonksiyon gösterici kullanarak işlemleri dinamik bir şekilde çağırabiliriz. Öncelikle işlemleri gerçekleştiren fonksiyonları tanımlayalım:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint cikarma(int a, int b) {\n    return a - b;\n}\n\nint carpma(int a, int b) {\n    return a * b;\n}\n```\nŞimdi, işlemleri yapmak için bir fonksiyon göstericisi tanımlayalım:\n```c\nint (*islem)(int, int);\n```\nSonrasında, kullanıcıdan hangi işlemi yapmak istediğini alacak ve uygun fonksiyonu seçeceğiz:\n```c\nint main() {\n    int a = 10, b = 5;\n    char islemSecimi;\n\n    printf(\"Yapmak istediğiniz işlemi seçiniz (t: toplama, c: çıkarma, m: çarpma): \");\n    scanf(\" %c\", &islemSecimi);\n\n    switch (islemSecimi) {\n        case 't':\n            islem = toplama;\n            break;\n        case 'c':\n            islem = cikarma;\n            break;\n        case 'm':\n            islem = carpma;\n            break;\n        default:\n            printf(\"Geçersiz seçim!\\n\");\n            return 1;\n    }\n\n    int sonuc = islem(a, b);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu programda, kullanıcıdan hangi matematiksel işlemi yapmak istediğini alıyoruz. Ardından, seçilen işleme göre fonksiyon göstericimizi uygun fonksiyona yönlendiriyoruz. Son olarak, seçilen fonksiyonu çağırarak sonucun ekrana yazdırılmasını sağlıyoruz. Bu şekilde, function pointerlar sayesinde kodumuzda esneklik ve dinamik bir yapı elde ediyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:09:58.502662"
  },
  {
    "question": "C dilinde bir dizi üzerinde farklı matematiksel işlemleri gerçekleştiren bir fonksiyon yazmak istiyorum. Bu işlemler için function pointer kullanarak bir yapı oluşturabilir misin?",
    "answer": "Evet, function pointerlar kullanarak bir dizi üzerinde farklı matematiksel işlemler gerçekleştirebiliriz. Öncelikle, işlemleri temsil edecek fonksiyonları tanımlayalım. Örneğin, toplama, çıkarma ve çarpma işlemleri için fonksiyonlar yazalım:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint cikarma(int a, int b) {\n    return a - b;\n}\n\nint carpma(int a, int b) {\n    return a * b;\n}\n```\n\nŞimdi bir function pointer türü tanımlayalım:\n\n```c\ntypedef int (*IslemFonksiyonu)(int, int);\n```\n\nDaha sonra, bir fonksiyon yazarak dizi üzerinde bu işlemleri uygulayabiliriz. Aşağıda bir diziye toplama, çıkarma ve çarpma işlemlerini uygulayan bir örnek verilmiştir:\n\n```c\nvoid diziIslemleri(int *dizi, int boyut, IslemFonksiyonu islem) {\n    for (int i = 0; i < boyut - 1; i++) {\n        dizi[i] = islem(dizi[i], dizi[i + 1]);\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n\n    diziIslemleri(dizi, boyut, toplama);\n\n    printf(\"Toplama Sonucu: \");\n    for (int i = 0; i < boyut - 1; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\nBu kod, toplama işlemi gerçekleştirecek ve çıktıyı alacaktır. Fonksiyon pointerını değiştirerek çıkarma veya çarpma işlemleri de yapılabilir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:10:17.671205"
  },
  {
    "question": "Bir oyun motorunda farklı türde nesneler (örneğin, düşman ve dost karakterler) ile etkileşim sağlayan bir sistem geliştirmek istiyorum. Bu sistemde function pointer kullanarak nesnelerin davranışlarını nasıl özelleştirebilirim?",
    "answer": "Oyun motorunda farklı nesnelerin davranışlarını özelleştirmek için function pointerlar harika bir çözüm olabilir. İlk olarak, her nesne türü için bir yapı tanımlayabiliriz. Bu yapı, nesnenin davranışlarını belirlemek için kullanılacak function pointerları içerebilir:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*hareket)();\n    void (*salvo)();\n} Nesne;\n```\n\nŞimdi, dost ve düşman karakterler için bu yapı ile fonksiyonlar tanımlayalım:\n\n```c\nvoid dostHareket() {\n    printf(\"Dost karakter hareket ediyor.\\n\");\n}\n\nvoid dostSalvo() {\n    printf(\"Dost karakter ateş ediyor.\\n\");\n}\n\nvoid dusmanHareket() {\n    printf(\"Düşman karakter hareket ediyor.\\n\");\n}\n\nvoid dusmanSalvo() {\n    printf(\"Düşman karakter ateş ediyor.\\n\");\n}\n```\n\nŞimdi her nesne için bir yapı örneği oluşturalım ve fonksiyon pointerlarını atayalım:\n\n```c\nint main() {\n    Nesne dost = {dostHareket, dostSalvo};\n    Nesne dusman = {dusmanHareket, dusmanSalvo};\n\n    // Dost karakterin hareket etmesi ve ateş etmesi\n    dost.hareket();\n    dost.salvo();\n\n    // Düşman karakterin hareket etmesi ve ateş etmesi\n    dusman.hareket();\n    dusman.salvo();\n\n    return 0;\n}\n```\n\nBu kod, dost ve düşman karakterlerin hareket etme ve ateş etme davranışlarını özelleştirir. Fonksiyonları değiştirmek, yeni nesne türleri eklemek için sadece yeni fonksiyonlar tanımlamamız yeterli olacaktır. Bu şekilde, oyun motorundaki nesneleri daha esnek bir şekilde yönetebiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:10:17.671278"
  },
  {
    "question": "C dilinde iki sayının toplanması için bir fonksiyon tanımlayın ve bu fonksiyonu bir function pointer ile çağırın. Örneğin, toplama işlemini gerçekleştiren bir fonksiyon ve bu fonksiyonu gösteren bir pointer oluşturarak sonucu yazdırın.",
    "answer": "Aşağıdaki kod, iki sayının toplamını hesaplamak için bir fonksiyon tanımlar ve bu fonksiyonu bir function pointer ile çağırır:\n\n```c\n#include <stdio.h>\n\n// Toplama işlemi yapan fonksiyon\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    // Fonksiyon pointer'ı tanımlama\n    int (*islem)(int, int);\n    // Fonksiyon pointer'ına toplama fonksiyonunu atama\n    islem = toplama;\n    \n    int sonuc = islem(5, 10); // Fonksiyon pointer'ı ile fonksiyonu çağırma\n    printf(\"Sonuç: %d\\n\", sonuc); // Sonucu yazdırma\n    return 0;\n}\n```\nBu kodda, `toplama` adlı bir fonksiyon tanımlıyoruz. `islem` adlı bir function pointer oluşturuyoruz ve bu pointer'ı `toplama` fonksiyonunun adresi ile ilişkilendiriyoruz. Daha sonra `islem` pointer'ını kullanarak toplama işlemi yapıyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:10:39.550281"
  },
  {
    "question": "C dilinde bir dizi üzerinde çeşitli işlemler yapmak için bir function pointer kullanarak örnek bir uygulama geliştirin. Örneğin, bir dizideki elemanları sıralamak için bir fonksiyon ve bu fonksiyonu function pointer ile çağırın.",
    "answer": "Aşağıdaki kod, bir dizi üzerinde sıralama işlemi yapmak için bir fonksiyon tanımlar ve bu fonksiyonu bir function pointer ile çağırır:\n\n```c\n#include <stdio.h>\n\n// Dizi sıralama fonksiyonu (bubble sort)\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    // Fonksiyon pointer'ı tanımlama\n    void (*siralamaFonksiyonu)(int*, int);\n    // Fonksiyon pointer'ına sıralama fonksiyonunu atama\n    siralamaFonksiyonu = sirala;\n    \n    int dizi[] = {5, 3, 8, 1, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    \n    // Önce diziyi yazdırma\n    printf(\"Sıralamadan önce:\\n\");\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    \n    // Function pointer'ı ile sıralama fonksiyonunu çağırma\n    siralamaFonksiyonu(dizi, boyut);\n    \n    // Sıralandıktan sonra diziyi yazdırma\n    printf(\"Sıralandıktan sonra:\\n\");\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kodda, `sirala` adlı bir fonksiyon tanımlıyoruz. Bu fonksiyon, verilen bir diziyi sıralamak için kullanılan bir algoritmayı içeriyor. `siralamaFonksiyonu` adlı bir function pointer oluşturuyoruz ve bu pointer'ı `sirala` fonksiyonunun adresi ile ilişkilendiriyoruz. Daha sonra bu pointer'ı kullanarak diziyi sıralıyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:10:39.550356"
  },
  {
    "question": "Bir dizi içindeki tüm sayılara verilen bir fonksiyonu uygulayan bir C programı yazın. Bu programda function pointer kullanarak işlemleri dinamik olarak belirleyin. Örneğin, dizideki her sayının karesini alacak ve toplamını hesaplayacak bir fonksiyon tanımlayın.",
    "answer": "Aşağıdaki C kodu, bir dizi içindeki sayılara verilen bir fonksiyonu uygulamak için function pointer kullanır. 'applyFunction' fonksiyonu, dizi elemanlarına belirlenen işlemi uygular.\n\n```c\n#include <stdio.h>\n\n// Sayının karesini hesaplayan fonksiyon\nint square(int x) {\n    return x * x;\n}\n\n// Dizi elemanlarına verilen fonksiyonu uygulayan fonksiyon\nvoid applyFunction(int *arr, int size, int (*func)(int)) {\n    for (int i = 0; i < size; i++) {\n        arr[i] = func(arr[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    applyFunction(numbers, size, square);\n\n    // Sonuçları yazdır\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\nBu kodda, 'square' fonksiyonu bir sayının karesini döner. 'applyFunction' fonksiyonu ise verilen bir dizi ve boyut ile çağrılır. İkinci parametre olarak function pointer olan 'func' kullanarak, dizideki her elemanı fonksiyona gönderir ve sonuçları dizi üzerinde günceller.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:11:45.869058"
  },
  {
    "question": "Farklı matematiksel işlemleri (toplama, çıkarma, çarpma, bölme) yapan fonksiyonları tanımlayın. Ardından bu fonksiyonları dinamik olarak seçebileceğiniz bir menü oluşturarak kullanıcıdan iki sayı alıp sonucu hesaplayan bir program yazın. Function pointer kullanarak işlemleri gerçekleştirin.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan iki sayı alır ve seçilen matematiksel işlemi gerçekleştirir. Function pointer kullanarak işlemler dinamik olarak tanımlanır.\n\n```c\n#include <stdio.h>\n\n// Toplama işlemi\nfloat add(float a, float b) {\n    return a + b;\n}\n\n// Çıkarma işlemi\nfloat subtract(float a, float b) {\n    return a - b;\n}\n}\n\n// Çarpma işlemi\nfloat multiply(float a, float b) {\n    return a * b;\n}\n\n// Bölme işlemi\nfloat divide(float a, float b) {\n    if (b != 0) {\n        return a / b;\n    } else {\n        printf(\"Sıfıra bölme hatası!\\n\");\n        return 0;\n    }\n}\n\nint main() {\n    float a, b;\n    int choice;\n    float (*operation)(float, float);\n\n    printf(\"İki sayı girin: \");\n    scanf(\"%f %f\", &a, &b);\n\n    printf(\"Yapmak istediğiniz işlemi seçin:\\n1. Toplama\\n2. Çıkarma\\n3. Çarpma\\n4. Bölme\\nSeçiminiz: \");\n    scanf(\"%d\", &choice);\n\n    switch (choice) {\n        case 1:\n            operation = add;\n            break;\n        case 2:\n            operation = subtract;\n            break;\n        case 3:\n            operation = multiply;\n            break;\n        case 4:\n            operation = divide;\n            break;\n        default:\n            printf(\"Geçersiz seçim!\\n\");\n            return 1;\n    }\n\n    float result = operation(a, b);\n    printf(\"Sonuç: %.2f\\n\", result);\n\n    return 0;\n}\n```\n\nBu kodda, kullanıcıdan iki sayı ve bir işlem seçimi alınıyor. 'operation' pointer'ı, seçilen işlemi temsil eden fonksiyona atanıyor ve ardından bu fonksiyon çağrılarak sonuç hesaplanıyor. Böylece farklı işlemler dinamik olarak uygulanabiliyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:11:45.869151"
  },
  {
    "question": "Bir dizi içerisindeki sayıların toplamını, farklı toplama yöntemleri kullanarak hesaplamak için bir fonksiyon işaretçisi kullanarak bir yapı oluşturun. Örnek olarak, sadece pozitif sayıları toplayan bir fonksiyon ve tüm sayıları toplayan bir fonksiyon yazın. Bu fonksiyonları işaretçi ile kullanarak toplamı hesaplayın.",
    "answer": "Aşağıdaki kod örneğinde, fonksiyon işaretçileri kullanarak iki farklı toplama yöntemini uygulayan bir program bulunmaktadır. 'sum_all' fonksiyonu tüm sayıları toplarken, 'sum_positive' fonksiyonu sadece pozitif sayıları toplar.\n\n```c\n#include <stdio.h>\n\n// Toplama fonksiyonları\nint sum_all(int *arr, int size) {\n    int total = 0;\n    for (int i = 0; i < size; i++) {\n        total += arr[i];\n    }\n    return total;\n}\n\nint sum_positive(int *arr, int size) {\n    int total = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] > 0) {\n            total += arr[i];\n        }\n    }\n    return total;\n}\n\nint main() {\n    int numbers[] = {1, -2, 3, 4, -5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    // Fonksiyon işaretçisi tanımlaması\n    int (*sum_func)(int*, int);\n\n    // İlk olarak tüm sayıları toplayan fonksiyonu kullan\n    sum_func = sum_all;\n    printf(\"Toplam (tüm sayılar): %d\\n\", sum_func(numbers, size));\n\n    // Pozitif sayıları toplayan fonksiyonu kullan\n    sum_func = sum_positive;\n    printf(\"Toplam (pozitif sayılar): %d\\n\", sum_func(numbers, size));\n\n    return 0;\n}\n```\nBu kod, dizideki elemanları toplamak için fonksiyon işaretçilerini kullanmaktadır. Farklı toplama yöntemleri kullanarak aynı dizi üzerinde işlem yapılabilmektedir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:12:09.510070"
  },
  {
    "question": "Bir uygulamada farklı matematiksel işlemleri (toplama, çıkarma, çarpma, bölme) gerçekleştirmek için bir yapı oluşturun. Her işlemi bir fonksiyon olarak tanımlayın ve işlem türüne göre fonksiyon işaretçileri kullanarak uygun olanı çağırın.",
    "answer": "Aşağıdaki kod örneğinde, dört temel matematiksel işlemi gerçekleştiren fonksiyonlar tanımlanmıştır. Fonksiyon işaretçileri kullanılarak istenen işlem dinamik bir şekilde seçilmekte ve uygulanmaktadır.\n\n```c\n#include <stdio.h>\n\n// Matematiksel işlemler\nfloat add(float a, float b) {\n    return a + b;\n}\n\nfloat subtract(float a, float b) {\n    return a - b;\n}\n\nfloat multiply(float a, float b) {\n    return a * b;\n}\n\nfloat divide(float a, float b) {\n    if (b != 0) {\n        return a / b;\n    } else {\n        printf(\"Hata: Sıfıra bölme!\\n\");\n        return 0;\n    }\n}\n\nint main() {\n    float x = 10.0, y = 5.0;\n    char operation;\n\n    // Fonksiyon işaretçisi tanımlaması\n    float (*operation_func)(float, float);\n\n    printf(\"Yapmak istediğiniz işlemi seçin (+, -, *, /): \");\n    scanf(\" %c\", &operation);\n\n    switch (operation) {\n        case '+':\n            operation_func = add;\n            break;\n        case '-':\n            operation_func = subtract;\n            break;\n        case '*':\n            operation_func = multiply;\n            break;\n        case '/':\n            operation_func = divide;\n            break;\n        default:\n            printf(\"Geçersiz işlem!\\n\");\n            return 1;\n    }\n\n    float result = operation_func(x, y);\n    printf(\"Sonuç: %.2f\\n\", result);\n\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir aritmetik işlem seçiniz ve ardından uygun fonksiyon işaretçisini kullanarak belirlenen işlemi gerçekleştirir. Bu sayede farklı işlemler için aynı yapı üzerinden esnek bir kullanım sağlanmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:12:09.510149"
  },
  {
    "question": "Bir programda farklı matematiksel işlemleri gerçekleştiren fonksiyonlar tanımladım. Ancak, fonksiyonlar arasında geçiş yapmak için function pointer kullanmak istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Function pointer kullanarak, matematiksel işlemler arasında kolayca geçiş yapabilirsiniz. İşte bunu nasıl gerçekleştirebileceğinize dair bir örnek:\n\n```c\n#include <stdio.h>\n\n// Fonksiyon prototipleri\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint cikarma(int a, int b) {\n    return a - b;\n}\n}\n\nint main() {\n    // Function pointer tanımı\n    int (*islem)(int, int);\n    int secim, x = 10, y = 5;\n\n    printf(\"İşlem seçin (1: toplama, 2: çıkarma): \");\n    scanf(\"%d\", &secim);\n\n    if (secim == 1) {\n        islem = toplama; // toplama fonksiyonunu ata\n    } else if (secim == 2) {\n        islem = cikarma; // çıkarma fonksiyonunu ata\n    } else {\n        printf(\"Geçersiz işlem!\");\n        return 1;\n    }\n\n    printf(\"Sonuç: %d\\n\", islem(x, y)); // Seçilen fonksiyonu çağır\n    return 0;\n}\n```\n\nBu kodda iki farklı matematiksel işlem fonksiyonu tanımladık. Kullanıcıdan hangi işlemi yapmak istediğini alarak, uygun fonksiyonu function pointer aracılığıyla seçiyoruz. Bu sayede daha esnek bir yapı elde etmiş oluyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:12:31.624809"
  },
  {
    "question": "Bir dizi üzerinde farklı sıralama algoritmalarını kullanmak istiyorum. Her bir sıralama algoritması için ayrı bir fonksiyonum var. Function pointerlar ile bunu nasıl yapabilirim?",
    "answer": "Sıralama algoritmalarını fonksiyon pointerlar ile dinamik olarak seçmek, kodunuzu daha modüler hale getirir. Aşağıda bu yaklaşımın nasıl uygulanabileceğine dair bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\n// Sıralama algoritmaları için fonksiyon prototipleri\nvoid bubbleSort(int arr[], int n) {\n    // Bubble sort uygulaması\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nvoid selectionSort(int arr[], int n) {\n    // Selection sort uygulaması\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    void (*sortFunction)(int[], int);\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int secim;\n\n    printf(\"Sıralama türünü seçin (1: Bubble Sort, 2: Selection Sort): \");\n    scanf(\"%d\", &secim);\n\n    if (secim == 1) {\n        sortFunction = bubbleSort; // bubbleSort fonksiyonunu ata\n    } else if (secim == 2) {\n        sortFunction = selectionSort; // selectionSort fonksiyonunu ata\n    } else {\n        printf(\"Geçersiz seçim!\");\n        return 1;\n    }\n\n    sortFunction(arr, n); // Seçilen sıralama fonksiyonunu çağır\n    printf(\"Sıralanmış dizi: \\\n\");\n    printArray(arr, n);\n    return 0;\n}\n```\n\nBu örnekte, kullanıcıdan hangi sıralama algoritmasını kullanmak istediğini alıyoruz ve buna göre uygun fonksiyonu function pointer aracılığıyla çağırıyoruz. Bu yapı, yeni sıralama algoritmaları eklemeyi ve mevcut kodu daha esnek hale getirmeyi kolaylaştırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:12:31.624872"
  },
  {
    "question": "Bir oyun motorunda farklı türdeki düşmanların saldırı yöntemlerini tanımlamak için function pointerları kullanmak istiyorum. Ancak, her düşmanın saldırı yöntemi farklı parametreler alıyor. Bu durumu nasıl çözebilirim?",
    "answer": "Bu durumda, her düşman için farklı bir saldırı fonksiyonu tanımlamak ve bu fonksiyonları bir yapı içerisinde tutmak iyi bir çözüm olur. Ayrıca, her fonksiyonun alacağı parametreleri standart hale getirmek için bir yapı kullanabiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    int id;\n    void (*attack)(int damage);\n} Enemy;\n\nvoid goblinAttack(int damage) {\n    printf(\"Goblin saldırıyor! Hasar: %d\\n\", damage);\n}\n\nvoid dragonAttack(int damage) {\n    printf(\"Dragon ateş püskürtüyor! Hasar: %d\\n\", damage);\n}\n\nint main() {\n    Enemy goblin = {1, goblinAttack};\n    Enemy dragon = {2, dragonAttack};\n\n    goblin.attack(10);\n    dragon.attack(50);\n\n    return 0;\n}\n```\nBu yapıda, `Enemy` yapısı her düşmanın ID'sini ve ona ait saldırı fonksiyonunu tutuyor. Her düşmanın saldırı fonksiyonu farklı parametre alabilir, ancak her biri `attack` fonksiyonu aracılığıyla çağrıldığında uygun şekilde işleniyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:13:52.895274"
  },
  {
    "question": "Bir hesaplama uygulamasında, kullanıcıdan alınan matematiksel işlemler için farklı fonksiyonlar tanımladım. Ancak, bu fonksiyonların hepsini bir dizi içinde toplamak istiyorum. En iyi yaklaşım nedir?",
    "answer": "Bu durumda, işlemleri temsil eden fonksiyonları bir dizi içerisinde tutmak için function pointerları kullanabilirsiniz. Fonksiyon imzasını standart hale getirerek, daha sonra bu işlevleri diziye ekleyip, kullanıcıdan alınan işleme göre uygun olan fonksiyonu çağırabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\ntypedef double (*MathOperation)(double, double);\n\ndouble add(double a, double b) { return a + b; }\n\ndouble subtract(double a, double b) { return a - b; }\n\ndouble multiply(double a, double b) { return a * b; }\n\ndouble divide(double a, double b) { return (b != 0) ? (a / b) : 0; }\n\nint main() {\n    MathOperation operations[4] = { add, subtract, multiply, divide };\n    char *operationNames[4] = { \"Toplama\", \"Çıkarma\", \"Çarpma\", \"Bölme\" };\n    double a = 10, b = 5;\n\n    for (int i = 0; i < 4; i++) {\n        printf(\"%s: %f\\n\", operationNames[i], operations[i](a, b));\n    }\n\n    return 0;\n}\n```\nBu örnekte, `MathOperation` adında bir function pointer tipi tanımlıyoruz. Dizi içerisinde toplama, çıkarma, çarpma ve bölme işlemlerini depoluyoruz. Her bir fonksiyonu dizi üzerinden çağırarak işlemlerin sonuçlarını elde ediyoruz. Bu yapı, yeni işlemler eklemek istediğinizde oldukça esnek bir çözüm sunar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-05-31T17:13:52.895342"
  },
  {
    "question": "Aşağıdaki C kodunun eksik kısmını tamamlayın ve bellek sızıntısını önleyin. \n\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    if (arr == NULL) {\n        return 1;\n    }\n    // Burada bazı işlemler yapılacak...\n    // Eksik kısım burası\n    return 0;\n}",
    "answer": "Kodun eksik kısmını tamamlamak için malloc ile ayrılan belleği serbest bırakmalıyız. Bu sayede bellek sızıntısını önlemiş oluruz. Aşağıda, eksik kısmı tamamlanmış hali:\n\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    if (arr == NULL) {\n        return 1;\n    }\n    // Burada bazı işlemler yapılacak...\n    free(arr); // Bellek serbest bırakılıyor\n    return 0;\n}\n\nBu kodda, malloc ile ayrılan bellek \"arr\" işaretçisi kullanılarak oluşturulmuştur. Bellek sızıntısını önlemek için, programın sonunda free(arr) ile bellek serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:02.000513"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını önlemek için ne yapılmalı? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray() {\n    int *array = (int *)malloc(5 * sizeof(int));\n    if (array == NULL) {\n        return;\n    }\n    // İşlemler burada...\n}\n\nint main() {\n    createArray();\n    return 0;\n}",
    "answer": "Bu kodda, createArray fonksiyonunda malloc ile ayrılan bellek serbest bırakılmamaktadır. Bu nedenle bellek sızıntısına neden olur. Kodun düzeltilmesi için 'free(array);' ifadesini eklemeliyiz. İşte düzeltilmiş hali:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray() {\n    int *array = (int *)malloc(5 * sizeof(int));\n    if (array == NULL) {\n        return;\n    }\n    // İşlemler burada...\n    free(array); // Bellek serbest bırakılıyor\n}\n\nint main() {\n    createArray();\n    return 0;\n}\n\nBu düzenlemede, oluşturulan dizi üzerinde işlem yaptıktan sonra free(array) ile belleği serbest bırakıyoruz ve böylece bellek sızıntısını önlemiş oluyoruz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:02.000684"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını düzeltecek şekilde eksik kodu tamamlayın. Kod, dinamik olarak bir dizi oluşturmakta ve bu diziyi kullanıldıktan sonra serbest bırakmamaktadır. Kodun eksik kısmını doldurun.\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array;\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    array = (int *)malloc(n * sizeof(int));\n    // Dizi elemanlarını doldur\n    for (int i = 0; i < n; i++) {\n        array[i] = i * 2;\n    }\n    // Dizi elemanlarını yazdır\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", array[i]);\n    }\n    // Burada bellek sızıntısını önlemek için gereken kodu ekleyin.\n    return 0;\n}",
    "answer": "Kodun bellek sızıntısını önlemek için, dinamik olarak ayrılan belleği kullanımdan sonra serbest bırakmalıyız. Bunun için 'free' fonksiyonunu kullanmalıyız. Eksik kısım şu şekilde tamamlanır:\n\n    free(array);\n\nBöylece, program sonunda dinamik olarak ayrılan 'array' belleği serbest bırakılır ve bellek sızıntısı önlenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:35.481686"
  },
  {
    "question": "Aşağıdaki C kodunda, bir yapı dizisi dinamik olarak oluşturulmakta ancak yapıların belleği serbest bırakılmamaktadır. Bellek sızıntısını düzeltecek şekilde eksik kodu tamamlayın.\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Person;\n\nint main() {\n    int n;\n    printf(\"Kişi sayısını girin: \");\n    scanf(\"%d\", &n);\n    Person *people = (Person *)malloc(n * sizeof(Person));\n    // Kişi bilgilerini doldur\n    for (int i = 0; i < n; i++) {\n        printf(\"Kişi %d adını girin: \", i + 1);\n        scanf(\"%s\", people[i].name);\n        printf(\"Kişi %d yaşını girin: \", i + 1);\n        scanf(\"%d\", &people[i].age);\n    }\n    // Kişi bilgilerini yazdır\n    for (int i = 0; i < n; i++) {\n        printf(\"Ad: %s, Yaş: %d\\n\", people[i].name, people[i].age);\n    }\n    // Bellek sızıntısını önlemek için gereken kodu ekleyin.\n    return 0;\n}",
    "answer": "Kodda oluşturulan 'people' dizisinin belleği serbest bırakılmamış. Bellek sızıntısını önlemek için, programın sonunda 'free' fonksiyonunu kullanmalıyız:\n\n    free(people);\n\nBu şekilde, dinamik olarak ayrılan 'people' belleği serbest bırakılır ve bellek sızıntısı engellenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:35.482108"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısını gidermek için eksik olan kısmı tamamlayın ve açıklayın:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray(int size) {\n    int *array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n        printf(\"Hafıza ayırma hatası!\");\n        return;\n    }\n    // Array kullanımı burada...\n}\n\nint main() {\n    createArray(10);\n    return 0;\n}",
    "answer": "Kodda bellek sızıntısını önlemek için malloc ile ayrılan bellek alanının kullanılmadıktan sonra serbest bırakılması gerekiyor. Bu nedenle, createArray fonksiyonu içinde oluşturulan 'array' değişkenini kullanmayı bitirdikten sonra free(array); komutunu eklemeliyiz. Düzgün bir şekilde işlenmiş kod şöyle olacak:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray(int size) {\n    int *array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n        printf(\"Hafıza ayırma hatası!\");\n        return;\n    }\n    // Array kullanımı burada...\n    free(array); // Bellek serbest bırakılıyor\n}\n\nint main() {\n    createArray(10);\n    return 0;\n} \n\nBu sayede, 'array' için ayrılan bellek, kullanım tamamlandıktan sonra serbest bırakılarak bellek sızıntısı önlenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:49.312664"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısına neden olan kodu tamamlayın ve düzeltin:\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode* createNode(int value) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid freeList(Node *head) {\n    // Buraya bellek serbest bırakma kodunu ekleyin\n}\n\nint main() {\n    Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    return 0;\n}",
    "answer": "Kodda, createNode fonksiyonu ile oluşturulan düğümlerin serbest bırakılmadığı için bellek sızıntısı oluşur. Bunun için freeList fonksiyonunu tamamlamamız gerekiyor. Aşağıda, düğüm listesinin sonunu bulup her bir düğümü serbest bırakan bir kod örneği verilmiştir:\n\nvoid freeList(Node *head) {\n    Node *temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp); // Düğüm serbest bırakılıyor\n    }\n}\n\nint main() {\n    Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    freeList(head); // Listeyi serbest bırakıyoruz\n    return 0;\n}\n\nBu düzenlemeyle, oluşturulan düğümlerin bellek alanları işlev tamamlandıktan sonra serbest bırakılarak bellek sızıntısı engellenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:49.312815"
  },
  {
    "question": "Bir programda dinamik olarak tahsis edilen belleğin serbest bırakılmadığını nasıl tespit edebilirim?",
    "answer": "Dinamik bellek tahsisi için 'malloc' veya 'calloc' kullanıldıktan sonra, bu belleği serbest bırakmak için 'free' fonksiyonunu kullanmak önemlidir. Bellek sızıntısını tespit etmek için valgrind gibi araçlar kullanılabilir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int)); // Dinamik bellek tahsisi\n    // Belleği kullanmak...\n    // Burada free(arr); yazmayı unuttuk, bu bir bellek sızıntısına neden olur.\n    return 0;\n}\n```\nBu kodda, 'arr' için tahsis edilen bellek serbest bırakılmadığı için bir bellek sızıntısı meydana gelir. Valgrind ile çalıştırıldığında, tahsis edilen belleğin serbest bırakılmadığına dair bir uyarı alırsınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:59.972786"
  },
  {
    "question": "Bir fonksiyondan dönerken dinamik olarak tahsis edilen belleği nasıl düzgün bir şekilde yönetebilirim?",
    "answer": "Fonksiyonun içinde dinamik bellek tahsisi yapıyorsanız, bu belleği fonksiyonun dışında kullanabilmek için pointer'ı geri döndürmelisiniz. Ancak, bu belleği serbest bırakmayı unutmak da bellek sızıntısına neden olur. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* createArray(int size) {\n    int *arr = (int *)malloc(size * sizeof(int));\n    return arr; // Belleği döndürüyoruz ancak serbest bırakmayı unuttuk.\n}\n\nint main() {\n    int *myArray = createArray(5);\n    // Belleği kullanmak...\n    // free(myArray); yazmayı unutursak burada da bellek sızıntısı oluşur.\n    return 0;\n}\n```\nBu kodda, 'createArray' fonksiyonu tarafından tahsis edilen bellek, 'main' fonksiyonunda serbest bırakılmadığı için bellekte sızıntıya yol açar. Bu yüzden, kullanımdan sonra 'free(myArray);' ekleyerek bellek sızıntısını önlemeliyiz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:14:59.972829"
  },
  {
    "question": "Dinamik olarak allocate edilmiş bir dizi kullanarak toplamlarını hesaplayan bir programda bellek sızıntısı nasıl oluşur ve nasıl düzeltilebilir?",
    "answer": "Dinamik olarak allocate edilmiş bir dizi kullanırken, belleğe ayırma işlemi için malloc() veya calloc() kullanılır. Ancak, bu dizinin kullanımı bittikten sonra belleği serbest bırakmayı unuttuğunuzda, bellek sızıntısı meydana gelir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int)); // Bellek allocate edildi\n    if (arr == NULL) {\n        return 1; // Hata kontrolü\n    }\n\n    for (int i = 0; i < 10; i++) {\n        arr[i] = i + 1;\n    }\n\n    // İşlemler...\n    // free(arr); // Bellek serbest bırakılmadı, bu bir bellek sızıntısına yol açar\n}\n```\n\nBu örnekte, diziyi kullanmayı bitirdikten sonra free() fonksiyonu ile belleği serbest bırakmayı unutmak bellek sızıntısına neden olur. Bunu düzeltmek için, dizinin kullanımı bittiğinde free() fonksiyonu ile belleği serbest bırakmalısınız:\n\n```c\nfree(arr);\n```\n\nBu şekilde hafıza yönetimini düzgün bir şekilde gerçekleştirmiş olursunuz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:23.388894"
  },
  {
    "question": "Bir linked list uygulamasında düğümlerin serbest bırakılmaması nedeniyle oluşan bellek sızıntısını nasıl tespit edip düzeltebiliriz?",
    "answer": "Linked list yapısı kullanırken, her düğüm için dinamik bellek allocate ettiğinizde, her düğümü serbest bırakmayı unuttuğunuzda bellek sızıntısı meydana gelir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nint main() {\n    Node* head = (Node*)malloc(sizeof(Node)); // Başlangıç düğümü allocate edildi\n    head->data = 1;\n    head->next = NULL;\n\n    // Daha fazla düğüm ekle... (düğüm ekleme işlemi)\n    // Düğümleri serbest bırakmadan çıkmak bellek sızıntısına neden olur.\n}\n```\n\nBu kodda, linked list'teki düğümleri serbest bırakmamız gerektiğini unutursak, bellek sızıntısı meydana gelir. Bu durumu düzeltmek için, tüm düğümleri serbest bırakmak üzere bir fonksiyon yazabiliriz:\n\n```c\nvoid freeList(Node* head) {\n    Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n```\n\nAna fonksiyonda, linked list'i kullanmayı bitirdikten sonra freeList(head) fonksiyonunu çağırarak tüm düğümleri serbest bırakmalısınız. Bu şekilde bellek yönetimini düzgün bir şekilde sağlamış olursunuz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:23.388942"
  },
  {
    "question": "C dilinde bir bellek sızıntısının ne olduğunu ve nasıl oluştuğunu açıklayın.",
    "answer": "Bellek sızıntısı, bir programın dinamik olarak tahsis ettiği bellek alanını kullanmayı bıraktığı ve bu alanı serbest bırakmadığı durumlarda meydana gelir. Örneğin, malloc() fonksiyonu ile bir dizi için bellek tahsis ettiğimizi düşünelim. Eğer bu bellek alanını kullanmayı bitirdikten sonra free() fonksiyonu ile serbest bırakmazsak, bu bellek alanı programın yaşam döngüsü boyunca kullanılabilir durumda kalır ve başka bir işlem veya program tarafından kullanılamaz. Bu durum, zamanla sistemde bellek kullanımının artmasına ve performansın düşmesine neden olabilir. Örnek bir kod parçası: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(10 * sizeof(int)); // 10 tamsayı için bellek tahsisi\n    // Bellek kullanımı burada yapılabilir\n    // Ancak free() çağrılmadığı için bellek sızıntısı oluşur\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:33.696716"
  },
  {
    "question": "C dilinde bellek sızıntılarını önlemek için hangi önlemleri alabiliriz?",
    "answer": "Bellek sızıntılarını önlemek için bazı temel önlemler alabiliriz. Öncelikle, dinamik belleği kullanırken her malloc() çağrısından sonra, bu bellek alanını kullanmayı bitirdiğimizde mutlaka free() fonksiyonu ile serbest bırakmalıyız. Ayrıca, belleğe yapılan her tahsis için bir gösterici (pointer) kullanmak ve bu göstericiyi null yapmak, gereksiz bellek sızıntılarını önlemek için faydalıdır. Örneğin: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(10 * sizeof(int)); // Bellek tahsis ediliyor\n    if (arr == NULL) {\n        printf(\"Bellek tahsisi başarısız oldu!\");\n        return 1;\n    }\n    // Bellek kullanımı burada yapılabilir\n    free(arr); // Bellek serbest bırakılıyor\n    arr = NULL; // Gösterici null yapılıyor\n    return 0;\n}\n``` \nBu şekilde, bellek alanını serbest bırakarak sızıntıları önleyebiliriz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:33.696775"
  },
  {
    "question": "Dinamik bellek tahsisi yapan bir C programında neden bellek sızıntıları oluşur ve bunu nasıl önleyebiliriz?",
    "answer": "Dinamik bellek tahsisi, 'malloc' veya 'calloc' gibi fonksiyonlarla yapılır. Bu fonksiyonlar, istenen boyutta bellek ayırır ancak bu belleği serbest bırakmayı unuttuğumuzda, yani 'free' fonksiyonunu çağırmadığımızda bellek sızıntısı meydana gelir. Örneğin, bir dizi için hafıza ayırıp işlem yaparız, ancak işlem sonunda belleği serbest bırakmazsak, bu bellek kullanılmaz hale gelir ve sistemde bellek sızıntısına neden olur. Bellek sızıntılarını önlemek için, her 'malloc' veya 'calloc' çağrısından sonra 'free' fonksiyonunu kullanarak belleği serbest bırakmalıyız. Ayrıca, belleği kullanmayı bitirdikten sonra pointer'ı NULL olarak ayarlamak, tekrar kullanımda hataları önleyebilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:44.657844"
  },
  {
    "question": "Bir yapı (struct) içerisinde dinamik olarak tahsis edilmiş bellek kullanıyorsanız, bellek sızıntısını nasıl kontrol edersiniz?",
    "answer": "Bir yapı içerisinde dinamik bellek kullanıyorsanız, yapının içindeki her bir dinamik olarak tahsis edilmiş belleği serbest bırakmak için yapının yok edilmesi sırasında doğru bir şekilde yönetmelisiniz. Örneğin, bir yapı tanımlayıp içindeki bir karakter dizisi için bellek ayırdığınızı düşünelim. Yapıyı kullanmayı bitirdikten sonra, öncelikle karakter dizisini 'free' ile serbest bırakmalı ve ardından yapının kendisini serbest bırakmalısınız. Eğer bu adımları atlarsanız, yapı içerisindeki tahsis edilmiş bellek sızıntısına yol açar. Aşağıda bir örnek veriyorum: \n\n```c\ntypedef struct {\n    char *name;\n} Person;\n\nPerson* createPerson(const char* name) {\n    Person *p = (Person *)malloc(sizeof(Person));\n    p->name = (char *)malloc(strlen(name) + 1);\n    strcpy(p->name, name);\n    return p;\n}\n\nvoid freePerson(Person *p) {\n    if (p != NULL) {\n        free(p->name);  // Önce name alanını serbest bırak\n        free(p);        // Ardından yapıyı serbest bırak\n    }\n}\n\nint main() {\n    Person *person = createPerson(\"John\");\n    // İşlemler...\n    freePerson(person); // Bellek sızıntısını önlemek için\n    return 0;\n}\n```  Bu örnekte, 'createPerson' fonksiyonu bir 'Person' nesnesi oluşturur ve bellek ayırır. 'freePerson' fonksiyonu ise oluşturulan nesne üzerindeki belleği doğru bir şekilde serbest bırakır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:44.657922"
  },
  {
    "question": "C dilinde dinamik bellek tahsisi yaparken bellek sızıntılarını nasıl önleyebilirim?",
    "answer": "Dinamik bellek tahsisi için 'malloc' veya 'calloc' gibi fonksiyonlar kullandığınızda, tahsis ettiğiniz belleği serbest bırakmayı unutmamalısınız. Bellek sızdırmamak için her 'malloc' veya 'calloc' çağrısından sonra, tahsis edilen belleği kullandıktan sonra 'free' fonksiyonunu çağırarak bu belleği serbest bırakmalısınız. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(10 * sizeof(int)); // Dinamik bellek tahsisi\n    if (arr == NULL) {\n        fprintf(stderr, \"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n    // Belleği kullan\n    for (int i = 0; i < 10; i++) {\n        arr[i] = i;\n    }\n    // Belleği serbest bırak\n    free(arr);\n    return 0;\n}\n```\n\nYukarıdaki örnekte, 'arr' adlı bir tamsayı dizisi için bellek tahsis ediliyor. Bellek kullanıldıktan sonra 'free' ile serbest bırakılıyor. Eğer 'free' çağrısını yapmazsanız, bellek sızıntısı meydana gelir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:57.866584"
  },
  {
    "question": "Bellek sızıntılarını tespit etmek için hangi araçlar veya yöntemler kullanılabilir?",
    "answer": "Bellek sızıntılarını tespit etmek için çeşitli araçlar ve yöntemler mevcuttur. En yaygın kullanılan araçlardan biri 'Valgrind'dır. Valgrind, C programlarınızı çalıştırırken bellek sızıntılarını tespit eder ve hangi satırda sızıntı meydana geldiğini bildirir. Aşağıda Valgrind kullanımına dair bir örnek verilmiştir:\n\n1. Programınızı derleyin:\n```bash\ngcc -g my_program.c -o my_program\n```\n2. Valgrind ile programınızı çalıştırın:\n```bash\nvalgrind --leak-check=full ./my_program\n```\n\nValgrind, bellek sızıntıları ve yanlış hafıza kullanımı hakkında detaylı rapor sunar. Ayrıca, 'AddressSanitizer' gibi derleyici tabanlı araçlar da kullanılabilir. Bu araçları kullanarak, programınızda bellek sızıntılarına karşı daha dikkatli olabilirsiniz. Örnek olarak, GCC ile 'AddressSanitizer' kullanmak için derleme komutunuz şöyle olabilir:\n```bash\ngcc -fsanitize=address -g my_program.c -o my_program\n```\nBu şekilde derlenmiş bir programda, bellek sızıntısı oluştuğunda derleyici bilgilendirme yapacaktır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:15:57.866624"
  },
  {
    "question": "Dinamik olarak bir dizi oluşturup, bu diziyi kullanmadan önce bellek sızıntısı yapmadan nasıl serbest bırakabilirim?",
    "answer": "Dinamik bellek tahsisi yaparken her zaman tahsis edilen belleği serbest bırakmayı unutmayın. Örneğin, bir dizi oluşturup kullanımından sonra belleği serbest bırakmayı gösteren bir kod: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array;\n    int size = 10;\n\n    // Bellek tahsisi\n    array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < size; i++) {\n        array[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", array[i]);\n    }\n    printf(\"\\n\");\n\n    // Belleği serbest bırakma\n    free(array);\n    return 0;\n}\n``` \nBu kod, dinamik olarak bir dizi oluşturur, kullanır ve sonunda `free` fonksiyonu ile belleği serbest bırakır. Bu şekilde bellek sızıntısını önlemiş oluruz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:13.150389"
  },
  {
    "question": "Bir fonksiyonda dinamik olarak tahsis ettiğim belleği nasıl doğru bir şekilde yönetebilirim?",
    "answer": "Fonksiyonlar içinde dinamik bellek tahsisi yaparken, belleği doğru bir şekilde yönetmek kritik öneme sahiptir. Aşağıda bir örnek verelim: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray(int **array, int size) {\n    // Dizi için bellek tahsisi\n    *array = (int *)malloc(size * sizeof(int));\n    if (*array == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < size; i++) {\n        (*array)[i] = i + 1;\n    }\n}\n\nint main() {\n    int *myArray;\n    int size = 5;\n\n    // Fonksiyonu çağırarak dizi oluşturma\n    createArray(&myArray, size);\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", myArray[i]);\n    }\n    printf(\"\\n\");\n\n    // Belleği serbest bırakma\n    free(myArray);\n    return 0;\n}\n``` \nBu kodda, `createArray` fonksiyonu içinde dinamik bellek tahsisi yapılıyor. Fonksiyon, işlevselliğini sağlamak için bir gösterici kullanıyor. `main` içinde bellek kullanıldıktan sonra `free` ile serbest bırakılıyor. Böylece bellek sızıntısı önleniyor.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:13.150431"
  },
  {
    "question": "Dinamik bir dizi oluşturan ve belirli bir elemanın değerini değiştiren C programını yazın. Bellek sızıntısı nasıl oluşur ve nasıl önlenir?",
    "answer": "Aşağıdaki C kodu, dinamik bir dizi oluşturur ve belirli bir indeksteki değeri değiştirir. Ancak, bellek sızıntısına neden olabilecek bir hata içerir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array;\n    int size = 5;\n    \n    // Dinamik dizi oluşturma\n    array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n        printf(\"Bellek tahsisinde hata!\\n\");\n        return 1;\n    }\n    \n    // Diziye değer atama\n    for (int i = 0; i < size; i++) {\n        array[i] = i + 1;\n    }\n    \n    // Belirli bir indeksteki değeri değiştirme\n    array[2] = 10;\n    \n    printf(\"Dizi elemanları:\");\n    for (int i = 0; i < size; i++) {\n        printf(\" %d\", array[i]);\n    }\n    printf(\"\\n\");\n\n    // Belleği serbest bırakma kısmı atlandı\n    return 0;\n}\n```\n\nBu kodda, diziyi oluşturmak için malloc kullanıyoruz fakat programın sonunda `free(array);` satırı eksik. Bu durum, program çalıştığında bellekte tahsis edilen alanın serbest bırakılmaması ve bellek sızıntısına yol açmasına neden olur. Bellek sızıntısını önlemek için, dinamik olarak tahsis edilen belleği kullanmayı bitirdikten sonra serbest bırakmak önemlidir. Kodun düzeltilmiş hali:\n\n```c\n    // Belleği serbest bırakma\n    free(array);\n```\n\nBu satırı eklediğimizde, bellek sızıntısı önlenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:38.044085"
  },
  {
    "question": "Bir bağlı liste oluşturan ve tüm düğümleri serbest bırakmayan bir C programı yazın. Bellek sızıntısı nasıl oluşur ve nasıl önlenir?",
    "answer": "Aşağıdaki C kodu, bağlı bir liste oluşturur ve listeyi traverse eder. Ancak, tüm düğümleri serbest bırakmayan bir hata içerir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nvoid append(Node** head_ref, int new_data) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n    \n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n    \n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = new_node;\n}\n\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Node* head = NULL;\n    append(&head, 1);\n    append(&head, 2);\n    append(&head, 3);\n    printf(\"Bağlı liste elemanları: \");\n    printList(head);\n    \n    // Bellek serbest bırakma kısmı eksik\n    return 0;\n}\n```\n\nBu kodda, bağlı liste oluşturmak için dinamik bellek tahsisi yapılmakta ancak program sonunda her düğüm için `free()` fonksiyonu çağrılmamakta. Bu durum, uygulamanın çalışması sırasında bellekte kullanılmayan alanın serbest bırakılmaması ve dolayısıyla bellek sızıntısına yol açmasına neden olur. Bellek sızıntısını önlemek için, tüm düğümleri serbest bırakmak gerekir. Düzeltme için şu fonksiyonu ekleyebiliriz:\n\n```c\nvoid freeList(Node* head) {\n    Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n```\n\nVe `main` fonksiyonunda çağrılması:\n\n```c\n    // Belleği serbest bırakma\n    freeList(head);\n```\n\nBu şekilde, tüm düğümlerin belleği serbest bırakılır ve bellek sızıntısı önlenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:38.044138"
  },
  {
    "question": "C dilinde bir dinamik dizi oluşturan ve bellekte sızıntı olmasına neden olabilecek bir kod yazın. Ardından, bu sızıntıyı nasıl düzelteceğinizi açıklayın.",
    "answer": "Aşağıda, dinamik olarak bir dizi oluşturan fakat bellekte sızıntı yaratabilen bir C kodu örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(5 * sizeof(int));  // Dinamik dizi oluşturma\n    if (arr == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return 1;\n    }\n\n    // Dizi elemanlarını doldurma\n    for (int i = 0; i < 5; i++) {\n        arr[i] = i * 2;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    // Belleği serbest bırakma işlemi unutulmuş!\n    // free(arr);\n    return 0;\n}\n```\n\nBu kodda, dinamik olarak allocate edilen `arr` dizisi için bellek tahsis edilmektedir. Ancak, dizinin kullanımı tamamlandıktan sonra `free(arr);` komutu ile belleği serbest bırakma işlemi yapılmamıştır. Bu, bir bellek sızıntısına yol açar. Bellek sızıntısını önlemek için, dizinin kullanımı tamamlandıktan sonra belleği serbest bırakmalıyız:\n\n```c\nfree(arr);\n```\nBu satırı ekleyerek, bellekteki sızıntıyı önleyebiliriz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:56.611637"
  },
  {
    "question": "Bir linked list uygulaması yazın ve bu uygulamada bellek sızıntılarına yol açabilecek bir hata bulun. Hatanın nasıl düzeltileceğini açıklayın.",
    "answer": "Aşağıda, bir linked list'in temel işlemlerini gerçekleştiren bir C kodu örneği verilmiştir. Ancak bu kodda, bellek sızıntısına yol açan bir hata bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode* createNode(int data) {\n    Node *newNode = malloc(sizeof(Node));\n    if (newNode == NULL) {\n        return NULL;\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid addNode(Node **head, int data) {\n    Node *newNode = createNode(data);\n    if (*head == NULL) {\n        *head = newNode;\n    } else {\n        Node *temp = *head;\n        while (temp->next != NULL) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n    // Bellek serbest bırakma işlemi unutulmuş!\n}\n\nvoid freeList(Node *head) {\n    Node *temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n\nint main() {\n    Node *head = NULL;\n    addNode(&head, 10);\n    addNode(&head, 20);\n    addNode(&head, 30);\n\n    // Listeyi serbest bırakma işlemi unutuldu\n    // freeList(head);\n    return 0;\n}\n```\n\nBu kodda, linked list oluşturma ve düğüm ekleme işlemleri yapılmaktadır. Ancak, `freeList(head);` fonksiyonu çağrılmadığı için, linked list'in sonundaki tüm düğümler bellekte serbest bırakılmayacak ve sonuç olarak bellekte bir sızıntı oluşacaktır. Bu bellek sızıntısını önlemek için, programın sonunda `freeList(head);` fonksiyonunu çağırarak tüm düğümleri serbest bırakmalıyız:\n\n```c\nfreeList(head);\n```\nBu ekleme ile, linked list kullanımı tamamlandıktan sonra belleği düzgün bir şekilde serbest bırakmış olacağız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:16:56.611688"
  },
  {
    "question": "Bir dinamik dizi oluşturduğumuz ve bu diziyi bir fonksiyon içinde kullandığımız bir senaryoda, bellek sızıntısını nasıl önleyebiliriz?",
    "answer": "Dinamik olarak oluşturduğumuz bir dizi, kullanıldıktan sonra serbest bırakılmadığında bellek sızıntısına yol açar. Aşağıdaki kodda, `createArray` fonksiyonu dinamik bir dizi oluşturuyor, fakat çağrıldığı yerde bellek serbest bırakma işlemi yapılmıyor. Bu durumu düzeltmek için, oluşturulan diziyi kullandıktan sonra `free` ile serbest bırakmalıyız.\n\n```c\nint* createArray(int size) {\n    int* array = (int*)malloc(size * sizeof(int));\n    if (array == NULL) {\n        // Bellek tahsisi başarısız oldu\n        return NULL;\n    }\n    return array;\n}\n\nint main() {\n    int size = 10;\n    int* myArray = createArray(size);\n    // Dizi kullanılıyor\n\n    // Bellek serbest bırakma\n    free(myArray);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:17:35.943052"
  },
  {
    "question": "Bir yapının içinde başka bir yapıyı barındırıyorsa ve bu iç yapının dinamik olarak tahsis edilmiş bir alanı varsa, bellek sızıntısını nasıl önleriz?",
    "answer": "Yapılar içinde dinamik bellek tahsisi yapıldığında, iç yapıların bellek alanlarını serbest bırakmayı unutmamak önemlidir. Aşağıdaki örnekte, `InnerStruct` yapısı dinamik olarak tahsis edilmiş bir `char` dizisi içeriyor. `OuterStruct` içerisinde `InnerStruct` yer alıyor. `OuterStruct` serbest bırakıldıktan önce, `InnerStruct`'un içindeki `char` dizisini serbest bırakmayı unutmamalıyız.\n\n```c\ntypedef struct {\n    char* name;\n} InnerStruct;\n\ntypedef struct {\n    InnerStruct* inner;\n} OuterStruct;\n\nOuterStruct* createOuter() {\n    OuterStruct* outer = (OuterStruct*)malloc(sizeof(OuterStruct));\n    outer->inner = (InnerStruct*)malloc(sizeof(InnerStruct));\n    outer->inner->name = (char*)malloc(50 * sizeof(char)); // Dinamik tahsis\n    return outer;\n}\n\nvoid freeOuter(OuterStruct* outer) {\n    free(outer->inner->name); // İç yapının alanını serbest bırak\n    free(outer->inner);       // İç yapıyı serbest bırak\n    free(outer);              // Dış yapıyı serbest bırak\n}\n\nint main() {\n    OuterStruct* myOuter = createOuter();\n    // Kullanım\n\n    // Bellek serbest bırakma\n    freeOuter(myOuter);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:17:35.943117"
  },
  {
    "question": "Bir C programında bir dizi dinamik olarak ayrılmış ve kullanılmadıktan sonra serbest bırakılmamış. Bu durumda bellek sızıntısını nasıl önleyebiliriz?",
    "answer": "Dinamik bellek yönetimi yaparken, her malloc çağrısından sonra ilgili bellek alanını serbest bırakmak için free() fonksiyonunu kullanmalıyız. Örneğin, aşağıdaki kodda bellek sızıntısı var:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    // Dizi üzerinde bazı işlemler yapılabilir...\n    // Ancak arr serbest bırakılmıyor.\n    return 0;\n}\n```\nBu durumda, programın sonunda arr'yi serbest bırakmalıyız:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    // Dizi üzerinde bazı işlemler yapılabilir...\n    free(arr); // Bellek sızıntısını önlüyoruz.\n    return 0;\n}\n```\nAyrıca, malloc'un dönüş değerinin NULL olup olmadığını kontrol etmek de iyi bir uygulamadır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:17:50.953646"
  },
  {
    "question": "Bir C programında bir yapıdan birden fazla kopya oluşturulmuş ve her kopya için dinamik bellek kullanımı yapılmış. Ancak serbest bırakma işlemleri yanlış yönetilmiş. Bu durumun sonuçları neler olabilir ve nasıl düzeltilebilir?",
    "answer": "Bir yapının birden fazla kopyasını oluşturduğunuzda, her kopya için ayrı bir bellek alanı ayırmanız ve bunları doğru bir şekilde serbest bırakmanız gerekir. Aksi halde, serbest bırakılmayan her kopya için bellek sızıntısı olacaktır. Aşağıdaki kodda bu durum mevcuttur:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char *name;\n} Person;\n\nint main() {\n    Person *p1 = (Person *)malloc(sizeof(Person));\n    p1->name = (char *)malloc(50);\n\n    Person *p2 = (Person *)malloc(sizeof(Person));\n    p2->name = (char *)malloc(50);\n\n    // Bellek serbest bırakma yapılmıyor.\n    return 0;\n}\n```\nBu durumda, her Person yapısının ve içindeki name alanının serbest bırakılması gerekiyor:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char *name;\n} Person;\n\nint main() {\n    Person *p1 = (Person *)malloc(sizeof(Person));\n    p1->name = (char *)malloc(50);\n\n    Person *p2 = (Person *)malloc(sizeof(Person));\n    p2->name = (char *)malloc(50);\n\n    // Belleği serbest bırakma işlemleri\n    free(p1->name);\n    free(p1);\n    free(p2->name);\n    free(p2);\n    return 0;\n}\n```\nBu şekilde, her bir dinamik olarak ayrılan bellek alanını doğru bir şekilde serbest bırakarak bellek sızıntısını önleyebiliriz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-05-31T17:17:50.953717"
  },
  {
    "question": "Kullanıcının girdiği bir tamsayıyı bir bağlı listeye ekleyen C kodunu tamamlayın. Başlangıçta bağlı liste boş.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Bağlı liste düğümü tanımı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Bağlı listeye düğüm ekleme fonksiyonu\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = createNode(new_data);\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n    struct Node* last = *head_ref;\n    while (last->next != NULL)\n        last = last->next;\n    last->next = new_node;\n}\n\nint main() {\n    struct Node* head = NULL;\n    int value;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &value);\n    append(&head, value);\n    printf(\"Başarıyla eklendi: %d\\n\", head->data);\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir tamsayı girişi alır ve bunu bir bağlı listeye ekler. Bağlı liste başlangıçta boş olduğu için 'head' pointer'ı NULL'dır. Kullanıcı bir tamsayı girdikten sonra, bu değer bağlı listeye yeni bir düğüm olarak eklenir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:05.099208"
  },
  {
    "question": "Bağlı listedeki tüm elemanları yazdıran bir C fonksiyonu tamamlayın. Başlangıçta bağlı liste dolu.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Bağlı liste düğümü tanımı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Bağlı listedeki tüm elemanları yazdırma fonksiyonu\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    // Örnek bağlı liste oluşturma\n    struct Node* head = (struct Node*)malloc(sizeof(struct Node));\n    head->data = 1;\n    head->next = (struct Node*)malloc(sizeof(struct Node));\n    head->next->data = 2;\n    head->next->next = (struct Node*)malloc(sizeof(struct Node));\n    head->next->next->data = 3;\n    head->next->next->next = NULL;\n\n    printList(head);\n    return 0;\n}\n\n// Açıklama: Bu kod, başlangıçta dolu bir bağlı liste oluşturur ve 'printList' fonksiyonu yardımıyla listedeki tüm elemanları yazdırır. Her bir düğüm 'data' alanına sahip olup, 'next' alanı ile birbirine bağlıdır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:05.099275"
  },
  {
    "question": "Tek yönlü bir bağlı liste oluşturan bir fonksiyon yazın. Kullanıcıdan alınan sayıları listeye eklesin ve listeyi ekrana yazdırsın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* head = NULL;\n\nvoid append(int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = head;\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (head == NULL) {\n        head = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}\n\nvoid printList() {\n    struct Node* node = head;\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    int value;\n    printf(\"Kaç sayı eklemek istersiniz? \");\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Sayı girin: \");\n        scanf(\"%d\", &value);\n        append(value);\n    }\n    printList();\n    return 0;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:23.042861"
  },
  {
    "question": "Bağlı listedeki tüm elemanları tersine çeviren bir fonksiyon yazın. Eksik kodu tamamlayın ve örnek bir kullanım ile gösterin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* head = NULL;\n\nvoid append(int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = head;\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (head == NULL) {\n        head = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}\n\nvoid reverse() {\n    struct Node* prev = NULL;\n    struct Node* current = head;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    head = prev;\n}\n\nvoid printList() {\n    struct Node* node = head;\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    append(1);\n    append(2);\n    append(3);\n    append(4);\n    printf(\"Orijinal Liste: \");\n    printList();\n    reverse();\n    printf(\"Tersine Çevrilmiş Liste: \");\n    printList();\n    return 0;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:23.042936"
  },
  {
    "question": "Bir bağlı liste tanımlayın ve bu listeye verilen bir değeri ekleyen bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Bağlı liste düğümü yapısı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Yeni bir düğüm oluşturma fonksiyonu\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Bağlı listeye eleman ekleme fonksiyonu\nvoid insertEnd(struct Node** head, int value) {\n    struct Node* newNode = createNode(value);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    struct Node* last = *head;\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = newNode;\n}\n\n// Listeyi yazdırma fonksiyonu\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    struct Node* head = NULL;\n    insertEnd(&head, 10);\n    insertEnd(&head, 20);\n    insertEnd(&head, 30);\n    printList(head);\n    return 0;\n}\n\n// Açıklama: Bu kodda bir bağlı liste tanımlanıyor ve listeye eleman eklemek için 'insertEnd' fonksiyonu kullanılıyor. Düğüm yapısı ve bağlı listeyi oluşturmak için gerekli fonksiyonlar tanımlanmıştır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:37.838531"
  },
  {
    "question": "Bir bağlı listeden belirli bir değeri silen bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Bağlı liste düğümü yapısı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Düğüm oluşturma fonksiyonu\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Düğüm silme fonksiyonu\nvoid deleteNode(struct Node** head, int value) {\n    struct Node* temp = *head, *prev = NULL;\n    if (temp != NULL && temp->data == value) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n    while (temp != NULL && temp->data != value) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    prev->next = temp->next;\n    free(temp);\n}\n\n// Listeyi yazdırma fonksiyonu\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(10);\n    head->next = createNode(20);\n    head->next->next = createNode(30);\n    printf(\"Liste: \");\n    printList(head);\n    deleteNode(&head, 20);\n    printf(\"Güncellenmiş Liste: \");\n    printList(head);\n    return 0;\n}\n\n// Açıklama: Bu kodda, bir bağlı listeden belirli bir değeri silmek için 'deleteNode' fonksiyonu tanımlanmıştır. Fonksiyon, verilen değeri bulup onu siler ve listeyi günceller. Listeyi yazdıran fonksiyon da mevcuttur.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:37.838573"
  },
  {
    "question": "Bir bağlı liste oluşturma sırasında, liste elemanlarını eklerken her elemanın adresini doğru şekilde güncellemiyorum. Bu durumda ne olur?",
    "answer": "Eğer bağlı liste oluştururken elemanların adreslerini doğru bir şekilde güncellemezseniz, listenin yapısı bozulur. Örneğin, bir düğümün 'next' işaretçisini doğru bir şekilde ayarlamazsanız, bu düğümden sonraki düğümlere ulaşamazsınız. Bu durumda listenizde kaybolan elemanlar olur ve bu, bellek sızıntısına yol açabilir. Doğru bir bağlı liste oluşturmak için her yeni düğüm eklendiğinde, mevcut son düğümün 'next' işaretçisini yeni düğümü gösterecek şekilde güncellemelisiniz. Örneğin:\n\n```c\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid addNode(struct Node** head, int newData) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = newData;\n    newNode->next = (*head);\n    (*head) = newNode;\n}\n```\nBurada `addNode` fonksiyonu, yeni bir düğüm eklerken mevcut başı ('head') güncelleyerek hatalı adres güncellemelerinin önüne geçer.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:48.879258"
  },
  {
    "question": "Bağlı listemi dolaşırken, döngü kontrolü için kullandığım 'while' koşulu yanlış tanımlanmış. Bu durumda ne gibi sorunlarla karşılaşabilirim?",
    "answer": "Eğer bağlı listenizi dolaşırken döngü koşulunu yanlış tanımlarsanız, ya sonsuz bir döngüye girersiniz ya da bazı düğümlerinizi atlayarak listeyi eksik dolaşırsınız. Örneğin, koşul olarak 'current != NULL' yerine 'current == NULL' kullanıyorsanız, bu durumda döngüye hiç girmeyeceksiniz ve bağlı listenizi hiç görüntüleyemeyeceksiniz. Doğru bir döngü koşulu kullanmak için şu şekilde yazmalısınız:\n\n```c\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n}\n```\nBu şekilde, 'node' NULL olmadığı sürece listenin elemanlarını düzgün bir şekilde bastırmış olursunuz. Yanlış koşul kullanımı, programınızın beklenmedik şekilde çalışmasına neden olabilir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:18:48.879310"
  },
  {
    "question": "Bağlı listeyi tersine çevirmeye çalışan aşağıdaki kodda bir hata var. Hatanın sebebini bul ve düzelt: \n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* reverseList(Node* head) {\n    Node* prev = NULL;\n    Node* current = head;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return head;  // Hatalı dönüş\n}\n```",
    "answer": "Kodda tersine çevirme işlemi doğru ancak işlevin sonunda `head` yerine `prev` döndürülmeli. Çünkü `head` değişkeni artık listenin yeni başını tutmuyor. Düzeltmek için son satırı `return prev;` olarak değiştirmeliyiz. İşte düzeltilmiş kod:\n\n```c\nreturn prev;  // Doğru dönüş\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:02.718205"
  },
  {
    "question": "Aşağıdaki kodda bağlı listeye eleman eklemeye çalışırken bir hata var. Hatanın sebebini bul ve düzelt: \n\n```c\nvoid insertAtEnd(Node** head, int newData) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = newData;\n    newNode->next = NULL;\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    Node* last = *head;\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = newNode;\n    newNode->next = last;  // Hatalı atama\n}\n```",
    "answer": "Kodda elemanı listenin sonuna eklerken `newNode->next = last;` satırı hatalı. Bu satır yeni düğümün `last`'in önüne geçmesine neden oluyor, yani döngüsel bir liste oluşuyor. Doğru atama `last->next = newNode;` şeklinde olmalı. İşte düzeltilmiş kod:\n\n```c\nlast->next = newNode;  // Doğru atama\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:02.718436"
  },
  {
    "question": "Bir bağlı listeyi ters çevirmek için yazdığım kodda bir hata var. Kod çalışıyor ama sonucun beklediğim gibi olmadığını görüyorum. Yardımcı olur musun?",
    "answer": "Elbette! Bağlı listeyi ters çevirmek için uyguladığın algoritmada muhtemelen düğümleri güncellerken bir hata bulunmaktadır. İşte örnek bir kod parçası:\n\n```c\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid reverseList(struct Node** head_ref) {\n    struct Node* prev = NULL;\n    struct Node* current = *head_ref;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;  // Sonraki düğümü kaydet\n        current->next = prev;  // Geçerli düğümü tersine çevir\n        prev = current;        // Önceki düğümü güncelle\n        current = next;        // Geçerli düğümü ilerlet\n    }\n    *head_ref = prev; // Baş düğümü güncelle\n}\n```\n\nEğer bu kod çalışmıyorsa, kontrol etmen gereken birkaç nokta var:\n1. `head_ref` işaretçisini düzgün bir şekilde güncellediğinden emin ol. Ters çevirme işlemi tamamlandıktan sonra `*head_ref`'in son düğüm haline geldiğinden emin olmalısın.\n2. Düğüm yapısının tanımının doğru ve her düğüm için `next` işaretçisinin doğru şekilde başlatıldığından emin ol.  Düğümleri yanlış şekilde güncelleyebilirsen, bağlantı kaybolabilir.\n\nBu düzeltmeler ve kontroller ile sorununuz çözülmelidir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:18.291925"
  },
  {
    "question": "Bağlı listemi bir diziye kopyalamak için yazdığım kodda bellek sızıntısı yaşıyorum. Bunun nedeni ne olabilir?",
    "answer": "Bellek sızıntısı genellikle dinamik bellek yönetimini düzgün yapmadığımızda ortaya çıkar. Aşağıdaki örnek, bağlı listeden bir diziye veri kopyalama işlemini gerçekleştiren bir kodu gösteriyor:\n\n```c\nvoid copyListToArray(struct Node* head, int** array, int* size) {\n    struct Node* current = head;\n    int count = 0;\n\n    // İlk olarak, listenin boyutunu belirle\n    while (current != NULL) {\n        count++;\n        current = current->next;\n    }\n\n    *size = count;  // Dizinin boyutunu ayarlama\n    *array = (int*)malloc(count * sizeof(int)); // Dinamik dizi oluşturma\n\n    current = head;\n    for (int i = 0; i < count; i++) {\n        (*array)[i] = current->data; // Değerleri kopyala\n        current = current->next;\n    }\n}\n```\n\nEğer bu kodda bellek sızıntısı yaşıyorsanız, muhtemelen `malloc` fonksiyonu ile oluşturulan diziyi serbest bırakmayı unuttunuz. Bu nedenle, fonksiyonun çağrıldığı yerden döndüğünde bellek yönetimi düzgün bir şekilde gerçekleştirilmez. Örneğin, fonksiyondan döndükten sonra diziyi kullanmayı bitirdiğinizde şu şekilde serbest bırakmayı unutmayın:\n\n```c\nint* array;\nint size;\ncopyListToArray(head, &array, &size);\n// Kullanım işlemleri\nfree(array); // Bellek serbest bırakma\n```\n\nBunun yanı sıra, kodunuzu kontrol ederken bağlı listenizin ve her düğümün doğru bir şekilde oluşturulduğundan ve bellekten serbest bırakıldığından emin olun.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:18.291972"
  },
  {
    "question": "Bağlı liste nedir ve hangi durumlarda kullanılmalıdır?",
    "answer": "Bağlı liste, verilerin düğümler halinde saklandığı bir veri yapısıdır. Her düğüm, veriyi ve bir sonraki düğümün adresini içerir. Bağlı listeler, dinamik bellek yönetimi gerektiren durumlarda kullanışlıdır. Örneğin, bir uygulama kullanıcıların sürekli olarak ekleme ve silme işlemleri yaptığı bir liste tutuyorsa, bağlı liste kullanmak verimlidir. Dizi kullanmak, her seferinde bellekte yeniden boyutlandırma gerektirebilir, bu da performansı olumsuz etkiler. Bağlı liste ile bu işlemler O(1) karmaşıklığında yapılabilir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:30.801372"
  },
  {
    "question": "C dilinde basit bir bağlı liste nasıl oluşturulur ve düğüm eklenir?",
    "answer": "C dilinde bağlı liste oluşturmak için önce bir düğüm yapısı tanımlamalıyız. Örneğin: \n```c\nstruct Node {\n    int data;\n    struct Node* next;\n};\n``` \nBu yapı, bir tamsayı verisi ve bir sonraki düğümün adresini tutar. Bağlı listeye düğüm eklemek için bir fonksiyon yazmalıyız. Örnek bir ekleme fonksiyonu şu şekilde olabilir: \n```c\nvoid ekle(struct Node** head_ref, int yeni_veri) {\n    struct Node* yeni_dugum = (struct Node*) malloc(sizeof(struct Node));\n    yeni_dugum->data = yeni_veri;\n    yeni_dugum->next = (*head_ref);\n    (*head_ref) = yeni_dugum;\n}\n``` \nBu fonksiyon, verilen veriyi yeni bir düğüm olarak liste başına ekler. `head_ref`, liste başını gösteren bir işaretçidir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:30.801412"
  },
  {
    "question": "Bağlı listelerin (linked lists) avantajları ve dezavantajları nelerdir? Bir programda neden bağlı liste kullanmalıyım?",
    "answer": "Bağlı listeler, veri yapıları arasında dinamik hafıza yönetimi açısından önemli avantajlar sunar. Örneğin, dizi (array) kullanıldığında boyutunu önceden belirlememiz gerekir. Ancak bağlı listelerde, eleman eklemek veya çıkarmak istediğimizde, sadece bağlantıları güncelleyerek işlemi gerçekleştiririz. Bu, bellek kullanımını daha verimli hale getirir. Ayrıca, bağlı listeler, sıralı verilerin depolanmasında da kullanışlıdır. Dezavantajları ise, diziye göre daha fazla bellek kullanması ve erişim sürelerinin daha uzun olmasıdır; çünkü belirli bir elemana erişmek için listedeki elemanları sırayla gezmemiz gerekir. Örneğin, bir müzik çalar uygulamasında şarkıların sırayla çalınması gereken bir senaryo düşünelim. Bağlı liste, şarkıların dinamik olarak eklenip çıkarılabileceği ve sırayla çalınabileceği ideal bir veri yapısıdır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:42.611517"
  },
  {
    "question": "Bağlı listelerde bir elemanı silmek için gereken adımları açıklayabilir misiniz? Örnek bir C kodu ile gösteriniz.",
    "answer": "Bağlı listelerde bir elemanı silmek için genellikle aşağıdaki adımları izleriz: Öncelikle silmek istediğimiz elemanın bulunduğu düğümü (node) bulmalıyız. Bunun için, listenin başından başlayarak her düğümün veri alanını kontrol ederiz. Eğer bulunan düğüm silinecekse, düğümün önceki bağlantısını (prev) güncelleyerek, silinecek düğümü atlayarak bir sonraki düğüme (next) bağlarız. Bu işlemi gerçekleştirdikten sonra, silinen düğümü serbest bırakırız. Aşağıdaki C kodu, bağlı listeden belirli bir anahtara (key) sahip bir elemanı silme işlemini göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nvoid deleteNode(Node** head_ref, int key) {\n    Node* temp = *head_ref, *prev = NULL;\n\n    // Eğer baş düğüm silinmek isteniyorsa\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next; // Baş düğümü güncelle\n        free(temp); // Belleği serbest bırak\n        return;\n    }\n\n    // Anahtara sahip düğümü bul\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // Anahtar bulunamadıysa\n    if (temp == NULL) return;\n\n    // Düğümü sil\n    prev->next = temp->next;\n    free(temp); // Belleği serbest bırak\n}\n```\nBu kod, bir bağlı listedeki belirli bir anahtara sahip düğümü silmek için gerekli olan temel işlevleri içermektedir. Önce baştan başlayarak anahtar bulunur ve ardından uygun güncellemeler yapılır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:19:42.611565"
  },
  {
    "question": "Bağlı listeler kullanarak bir çarpanlar listesini nasıl oluşturabilirim? Örneğin, bir sayının çarpanlarını tutacak bir bağlı liste yapısı kurmalıyım.",
    "answer": "Bağlı listeler, dinamik veri yapılarıdır ve eleman ekleme veya silme işlemleri sırasında bellek yönetimini kolaylaştırır. Bir sayının çarpanlarını tutacak bir bağlı liste oluşturmak için öncelikle bir düğüm (node) yapısı tanımlamalıyız. Bu yapı, sayının değerini ve bir sonraki düğümün adresini tutmalıdır. Ardından, verilen sayının çarpanlarını bulacak bir fonksiyon yazmalıyız. Bu fonksiyon, sayıyı 1'den başlayarak kendisine kadar kontrol eder ve çarpanları buldukça bağlı listeye ekler. İşte örnek bir uygulama: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* createNode(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid insert(Node** head, int value) {\n    Node* newNode = createNode(value);\n    newNode->next = *head;\n    *head = newNode;\n}\n\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid findFactors(int number) {\n    Node* factorList = NULL;\n    for (int i = 1; i <= number; i++) {\n        if (number % i == 0) {\n            insert(&factorList, i);\n        }\n    }\n    printList(factorList);\n}\n\nint main() {\n    int number = 12;\n    printf(\"%d sayısının çarpanları: \", number);\n    findFactors(number);\n    return 0;\n}\n```\nBu kodda, `findFactors` fonksiyonu, verilen bir sayının çarpanlarını bulmakta ve bağlı listeye eklemektedir. Sonuç olarak, çarpanlar baştan sona yazdırılmaktadır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:02.984227"
  },
  {
    "question": "Bir bağlı liste kullanarak, kullanıcıdan alınan bir dizi sayıyı sıralamak için hangi yöntemleri kullanabilirim? Örneğin, bağlı listeyi kullanarak bir sıralama algoritması uygulamak istiyorum.",
    "answer": "Bağlı listeler üzerinde sıralama yapmak, özellikle eleman sayısı dinamik olduğunda oldukça faydalıdır. Sıralama için kullanılan birçok algoritma vardır, ancak burada 'Insertion Sort' (Ekleme Sıralaması) algoritmasını uygulayacağız. Bu algoritma, her bir elemanı bağlı listeye eklerken doğru konumuna yerleştirerek sıralı bir liste oluşturacaktır. İşte örnek bir uygulama: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* createNode(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid sortedInsert(Node** head, int value) {\n    Node* newNode = createNode(value);\n    if (*head == NULL || (*head)->data >= newNode->data) {\n        newNode->next = *head;\n        *head = newNode;\n    } else {\n        Node* current = *head;\n        while (current->next != NULL && current->next->data < newNode->data) {\n            current = current->next;\n        }\n        newNode->next = current->next;\n        current->next = newNode;\n    }\n}\n\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Node* sortedList = NULL;\n    int arr[] = {5, 3, 8, 1, 4};\n    for (int i = 0; i < 5; i++) {\n        sortedInsert(&sortedList, arr[i]);\n    }\n    printf(\"Sıralı liste: \");\n    printList(sortedList);\n    return 0;\n}\n```\nBu kodda, `sortedInsert` fonksiyonu, her bir elemanı bağlı listeye eklerken doğru sıralı konumda eklemektedir. Sonuç olarak, kullanıcıdan alınan dizi sayıları bağlı listede sıralı bir şekilde yazdırılmaktadır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:02.984293"
  },
  {
    "question": "Bir bağlı liste oluşturan ve listeye eleman ekleyen bir C programı yazın.",
    "answer": "Bağlı liste, her düğümün bir veri alanı ve bir sonraki düğümün adresini içeren veri yapısıdır. Aşağıdaki kod, temel bir bağlı liste oluşturan ve listeye yeni eleman ekleyen bir örnektir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısı tanımı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Bağlı listeye eleman ekleme fonksiyonu\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = createNode(new_data);\n    struct Node* last = *head_ref;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}\n\n// Listeyi yazdırma fonksiyonu\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    struct Node* head = NULL;\n    append(&head, 10);\n    append(&head, 20);\n    append(&head, 30);\n\n    printf(\"Bağlı liste elemanları: \");\n    printList(head);\n\n    return 0;\n}\n``` \nBu programda, `Node` adında bir yapı tanımlıyoruz. `createNode` fonksiyonu yeni bir düğüm oluştururken, `append` fonksiyonu bu düğümü listeye ekliyor. `printList` fonksiyonu ise listeyi yazdırmakta.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:23.250257"
  },
  {
    "question": "Bir bağlı listeden belirli bir değeri silen bir C programı yazın.",
    "answer": "Bağlı listeden bir elemanı silmek, silinecek düğümün adresine erişip bağlantıları güncellemeyi gerektirir. Aşağıda verilen kod, bağlı listeden belirli bir değeri silen bir örnektir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısı tanımı\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Listeye eleman ekleme fonksiyonu\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = createNode(new_data);\n    struct Node* last = *head_ref;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}\n\n// Belirli bir değeri silme fonksiyonu\nvoid deleteNode(struct Node** head_ref, int key) {\n    struct Node* temp = *head_ref;\n    struct Node* prev = NULL;\n\n    // Eğer silinecek düğüm başta ise\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next; // Baş düğüm güncelleniyor\n        free(temp);\n        return;\n    }\n\n    // Silinecek düğümün diğer düğümlerde aranması\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // Düğüm bulunamadıysa geri dön\n    if (temp == NULL) return;\n\n    // Düğüm bulundu, bağlantılar güncelleniyor\n    prev->next = temp->next;\n    free(temp);\n}\n\n// Listeyi yazdırma fonksiyonu\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    struct Node* head = NULL;\n    append(&head, 10);\n    append(&head, 20);\n    append(&head, 30);\n\n    printf(\"Bağlı liste elemanları: \");\n    printList(head);\n\n    deleteNode(&head, 20);\n    printf(\"20 silindikten sonra liste: \");\n    printList(head);\n\n    return 0;\n}\n``` \nBu programda, `deleteNode` fonksiyonu, verilen değere sahip düğümü silmek için listede dolaşır ve bağlantıları güncelleyerek silme işlemini gerçekleştirir. Listeyi yazdırırken her seferinde güncel durumu görebiliriz.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:23.250316"
  },
  {
    "question": "Bağlı liste kullanarak bir tamsayı listesini sıralamak için bir fonksiyon yazın. Fonksiyonu, bağlı liste düğümlerini kullanarak bir sıralama algoritması (örneğin, 'insertion sort') ile gerçekleştirin.",
    "answer": "Aşağıda, bağlı liste düğümlerini kullanarak bir tamsayı listesini sıralamak için 'insertion sort' algoritmasını uygulayan bir C kodu bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısını tanımlıyoruz.\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Yeni bir düğüm oluşturan fonksiyon.\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\n// Bağlı listeye eleman ekleyen fonksiyon.\nvoid insert(Node** head_ref, int new_data) {\n    Node* new_node = newNode(new_data);\n    Node* current;\n\n    // Eğer liste boşsa yeni düğümü başa atıyoruz.\n    if (*head_ref == NULL || (*head_ref)->data >= new_node->data) {\n        new_node->next = *head_ref;\n        *head_ref = new_node;\n    } else {\n        current = *head_ref;\n        while (current->next != NULL && current->next->data < new_node->data) {\n            current = current->next;\n        }\n        new_node->next = current->next;\n        current->next = new_node;\n    }\n}\n\n// Listeyi sıralı şekilde yazdıran fonksiyon.\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n}\n\nint main() {\n    Node* head = NULL;\n    insert(&head, 3);\n    insert(&head, 1);\n    insert(&head, 4);\n    insert(&head, 2);\n\n    printf(\"Sıralı Liste: \");\n    printList(head);\n    return 0;\n}\n```\n\nBu kodda 'Node' yapısı, her bir düğümü tanımlar. 'insert' fonksiyonu, düğümleri sıralı bir şekilde listeye ekler. 'printList' fonksiyonu ise listeyi ekrana yazdırır. Bu yöntemle, bağlı liste üzerinde 'insertion sort' algoritmasını uygulamış olduk.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:47.782425"
  },
  {
    "question": "Bağlı liste kullanarak bir metin dosyasındaki kelimeleri okuyup, her kelimenin kaç kez geçtiğini sayan bir program yazın. Sonuçları bağlı liste kullanarak saklayın ve sıralı bir şekilde çıktı verin.",
    "answer": "Aşağıdaki C kodu, bir metin dosyasındaki kelimeleri okur, kelimeleri sayar ve her kelimenin kaç kez geçtiğini bağlı listede saklar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Kelime sayısını tutan düğüm yapısı.\ntypedef struct WordCount {\n    char word[50];\n    int count;\n    struct WordCount* next;\n} WordCount;\n\n// Yeni bir kelime sayısı düğümü oluşturan fonksiyon.\nWordCount* newWordCount(char* word) {\n    WordCount* wc = (WordCount*)malloc(sizeof(WordCount));\n    strcpy(wc->word, word);\n    wc->count = 1;\n    wc->next = NULL;\n    return wc;\n}\n\n// Bağlı listeye kelime ekleyen fonksiyon.\nvoid addWordCount(WordCount** head_ref, char* word) {\n    WordCount* current = *head_ref;\n    WordCount* prev = NULL;\n\n    while (current != NULL && strcmp(current->word, word) < 0) {\n        prev = current;\n        current = current->next;\n    }\n\n    if (current != NULL && strcmp(current->word, word) == 0) {\n        current->count++;\n    } else {\n        WordCount* new_wc = newWordCount(word);\n        if (prev == NULL) {\n            new_wc->next = *head_ref;\n            *head_ref = new_wc;\n        } else {\n            new_wc->next = current;\n            prev->next = new_wc;\n        }\n    }\n}\n\n// Bağlı listeyi yazdıran fonksiyon.\nvoid printWordCountList(WordCount* head) {\n    while (head != NULL) {\n        printf(\"%s: %d\\n\", head->word, head->count);\n        head = head->next;\n    }\n}\n\nint main() {\n    WordCount* head = NULL;\n    char word[50];\n    FILE* file = fopen(\"metin.txt\", \"r\");\n\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%s\", word) != EOF) {\n        addWordCount(&head, word);\n    }\n    fclose(file);\n\n    printf(\"Kelime Sayımları:\\n\");\n    printWordCountList(head);\n    return 0;\n}\n```\n\nBu kodda, 'WordCount' yapısı, her kelimenin ve sayısının saklanmasını sağlar. 'addWordCount' fonksiyonu, kelimeleri bağlı listeye ekler veya mevcutsa sayısını artırır. 'printWordCountList' fonksiyonu ise bağlı listeyi ekrana yazdırır. Bu şekilde, bir metin dosyasındaki kelimelerin sıklığını analiz eden bir program oluşturmuş olduk.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:20:47.782530"
  },
  {
    "question": "Bir bağlı listeyi tersine çeviren bir C fonksiyonu yazın. Bağlı liste bir düğüm yapısı ile temsil edilsin.",
    "answer": "Aşağıda, bir bağlı listeyi tersine çevirmek için gerekli C kodu bulunmaktadır. Bu kodda, bağlı listeyi temsil eden bir düğüm yapısı tanımlanmış ve ardından listeyi tersine çeviren bir fonksiyon yazılmıştır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısını tanımlıyoruz.\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Bağlı listeyi tersine çeviren fonksiyon.\nNode* reverseList(Node* head) {\n    Node* prev = NULL;\n    Node* current = head;\n    Node* next = NULL;\n\n    while (current != NULL) {\n        next = current->next;  // Sonraki düğümü kaydet\n        current->next = prev;  // Önceki düğüme bağla\n        prev = current;        // Önceki düğümü güncelle\n        current = next;        // İleri git\n    }\n    return prev;  // Yeni baş düğüm\n}\n\n// Listeyi yazdırma fonksiyonu.\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n// Örnek kullanım.\nint main() {\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->data = 1;\n    head->next = (Node*)malloc(sizeof(Node));\n    head->next->data = 2;\n    head->next->next = (Node*)malloc(sizeof(Node));\n    head->next->next->data = 3;\n    head->next->next->next = NULL;\n\n    printf(\"Orijinal liste: \");\n    printList(head);\n\n    head = reverseList(head);\n\n    printf(\"Ters çevrilmiş liste: \");\n    printList(head);\n\n    return 0;\n}\n```\n\nBu kodda, önce bağlı liste düğüm yapısı tanımlanır. `reverseList` fonksiyonu, mevcut düğümlerin referanslarını kullanarak listeyi tersine çevirir. Önceden tanımlı bir liste ile test edildiğinde, orijinal ve ters çevrilmiş listeyİ yazdırır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:15.489636"
  },
  {
    "question": "Bir bağlı listeye bir eleman eklemek ve belirli bir değeri içeren düğümü silmek için bir C fonksiyonu yazın.",
    "answer": "Aşağıda, bir bağlı listeye eleman ekleyen ve belirli bir değeri silen C kodu örneği bulunmaktadır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısını tanımlıyoruz.\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Bağlı listeye yeni bir eleman ekleyen fonksiyon.\nvoid append(Node** head_ref, int new_data) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    Node* last = *head_ref;\n\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = new_node;\n}\n\n// Belirli bir değeri silen fonksiyon.\nvoid deleteNode(Node** head_ref, int key) {\n    Node* temp = *head_ref;\n    Node* prev = NULL;\n\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next;  // Baş düğüm siliniyorsa\n        free(temp);\n        return;\n    }\n\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return;  // Değer bulunamadı\n    prev->next = temp->next;  // Düğümü sil\n    free(temp);\n}\n\n// Listeyi yazdırma fonksiyonu.\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n// Örnek kullanım.\nint main() {\n    Node* head = NULL;\n\n    append(&head, 1);\n    append(&head, 2);\n    append(&head, 3);\n\n    printf(\"Liste: \");\n    printList(head);\n\n    deleteNode(&head, 2);\n    printf(\"2 silindikten sonra: \");\n    printList(head);\n\n    return 0;\n}\n```\n\nBu kodda, `append` fonksiyonu bağlı listeye yeni düğüm eklerken, `deleteNode` fonksiyonu belirli bir değere sahip düğümü siler. Örnek kullanımda, önce 1, 2 ve 3 değerleri listeye eklenir, ardından 2 silinir ve sonuç yazdırılır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:15.489681"
  },
  {
    "question": "Bağlı listelerde bir düğüm eklerken, baş ve son düğüm durumlarını nasıl yönetmeliyim?",
    "answer": "Bağlı listelerde bir düğüm eklerken, listenin başına ekleme yapıyorsanız, baş göstericisini güncellemeniz gerekiyor. Eğer liste boşsa, hem baş hem de son göstericiyi yeni düğüme atamalısınız. İşte bunun nasıl yapılacağına dair bir örnek:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct LinkedList {\n    Node* head;\n    Node* tail;\n} LinkedList;\n\nvoid addNode(LinkedList* list, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n\n    if (list->head == NULL) {\n        list->head = newNode;\n        list->tail = newNode;\n    } else {\n        list->tail->next = newNode;\n        list->tail = newNode;\n    }\n}\n``` \nBu kod parçası, listenin başı ve sonu için gerekli güncellemeleri yaparak yeni düğümlerin eklenmesini sağlar. Ancak, her zaman `malloc` sonrası hata kontrolü yapmayı unutmayın.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:28.048786"
  },
  {
    "question": "Bağlı listeyi tersine çevirmek için etkili bir yöntem nedir?",
    "answer": "Bağlı listeyi tersine çevirmek için iteratif bir yöntem kullanabilirsiniz. Bu, her düğümün `next` işaretçisini bir önceki düğüme işaret edecek şekilde güncelleyerek gerçekleştirilir. İşte bir örnek:\n\n```c\nvoid reverseList(LinkedList* list) {\n    Node* prev = NULL;\n    Node* current = list->head;\n    Node* next = NULL;\n    list->tail = list->head; // Yeni son, eski baş olacak\n\n    while (current != NULL) {\n        next = current->next; // Sonraki düğümü kaydet\n        current->next = prev; // İlişkileri tersine çevir\n        prev = current; // Bir adım ilerle\n        current = next;\n    }\n    list->head = prev; // Yeni baş, eski son\n}\n```\nBu kod, bağlı listenin başını ve sonunu güncelleyerek listeyi tersine çevirir. İyi bir uygulama olarak hata kontrolü eklemeyi unutmayın, örneğin listenin boş olup olmadığını kontrol etmek önemli.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:28.048835"
  },
  {
    "question": "Bir bağlı liste içinde belirli bir değeri arama işlemini gerçekleştiren bir fonksiyonun kodunu inceledim. Kodda kullanılan döngünün karmaşıklığı ve performansı hakkında ne düşünüyorsunuz?",
    "answer": "Kodda kullanılan döngü, bağlı listenin her bir düğümünü sırasıyla kontrol ederek belirli bir değeri aramak için tasarlanmış. Ancak, bağlı listenin uzunluğu artırıldıkça, arama işleminin zaman karmaşıklığı O(n) olur. Bu durumda daha verimli bir çözüm yoktur çünkü bağlı liste yapısı, doğası gereği sıralı erişim sunmaz. Ancak, arama işlemi sırasında, sıklıkla aranan değerleri bir önbellekte tutarak (örneğin, bir hash tablosu kullanarak) tekrarlanan aramaların süresini kısaltabilirsiniz. Ayrıca, arama işlemi için bir işaretçi veya iterator kullanarak daha temiz ve yönetilebilir bir kod yapısı oluşturmak da faydalı olabilir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:45.079959"
  },
  {
    "question": "Bir bağlı listeyle çalışan bir veri yapısında, düğüm ekleme ve silme işlemleri gerçekleştiren bir kod parçası var. Bu işlemlerin bellek yönetimi açısından değerlendirilmesi ve potansiyel bellek sızıntıları hakkında hangi önlemleri almalıyız?",
    "answer": "Düğüm ekleme ve silme işlemleri sırasında bellek sızıntılarını önlemek için, her düğüm oluşturulduğunda bellek tahsis edilmelidir ve silme sırasında bu bellek geri serbest bırakılmalıdır. Kodunuzu gözden geçirdim ve düğüm silme işleminin ardından serbest bırakma işleminin yapılmadığını fark ettim. Bu, bellek sızıntısına sebep olabilir. Silme işlemi için şu şekilde bir fonksiyon kullanabilirsiniz: \n```c \nvoid silDugum(Dugum **bas, int deger) { \n    Dugum *temp = *bas, *prev = NULL; \n    while (temp != NULL && temp->deger != deger) { \n        prev = temp; \n        temp = temp->next; \n    } \n    if (temp == NULL) return; \n    if (prev == NULL) *bas = temp->next; \n    else prev->next = temp->next; \n    free(temp); \n} \n``` \nBu kod, belirtilen değere sahip düğümü listeden silerken, `free()` fonksiyonu ile belleği serbest bırakarak sızmaların önüne geçer. Ayrıca, her bellek tahsisi ve serbest bırakma işlemini dikkatlice takip etmek için bir bellek yönetimi stratejisi uygulamak da önemlidir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-05-31T17:21:45.080110"
  },
  {
    "question": "Bir stack (yığın) veri yapısını tanımlayın ve içine veri eklemek (push) ve veriyi çıkarmak (pop) için gerekli fonksiyonları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int value) {\n    if (isFull(s)) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    s->arr[++(s->top)] = value;\n}\n\nint pop(Stack* s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1; // Hata durumu\n    }\n    return s->arr[(s->top)--];\n}\n\nint main() {\n    Stack myStack;\n    initialize(&myStack);\n    push(&myStack, 10);\n    push(&myStack, 20);\n    printf(\"Pop edilen değer: %d\\n\", pop(&myStack));\n    printf(\"Pop edilen değer: %d\\n\", pop(&myStack));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:03.235789"
  },
  {
    "question": "Bir kuyruk (queue) veri yapısını tanımlayın ve içine veri eklemek (enqueue) ve veriyi çıkarmak (dequeue) için gerekli fonksiyonları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid initialize(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue* q) {\n    return q->rear == MAX - 1;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == -1 || q->front > q->rear;\n}\n\nvoid enqueue(Queue* q, int value) {\n    if (isFull(q)) {\n        printf(\"Kuyruk dolu!\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0; // İlk eleman ekleniyor\n    }\n    q->arr[++(q->rear)] = value;\n}\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) {\n        printf(\"Kuyruk boş!\\n\");\n        return -1; // Hata durumu\n    }\n    return q->arr[(q->front)++];\n}\n\nint main() {\n    Queue myQueue;\n    initialize(&myQueue);\n    enqueue(&myQueue, 5);\n    enqueue(&myQueue, 10);\n    printf(\"Dequeue edilen değer: %d\\n\", dequeue(&myQueue));\n    printf(\"Dequeue edilen değer: %d\\n\", dequeue(&myQueue));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:03.235853"
  },
  {
    "question": "Bir stack yapısında kullanıcıdan tam sayılar alıp, bu sayıların toplamını hesaplamak için eksik kodu tamamlayın. Stack yapısının temel işlevlerini kullanarak bu işlemi gerçekleştirin. Aşağıdaki kodu tamamlayın: \n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int data[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nvoid push(Stack *s, int value) {\n    if (!isFull(s)) {\n        s->data[++s->top] = value;\n    }\n}\n\nint pop(Stack *s) {\n    if (!isEmpty(s)) {\n        return s->data[s->top--];\n    }\n    return -1; // Hata durumu\n}\n\nint main() {\n    Stack s;\n    init(&s);\n    int num, toplam = 0;\n    printf(\"Tam sayılar girin (çıkmak için -1 girin): \");\n    while (1) {\n        scanf(\"%d\", &num);\n        if (num == -1) break;\n        push(&s, num);\n    }\n\n    // Burayı tamamlayın\n    while (!isEmpty(&s)) {\n        toplam += pop(&s);\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Yukarıdaki kod, bir stack yapısı kullanarak kullanıcıdan alınan tam sayıların toplamını hesaplamaktadır. Eksik kısım, stack'ten elemanları çıkartarak toplamı hesaplama kısmıdır. Bu kısım while döngüsü ile `pop` fonksiyonu kullanılarak tamamlanmıştır. Her `pop` işlemi, stack'ten bir elemanı çıkarır ve bu elemanlar toplam değişkenine eklenir. Sonuç olarak, tüm sayılar toplandıktan sonra kullanıcıya yazdırılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:21.797361"
  },
  {
    "question": "Bir queue yapısı kullanarak, kullanıcıdan bir dizi kelime alıp, bu kelimeleri ters sırayla yazdırmak için eksik kodu tamamlayın. Aşağıdaki kodu tamamlayın: \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct {\n    char *data[MAX];\n    int front, rear;\n} Queue;\n\nvoid init(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nint isFull(Queue *q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, char *value) {\n    if (!isFull(q)) {\n        q->data[q->rear] = value;\n        q->rear = (q->rear + 1) % MAX;\n    }\n}\n\nchar* dequeue(Queue *q) {\n    if (!isEmpty(q)) {\n        char *value = q->data[q->front];\n        q->front = (q->front + 1) % MAX;\n        return value;\n    }\n    return NULL; // Hata durumu\n}\n\nint main() {\n    Queue q;\n    init(&q);\n    char kelime[100];\n    printf(\"Kelime girin (çıkmak için 'exit' yazın): \");\n    while (1) {\n        scanf(\"%s\", kelime);\n        if (strcmp(kelime, \"exit\") == 0) break;\n        enqueue(&q, strdup(kelime)); // Strdup kullanarak hafızada saklıyoruz\n    }\n\n    // Burayı tamamlayın\n    printf(\"Ters sırayla kelimeler: \");\n    while (!isEmpty(&q)) {\n        printf(\"%s \", dequeue(&q));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "answer": "Yukarıdaki kod, bir queue yapısı kullanarak kullanıcıdan alınan kelimeleri saklamakta ve daha sonra bu kelimeleri ters sırayla yazdırmaktadır. Eksik kısım, queue'dan kelimeleri çıkartarak sırayla yazdırma kısmıdır. `dequeue` fonksiyonu kullanılarak her kelime sırayla alınmakta ve ekrana yazdırılmaktadır. Bu işlem, queue'dan kelime kalmayana kadar devam eder.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:21.797698"
  },
  {
    "question": "C dilinde bir Stack veri yapısı oluşturun. 'push', 'pop' ve 'peek' işlevlerini tamamlayın. Stack'in dolu olup olmadığını kontrol eden bir 'isFull' ve boş olup olmadığını kontrol eden 'isEmpty' işlevini de ekleyin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (isFull(s)) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    s->items[++(s->top)] = item;\n}\n\nint pop(Stack* s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[(s->top)--];\n}\n\nint peek(Stack* s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[s->top];\n}\n\nint main() {\n    Stack s;\n    initStack(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printf(\"Peek: %d\\n\", peek(&s));\n    printf(\"Pop: %d\\n\", pop(&s));\n    printf(\"Pop: %d\\n\", pop(&s));\n    printf(\"Pop: %d\\n\", pop(&s));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:44.581020"
  },
  {
    "question": "C dilinde bir Queue veri yapısı oluşturun. 'enqueue', 'dequeue' ve 'front' işlevlerini tamamlayın. Queue'un dolu olup olmadığını kontrol eden bir 'isFull' ve boş olup olmadığını kontrol eden 'isEmpty' işlevini de ekleyin. Ayrıca, Queue'yu döngüsel (circular) hale getirin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 5\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue* q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (isFull(q)) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->rear = (q->rear + 1) % MAX;\n    q->items[q->rear] = item;\n}\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    int item = q->items[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front = (q->front + 1) % MAX;\n    }\n    return item;\n}\n\nint front(Queue* q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return q->items[q->front];\n}\n\nint main() {\n    Queue q;\n    initQueue(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    printf(\"Front: %d\\n\", front(&q));\n    printf(\"Dequeue: %d\\n\", dequeue(&q));\n    enqueue(&q, 30);\n    printf(\"Front: %d\\n\", front(&q));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:44.581120"
  },
  {
    "question": "Bir stack uygulamasında, elemanları eklerken yanlışlıkla 'pop' fonksiyonu çağrıldığında ne olabilir?",
    "answer": "Stack veri yapısında 'pop' fonksiyonu, üstteki elemanı çıkartır ve bu işlem, o elemanın kaybına yol açar. Örneğin, aşağıdaki kodda eleman eklemek yerine yanlışlıkla 'pop' çağrıldığında, veriler kaybolur:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\nint stack[MAX];\nint top = -1;\n\nvoid push(int value) {\n    if (top == MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = value;\n}\n\nint pop() {\n    if (top == -1) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return stack[top--];\n}\n\nint main() {\n    push(10);\n    push(20);\n    pop(); // Burada pop çağrışı yapılması, en son eklenen 20 değerinin kaybına neden olur.\n    printf(\"En üstteki eleman: %d\\n\", pop()); // Bu çağrı aslında 10 değerini döndürür.\n    return 0;\n}\n```\nBu senaryo, stack kullanımında dikkat edilmesi gereken unsurlardan biridir. Her iki işlem arasında dikkatli olunmalıdır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:58.816653"
  },
  {
    "question": "Bir kuyruk uygulamasında 'enqueue' işlemi sırasında bellek taşması (buffer overflow) hatası neden oluşabilir?",
    "answer": "Kuyruk veri yapısı, eleman eklemek için 'enqueue' fonksiyonu kullanır. Eğer kuyruk doluysa ve daha fazla eleman eklenmeye çalışılırsa, bellek taşması hatası meydana gelir. Aşağıdaki örnekte bu durum gözlemlenebilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 5\nint queue[MAX];\nint front = -1, rear = -1;\n\nvoid enqueue(int value) {\n    if (rear == MAX - 1) {\n        printf(\"Kuyruk dolu!\\n\");\n        return;\n    }\n    if (front == -1) front = 0; // İlk eleman ekleniyor\n    queue[++rear] = value;\n}\n\nint dequeue() {\n    if (front == -1 || front > rear) {\n        printf(\"Kuyruk boş!\\n\");\n        return -1;\n    }\n    return queue[front++];\n}\n\nint main() {\n    for (int i = 0; i < 6; i++) {\n        enqueue(i); // 6. elemanı eklemeye çalıştığımızda kuyruğun boyutunu aşmış oluyoruz.\n    }\n    return 0;\n}\n```\nBu hatadan kaçınmak için, 'enqueue' işleminden önce kuyruk boyutunu kontrol etmek gerekir. Ayrıca, kuyruk boyutunu dinamik olarak yönetmek için daha gelişmiş bir yapı kullanılabilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:22:58.816699"
  },
  {
    "question": "C dilinde bir stack uygulamasında push ve pop fonksiyonları doğru çalışmıyor. Kod aşağıdaki gibi: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nvoid push(Stack *s, int value) {\n    if (isFull(s)) {\n        printf(\"Stack OverFlow\\n\");\n        return;\n    }\n    s->arr[++(s->top)] = value;\n}\n\nint pop(Stack *s) {\n    if (isEmpty(s)) {\n        printf(\"Stack UnderFlow\\n\");\n        return -1;\n    }\n    return s->arr[(s->top)--];\n}\n\nint main() {\n    Stack s;\n    initStack(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printf(\"Pop: %d\\n\", pop(&s));\n    printf(\"Pop: %d\\n\", pop(&s));\n    printf(\"Pop: %d\\n\", pop(&s));\n    return 0;\n}\n``` \n\nBu kodu çalıştırdığınızda beklenmedik bir sonuç alıyorsunuz. Sorun ne olabilir?",
    "answer": "Bu kodda pop işlemi sırasında stack'in boş olup olmadığını kontrol ediyoruz. Ancak, pop fonksiyonunun dönüş değeri -1 olduğunda, çağrıldığı yerlerde -1 değerini bir sayı olarak kullanmaya çalışıyoruz. Bu, programın mantığında bir hata yaratabilir. Bunun önüne geçmek için, pop fonksiyonunu çağırdıktan sonra dönen değerin -1 olup olmadığını kontrol etmemiz gerekiyor. Yani, main fonksiyonundaki pop çağrılarının sonuçları kontrol edilmelidir: \n\n```c\nint result = pop(&s);\nif (result != -1) {\n    printf(\"Pop: %d\\n\", result);\n} else {\n    printf(\"Stack boş, pop işlemi yapılamaz.\\n\");\n}\n``` \n\nBu şekilde, stack'in boş olduğu durumları kontrol ederek, daha güvenli bir program yazmış oluruz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:21.578058"
  },
  {
    "question": "Bir queue uygulamasında enqueue ve dequeue fonksiyonları çalışmıyor. Kod aşağıdaki gibi: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue *q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue *q, int value) {\n    if (isFull(q)) {\n        printf(\"Queue Full\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->rear = (q->rear + 1) % MAX;\n    q->arr[q->rear] = value;\n}\n\nint dequeue(Queue *q) {\n    if (isEmpty(q)) {\n        printf(\"Queue Empty\\n\");\n        return -1;\n    }\n    int value = q->arr[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front = (q->front + 1) % MAX;\n    }\n    return value;\n}\n\nint main() {\n    Queue q;\n    initQueue(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    printf(\"Dequeue: %d\\n\", dequeue(&q));\n    printf(\"Dequeue: %d\\n\", dequeue(&q));\n    printf(\"Dequeue: %d\\n\", dequeue(&q));\n    return 0;\n}\n``` \n\nBu kodu çalıştırdığınızda beklenmedik bir sonuç alıyorsunuz. Sorun ne olabilir?",
    "answer": "Bu kodda, dequeue fonksiyonu çalıştığında, sıranın boş olup olmadığını kontrol ediyoruz. Ancak, dequeue işlemi gerçekleştikten sonra, front ve rear değişkenlerini güncellememiz gerekiyor. Eğer dequeue işlemi sonrasında hem front hem de rear -1'e ayarlanırsa, bir sonraki enqueue işlemi sırasında front'un -1 olarak kalmasına neden olabiliriz. Bu, sıranın dolup dolmadığını kontrol eden isFull fonksiyonuna yanlış bilgi verebilir. Bunun önüne geçmek için dequeue fonksiyonu içinde, dequeue işleminden sonra front ve rear değerlerini kontrol etmemiz gerekir. Dequeue sonrası front ve rear'ı ayrı ayrı kontrol edip, gerekirse onları güncellemeliyiz. \n\nAyrıca, queue'nun tam olarak boş olup olmadığını anlamak için, dequeue'dan sonra sadece front değişkenini kontrol etmek yeterli değildir. Bu nedenle, enqueue fonksiyonunda isEmpty kontrolü yaparak front değerini ayarlamak da önemlidir. \n\nÖrneğin: \n\n```c\nif (q->front == q->rear) {\n    q->front = -1;\n    q->rear = -1;\n} else {\n    q->front = (q->front + 1) % MAX;\n}\n``` \n\nBu şekilde, kod daha stabil hale gelir ve beklenmedik sonuçların önüne geçilmiş olur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:21.578381"
  },
  {
    "question": "Aşağıdaki C kodunda bir yığın (stack) uygulaması bulunmaktadır. Ancak, kod çalıştırıldığında 'stack overflow' hatası alıyorum. Hatanın kaynağını bularak düzeltin ve nedenini açıklayın.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX 5\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint push(Stack *s, int value) {\n    if (isFull(s)) {\n        return 0; // Stack overflow\n    }\n    s->items[++(s->top)] = value;\n    return 1;\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    for (int i = 0; i <= MAX; i++) {\n        push(&s, i);\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda, 'for' döngüsü MAX (5) değerine eşit olan i değerine kadar devam ediyor. Ancak, 'push' fonksiyonu, yığının en son elemanının dizinini 'top' değişkenine göre belirliyor. Bu durumda, 'top' 0'dan başlayarak 4'e kadar (5 eleman) yükseliyor ve döngü 5. iterasyonda 'top' 5 olunca 'isFull' fonksiyonu 1 döndürmüyor ve 'push' fonksiyonu hata veriyor. Düzeltmek için döngüyü  < MAX olarak değiştirmeliyiz:\n\n```c\nfor (int i = 0; i < MAX; i++) {\n    push(&s, i);\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:38.548314"
  },
  {
    "question": "Aşağıdaki C kodunda bir kuyruk (queue) uygulaması bulunmaktadır. Ancak, kod çalıştırıldığında 'segmentation fault' hatası alıyorum. Problemi bulun ve çözümleyin. Hatanın nedeni nedir?\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX 5\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initialize(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nint enqueue(Queue *q, int value) {\n    if (q->rear == MAX - 1) {\n        return 0; // Queue is full\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->items[++(q->rear)] = value;\n    return 1;\n}\n\nint dequeue(Queue *q) {\n    if (isEmpty(q)) {\n        return -1; // Queue is empty\n    }\n    if (q->front == q->rear) {\n        q->front = q->rear = -1; // Reset queue if it becomes empty\n    }\n    return q->items[q->front++];\n}\n\nint main() {\n    Queue q;\n    initialize(&q);\n    for (int i = 0; i < MAX + 2; i++) {\n        enqueue(&q, i);\n    }\n    return 0;\n}\n```",
    "answer": "Bu kodda, 'enqueue' fonksiyonu, kuyruk dolu olduğunda 'segmentation fault' hatası oluşturabilir. Ana işlevde, 'for' döngüsü MAX + 2 kadar devam ediyor. Bu, kuyruk dolduktan sonra (5 öğe eklendikten sonra) daha fazla öğe eklemeye çalışmak anlamına gelir. Bu durumda, 'rear' değişkeni MAX - 1 olduğunda, yeni bir öğe eklenmeye çalışıldığında bellek dışında bir alana yazma işlemi gerçekleşiyor, bu da 'segmentation fault' hatasına neden oluyor. Düzeltmek için döngüyü MAX kadar sınırlamalıyız:\n\n```c\nfor (int i = 0; i < MAX; i++) {\n    enqueue(&q, i);\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:38.548582"
  },
  {
    "question": "Stack nedir ve bir uygulama senaryosunu açıklayın.",
    "answer": "Stack, son giren ilk çıkar (LIFO) prensibiyle çalışan bir veri yapısıdır. Yani, en son eklenen eleman ilk önce çıkar. Örneğin, bir tarayıcıda gezinirken geri ve ileri tuşlarını kullanma senaryosu düşünelim. Kullanıcı bir sayfayı ziyaret ettiğinde bu sayfa stack'e eklenir. Kullanıcı 'geri' tuşuna bastığında, en son eklenen sayfa stack'ten çıkar ve kullanıcı bir önceki sayfaya döner. Bu durumda, geri tuşu stack'in 'pop' işlemini temsil eder.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:44.445055"
  },
  {
    "question": "Queue nedir ve gerçek bir uygulama senaryosunu belirtin.",
    "answer": "Queue, ilk giren ilk çıkar (FIFO) prensibiyle çalışan bir veri yapısıdır. Bu, verilerin sıralı bir şekilde işlendiği senaryolar için uygundur. Örneğin, bir yazıcıya gönderilen belgeleri düşünelim. Belgeler, yazıcıya sırayla gönderilir. İlk gönderilen belge ilk olarak yazdırılır. Bu durumda, queue'nun 'enqueue' işlemi belgeleri sıraya eklemek, 'dequeue' işlemi ise belgeleri yazıcıdan çıkarmak anlamına gelir. Böylece, belgeler öncelik sırasına göre işlenir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:23:44.445103"
  },
  {
    "question": "Bir web tarayıcısında geri ve ileri butonları nasıl çalışır? Bu işlevselliği implement etmek için Stack kullanarak bir örnek oluştur.",
    "answer": "Web tarayıcılarında geri ve ileri butonları kullanılırken, ziyaret edilen sayfaların sırasını takip etmek için Stack yapısı kullanılır. Stack, son giren ilk çıkar (LIFO) prensibine dayanır. Ziyaret edilen sayfalar, bir Stack'e eklenir ve geri butonuna basıldığında en son eklenen sayfa çıkarılarak gösterilir. Örnek bir C kodu: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 10\n\ntypedef struct {\n    char *pages[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nvoid push(Stack *s, char *page) {\n    if (!isFull(s)) {\n        s->pages[++s->top] = strdup(page);\n    } else {\n        printf(\"Stack dolu!\\n\");\n    }\n}\n\nchar *pop(Stack *s) {\n    if (!isEmpty(s)) {\n        return s->pages[s->top--];\n    } else {\n        printf(\"Stack boş!\\n\");\n        return NULL;\n    }\n}\n\nint main() {\n    Stack history;\n    init(&history);\n\n    push(&history, \"google.com\");\n    push(&history, \"stackoverflow.com\");\n    push(&history, \"github.com\");\n    printf(\"Geri gidiyoruz: %s\\n\", pop(&history)); // github.com\n    printf(\"Geri gidiyoruz: %s\\n\", pop(&history)); // stackoverflow.com\n\n    return 0;\n}\n```\nBu kodda, Stack yapısı ile ziyaret edilen sayfalar tutuluyor ve geri gitme işlemi yapılırken son eklenen sayfa çıkarılıyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:06.699641"
  },
  {
    "question": "Bir işlemci kuyruk yönetimi nasıl gerçekleştirir? FIFO prensibiyle çalışan bir kuyruk uygulaması yaparak açıklayınız.",
    "answer": "İşlemciler, gelen görevleri sıralamak ve yönetmek için Queue yapısını kullanır. FIFO (First In, First Out) prensibine göre çalıştığı için, ilk gelen görev ilk işlenir. Bu, görevlerin sırayla işlenmesini sağlar. Örnek bir C kodu: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 5\n\ntypedef struct {\n    char *tasks[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid init(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nint isFull(Queue *q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, char *task) {\n    if (!isFull(q)) {\n        q->tasks[q->rear] = strdup(task);\n        q->rear = (q->rear + 1) % MAX;\n    } else {\n        printf(\"Kuyruk dolu!\\n\");\n    }\n}\n\nchar *dequeue(Queue *q) {\n    if (!isEmpty(q)) {\n        char *task = q->tasks[q->front];\n        q->front = (q->front + 1) % MAX;\n        return task;\n    } else {\n        printf(\"Kuyruk boş!\\n\");\n        return NULL;\n    }\n}\n\nint main() {\n    Queue taskQueue;\n    init(&taskQueue);\n\n    enqueue(&taskQueue, \"Görev 1\");\n    enqueue(&taskQueue, \"Görev 2\");\n    enqueue(&taskQueue, \"Görev 3\");\n    printf(\"İşlem yapılıyor: %s\\n\", dequeue(&taskQueue)); // Görev 1\n    printf(\"İşlem yapılıyor: %s\\n\", dequeue(&taskQueue)); // Görev 2\n\n    return 0;\n}\n```\nBu kodda, bir kuyruk yapısı ile görevler sıraya alınıyor ve FIFO prensibi ile işleniyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:06.699688"
  },
  {
    "question": "Bir tarayıcı geçmişini nasıl Stack veri yapısı ile yönetebiliriz? Tarayıcı geri ve ileri butonları ile ilgili bir uygulama örneği verin.",
    "answer": "Bir tarayıcı geçmişi, kullanıcının gezindiği sayfaların bir sırasını takip etmek için Stack veri yapısını kullanır. Stack, LIFO (Last In, First Out) prensibine göre çalışır, yani en son eklenen öğe ilk olarak çıkar. Görsel bir örnekle açıklayalım: Tarayıcıda 'A' sayfasını açtık, ardından 'B' ve 'C' sayfalarına geçtik. Bu durumda stackimiz şöyle olacak: ['A', 'B', 'C']. Eğer kullanıcı geri tuşuna basarsa, 'C' sayfası stack'ten çıkar ve 'B' sayfası görüntülenir. Bunun için basit bir C kodu yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct Stack {\n    char* pages[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, char* page) {\n    if (!isFull(s)) {\n        s->pages[++(s->top)] = strdup(page);\n    }\n}\n\nchar* pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->pages[(s->top)--];\n    }\n    return NULL;\n}\n\nint main() {\n    Stack history;\n    init(&history);\n    push(&history, \"A\");\n    push(&history, \"B\");\n    push(&history, \"C\");\n    printf(\"Geri gidiliyor: %s\\n\", pop(&history)); // 'C' sayfası geri gidiyor\n    return 0;\n}\n```\nBu kodda, tarayıcı geçmişini bir stack ile yönetiyoruz. Kullanıcı geri gittiğinde en son açtığı sayfa çıkıyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:29.705410"
  },
  {
    "question": "Bir acil durum yönetim sisteminde, gelen çağrıları nasıl Queue veri yapısı ile yönetebiliriz? Örnek bir uygulama ile açıklayın.",
    "answer": "Acil durum yönetim sistemleri, gelen çağrıları zaman sırasına göre işlemek için Queue veri yapısını kullanır. Queue, FIFO (First In, First Out) prensibine göre çalışır; yani en önce gelen çağrı, önce işleme alınır. Örneğin, bir acil durum çağrı merkezine üç çağrı geldi: 'Çağrı 1', 'Çağrı 2', 'Çağrı 3'. Queue, bu çağrıları şu şekilde tutar: ['Çağrı 1', 'Çağrı 2', 'Çağrı 3']. İlk olarak 'Çağrı 1' işlenir, ardından 'Çağrı 2' ve son olarak 'Çağrı 3'. Aşağıda basit bir C kodu ile bunu gösterebiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct Queue {\n    char* calls[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid init(Queue* q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nint isFull(Queue* q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue* q, char* call) {\n    if (!isFull(q)) {\n        q->calls[q->rear] = strdup(call);\n        q->rear = (q->rear + 1) % MAX;\n    }\n}\n\nchar* dequeue(Queue* q) {\n    if (!isEmpty(q)) {\n        char* call = q->calls[q->front];\n        q->front = (q->front + 1) % MAX;\n        return call;\n    }\n    return NULL;\n}\n\nint main() {\n    Queue emergencyCalls;\n    init(&emergencyCalls);\n    enqueue(&emergencyCalls, \"Çağrı 1\");\n    enqueue(&emergencyCalls, \"Çağrı 2\");\n    enqueue(&emergencyCalls, \"Çağrı 3\");\n    printf(\"İşlenen çağrı: %s\\n\", dequeue(&emergencyCalls)); // 'Çağrı 1' işleniyor\n    return 0;\n}\n``` \nBu kodda, bir acil durum çağrı merkezinde gelen çağrıları bir queue ile yönetiyoruz. İlk gelen çağrı her zaman ilk işleniyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:29.705461"
  },
  {
    "question": "Bir stack yapısını nasıl implement edersiniz ve bu yapının temel işlevlerini nasıl tanımlarsınız?",
    "answer": "Stack, LIFO (Last In First Out) prensibine göre çalışan bir veri yapısıdır. Yani, en son eklenen eleman ilk çıkar. Bu yapıyı C dilinde basit bir yapı ile implement edebiliriz. Öncelikle bir 'Node' yapısı tanımlarız. Bu yapı, bir değeri ve bir sonraki düğümü gösterecek bir pointer içerir. Ardından, stack yapısı için 'push', 'pop' ve 'peek' (üstteki elemanı görme) işlevlerini tanımlayabiliriz. İşte temel bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nvoid push(Stack* stack, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack is empty!\\n\");\n        return -1;\n    }\n    Node* temp = stack->top;\n    int poppedData = temp->data;\n    stack->top = stack->top->next;\n    free(temp);\n    return poppedData;\n}\n\nint peek(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack is empty!\\n\");\n        return -1;\n    }\n    return stack->top->data;\n}\n```\n\nBu kodda, 'createStack' fonksiyonu yeni bir stack oluşturur, 'push' fonksiyonu yeni bir elemanı stack'e ekler, 'pop' fonksiyonu en üstteki elemanı çıkartır ve 'peek' fonksiyonu en üstteki elemanı döndürür.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:51.606098"
  },
  {
    "question": "Bir queue yapısını nasıl implement edersiniz ve bu yapının temel işlevlerini nasıl tanımlarsınız?",
    "answer": "Queue, FIFO (First In First Out) prensibine göre çalışan bir veri yapısıdır. Yani, ilk eklenen eleman ilk çıkar. C dilinde bir queue yapısını implement etmek için yine bir 'Node' yapısı tanımlarız. Bu yapı, bir değeri ve bir sonraki düğümü gösterecek bir pointer içerir. Ardından, queue yapısı için 'enqueue', 'dequeue' ve 'peek' (öndeki elemanı görme) işlevlerini tanımlayabiliriz. İşte temel bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nQueue* createQueue() {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->front = queue->rear = NULL;\n    return queue;\n}\n\nvoid enqueue(Queue* queue, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    if (queue->rear == NULL) {\n        queue->front = queue->rear = newNode;\n        return;\n    }\n    queue->rear->next = newNode;\n    queue->rear = newNode;\n}\n\nint dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue is empty!\\n\");\n        return -1;\n    }\n    Node* temp = queue->front;\n    int dequeuedData = temp->data;\n    queue->front = queue->front->next;\n    if (queue->front == NULL) {\n        queue->rear = NULL;\n    }\n    free(temp);\n    return dequeuedData;\n}\n\nint peek(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue is empty!\\n\");\n        return -1;\n    }\n    return queue->front->data;\n}\n```\n\nBu kodda, 'createQueue' fonksiyonu yeni bir queue oluşturur, 'enqueue' fonksiyonu yeni bir elemanı queue'ya ekler, 'dequeue' fonksiyonu öndeki elemanı çıkartır ve 'peek' fonksiyonu öndeki elemanı döndürür.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:24:51.606161"
  },
  {
    "question": "C dilinde bir stack (yığın) veri yapısını nasıl implement edersiniz? Stack'in temel işlevlerini (push, pop, peek) nasıl tanımlarsınız?",
    "answer": "Stack, LIFO (Last In First Out) prensibiyle çalışan bir veri yapısıdır. C dilinde basit bir stack implementasyonu için bir struct tanımlayarak başlayabiliriz. İşlevlerimiz push, pop ve peek olacak. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int value) {\n    if (!isFull(s)) {\n        s->arr[++(s->top)] = value;\n    } else {\n        printf(\"Stack dolu!\\n\");\n    }\n}\n\nint pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->arr[(s->top)--];\n    } else {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n}\n\nint peek(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->arr[s->top];\n    } else {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n}\n\nint main() {\n    Stack s;\n    init(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printf(\"Peek: %d\\n\", peek(&s)); // 20\n    printf(\"Pop: %d\\n\", pop(&s));   // 20\n    printf(\"Pop: %d\\n\", pop(&s));   // 10\n    return 0;\n}\n```\nBu kodda bir Stack yapısı tanımlıyoruz, ardından temel işlevleri (push, pop, peek) implement ediyoruz. Bu basit implementasyon, stack'in temel özelliklerini ve kullanımını anlamanıza yardımcı olur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:13.119683"
  },
  {
    "question": "C dilinde bir queue (kuyruk) veri yapısını nasıl implement edersiniz? Queue'un temel işlevlerini (enqueue, dequeue, front) nasıl tanımlarsınız?",
    "answer": "Queue, FIFO (First In First Out) prensibiyle çalışan bir veri yapısıdır. C dilinde bir queue implementasyonu için bir struct tanımlıyor ve temel işlevleri enqueue, dequeue ve front olarak belirliyoruz. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid init(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue* q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue* q, int value) {\n    if (!isFull(q)) {\n        if (isEmpty(q)) {\n            q->front = 0;\n        }\n        q->rear = (q->rear + 1) % MAX;\n        q->arr[q->rear] = value;\n    } else {\n        printf(\"Queue dolu!\\n\");\n    }\n}\n\nint dequeue(Queue* q) {\n    if (!isEmpty(q)) {\n        int value = q->arr[q->front];\n        if (q->front == q->rear) {\n            q->front = -1;\n            q->rear = -1;\n        } else {\n            q->front = (q->front + 1) % MAX;\n        }\n        return value;\n    } else {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n}\n\nint front(Queue* q) {\n    if (!isEmpty(q)) {\n        return q->arr[q->front];\n    } else {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n}\n\nint main() {\n    Queue q;\n    init(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    printf(\"Front: %d\\n\", front(&q)); // 10\n    printf(\"Dequeue: %d\\n\", dequeue(&q)); // 10\n    printf(\"Dequeue: %d\\n\", dequeue(&q)); // 20\n    return 0;\n}\n```\nBu kodda bir Queue yapısı tanımlıyoruz ve temel işlevleri (enqueue, dequeue, front) implement ediyoruz. Bu implementasyon, queue'un temel özelliklerini ve kullanımını anlamanızı sağlar.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:13.119769"
  },
  {
    "question": "Bir denge kontrolü algoritması yazın. Verilen bir string ifadesinde parantezlerin dengeli olup olmadığını kontrol edin. Örneğin, '((()))' dengeli, '(()' ise dengesizdir. Bu kontrolü yapmak için Stack kullanın.",
    "answer": "Aşağıdaki kod parçası, verilen bir string ifadesinde parantezlerin dengeli olup olmadığını kontrol eden bir algoritma içermektedir. Stack yapısını kullanarak parantezleri takip ediyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Stack {\n    int top;\n    unsigned capacity;\n    char* array;\n} Stack;\n\nStack* createStack(unsigned capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (char*)malloc(stack->capacity * sizeof(char));\n    return stack;\n}\n\nbool isFull(Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nbool isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nvoid push(Stack* stack, char item) {\n    if (!isFull(stack)) {\n        stack->array[++stack->top] = item;\n    }\n}\n\nchar pop(Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->array[stack->top--];\n    }\n    return ' '; // Hata durumunda boş karakter döndür\n}\n\nbool isMatchingPair(char character1, char character2) {\n    return (character1 == '(' && character2 == ')');\n}\n\nbool areParenthesesBalanced(char* expr) {\n    Stack* stack = createStack(strlen(expr));\n    for (int i = 0; i < strlen(expr); i++) {\n        if (expr[i] == '(') {\n            push(stack, expr[i]);\n        } else if (expr[i] == ')') {\n            if (isEmpty(stack) || !isMatchingPair(pop(stack), expr[i])) {\n                return false;\n            }\n        }\n    }\n    return isEmpty(stack);\n}\n\nint main() {\n    char expr[] = \"((()))\";\n    if (areParenthesesBalanced(expr))\n        printf(\"Dengeli\\n\");\n    else\n        printf(\"Dengesiz\\n\");\n    return 0;\n}\n```\nBu kod, bir string ifadesini alır ve içinde bulunan parantezlerin dengeli olup olmadığını kontrol eder. Eğer tüm açılan parantezler kapatılmışsa, 'Dengeli' yazdırır; aksi takdirde 'Dengesiz' yazdırır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:34.253030"
  },
  {
    "question": "Bir işlemci simülasyonu için bir FIFO (First In First Out) Kuyruğu oluşturun. Kuyruk, gelen iş yüklerini saklayacak ve onları işlem sırasına göre yönetecektir. Kuyruğa iş yükü ekleyin ve bunları işleyerek çıktısını alın.",
    "answer": "Aşağıdaki kod, bir FIFO kuyruğu simülasyonu yapmaktadır. İş yükü ekleyip, bunları sırayla işleyerek çıktısını alıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Queue {\n    int front, rear, capacity;\n    int* array;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->capacity = capacity;\n    queue->front = queue->rear = 0;\n    queue->array = (int*)malloc(queue->capacity * sizeof(int));\n    return queue;\n}\n\nbool isFull(Queue* queue) {\n    return (queue->rear == queue->capacity);\n}\n\nbool isEmpty(Queue* queue) {\n    return (queue->front == queue->rear);\n}\n\nvoid enqueue(Queue* queue, int item) {\n    if (!isFull(queue)) {\n        queue->array[queue->rear++] = item;\n    } else {\n        printf(\"Kuyruk dolu!\\n\");\n    }\n}\n\nint dequeue(Queue* queue) {\n    if (!isEmpty(queue)) {\n        return queue->array[queue->front++];\n    }\n    printf(\"Kuyruk boş!\\n\");\n    return -1; // Hata durumu\n}\n\nvoid processTasks(Queue* queue) {\n    while (!isEmpty(queue)) {\n        int task = dequeue(queue);\n        if (task != -1) {\n            printf(\"İşlem yapılıyor: %d\\n\", task);\n        }\n    }\n}\n\nint main() {\n    Queue* queue = createQueue(5);\n    enqueue(queue, 1);\n    enqueue(queue, 2);\n    enqueue(queue, 3);\n    enqueue(queue, 4);\n    enqueue(queue, 5);\n    processTasks(queue);\n    return 0;\n}\n```\nBu kod, bir FIFO kuyruğu oluşturur ve farklı iş yükleri ekler. İş yüklerini sırayla işleyerek kullanıcıya çıktısını verir. Kuyruğun dolu olup olmadığını ve boş olup olmadığını kontrol eden fonksiyonlar da mevcuttur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:34.253108"
  },
  {
    "question": "Bir programda, kullanıcıdan alınan bir dizi sayının tersine çevrilmesi isteniyor. Mevcut kodda bir stack kullanarak bu işlem gerçekleştiriliyor. Ancak, kodun verimliliği ve okunabilirliği artırılabilir. Mevcut kod şu şekilde:",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int arr[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nvoid push(Stack *s, int value) {\n    if (!isFull(s)) {\n        s->arr[++s->top] = value;\n    }\n}\n\nint pop(Stack *s) {\n    if (!isEmpty(s)) {\n        return s->arr[s->top--];\n    }\n    return -1; // Hata durumu\n}\n\nint main() {\n    Stack s;\n    initStack(&s);\n    int n, value;\n\n    printf(\"Kaç sayı gireceksiniz? \");\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &value);\n        push(&s, value);\n    }\n\n    printf(\"Ters sıralama: \");\n    while (!isEmpty(&s)) {\n        printf(\"%d \", pop(&s));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` \nYukarıdaki kod, temel bir stack uygulamasıyla çalışıyor. Ancak daha okunabilir ve verimli hale getirmek için şu önerilerde bulunabilirim: 1. `MAX` değerini dinamik hale getirin, böylece kullanıcıdan alınan değer kadar bellek ayırabilirsiniz. 2. `push` ve `pop` fonksiyonlarında hata kontrolü ekleyin ve kullanıcıya uygun hata mesajları verin. 3. `main` içindeki döngüler ve giriş işlemlerini ayrı fonksiyonlara ayırarak kodun okunabilirliğini artırabilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:52.999333"
  },
  {
    "question": "Bir uygulamada, bir müşteri hizmetleri çağrı merkezinin çağrılarını yönetmek için bir kuyruk (queue) kullanılıyor. Queue yapısı tipik bir `enqueue` ve `dequeue` işlemleriyle çalışıyor. Mevcut kodda, çağrılar işlendiğinde bazı sorunlar yaşanıyor. İşte mevcut kod:",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 50\n\ntypedef struct {\n    int arr[MAX];\n    int front;\n    int rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue *q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue *q, int value) {\n    if (isFull(q)) {\n        printf(\"Kuyruk dolu!\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->rear = (q->rear + 1) % MAX;\n    q->arr[q->rear] = value;\n}\n\nint dequeue(Queue *q) {\n    if (isEmpty(q)) {\n        printf(\"Kuyruk boş!\\n\");\n        return -1; // Hata durumu\n    }\n    int value = q->arr[q->front];\n    if (q->front == q->rear) {\n        initQueue(q); // Kuyruk boşsa sıfırla\n    } else {\n        q->front = (q->front + 1) % MAX;\n    }\n    return value;\n}\n\nint main() {\n    Queue q;\n    initQueue(&q);\n    // Örnek çağrılar ekleme ve çıkarma işlemleri\n    enqueue(&q, 101);\n    enqueue(&q, 102);\n    printf(\"İşlem gören çağrı: %d\\n\", dequeue(&q));\n    printf(\"İşlem gören çağrı: %d\\n\", dequeue(&q));\n    printf(\"İşlem gören çağrı: %d\\n\", dequeue(&q)); // Boş kuyruğa erişim\n    return 0;\n}\n``` \nBu kodda birkaç iyileştirme önerim var: 1. Kullanıcı dostu bir deneyim için hata mesajlarını daha açıklayıcı hale getirin. 2. Dinamik bellek yönetimi ile kuyruğun boyutunu dinamik hale getirin, böylece `MAX` değeriyle sınırlı kalmazsınız. 3. `dequeue` fonksiyonunda kuyruğun boş olup olmadığını kontrol ettikten sonra, işlemi gerçekleştirdikten sonra çağrıyı yazdırmak için bir kontrol eklemek faydalı olabilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:25:52.999418"
  },
  {
    "question": "Bir diziyi ters çevirmek için bir stack kullanarak bir C fonksiyonu yazın. Mevcut haliyle kodu optimize edin ve bellek yönetimi konusunda iyileştirmeler yapın.",
    "answer": "Aşağıdaki gibi bir kod yazdığımızı varsayalım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (!isFull(s)) {\n        s->items[++(s->top)] = item;\n    }\n}\n\nint pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->items[(s->top)--];\n    }\n    return -1; // hata durumu\n}\n\nvoid reverseArray(int* arr, int n) {\n    Stack s;\n    initStack(&s);\n    for (int i = 0; i < n; i++) {\n        push(&s, arr[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        arr[i] = pop(&s);\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n``` \n\nBu kod işlevsel ancak optimize edilebilir. Öneriler:\n1. Stack boyutunu dinamik olarak belirleyin. Kullanıcıdan boyut alarak stack'i oluşturun, bu gereksiz bellek kullanımını önler.\n2. Stack'i bir linked list olarak uygularsanız, boyut sınırını aşmazsınız ve bellek yönetimi daha verimli olur.\n\nÖrnek güncellenmiş kod:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = NULL;\n}\n\nvoid push(Stack* s, int item) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = item;\n    newNode->next = s->top;\n    s->top = newNode;\n}\n\nint pop(Stack* s) {\n    if (s->top != NULL) {\n        Node* temp = s->top;\n        int item = temp->data;\n        s->top = s->top->next;\n        free(temp);\n        return item;\n    }\n    return -1; // hata durumu\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:26:20.536122"
  },
  {
    "question": "Bir Queue yapısını kullanarak bir işleme sırasını temsil eden bir C fonksiyonu yazın. Mevcut haliyle kodu inceleyin ve performans ve okunabilirlik açısından iyileştirmeler yapın.",
    "answer": "Aşağıdaki gibi bir kod yazdığımızı düşünelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = 0;\n    q->rear = -1;\n}\n\nint isFull(Queue* q) {\n    return ((q->rear + 1) % MAX) == q->front;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == ((q->rear + 1) % MAX);\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (!isFull(q)) {\n        q->rear = (q->rear + 1) % MAX;\n        q->items[q->rear] = item;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (!isEmpty(q)) {\n        int item = q->items[q->front];\n        q->front = (q->front + 1) % MAX;\n        return item;\n    }\n    return -1; // hata durumu\n}\n\nint main() {\n    Queue q;\n    initQueue(&q);\n    for (int i = 1; i <= 5; i++) {\n        enqueue(&q, i);\n    }\n    while (!isEmpty(&q)) {\n        printf(\"%d \", dequeue(&q));\n    }\n    return 0;\n}\n```\n\nBu kod işlevsel ancak bazı iyileştirmeler yapılabilir:\n1. Dinamik bellek kullanarak Queue'nun boyutunu kullanıcıya bırakın. Bu, daha esnek bir yapı sağlar.\n2. Queue’nun her işlemdeki performansını artırmak için linked list tabanlı bir uygulama geliştirin.\n\nÖrnek güncellenmiş kod:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* front;\n    Node* rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = q->rear = NULL;\n}\n\nvoid enqueue(Queue* q, int item) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = item;\n    newNode->next = NULL;\n    if (q->rear) {\n        q->rear->next = newNode;\n    }\n    q->rear = newNode;\n    if (!q->front) {\n        q->front = newNode;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (q->front) {\n        Node* temp = q->front;\n        int item = temp->data;\n        q->front = q->front->next;\n        if (!q->front) {\n            q->rear = NULL;\n        }\n        free(temp);\n        return item;\n    }\n    return -1; // hata durumu\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-05-31T17:26:20.536182"
  },
  {
    "question": "Ağaç yapısında bir düğüm tanımlamak için C dilinde eksik kodu tamamlayın. Düğüm, bir tamsayı değerine ve sol ve sağ çocuk düğümlere sahip olmalıdır.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data; // Düğümün veri alanı\n    struct Node* left; // Sol çocuk düğüm\n    struct Node* right; // Sağ çocuk düğüm\n} Node;\n\nNode* createNode(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value; // Düğüm verisini ayarla\n    newNode->left = NULL; // Sol çocuk başlangıçta boş\n    newNode->right = NULL; // Sağ çocuk başlangıçta boş\n    return newNode;\n}\n``` Açıklama: Bu kod parçasında, bir ağaç düğümü için yapı tanımlanmıştır. Düğüm, bir tamsayı değeri ve iki çocuk düğmeyi (sol ve sağ) içerir. Ayrıca, `createNode` fonksiyonu yeni bir düğüm oluşturmak için kullanılır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:26:32.196557"
  },
  {
    "question": "Bir ikili arama ağacına düğüm eklemek için C dilinde eksik kodu tamamlayın. Fonksiyon, yeni bir tamsayı değerini almalı ve uygun konumda ağaçta yeni düğümü eklemelidir.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* insert(Node* root, int value) {\n    if (root == NULL) {\n        return createNode(value); // Eğer ağaç boşsa, yeni düğüm oluştur\n    }\n    if (value < root->data) {\n        root->left = insert(root->left, value); // Sol alt ağaçta ekle\n    } else {\n        root->right = insert(root->right, value); // Sağ alt ağaçta ekle\n    }\n    return root; // Güncellenmiş kök düğümünü döndür\n}\n``` Açıklama: Bu kod, bir ikili arama ağacına yeni bir düğüm eklemek için gerekli olan `insert` fonksiyonunu içerir. Eğer mevcut kök düğüm boşsa, yeni düğüm oluşturulur. Eğer değer, mevcut düğümün verisinden küçükse sol alt ağaçta, büyükse sağ alt ağaçta eklenir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:26:32.196649"
  },
  {
    "question": "Bir ikili ağaç yapısı oluşturun ve bu ağaçta düğüm sayısını hesaplayan bir fonksiyon yazın. Eksik kodu tamamlayın:",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint countNodes(struct Node* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return 1 + countNodes(root->left) + countNodes(root->right);\n}\n\nint main() {\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n\n    printf(\"Düğüm sayısı: %d\\n\", countNodes(root));\n    return 0;\n}\n\n// Açıklama: Bu kod, basit bir ikili ağaç yapısı oluşturur ve düğüm sayısını hesaplayan bir fonksiyon tanımlar. 'countNodes' fonksiyonu, ağaçtaki düğüm sayısını döndürmek için rekürsif olarak kendisini çağırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:26:48.218742"
  },
  {
    "question": "Bir ikili arama ağacı oluşturun ve belirli bir değeri ağaçta arayan bir fonksiyon yazın. Eksik kodu tamamlayın:",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) {\n        return newNode(data);\n    }\n    if (data < node->data) {\n        node->left = insert(node->left, data);\n    } else {\n        node->right = insert(node->right, data);\n    }\n    return node;\n}\n\nint search(struct Node* root, int key) {\n    if (root == NULL || root->data == key) {\n        return root != NULL;\n    }\n    if (key < root->data) {\n        return search(root->left, key);\n    }\n    return search(root->right, key);\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    int key = 40;\n    if (search(root, key)) {\n        printf(\"%d bulundu.\\n\", key);\n    } else {\n        printf(\"%d bulunamadı.\\n\", key);\n    }\n    return 0;\n}\n\n// Açıklama: Bu kod, bir ikili arama ağacı oluşturur ve ağaçta belirli bir anahtarın (değerin) varlığını kontrol eden bir arama fonksiyonu tanımlar. 'search' fonksiyonu, ağacı gezer ve aramak istediği değeri bulursa 1, bulamazsa 0 döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:26:48.218813"
  },
  {
    "question": "Binary Search Tree (BST) yapısında bir düğüm ekleme fonksiyonunu tamamlayın. Ağaç yapısının kök düğümünü ve eklemek istediğiniz değeri parametre olarak alan bir fonksiyon yazmalısınız.",
    "answer": "#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int value;\\n    struct Node* left;\\n    struct Node* right;\\n} Node;\\n\\nNode* insert(Node* root, int value) {\\n    if (root == NULL) {\\n        Node* newNode = (Node*)malloc(sizeof(Node));\\n        newNode->value = value;\\n        newNode->left = NULL;\\n        newNode->right = NULL;\\n        return newNode;\\n    }\\n    if (value < root->value) {\\n        root->left = insert(root->left, value);\\n    } else {\\n        root->right = insert(root->right, value);\\n    }\\n    return root;\\n}\\n\\nint main() {\\n    Node* root = NULL;\\n    root = insert(root, 50);\\n    insert(root, 30);\\n    insert(root, 70);\\n    insert(root, 20);\\n    insert(root, 40);\\n    insert(root, 60);\\n    insert(root, 80);\\n    return 0;\\n}\\n\\n// Açıklama: Bu kod, ikili arama ağacı (BST) oluşturmak için bir düğüm ekleme fonksiyonu tanımlar. Fonksiyon, ağaçta uygun yeri bulana kadar sol veya sağ alt ağaçlara rekürsif olarak çağrılır. Eğer kök NULL ise yeni bir düğüm oluşturulur ve döndürülür.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:03.789922"
  },
  {
    "question": "Bir ağaç yapısında belirli bir değerin bulunup bulunmadığını kontrol eden bir fonksiyon yazın. Fonksiyon, ağaç kökü ve aranacak değeri almalı, değerin ağaçta olup olmadığını true/false ile döndürmelidir.",
    "answer": "#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int value;\\n    struct Node* left;\\n    struct Node* right;\\n} Node;\\n\\nbool search(Node* root, int value) {\\n    if (root == NULL) {\\n        return false;\\n    }\\n    if (root->value == value) {\\n        return true;\\n    } else if (value < root->value) {\\n        return search(root->left, value);\\n    } else {\\n        return search(root->right, value);\\n    }\\n}\\n\\nint main() {\\n    Node* root = NULL;\\n    // Ağaç oluşturalım ve düğümleri ekleyelim (insert fonksiyonu kullanılabilir)\\n    // Örnek değerler ekleyin ve arama yapın\\n    return 0;\\n}\\n\\n// Açıklama: Bu fonksiyon, verilen bir değerin ağacın herhangi bir düğümünde olup olmadığını kontrol eder. Eğer kök NULL ise false döndürür. Düğüm değeri ile karşılaştırılır ve uygun alt ağaçlarda rekürsif arama yapılır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:03.790005"
  },
  {
    "question": "Aşağıdaki kodda bir ikili ağaç oluşturmak için kullanılan yapı tanımı ve ağaç ekleme fonksiyonu var. Ancak, ekleme işlemi sırasında ağaç düzgün bir şekilde güncellenmiyor. Hatanın nerede olduğunu bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* insert(struct Node* root, int data) {\n    if (root == NULL) {\n        return createNode(data);\n    } else if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 10);\n    insert(root, 5);\n    insert(root, 15);\n    // Ağaç yapısını yazdırmak için bir fonksiyon eklenmelidir.\n    return 0;\n}\n```",
    "answer": "Kodda bir hata yok, fakat ağaç yapısını kontrol etmek için bir yazdırma fonksiyonu eklenmemiş. Bu nedenle ağaçta ekleme işleminin çalışıp çalışmadığını göremiyoruz. Ağaç yapısını görmek için inorder traversal ile yazdırma fonksiyonu ekleyebiliriz. Aşağıdaki gibi bir fonksiyon ekleyelim:\n\n```c\nvoid inorder(struct Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n```\n\nDaha sonra `main` fonksiyonuna şu ifadeyi ekleyelim:\n\n```c\ninorder(root);\n```\n\nBu, ağaç yapısını kontrol etmemizi sağlar. Kodun tam hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* insert(struct Node* root, int data) {\n    if (root == NULL) {\n        return createNode(data);\n    } else if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n\nvoid inorder(struct Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 10);\n    insert(root, 5);\n    insert(root, 15);\n    inorder(root);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:32.908113"
  },
  {
    "question": "Aşağıda, bir ikili ağaçta belirli bir değeri arayan bir fonksiyon var. Ancak, arama işlemi her zaman başarıyla sonuçlanmıyor. Hatanın kaynağını bulun ve düzeltin.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nint search(struct Node* root, int key) {\n    if (root == NULL) {\n        return 0;\n    }\n    if (root->data == key) {\n        return 1;\n    }\n    return (key < root->data) ? search(root->left, key) : search(root->right, key);\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = createNode(10);\n    root->left = createNode(5);\n    root->right = createNode(15);\n    if (search(root, 7)) {\n        printf(\"Bulundu\\n\");\n    } else {\n        printf(\"Bulunamadı\\n\");\n    }\n    return 0;\n}\n```",
    "answer": "Kodda, ağaç yapısının oluşturulmasında sorun var. `main` fonksiyonunda, `insert` fonksiyonu kullanılmadığı için ağaç tam olarak oluşturulmuyor. Bunun yerine doğrudan `createNode` ile düğümler oluşturulmuş ancak bunlar bir ağaç yapısı oluşturmuyor. Düğümleri eklemek için `insert` fonksiyonunu kullanmalıyız. Aşağıdaki gibi güncelleyebiliriz:\n\n```c\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 10);\n    insert(root, 5);\n    insert(root, 15);\n    if (search(root, 7)) {\n        printf(\"Bulundu\\n\");\n    } else {\n        printf(\"Bulunamadı\\n\");\n    }\n    return 0;\n}\n```\n\nBu değişiklikle birlikte `7` değerinin arama işlemi her zaman \"Bulunamadı\" mesajı verecektir çünkü `7` değeri ağaçta bulunmamaktadır. Ancak, arama işlemi doğru bir şekilde çalışacaktır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:32.908392"
  },
  {
    "question": "İkili ağaçta düğüm ekleme fonksiyonumda bir hata var. Aşağıdaki kodda neden 'NULL' referans hatası alıyorum?",
    "answer": "Hatanın nedeni, yeni bir düğüm eklerken 'NULL' kontrolü yapılmaması. Eğer eklemek istediğimiz düğüm, 'NULL' referansına atanıyorsa, bu hata alınır. Aşağıdaki düzeltilmiş kod örneğinde, önce mevcut düğümün 'NULL' olup olmadığını kontrol ediyoruz:\n\n```c\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* insert(struct Node* node, int value) {\n    if (node == NULL) {\n        struct Node* newNode = malloc(sizeof(struct Node));\n        newNode->data = value;\n        newNode->left = NULL;\n        newNode->right = NULL;\n        return newNode;\n    }\n    if (value < node->data) {\n        node->left = insert(node->left, value);\n    } else {\n        node->right = insert(node->right, value);\n    }\n    return node;\n}\n``` \nBu kodda, eğer yerleştirilecek düğüm 'NULL' ise, yeni bir düğüm oluşturup geri döndürüyoruz. Bu sayede 'NULL' referans hatasından kaçınıyoruz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:48.443695"
  },
  {
    "question": "Aşırı derin bir ikili ağaçta düğümleri dolaşmaya çalıştığımda 'stack overflow' hatası alıyorum. Bunu nasıl çözebilirim?",
    "answer": "Bu hata, ağaç çok derin olduğunda ve derinlik öncelikli (depth-first) dolaşım yapılmaya çalışıldığında ortaya çıkar. C dilinde, her fonksiyon çağrısı için bir yığın (stack) kullanılır, bu yüzden çok derin bir ağaçta yığın taşması yaşanır. Bu durumu önlemek için ya döngüsel (iterative) bir yaklaşım kullanmalı ya da ağaç yapısını dengelemelisiniz. Aşağıda, döngüsel bir yaklaşım kullanarak düğümleri dolaşmak için bir örnek verilmiştir:\n\n```c\nvoid inorderTraversal(struct Node* root) {\n    struct Node* stack[100]; // Yığın için sabit boyutlu dizi\n    int top = -1;\n    struct Node* current = root;\n    while (current != NULL || top != -1) {\n        while (current != NULL) {\n            stack[++top] = current; // Düğümü yığına ekle\n            current = current->left; // Sol alt ağaça git\n        }\n        current = stack[top--]; // Yığından düğümü al\n        printf(\"%d \", current->data); // Düğümü işle\n        current = current->right; // Sağ alt ağaça git\n    }\n}\n```\nBu kod, yığın kullanarak düğümleri dolaşmayı sağlar ve 'stack overflow' hatasından kaçınır. Yine de, çok derin ağaçlar için ağaç yapısını dengelemek, performans açısından daha iyi sonuç verebilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:27:48.443746"
  },
  {
    "question": "Ağaç yapısını kullanarak ikili arama ağacı (BST) oluşturacak bir fonksiyonda, ekleme işlemi sırasında bazı değerlerin doğru bir şekilde yerleştirilmediğini fark ettim. Kodum aşağıdaki gibi: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* insert(struct Node* root, int data) {\n    if (root == NULL) {\n        return createNode(data);\n    }\n    if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n    \n    // Yanlış olan ekleme işlemleri burada. \n    // Örneğin, 50 eklenmeye çalışıldığında, burası doğru bir yerde eklenmiyor.\n\n    return 0;\n}\n``` \nKodda hangi hatayı yaptım ve nasıl düzeltebilirim?",
    "answer": "Kodda görünürde bir hata yok, ancak ekleme işlemlerinin ardından ağaç yapısının doğru bir şekilde görselleştirildiğinden emin olmalısınız. Eğer ağaç yapısı doğru bir şekilde çalışıyorsa, eklenen her bir değer kendi alt ağaçlarına doğru yönlendirilmelidir. Önerim, eklemelerin ardından bir fonksiyon yazarak ağacınızı in-order traversal yöntemiyle gezip değerleri kontrol etmenizdir. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\nvoid inorderTraversal(struct Node* root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->data);\n        inorderTraversal(root->right);\n    }\n}\n```\nBu fonksiyonu `main` içerisinde ekleme işlemlerinden sonra çağırarak ağaç yapısının doğru olduğunu kontrol edebilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:11.984693"
  },
  {
    "question": "Bir ağaç yapısında derinlik öncelikli (pre-order) gezinti işlemini gerçekleştiren bir fonksiyonda, bazı düğümlerin atlandığını fark ettim. Aşağıdaki kodu incelediğimde, düğümlerin doğru bir şekilde ziyaret edilmediğini görüyorum: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nvoid preorderTraversal(struct Node* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    preorderTraversal(root->left);\n    preorderTraversal(root->right);\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    root->left->left = createNode(4);\n    root->left->right = createNode(5);\n    \n    preorderTraversal(root);\n    return 0;\n}\n``` \nKodda hangi hata var ve neden tüm düğümler ziyaret edilmiyor?",
    "answer": "Bu kodda görülen bir hata yok. Pre-order gezinti işleminin mantığı doğru bir şekilde uygulanmış. Düğüm ziyaret işlemi, sırasıyla önce kök düğüm, ardından sol alt ağaç ve sağ alt ağaç şeklinde geçiyor. Eğer bazı düğümlerin atlandığını düşünüyorsanız, muhtemelen ağacın yapısını oluştururken eksik bir düğüm eklemiş olabilirsiniz. Örneğin, `main` fonksiyonunda oluşturduğunuz ağaç yapısını kontrol edin. Eğer doğru bir şekilde oluşturulduysa, tüm düğümler ziyaret edilmelidir. Bunun için `preorderTraversal` fonksiyonunu çağırdıktan sonra çıktıyı kontrol edin. Eğer düğümler doğru bir şekilde oluşturulduysa, beklenen sonuç 1 2 4 5 3 şeklinde olmalıdır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:11.984940"
  },
  {
    "question": "Bir ikili ağaç (binary tree) nedir ve hangi durumlarda kullanılır?",
    "answer": "İkili ağaç, her düğümün en fazla iki çocuğa sahip olduğu bir ağaç yapısıdır. İkili ağaçlar, veri yapıları ve algoritmalarında sıklıkla kullanılır. Özellikle sıralı verileri saklamak ve aramak için idealdirler. Örneğin, bir ikili arama ağacı (binary search tree) kullanarak verilere hızlı bir şekilde erişim sağlanabilir. Ağaç yapısı, veriler üzerinde hiyerarşik bir düzende işlem yapmamıza olanak tanır. Ayrıca, ağaç yapılarında gezinme işlemleri (in-order, pre-order, post-order) ile verilerin sıralı bir şekilde işlenmesi sağlanabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:22.898753"
  },
  {
    "question": "Ağaç yapısında düğüm eklemek için temel bir algoritma nasıl yazılır?",
    "answer": "Bir ağaç yapısına düğüm eklemek için genellikle önce ekleme yapılacak düğümün hangi pozisyonda olduğunu belirlememiz gerekir. Örneğin, bir ikili arama ağacına eleman eklerken, yeni değeri mevcut düğümler ile karşılaştırarak hangi alt düğüme (sol veya sağ) ekleyeceğimiz kararını vermeliyiz. Aşağıda basit bir C kod örneği ile bunu gösterebiliriz:\n\n```c\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* insert(struct Node* node, int data) {\n    // Yeni düğüm oluştur\n    if (node == NULL) {\n        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n        newNode->data = data;\n        newNode->left = newNode->right = NULL;\n        return newNode;\n    }\n\n    // Veriyi karşılaştır ve uygun alt düğüme ekle\n    if (data < node->data) {\n        node->left = insert(node->left, data);\n    } else {\n        node->right = insert(node->right, data);\n    }\n    return node;\n}\n```\nBu algoritma, verilen değere göre uygun konuma yeni bir düğüm ekler. Öncelikle mevcut düğüm 'NULL' ise yeni bir düğüm oluşturur. Aksi takdirde, 'data' değeri ile mevcut düğümün verisini karşılaştırarak sol veya sağ alt ağaçta ekleme yapar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:22.898793"
  },
  {
    "question": "Bir ikili arama ağacı (Binary Search Tree) nasıl oluşturulur ve temel işlemleri (ekleme, silme, arama) nasıl gerçekleştirilir?",
    "answer": "İkili arama ağacı, her bir düğümün en fazla iki çocuğa sahip olduğu bir ağaç yapısıdır. Bu yapının temel özelliği, her düğümün sol alt ağacındaki tüm değerlerin kendisinden küçük, sağ alt ağacındaki tüm değerlerin ise kendisinden büyük olmasıdır.\n\nAğaç oluşturmak için bir düğüm yapısı tanımlamamız gerekecek:\n```c\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n```\n\nAğaçta bir düğüm eklemek için aşağıdaki fonksiyonu kullanabiliriz:\n```c\nNode* insert(Node* root, int data) {\n    if (root == NULL) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = data;\n        newNode->left = newNode->right = NULL;\n        return newNode;\n    }\n    if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n```\n\nDüğüm silme işlemi biraz daha karmaşıktır. Silinecek düğümün durumu (hiç çocuğu yok, bir çocuğu var, iki çocuğu var) kontrol edilmelidir. İşte basit bir örnek:\n```c\nNode* delete(Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data) {\n        root->left = delete(root->left, data);\n    } else if (data > root->data) {\n        root->right = delete(root->right, data);\n    } else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = delete(root->right, temp->data);\n    }\n    return root;\n}\n```\n\nArama işlemi ise oldukça basittir:\n```c\nNode* search(Node* root, int data) {\n    if (root == NULL || root->data == data) {\n        return root;\n    }\n    if (data < root->data) {\n        return search(root->left, data);\n    }\n    return search(root->right, data);\n}\n```\n\nBu temel işlemlerle birlikte bir ikili arama ağacı oluşturabilir, düğümler ekleyebilir, silebilir ve arama yapabilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:44.156680"
  },
  {
    "question": "Ağaç yapılarıyla bir dosya sisteminin nasıl temsil edileceğini ve dosya ekleme, silme işlemlerinin nasıl yapılacağını açıklayın.",
    "answer": "Bir dosya sistemi ağaç yapısı ile temsil edilebilir. Ağaçta her düğüm bir dosya veya bir dizin (klasör) olabilir. Dizinler alt dizinler veya dosyalar içerebilir, bu nedenle her düğüm, birden fazla çocuğa sahip olabilir. Ağaç yapımız şu şekilde tanımlanabilir:\n```c\ntypedef struct FileNode {\n    char* name;\n    int isDirectory; // 1 ise dizin, 0 ise dosya\n    struct FileNode** children;\n    int childCount;\n} FileNode;\n```\n\nBir dosya veya dizin eklemek için şu fonksiyonu kullanabiliriz:\n```c\nvoid addFile(FileNode* parent, char* name, int isDirectory) {\n    FileNode* newFile = (FileNode*)malloc(sizeof(FileNode));\n    newFile->name = name;\n    newFile->isDirectory = isDirectory;\n    newFile->children = NULL;\n    newFile->childCount = 0;\n    parent->children = (FileNode**)realloc(parent->children, sizeof(FileNode*) * (parent->childCount + 1));\n    parent->children[parent->childCount] = newFile;\n    parent->childCount++;\n}\n```\n\nDizin veya dosya silmek için ise aşağıdaki gibi bir fonksiyon yazabiliriz:\n```c\nvoid deleteFile(FileNode* parent, char* name) {\n    for (int i = 0; i < parent->childCount; i++) {\n        if (strcmp(parent->children[i]->name, name) == 0) {\n            free(parent->children[i]);\n            // Düğümü diziden çıkarmak için kaydırma işlemi\n            for (int j = i; j < parent->childCount - 1; j++) {\n                parent->children[j] = parent->children[j + 1];\n            }\n            parent->children = (FileNode**)realloc(parent->children, sizeof(FileNode*) * (parent->childCount - 1));\n            parent->childCount--;\n            return;\n        }\n    }\n}\n```\n\nBu yöntemlerle ağaç yapısı kullanarak dosya sistemini temsil edebilir ve dosyaları ekleyip silebilirsiniz. Ağaç yapısının avantajı, hiyerarşik veriyi düzenli bir şekilde temsil etmesi ve hızlı erişim sağlamasıdır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:44.156756"
  },
  {
    "question": "Ağaç veri yapısı kullanarak bir dosya sistemini nasıl modelleyebilirim? Hangi düğüm türlerini kullanmalıyım?",
    "answer": "Bir dosya sistemini modellemek için bir ağaç veri yapısı oldukça uygundur. Bu ağaçta her bir düğüm, bir dosya veya klasörü temsil edecektir. Klasörler, diğer klasörleri ve dosyaları içerebileceğinden, ağaç yapısında bir klasör düğümünün çocukları olabilir. Örneğin, bir 'Klasör' yapısı tanımlayabiliriz:\n\n```c\ntypedef struct Node {\n    char* name; // Düğüm adı\n    struct Node** children; // Alt düğümler\n    int childrenCount; // Alt düğüm sayısı\n} Node;\n```\n\nBurada 'name' alanı dosya veya klasörün adını tutar, 'children' ise alt düğümlerin bir dizisini saklar. 'childrenCount' ise bu dizideki eleman sayısını tutar. Dosya sistemini oluşturmak için, kök düğümden başlayarak alt düğümleri ekleyebiliriz. Kullanıcının belirli bir dosya veya klasörü bulmasını sağlamak için derinlik öncelikli (DFS) veya genişlik öncelikli (BFS) arama algoritmaları kullanılabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:57.891328"
  },
  {
    "question": "Ağaç yapısında belirli bir değeri ararken karşılaşabileceğim sorunlar nelerdir ve bunları nasıl çözebilirim?",
    "answer": "Ağaç yapısında belirli bir değeri ararken karşılaşabileceğiniz bazı sorunlar şunlardır: \n1. **Ağaç Dengesizliği**: Eğer ağaç dengesiz bir yapıda ise, arama işlemi O(n) zaman karmaşıklığına ulaşabilir. Dengeleyici ağaç yapıları (örneğin AVL ağaçları veya Kırmızı-Siyah ağaçlar) kullanarak bu durumu önleyebilirsiniz.\n\n2. **Düğümlere Erişim**: Ağaçta gezinti yaparken, doğru düğümlere erişim sağlamak önemlidir. Bunun için doğru algoritmayı seçmelisiniz. Örneğin, bir değer ararken DFS veya BFS kullanabilirsiniz. Her iki yöntemin de avantajları ve dezavantajları vardır; DFS derinlemesine gitmekte, BFS ise katman katman gezmektedir.\n\n3. **Bellek Yönetimi**: Ağaç yapısı dinamik bellek tahsisi gerektirdiği için, düğüm ekleme veya silme işlemlerinde bellek sızıntısı yaşanmaması için dikkatli olmalısınız. Her düğüm silindiğinde, o düğüme ait bellek alanını serbest bırakmayı unutmayın:\n```c\nfree(node);\n```\nBu sorunları göz önünde bulundurarak ağaç yapısında arama işlemini daha etkili ve güvenilir hale getirebilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:28:57.891373"
  },
  {
    "question": "Bir ikili arama ağacı (Binary Search Tree - BST) oluşturun ve verilen bir değeri ekleyen bir fonksiyon yazın. Ayrıca, ağacın in-order traversal'ını (sıralı gezinti) gerçekleştiren bir fonksiyon ekleyin.",
    "answer": "Aşağıdaki C kodu, bir ikili arama ağacı oluşturmayı ve eleman eklemeyi sağlar. Ayrıca, ağacın in-order traversal'ını gerçekleştiren bir fonksiyon içerir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nNode* insert(Node* root, int data) {\n    if (root == NULL) {\n        return createNode(data);\n    }\n    if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    Node* root = NULL;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    printf(\"In-order traversal: \");\n    inorder(root);\n    printf(\"\\n\");\n\n    return 0;\n}\n```\nBu kodda, öncelikle bir düğüm (Node) yapısı oluşturulmuştur. Ardından, `insert` fonksiyonu ile ağaç yapısına eleman eklenir. `inorder` fonksiyonu, ağacın elemanlarını sıralı bir şekilde ekrana yazdırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:15.521664"
  },
  {
    "question": "Bir ikili ağaçta (Binary Tree) düğümlerin sayısını hesaplayan bir fonksiyon yazın. Ayrıca, ağacın tüm düğümlerinin toplamını hesaplayan bir fonksiyon ekleyin.",
    "answer": "Aşağıdaki C kodu, bir ikili ağacın düğümlerinin sayısını ve düğümlerin toplamını hesaplayan fonksiyonları içerir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nint countNodes(Node* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return 1 + countNodes(root->left) + countNodes(root->right);\n}\n\nint sumOfNodes(Node* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return root->data + sumOfNodes(root->left) + sumOfNodes(root->right);\n}\n\nint main() {\n    Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    root->left->left = createNode(4);\n    root->left->right = createNode(5);\n\n    printf(\"Düğüm sayısı: %d\\n\", countNodes(root));\n    printf(\"Düğümlerin toplamı: %d\\n\", sumOfNodes(root));\n\n    return 0;\n}\n```\nBu kodda, öncelikle bir düğüm yapısı tanımlanmıştır. `countNodes` fonksiyonu, ağacın düğüm sayısını hesaplamakta, ve `sumOfNodes` fonksiyonu, düğümlerin toplamını bulmaktadır. `main` fonksiyonu örnek bir ağaç oluşturarak bu fonksiyonları çağırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:15.521718"
  },
  {
    "question": "Bir binary search tree (BST) yapısı oluşturun ve bu ağaçta belirli bir değeri arayan bir fonksiyon yazın. Eğer değer bulunursa, o düğümün adresini, bulunamazsa NULL döndürsün.",
    "answer": "Aşağıda bir binary search tree yapısının tanımı ve belirli bir değeri arayan fonksiyonun implementasyonu bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Ağaç düğüm yapısı\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\n// Düğüm ekleme fonksiyonu\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return createNode(data);\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    return node;\n}\n\n// Ağaçta değer arama fonksiyonu\nstruct Node* search(struct Node* root, int key) {\n    // Eğer ağaç boşsa veya aranan değer kök düğümse\n    if (root == NULL || root->data == key)\n        return root;\n    // Aranan değer kök değerinden daha küçükse, sol alt ağacı kontrol et\n    if (key < root->data)\n        return search(root->left, key);\n    // Aksi takdirde, sağ alt ağacı kontrol et\n    return search(root->right, key);\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    int key = 40;\n    struct Node* result = search(root, key);\n    if (result != NULL)\n        printf(\"%d bulundu.\\n\", result->data);\n    else\n        printf(\"%d bulunamadı.\\n\", key);\n\n    return 0;\n}\n```\nBu kod, önce bir binary search tree oluşturur, ardından `insert` fonksiyonu ile düğümler ekler ve en sonunda `search` fonksiyonu ile belirli bir değeri arar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:34.925548"
  },
  {
    "question": "Bir n-ary ağaç yapısı tanımlayın ve bu ağaçta bir düğümün çocuklarını ekleyebileceğiniz bir fonksiyon yazın. Ayrıca, tüm düğümlerin derinlik öncelikli (preorder) olarak sıralandığı bir fonksiyonu implement edin.",
    "answer": "Aşağıda bir n-ary ağaç yapısının tanımı ve düğüm ekleme ile derinlik öncelikli sıralama fonksiyonları yer almaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Ağaç düğüm yapısı\nstruct NaryNode {\n    int data;\n    struct NaryNode** children;\n    int childrenCount;\n};\n\n// Yeni n-ary düğüm oluşturma fonksiyonu\nstruct NaryNode* createNaryNode(int data) {\n    struct NaryNode* newNode = (struct NaryNode*)malloc(sizeof(struct NaryNode));\n    newNode->data = data;\n    newNode->children = NULL;\n    newNode->childrenCount = 0;\n    return newNode;\n}\n\n// Çocuk ekleme fonksiyonu\nvoid addChild(struct NaryNode* parent, struct NaryNode* child) {\n    parent->childrenCount++;\n    parent->children = (struct NaryNode**)realloc(parent->children, parent->childrenCount * sizeof(struct NaryNode*));\n    parent->children[parent->childrenCount - 1] = child;\n}\n\n// Derinlik öncelikli sıralama fonksiyonu\nvoid preorderTraversal(struct NaryNode* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    for (int i = 0; i < root->childrenCount; i++) {\n        preorderTraversal(root->children[i]);\n    }\n}\n\nint main() {\n    struct NaryNode* root = createNaryNode(1);\n    struct NaryNode* child1 = createNaryNode(2);\n    struct NaryNode* child2 = createNaryNode(3);\n    addChild(root, child1);\n    addChild(root, child2);\n    addChild(child1, createNaryNode(4));\n    addChild(child1, createNaryNode(5));\n    addChild(child2, createNaryNode(6));\n\n    printf(\"Derinlik öncelikli sıralama: \");\n    preorderTraversal(root);\n\n    return 0;\n}\n```\nBu kod, bir n-ary ağaç oluşturur ve `addChild` fonksiyonu ile çocuklar ekler. `preorderTraversal` fonksiyonu, ağacın düğümlerini derinlik öncelikli olarak sıralar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:34.925620"
  },
  {
    "question": "Bir ikili arama ağacı (Binary Search Tree) oluşturun ve bu ağaç üzerinde belirli bir değeri arayan bir fonksiyon yazın. Eğer değer bulunursa, o değerin düğümünü (node) geri döndürsün, bulunamazsa NULL döndürsün.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısı\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n// Ağaçta değer arama fonksiyonu\nstruct Node* search(struct Node* root, int value) {\n    // Eğer kök NULL ise veya değer kök değerine eşitse\n    if (root == NULL || root->data == value)\n        return root;\n\n    // Eğer aranan değer kök değerinden küçükse, sol alt ağaçta arama yap\n    if (value < root->data)\n        return search(root->left, value);\n\n    // Eğer aranan değer kök değerinden büyükse, sağ alt ağaçta arama yap\n    return search(root->right, value);\n}\n\nint main() {\n    struct Node* root = newNode(5);\n    root->left = newNode(3);\n    root->right = newNode(7);\n    root->left->left = newNode(2);\n    root->left->right = newNode(4);\n\n    int value = 4;\n    struct Node* result = search(root, value);\n    if (result != NULL) {\n        printf(\"Değer %d bulundu!\\n\", result->data);\n    } else {\n        printf(\"Değer bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu kod, bir ikili arama ağacı oluşturur ve arama fonksiyonu ile belirli bir değeri ağaç içinde arar. Eğer değer bulunursa ilgili düğüm geri döndürülür; aksi takdirde NULL döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:53.994439"
  },
  {
    "question": "Bir ikili ağaçta (Binary Tree) düğümlerin toplamını hesaplayan bir fonksiyon yazın. Bu fonksiyon, ağacın her bir düğümündeki verileri toplamalıdır.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Düğüm yapısı\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\n// Yeni düğüm oluşturma fonksiyonu\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n// Düğümlerin toplamını hesaplayan fonksiyon\nint sumNodes(struct Node* root) {\n    // Eğer kök NULL ise 0 döndür\n    if (root == NULL) return 0;\n    // Düğüm değerini ekle ve sol ve sağ alt ağaçların toplamını hesapla\n    return root->data + sumNodes(root->left) + sumNodes(root->right);\n}\n\nint main() {\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n\n    int total = sumNodes(root);\n    printf(\"Ağacın düğümlerinin toplamı: %d\\n\", total);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir ikili ağaç oluşturur ve her düğümdeki verileri toplamak için bir fonksiyon tanımlar. Fonksiyon, ağacın kökünden başlayarak her düğümün değerini toplar ve sonucu döndürür.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:29:53.994523"
  },
  {
    "question": "Bir ikili arama ağacında bir düğüm ekleme işleminin nasıl optimize edilebileceğini ve bunun önemi ile ilgili ne söyleyebilirsiniz?",
    "answer": "İkili arama ağaçları, verileri sıralı bir şekilde depolamak için kullanılır. Düğüm ekleme işlemi, ağacın dengeli olmasına bağlı olarak O(h) zaman karmaşıklığına sahiptir, burada h ağacın yüksekliğidir. Eğer ağaç dengesizse (örneğin sürekli artan veya azalan sayılar eklenirse), yükseklik n'ye kadar çıkabilir ve bu da O(n) karmaşıklığına neden olur. Bu nedenle, ağacı dengede tutmak için AVL veya Red-Black gibi dengeli ağaç yapıları kullanılmalıdır. Bu yapıların ekleme işlemleri sırasında yüksekliği sürekli kontrol edilerek, ağaç dengede tutulur. Örneğin, AVL ağaçlarında ekleme yaparken, eklenen düğümden sonra ağacın yükseklik dengesi kontrol edilir ve gerektiğinde döndürme işlemleri yapılır. Bu, arama, ekleme ve silme işlemlerinin daha hızlı gerçekleşmesini sağlar. Ayrıca, bu yapıların bakımı daha kolaydır ve performans optimizasyonu açısından büyük önem taşır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:30:04.750577"
  },
  {
    "question": "Ağaç yapılarında gereksiz bellek kullanımını önlemek için ne gibi yöntemler uygulanabilir?",
    "answer": "Ağaç yapılarında bellek yönetimi kritik bir konudur. Aşırı bellek kullanımı, programın performansını olumsuz etkileyebilir. Öncelikle, dinamik bellek tahsisi yerine, yerel değişkenler veya statik bellek kullanımı tercih edilebilir. Örneğin, düğüm yapısı oluştururken, düğümün içindeki veri için yeterli alanı tahsis etmek önemlidir. Ayrıca, kullanılmayan düğümlerin bellekte kalmasını önlemek için etkili bir silme algoritması uygulamak gerekir. Bu, 'sadece bir nesne için bellek ayır' ilkesine dayanarak yapılabilir. Düğüm silme işlemi yapılırken, düğümün çocuklarının durumuna göre düğümü silmek ve yerine uygun bir düğüm koymak, ağaç yapısının bütünlüğünü korurken bellek kullanımını da minimize eder. Özellikle, silme işlemi sonrasında ağacın dengesini sağlamak, böylece bellek ve performans optimizasyonu açısından fayda sağlar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:30:04.750618"
  },
  {
    "question": "Bir ikili arama ağacında (BST) bir düğüm silme işlemi gerçekleştirirken hangi durumları göz önünde bulundurmalıyım ve mevcut silme fonksiyonunu optimize etmek için ne gibi iyileştirmeler yapabilirim?",
    "answer": "Bir ikili arama ağacında bir düğüm silerken, üç ana durumu göz önünde bulundurmalısınız: 1) Silinecek düğümün hiç çocuğu yoksa, sadece düğümü silip bağlantılardan kaldırmalısınız. 2) Silinecek düğümün bir çocuğu varsa, silinecek düğümü o çocuğun bağlantısını düğüm yerine geçirerek güncelleyebilirsiniz. 3) Silinecek düğümün iki çocuğu varsa, genellikle ya en küçük sağ alt çocuğu ya da en büyük sol alt çocuğu kullanarak düğümü yer değiştirirsiniz. \n\n Optimize etmek için, ağacın dengeli olup olmadığını kontrol edin. Ağaç dengesizse, silme işlemi sonrasında ağaç yapısını dengelemek için bir dönüş (rotation) işlemi uygulayabilirsiniz. Ayrıca, gereksiz tekrarları önlemek için silme işlemi için bir yardımcı fonksiyon yazabilir ve kodun okunabilirliğini artırabilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:30:18.901638"
  },
  {
    "question": "Bir n-ary ağaçta belirli bir derinlikteki düğümleri bulmak için bir C fonksiyonu yazdım. Ancak bu fonksiyon gerektiğinde optimize edilmeli. Mevcut tasarımda hangi potansiyel sorunlar bulunuyor ve nasıl çözebilirim?",
    "answer": "n-ary ağaçlarda derinlikteki düğümleri bulmak için yazdığınız fonksiyonda genellikle iki ana sorun ile karşılaşılabilir: 1) Bellek yönetimi: Eğer ağaç büyükse ve çok sayıda düğüm içeriyorsa, her bir düğüm için ayrı bellek ayırmak gereksiz yere bellek tüketebilir. Bunun yerine, düğümlere erişmek için bir yığın (stack) veya kuyruk (queue) kullanmak daha verimli olabilir. 2) Zaman karmaşıklığı: Fonksiyon, her düğümü kontrol etmek için derinlik öncelikli (DFS) veya genişlik öncelikli (BFS) yaklaşımını kullanıyorsa, derinlik ve genişlik limitlerini optimize etmek önemlidir. \n\n Çözüm olarak, bir döngü kullanarak yığın veya kuyruk yapısını kullanarak düğümleri gezebilirsiniz ve derinlikteki düğümleri bulurken gereksiz tekrarları önleyebilirsiniz. Ayrıca, ağacın derinliğini sınırlamak için geçici bir değişken kullanarak gereksiz düğümlerin kontrol edilmesini engelleyebilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-05-31T17:30:18.901708"
  },
  {
    "question": "Aşağıdaki C kodunu, bir tamsayı dizisini seçme sıralama algoritması ile sıralayacak şekilde tamamlayın. Dizinin elemanlarını sıraladıktan sonra ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    int i, j, minIndex, temp;\n    for (i = 0; i < n - 1; i++) {\n        minIndex = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        temp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \\\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu kod, 'selectionSort' fonksiyonu ile verilen diziyi sıralar. Dıştaki döngü her elemanı kontrol ederken, içteki döngü daha küçük bir eleman bulur ve yer değiştirir. Sonuç olarak, dizinin sıralanmış hali ekrana yazdırılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:30:36.559696"
  },
  {
    "question": "Aşağıdaki C kodunu, bir tamsayı dizisini kabin sıralama algoritması ile sıralayacak şekilde tamamlayın. Sıralama işleminden sonra, sıralanmış diziyi ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid countingSort(int arr[], int n) {\n    int output[n]; // Sıralanmış diziyi tutmak için çıktı dizisi\n    int count[100] = {0}; // Sayım dizisi (0-99 arası elemanlar için)\n\n    // Elemanların sayımını yap\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    // Sayım dizisini toplama dizisine dönüştür\n    for (int i = 1; i < 100; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Çıktı dizisini oluştur\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    // Sıralanmış diziyi orijinal diziye kopyala\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nint main() {\n    int arr[] = {1, 4, 1, 2, 7, 5, 2};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    countingSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \\\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu kod, verilen dizinin elemanlarını kabin sıralama (counting sort) algoritması ile sıralar. İlk olarak, her elemanın sayısını tutan bir dizi oluşturulur. Daha sonra, bu sayılar kullanılarak sıralanmış bir çıktı dizisi oluşturulur ve sonuç olarak sıralanmış dizi ekrana yazdırılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:30:36.559749"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak bir dizi üzerinde hızlı sıralama (Quick Sort) algoritmasını uygulayın. Dizi elemanlarını sıralı bir şekilde ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivot = arr[high];  // Son elemanı pivot olarak seçiyoruz.\n        int i = (low - 1);  // Pivotun solundaki elemanların son indeksi\n\n        for (int j = low; j < high; j++) {\n            // Eğer mevcut eleman pivot'tan daha küçükse\n            if (arr[j] < pivot) {\n                i++;  // Sol elemanlar için indeksi artır\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;  // Elemanları takas et\n            }\n        }\n        // Pivot elemanını doğru konumuna yerleştir\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        // Pivotun sol ve sağındaki alt dizileri sıralamak için rekürsif olarak çağır\n        quickSort(arr, low, i);\n        quickSort(arr, i + 2, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralı Dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:21.497164"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak bir dizi üzerinde birleştirme sıralama (Merge Sort) algoritmasını uygulayın. Dizi elemanlarını sıralı bir şekilde ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    i = 0;  // İlk alt dizinin başlangıç indeksi\n    j = 0;  // İkinci alt dizinin başlangıç indeksi\n    k = left;  // Birleştirilmiş dizinin başlangıç indeksi\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    printf(\"Sıralı Dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:21.497218"
  },
  {
    "question": "Aşağıdaki C kodu, bir dizi içindeki tam sayıların sıralanmasını sağlamak için yazılmıştır. Ancak kod çalışmıyor. Hatanın nedenini bul ve düzelt.",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Hata: swap işlemi eksik\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\nAçıklama: Kodda, 'swap' işlemi eksikti. Bu nedenle, dizinin elemanları sıralanmadı. Doğru bir şekilde swap işlemi yaparak bu hatayı düzelttik.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:36.189392"
  },
  {
    "question": "Aşağıdaki C kodunda, bir diziyi sıralamak için seçme sıralaması algoritması kullanılmıştır. Ancak dizinin sıralandığına dair bir çıktı alınamıyor. Hatanın nedenini belirleyip düzeltin.",
    "answer": "#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        // Hata: swap işlemi eksik\n        int temp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {29, 10, 14, 37, 13};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\nAçıklama: Kodda 'swap' işlemi eksikti. Seçme sıralaması sırasında en küçük elemanı bulduktan sonra bu elemanın sırasını değiştirmek için swap işlemi gerçekleştirmemiz gerekiyordu. Bu hatayı düzelttikten sonra dizi sıralandı.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:36.189552"
  },
  {
    "question": "Bir dizi üzerinde hızlı sıralama (Quick Sort) algoritmasını uygulayan kodumda sıralama beklediğim gibi çalışmıyor. Kodum şu şekilde: \n\n```c\n#include <stdio.h>\n\nvoid quickSort(int arr[], int low, int high) {\n    int pivot, i, j;\n    if (low < high) {\n        pivot = arr[high];\n        i = (low - 1);\n        for (j = low; j < high; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        quickSort(arr, low, i);\n        quickSort(arr, i + 2, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kodda hangi hataları bulabilirsin?",
    "answer": "Kodda iki temel hata bulunuyor. Öncelikle, `quickSort` fonksiyonundaki rekurif çağrılarda `i` değerinin yanlış kullanımı var. \n\n```c\nquickSort(arr, low, i);\nquickSort(arr, i + 2, high);\n```\nBu kısımda `i` yerine `i + 1` kullanılmalıdır. Bu durum, dizinin doğru bir şekilde bölünmesine engel oluyor. Amacımız pivotun yerinde olduğu indeksi kullanarak diziyi ayırmak. \n\nDüzeltilmiş hali şu şekilde olmalı:\n\n```c\nquickSort(arr, low, i);\nquickSort(arr, i + 1, high);\n```\nDiğer bir hata ise, `main` fonksiyonu içinde dizinin boyutunu alırken herhangi bir kontrol yapılmıyor. Eğer dizinin boyutu sıfır olursa program hata verebilir. Bu yüzden `n` değişkeninin değerini kontrol etmek faydalı olacaktır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:56.274616"
  },
  {
    "question": "Bir diziyi sıralamak için seçim sıralaması (Selection Sort) algoritmasını kullanan bir C programım var, fakat sıralama işlemi doğru çalışmıyor. İşte kodum:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    for (i = 0; i < n - 1; i++) {\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kodda neyin yanlış olduğunu düşünüyorsun?",
    "answer": "Kodda bir hata var, `selectionSort` fonksiyonunun içindeki ikinci döngüdeki kontrol sınırı yanlış ayarlanmış. Dış döngüde `i < n - 1` ifadesi doğru, fakat iç döngüde `j < n` ifadesi kullanılmamalı. Bu, son elemanı kontrol etmediği ve sıralama işlemi tamam olmadığı için sıralamanın eksik olmasına yol açıyor. İç döngü şu şekilde düzeltilmelidir:\n\n```c\nfor (j = i + 1; j < n; j++)\n```\nBunu `for (j = i + 1; j < n; j++)` yerine `for (j = i + 1; j < n; j++)` olarak ayarladığımızda, tüm elemanların kontrol edilmesini sağlıyoruz. Ayrıca, programın sonunda dizinin doğru şekilde sıralandığını görmek için çıktıyı kontrol etmek de önemlidir. Bu değişikliklerden sonra program düzgün çalışacaktır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:31:56.274840"
  },
  {
    "question": "C dilinde bir 'quick sort' algoritması yazdım, ancak bazı durumlarda sıralama düzgün çalışmıyor. Aşağıdaki kodda hata nedir ve nasıl düzeltilir?",
    "answer": "Hatanın nedeni, pivotun düzgün seçilmemesi veya bölme işlemlerinin hatalı olmasıdır. Aşağıdaki kodu gözden geçirelim:\n\n```c\nvoid quick_sort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivot = partition(arr, low, high);\n        quick_sort(arr, low, pivot - 1);\n        quick_sort(arr, pivot + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Son elemanı pivot seçiyoruz\n    int i = (low - 1);\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n```\n\nEğer `partition` fonksiyonu doğru çalışmıyorsa, burada `pivot` seçimi ve elemanların karşılaştırılması kontrol edilmelidir. Özellikle `j` döngüsü içinde, `arr[j] < pivot` koşulunu inceleyin ve `swap` fonksiyonunun doğru çalıştığından emin olun. Ayrıca, `i` indexinin güncellenmesi de doğru yapılmalıdır. Bu düzenlemelerden sonra algoritmanın düzgün çalışacağını göreceksiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:13.413195"
  },
  {
    "question": "Bir 'merge sort' algoritmasında iki alt diziyi birleştirirken bir hata alıyorum. Aşağıdaki kodu inceleyebilir misiniz ve problemi çözebilir misiniz?",
    "answer": "Hatanın kaynağı genellikle dizilerin birleştirilmesi sırasında dizilerin sınırlarının aşılması veya yanlış indeks kullanımıdır. Aşağıdaki kodu gözden geçirelim:\n\n```c\nvoid merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k++] = L[i++];\n        } else {\n            arr[k++] = R[j++];\n        }\n    }\n\n    while (i < n1)\n        arr[k++] = L[i++];\n    while (j < n2)\n        arr[k++] = R[j++];\n}\n```\n\nBurada dikkat etmeniz gereken en önemli nokta, `L` ve `R` dizilerinin boyutlarının ve sınırlarının doğru ayarlandığıdır. Eğer `m` ile `l` arasındaki boşluğu yanlış hesaplarsanız, iki alt dizi birleştiğinde dizinin sınırını aşabilirsiniz. Kodunuzu kontrol edin ve `merge` fonksiyonunu çağırdığınız yerlerde `l`, `m` ve `r` parametrelerinin doğru geçtiğinden emin olun. Bu düzeltmeler ile algoritmayı hatasız bir şekilde çalıştırabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:13.413279"
  },
  {
    "question": "Bir dizi içindeki tamsayıları küçükten büyüğe sıralamak için hangi sıralama algoritmasını kullanabilirsiniz? Bubblesort algoritmasının nasıl çalıştığını açıklayınız.",
    "answer": "Bubblesort, en basit sıralama algoritmalarından biridir. Bu algoritma, dizinin her bitişiğindeki elemanları karşılaştırarak başlar. Eğer bir eleman, kendisinden sonraki elemandan büyükse, bu iki elemanı yer değiştirir. Bu işlem dizinin sonuna kadar devam eder. Tüm elemanlar sıralanana kadar bu işlemi tekrarlamak gerekir. Örneğin, {5, 2, 9, 1, 5, 6} dizisinde ilk geçişte '5' ve '2' karşılaştırılır ve yerlerini değiştiririz; böylece dizi {2, 5, 9, 1, 5, 6} olur. Ardından '5' ve '9' karşılaştırılır ve değişiklik olmaz. Bu işlem, dizinin tamamı sıralanana kadar devam eder. Bubblesort algoritması, genellikle küçük diziler için etkilidir, ancak büyük dizilerde yavaş çalıştığı için daha verimli sıralama algoritmalarını tercih etmek daha iyidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:28.383171"
  },
  {
    "question": "Bir öğrencinin notlarını sıralamak için hangi algoritmayı kullanabilirsiniz? Seçim sıralama algoritmasının temel mantığını açıklayınız.",
    "answer": "Seçim sıralama (Selection Sort) algoritması, sıralama işlemi için oldukça basit bir yöntemdir. Bu algoritma, diziyi iki alt diziye ayırır; sıralı ve sıralanmamış. Başlangıçta, sıralı dizi boşken, sıralanmamış dizinin en küçük elemanı bulunur ve sıralı diziye eklenir. Örneğin, {64, 25, 12, 22, 11} dizisinde, ilk adımda 11 en küçük eleman olarak seçilir ve sıralı diziye eklenir, böylece sıralı dizi {11} olur. Ardından, sıralanmamış dizideki geri kalan elemanlar üzerinde aynı işlemi gerçekleştiririz. Bu süreç tüm elemanlar sıralanana kadar devam eder. Seçim sıralama, zaman karmaşıklığı olarak O(n^2) karmaşıklığına sahiptir, bu yüzden küçük diziler için kullanışlıdır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:28.383220"
  },
  {
    "question": "Bir dizi içerisindeki sayıların sıralanması için Quick Sort algoritmasını nasıl uygularız? Hangi durumlarda bu algoritmanın kullanılması avantajlıdır?",
    "answer": "Quick Sort, böl ve fethet (divide and conquer) yaklaşımına dayanan bir sıralama algoritmasıdır. Öncelikle, bir pivot (dönüm noktası) seçiyoruz. Daha sonra, diziyi bu pivot'a göre iki alt diziye ayırıyoruz: bir alt dizi, pivot'tan küçük olan elemanları, diğeri ise pivot'tan büyük olan elemanları içerir. Bu işlemi alt diziler üzerinde de tekrarlayarak sıralama işlemini tamamlıyoruz.\n\nÖrneğin, aşağıdaki gibi bir dizi ele alalım: [34, 7, 23, 32, 5, 62].\n1. 34'ü pivot olarak seçelim. Diziyi iki alt diziye bölelim: [7, 23, 5] ve [62, 34, 32].\n2. İlk alt dizi üzerinde tekrar Quick Sort uygulayarak sıralıyoruz: [5, 7, 23].\n3. İkinci alt dizi üzerinde de aynı işlemi yaparak [32, 34, 62] elde ediyoruz.\n4. Nihayetinde, iki alt dizi birleştirildiğinde [5, 7, 23, 32, 34, 62] şeklinde sıralı bir dizi elde ediyoruz.\n\nQuick Sort'un avantajları arasında genellikle iyi performansı ve düşük bellek kullanımı yer alır. Ancak, en kötü durumda O(n^2) zaman karmaşıklığına sahip olabilir, bu nedenle genellikle rastgele bir pivot seçmek, bu durumu önlemeye yardımcı olur.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:45.764586"
  },
  {
    "question": "Bir öğrenci notları dizisini sıralamak için Bubble Sort algoritmasını kullanmak istiyoruz. Bu algoritmanın nasıl çalıştığını ve avantajlarını/dezavantajlarını açıklayabilir misin?",
    "answer": "Bubble Sort, basit bir sıralama algoritmasıdır ve sıralama işlemini birkaç geçiş yaparak gerçekleştirir. Algoritmanın temel mantığı, komşu elemanları karşılaştırmak ve gerektiğinde yer değiştirerek diziyi sıralamaktır.\n\nÖrneğin, [5, 1, 4, 2, 8] dizisini düşünelim:\n1. İlk geçişte, 5 ile 1'i karşılaştırırız ve yer değiştiririz, böylece [1, 5, 4, 2, 8] elde ederiz.\n2. Ardından, 5 ile 4'ü karşılaştırırız ve yine yer değiştiririz: [1, 4, 5, 2, 8].\n3. Bu işlemi tüm elemanlar için tekrarlayarak diziyi sıralamaya devam ederiz. En son geçişte, dizinin sıralı olduğunu kontrol ederiz.\n\nBubble Sort'un avantajları arasında basitliği ve uygulanabilirliği yer alır, özellikle küçük diziler için oldukça etkilidir. Ancak, zaman karmaşıklığı O(n^2) olduğu için büyük dizilerde performansı oldukça düşüktür. Bu nedenle, genellikle daha etkili sıralama algoritmaları tercih edilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:32:45.764645"
  },
  {
    "question": "Sıralama algoritmalarından quicksort algoritmasının çalışma prensibini açıklayın ve bir C kodu örneği ile gösterin.",
    "answer": "Quicksort, böl ve fethet (divide and conquer) yaklaşımını kullanan bir sıralama algoritmasıdır. Algoritmanın temel prensibi, bir 'pivot' seçmek ve diziyi bu pivot etrafında iki alt diziye ayırmaktır; biri pivot'tan küçük, diğeri ise büyük elemanları içerecektir. Daha sonra bu alt diziler için aynı işlemler tekrarlanır. Algoritmanın zaman karmaşıklığı, en iyi ve ortalama durumda O(n log n) ve en kötü durumda O(n²) olarak kabul edilir. Aşağıda quicksort algoritmasının C dilinde bir implementasyonu bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Pivot seçimi\n    int i = (low - 1); // Küçük elemanların indeksini tutar\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high); // Partitioning index\n        quickSort(arr, low, pi - 1); // Sol alt dizi\n        quickSort(arr, pi + 1, high); // Sağ alt dizi\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu kodda, `partition` fonksiyonu diziyi pivot etrafında bölerken, `quickSort` fonksiyonu bu işlemi rekürsif olarak tekrarlar. Sonuç olarak dizinin sıralanmış hali elde edilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:07.422975"
  },
  {
    "question": "Merge Sort algoritmasının avantajlarını ve dezavantajlarını açıklayın. Ayrıca, C dilinde bir örnek uygulama sunun.",
    "answer": "Merge Sort, yine bir böl ve fethet (divide and conquer) algoritmasıdır. Diziyi iki alt diziye ayırarak başlar, bu alt dizileri sıralar ve ardından bu iki sıralı alt diziyi birleştirerek (merge) tek bir sıralı dizi oluşturur. Merge Sort'un avantajları arasında kararlılığı (stable) ve büyük dizilerle çalışma kabiliyeti vardır, çünkü O(n log n) zaman karmaşıklığına sahiptir ve her durumda bu karmaşıklığı korur. Dezavantajı ise ek bellek gereksinimidir, çünkü yeni diziler oluşturulur. İşte Merge Sort algoritmasının C dilinde bir uygulaması:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; // İlk alt dizi için başlangıç\n    j = 0; // İkinci alt dizi için başlangıç\n    k = l; // Birleştirilmiş dizi için indeks\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < arr_size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu kodda, `merge` fonksiyonu iki alt diziyi birleştirirken, `mergeSort` fonksiyonu diziyi bölüp sıralamak için kullanılır. Sonuç olarak dizinin sıralanmış hali elde edilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:07.423043"
  },
  {
    "question": "Bir diziyi (array) artan sırayla sıralamak için basit bir seçme sıralama (selection sort) algoritması yazın.",
    "answer": "Seçme sıralama algoritması, sıralama işlemini yaparken dizinin her bir elemanını kontrol eder ve en küçük (veya en büyük) elemanı bulup, dizinin başındaki eleman ile takas eder. Aşağıdaki C kodu, bir dizi alır ve bu diziyi artan sırayla sıralar:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    \n    for (i = 0; i < n-1; i++) {\n        min_idx = i;\n        for (j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        // Takas işlemi\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    printArray(arr, n);\n    return 0;\n}\n```\nBu kod, `selectionSort` fonksiyonu ile verilen diziyi sıralar ve ardından sıralı diziyi ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:33.629353"
  },
  {
    "question": "Bir diziyi (array) azalan sırayla sıralamak için basit bir balon sıralama (bubble sort) algoritması yazın.",
    "answer": "Balon sıralama algoritması, dizideki her iki komşu elemanı karşılaştırır ve gerekirse yer değiştirerek diziyi sıralar. Bu işlem dizinin sonuna kadar devam eder ve en büyük değer en sona 'baloncuk' gibi yükselir. Aşağıdaki C kodu, bir dizi alır ve bu diziyi azalan sırayla sıralar:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    int i, j;\n    for (i = 0; i < n-1; i++) {\n        for (j = 0; j < n-i-1; j++) {\n            if (arr[j] < arr[j+1]) {\n                // Takas işlemi\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    printArray(arr, n);\n    return 0;\n}\n```\nBu kod, `bubbleSort` fonksiyonu ile verilen diziyi azalan şekilde sıralar ve sıralı diziyi ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:33.629399"
  },
  {
    "question": "Bir dizi içerisindeki tam sayıları, en küçükten en büyüğe sıralamak için bir Quick Sort algoritması implementasyonu yazın. Açıklama ekleyin.",
    "answer": "Quick Sort, böl ve fethet mantığına dayanan bir sıralama algoritmasıdır. Algoritmanın temel adımları şunlardır:\n\n1. Bir pivot seçilir. Genellikle dizinin son elemanı ya da ortada bir eleman seçilir.\n2. Pivot elemanına göre daha küçük olan elemanlar dizinin başına, daha büyük olanlar ise dizinin sonuna yerleştirilir.\n3. Sonuç olarak, pivot elemanının doğru konumunu bulmuş oluruz. Bu adımı tekrarlayarak alt dizileri sıralarız.\n\nAşağıda Quick Sort algoritmasının C dilindeki bir implementasyonunu bulabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Pivot olarak dizinin son elemanını seçiyoruz\n    int i = (low - 1); // Daha küçük elemanların indexi\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1); // Sol alt dizi\n        quickSort(arr, pi + 1, high); // Sağ alt dizi\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\n\nBu kod, verilen bir dizi içerisindeki tam sayıları Quick Sort algoritması ile sıralar ve ardından sıralanmış diziyi ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:56.072116"
  },
  {
    "question": "Bir dizi içerisindeki stringleri, alfabetik sıraya göre sıralamak için bir Merge Sort algoritması implementasyonu yazın. Açıklama ekleyin.",
    "answer": "Merge Sort, yine böl ve fethet yöntemine dayanan bir sıralama algoritmasıdır. Bu algoritmanın temel adımları şunlardır:\n\n1. Eğer dizi bir elemandan fazlaysa, dizi ikiye bölünür.\n2. Her iki yarıyı ayrı ayrı sıralamak için Merge Sort çağrılır.\n3. İki sıralı alt dizi bir araya getirilerek tam sıralı bir dizi oluşturulur.\n\nAşağıda Merge Sort algoritmasının C dilindeki bir implementasyonunu bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid merge(char arr[][100], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    char L[n1][100], R[n2][100];\n\n    for (i = 0; i < n1; i++)\n        strcpy(L[i], arr[l + i]);\n    for (j = 0; j < n2; j++)\n        strcpy(R[j], arr[m + 1 + j]);\n\n    i = 0; \n    j = 0; \n    k = l;\n\n    while (i < n1 && j < n2) {\n        if (strcmp(L[i], R[j]) <= 0) {\n            strcpy(arr[k], L[i]);\n            i++;\n        } else {\n            strcpy(arr[k], R[j]);\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        strcpy(arr[k], L[i]);\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        strcpy(arr[k], R[j]);\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(char arr[][100], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    char arr[][100] = {\"elma\", \"armut\", \"muz\", \"çilek\", \"kavun\"};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%s \", arr[i]);\n    return 0;\n}\n```\n\nBu kod, verilen bir string dizisini Merge Sort algoritması ile sıralar ve ardından sıralanmış stringleri ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:33:56.072165"
  },
  {
    "question": "Bir dizideki sayıların sıralanması için Quick Sort algoritmasını nasıl uygularsınız? Örnek bir C kodu ile gösteriniz.",
    "answer": "Quick Sort, böl ve fethet (divide and conquer) prensibi ile çalışan bir sıralama algoritmasıdır. İlk olarak bir pivot seçilir, dizinin elemanları bu pivot ile karşılaştırılarak pivotun soluna ve sağına yerleştirilir. Bu işlem, alt dizilerde tekrar edilir. Aşağıdaki C kodu, Quick Sort algoritmasının bir uygulamasıdır:\n\n```c\n#include <stdio.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  // Pivot olarak dizinin son elemanını seçiyoruz\n    int i = (low - 1);  // Daha küçük elemanların indeksini tutar\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);  // Soldaki alt diziyi sıralıyoruz\n        quickSort(arr, pi + 1, high);  // Sağdaki alt diziyi sıralıyoruz\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \\n\");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kodda, `partition` fonksiyonu diziyi pivot etrafında böler ve `quickSort` fonksiyonu bu bölme işlemini rekürsif olarak çağırarak diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:16.363019"
  },
  {
    "question": "Bir büyük veri kümesi üzerinde Merge Sort algoritması ile sıralama yapmayı nasıl gerçekleştirirsiniz? C dilinde örnek kod ile açıklayınız.",
    "answer": "Merge Sort, yine böl ve fethet yaklaşımını kullanan bir sıralama algoritmasıdır. Dizi, tek elemanlı parçalara ayrılır ve ardından bu parçalar birleştirilerek sıralanmış bir dizi elde edilir. Aşağıdaki C kodu, Merge Sort algoritmasının uygulanışını göstermektedir:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; // İlk alt dizinin başlangıcı\n    j = 0; // İkinci alt dizinin başlangıcı\n    k = l; // Birleştirilen dizinin başlangıcı\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);  // Soldaki yarıyı sırala\n        mergeSort(arr, m + 1, r);  // Sağdaki yarıyı sırala\n        merge(arr, l, m, r);  // İki yarıyı birleştir\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"Sıralanmış dizi: \\\");\n    for (int i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kodda, `merge` fonksiyonu iki alt diziyi birleştirirken, `mergeSort` fonksiyonu diziyi sürekli olarak böler ve sıralama işlemini yapar. Merge Sort, genellikle büyük veri setleri için daha verimli bir sıralama algoritmasıdır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:16.363102"
  },
  {
    "question": "Bir dizi içerisindeki sayıları küçükten büyüğe sıralamak için basit bir 'Bubble Sort' algoritması implementasyonu yazdım. Ancak performansını artırmak için optimize etmem gerektiğini düşünüyorum. Kod aşağıdaki gibidir: \n\n```c\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap arr[j] and arr[j+1]\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n``` \nBu kodda hangi optimizasyonları yapabilirim?",
    "answer": "Bubble Sort algoritması, en kötü durumda O(n²) zaman karmaşıklığına sahiptir, bu nedenle büyük veri setleri için uygun değildir. Kodunuzu optimize etmek adına aşağıdaki önerileri dikkate alabilirsiniz:\n\n1. **Flag Kullanımı:** İçteki döngüde bir 'flag' kullanarak, eğer bir takas yapılmamışsa sıralamanın tamamlandığını belirleyebilirsiniz. Bu şekilde, zaten sıralı olan dizilerde gereksiz döngülerin önüne geçilmiş olur.\n   ```c\n   void bubbleSortOptimized(int arr[], int n) {\n       int swapped;\n       do {\n           swapped = 0;\n           for (int j = 0; j < n - 1; j++) {\n               if (arr[j] > arr[j + 1]) {\n                   // Swap arr[j] and arr[j+1]\n                   int temp = arr[j];\n                   arr[j] = arr[j + 1];\n                   arr[j + 1] = temp;\n                   swapped = 1;\n               }\n           }\n           n--;\n       } while (swapped);\n   }\n   ```\n\n2. **Daha Hızlı Algoritmalar:** Eğer sıralama işlemleriniz büyük diziler için sıklıkla yapılıyorsa, daha hızlı algoritmalara (örneğin, 'Quick Sort' veya 'Merge Sort') geçmek daha mantıklı olacaktır. Bu algoritmalar O(n log n) zaman karmaşıklığına sahiptir ve büyük veri setleri için daha etkilidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:34.165787"
  },
  {
    "question": "Bir dizi içerisindeki stringleri alfabetik sıraya göre sıralamak için 'Selection Sort' algoritması kullanan bir kod yazdım. Ancak, performansını artırmak için bunu nasıl optimize edebilirim? İşte kod: \n\n```c\nvoid selectionSort(char* arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (strcmp(arr[j], arr[minIdx]) < 0) {\n                minIdx = j;\n            }\n        }\n        // Swap arr[i] and arr[minIdx]\n        char* temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n    }\n}\n``` \nBu kodda hangi optimizasyonları yapabilirim?",
    "answer": "Selection Sort algoritması da en kötü durumda O(n²) zaman karmaşıklığına sahiptir ve büyük diziler için etkili olmayabilir. Kodunuzu optimize etmek için aşağıdaki yöntemleri önerebilirim:\n\n1. **Daha Etkili Sıralama Algoritmaları:** Selection Sort yerine, string sıralama işlemleri için daha etkili bir algoritma kullanmak faydalı olacaktır. Örneğin, 'Quick Sort' veya 'Merge Sort' gibi algoritmalar bu tür sıralama işlemleri için daha iyi performans sağlar. \n\n2. **İkili Arama Kullanımı:** Eğer her bir elemanı sıralamak yerine yerleştiriyorsanız, elemanları yerleştirmeden önce sıralı dizi üzerinde ikili arama kullanarak doğru pozisyonu bulmak daha verimli olabilir. Ancak bu, Selection Sort'u doğrudan optimize etmez, daha ileri bir optimizasyon seviyesidir.\n\n3. **Daha Az Kopyalama:** Mevcut uygulamanızda her swap işleminde pointerları değiştirdiğiniz için maliyetleri azaltabilirsiniz, ancak bu zaten yapılmakta. Ancak, sıralama işleminin sonunda diziyi birleştirebilir veya başka bir veri yapısında saklayarak daha az yer kaplamasını sağlayabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:34.165957"
  },
  {
    "question": "QuickSort algoritmasının C dilinde uygulanmış hali aşağıda verilmiştir. Bu kodu incelerken, performansını nasıl artırabiliriz ve bellek kullanımını optimize etmek için ne gibi değişiklikler yapabiliriz?",
    "answer": "Aşağıdaki QuickSort implementasyonu, temel bir versiyondur. Ancak, 'pivot' seçimi ve bellek yönetimi açısından iyileştirmeler yapılabilir.\n\n```c\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Son eleman pivot olarak seçildi\n    int i = (low - 1); // Küçük eleman için indeks\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n```  \n\nÖneriler:\n1. Pivot Seçimi: Pivot olarak her zaman son elemanı seçmek yerine, 'median of three' yöntemini kullanarak, baştaki, ortadaki ve sondaki elemanların medyanını alabilirsiniz. Bu, özellikle sıralı ya da neredeyse sıralı dizilerde performansı artırır.\n2. Bellek Yönetimi: Recursive çağrılar yerine, iterative yaklaşım kullanmak ve stack boyutunu yönetmek bellek kullanımını optimize eder. Ayrıca, küçük alt diziler için Insertion Sort kullanarak performansı artırabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:54.067084"
  },
  {
    "question": "MergeSort algoritmasının C dilindeki implementasyonu aşağıda verilmiştir. Kodun optimizasyonunu yaparken, hem zaman karmaşıklığını hem de bellek kullanımını göz önünde bulundurmalıyız. Ne tür iyileştirmeler yapabiliriz?",
    "answer": "Aşağıdaki MergeSort implementasyonu, temel bir versiyondur. Ancak, bellek kullanımı açısından iyileştirmeler yapılabilir. \n\n```c\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; // İlk alt dizi için indeks\n    j = 0; // İkinci alt dizi için indeks\n    k = l; // Birleştirilmiş alt dizi için indeks\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n```  \n\nÖneriler:\n1. Bellek Kullanımı: 'L' ve 'R' dizilerini her bir merge işlemi için dinamik olarak ayırmak yerine, tek bir yardımcı dizi kullanarak tüm diziyi birleştirebilirsiniz. Bu, bellek kullanımını önemli ölçüde azaltacaktır. \n2. İteratif Yaklaşım: MergeSort'un iterative versiyonunu uygulamak, bazı durumlarda stack overflow sorunlarını önleyebilir. Ayrıca, sıralama küçük alt diziler için Insertion Sort kullanarak daha hızlı hale getirilebilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-05-31T17:34:54.067151"
  },
  {
    "question": "Aşağıdaki C kodunda, bir dizide verilen bir sayının ikili arama algoritması ile bulunmasını sağlayan eksik kısımları tamamlayın: \n\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        // burada eksik kısım\n    }\n    return -1; // eleman bulunamazsa -1 döner\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = binarySearch(arr, size, target);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n}",
    "answer": "İkili arama algoritmasında, dizinin ortasındaki eleman ile aranan sayıyı karşılaştırarak arama yapılır. Eğer ortadaki eleman aranan sayıya eşitse, elemanın indeksini döndürürüz. Eğer aranan sayı ortadan küçükse, sağ aralığı daraltırız, büyükse sol aralığı daraltırız. Eksik kısmı tamamlamak için aşağıdaki kodu ekleyin:\n\n```c\nif (arr[mid] == target) {\n    return mid;\n} else if (arr[mid] > target) {\n    right = mid - 1;\n} else {\n    left = mid + 1;\n}\n``` \n\nBu şekilde, arama algoritması doğru bir şekilde çalışacaktır. Kullanıcıdan alınan hedef sayıyı dizide bulmak için ikili arama mantığı kullanılmıştır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:12.576060"
  },
  {
    "question": "Aşağıdaki C kodunda, verilen bir dizi içerisinde belirli bir değeri lineer arama algoritması ile bulan eksik kısımları tamamlayın: \n\n#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    // burada eksik kısım\n    return -1; // eleman bulunamazsa -1 döner\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 30;\n    int result = linearSearch(arr, size, target);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n}",
    "answer": "Lineer arama algoritması, dizi üzerindeki her bir elemanı teker teker kontrol ederek aranan değeri bulmaya çalışır. Eğer eleman bulunursa, indeksini döndürür. Eksik kısmı tamamlamak için aşağıdaki kodu ekleyin:\n\n```c\nfor (int i = 0; i < size; i++) {\n    if (arr[i] == target) {\n        return i;\n    }\n}\n``` \n\nBu şekilde, her eleman kontrol edilerek aranan değer bulunur. Kullanıcıdan alınan hedef sayıyı dizi içerisinde bulmak için basit bir döngü kullanılmıştır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:12.576207"
  },
  {
    "question": "Aşağıdaki eksik ikili arama ağaç (Binary Search Tree) arama algoritmasını tamamlayın. Kullanıcıdan bir sayı alıp, bu sayının ağacın içinde olup olmadığını kontrol etmelidir. Eğer varsa, true döndürsün, yoksa false döndürsün.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint search(struct Node* root, int key) {\n    // Eğer kök NULL ise, aradığımız değer yok demektir.\n    if (root == NULL) {\n        return 0;\n    }\n    // Eğer aradığımız değer kökün değerine eşitse, true döndür.\n    if (key == root->data) {\n        return 1;\n    }\n    // Eğer aradığımız değer kök değerinden küçükse, sol alt ağaçta ara.\n    if (key < root->data) {\n        return search(root->left, key);\n    }\n    // Eğer aradığımız değer kök değerinden büyükse, sağ alt ağaçta ara.\n    return search(root->right, key);\n}\n\nint main() {\n    struct Node* root = newNode(10);\n    root->left = newNode(5);\n    root->right = newNode(15);\n    root->left->left = newNode(3);\n    root->left->right = newNode(7);\n\n    int key;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &key);\n\n    if (search(root, key)) {\n        printf(\"%d ağacın içinde mevcut.\\n\", key);\n    } else {\n        printf(\"%d ağacın içinde mevcut değil.\\n\", key);\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:28.244176"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak, verilen bir dizide ikili arama algoritması ile bir elemanı arayan bir fonksiyon yazın. Eğer eleman bulunursa dizinin indeksi, bulunamazsa -1 döndürsün.",
    "answer": "#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        // Hedefin ortadaki elemanla eşit olup olmadığını kontrol et.\n        if (arr[mid] == target) {\n            return mid;  // Hedef bulundu, indeksi döndür.\n        }\n        // Hedef ortadaki elemandan küçükse sağ alt ağaçta ara.\n        if (arr[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1; // Hedef ortadaki elemandan büyükse sol alt ağaçta ara.\n        }\n    }\n    return -1; // Hedef bulunamadı.\n}\n\nint main() {\n    int arr[] = {2, 3, 4, 10, 40};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &target);\n\n    int result = binarySearch(arr, n, target);\n    if (result == -1) {\n        printf(\"Eleman bulunamadı.\\n\");\n    } else {\n        printf(\"Eleman %d dizinin %d. indeksinde bulunuyor.\\n\", target, result);\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:28.244238"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak ikili arama algoritmasını uygulayın. Kullanıcıdan bir dizi ve bir hedef sayı alın. Diziyi sıralayın ve hedef sayının dizideki indeksini bulun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// İkili arama fonksiyonu\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Hedef bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Sağ tarafa geç\n        } else {\n            right = mid - 1; // Sol tarafa geç\n        }\n    }\n    return -1; // Hedef bulunamadı\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, target;\n    printf(\"Dizi eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    int *arr = (int*)malloc(n * sizeof(int));\n\n    printf(\"Dizi elemanlarını girin: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Hedef sayıyı girin: \");\n    scanf(\"%d\", &target);\n\n    // Diziyi sıralama\n    qsort(arr, n, sizeof(int), compare);\n\n    int result = binarySearch(arr, n, target);\n    if (result != -1) {\n        printf(\"Hedef sayı %d dizinin %d. indeksinde bulunuyor.\\n\", target, result);\n    } else {\n        printf(\"Hedef sayı dizide bulunamadı.\\n\");\n    }\n    free(arr);\n    return 0;\n}",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:43.111083"
  },
  {
    "question": "Verilen bir C kodunu tamamlayarak, bir dizide belirli bir öğeyi lineer arama algoritması ile arayın. Kullanıcıdan bir dizi ve aramak istediği öğe alın. Öğenin dizideki konumunu gösterin.",
    "answer": "#include <stdio.h>\n\n// Lineer arama fonksiyonu\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Hedef bulundu\n        }\n    }\n    return -1; // Hedef bulunamadı\n}\n\nint main() {\n    int n, target;\n    printf(\"Dizi eleman sayısını girin: \");\n    scanf(\"%d\", &n);\n    int arr[n];\n\n    printf(\"Dizi elemanlarını girin: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Aranacak öğeyi girin: \");\n    scanf(\"%d\", &target);\n\n    int result = linearSearch(arr, n, target);\n    if (result != -1) {\n        printf(\"Öğe %d dizinin %d. indeksinde bulunuyor.\\n\", target, result);\n    } else {\n        printf(\"Öğe dizide bulunamadı.\\n\");\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:43.111184"
  },
  {
    "question": "Bir dizide belirli bir sayıyı aramak için ikili arama algoritmasını kullanan C kodum var ama sonuç doğru çıkmıyor. Sorun ne olabilir? Kodu inceleyebilir misin?",
    "answer": "Tabii ki. Aşağıdaki kodu inceleyelim:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eğer bulunamazsa -1 döner.\n}\n\nint main() {\n    int arr[] = {2, 3, 4, 10, 40};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 10;\n    int result = binarySearch(arr, size, target);\n    if (result == -1) {\n        printf(\"Eleman bulunamadı.\");\n    } else {\n        printf(\"Eleman %d indeksinde bulundu.\", result);\n    }\n    return 0;\n}\n```\n\nEğer diziniz sıralı değilse, ikili arama algoritması yanlış sonuç verebilir. Bu algoritmayı kullanmadan önce dizinin sıralı olduğundan emin olmalısınız. Yukarıdaki örnek, sıralı dizide çalışacaktır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:55.977774"
  },
  {
    "question": "Dizideki en büyük elemanı bulmak için lineer arama algoritması kullanıyorum fakat sonuç beklediğim gibi değil. Kodumdaki hatayı bulabilir misin?",
    "answer": "Tabii ki. İşte aşağıdaki örneği gözden geçirelim:\n\n```c\n#include <stdio.h>\n\nint findMax(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int max = findMax(arr, size);\n    printf(\"En büyük eleman: %d\\n\", max);\n    return 0;\n}\n```\n\nBu kod mantıken doğru gibi görünüyor, fakat eğer dizide tüm elemanlar aynı değerde ise (örneğin `{5, 5, 5, 5}` gibi), ilk elemanın çıktısı ile sonuç değişmeyecektir. Çıktı yine doğru olur ancak bu durum, kullanıcıyı yanıltabilir. Sonuçta, lineer arama algoritması her durumda çalışır ama dizinin içeriğine göre beklenen sonuçlar değişebilir. Yani, kodda bir hata yok ama kullanıcı sonuçları beklediği gibi değerlendirmemelidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:35:55.977826"
  },
  {
    "question": "Binary search algoritması ile sıralı bir dizi içinde bir elemanı arayan bir fonksiyon yazdım ama her zaman -1 döndürüyor. Hatanın sebebi ne olabilir? Örnek kod: \n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
    "answer": "Hatanız, dizinin sıralı olup olmadığını kontrol etmemekten kaynaklanıyor olabilir. Binary search algoritması, yalnızca sıralı dizilerde doğru çalışır. Eğer dizi sıralı değilse, aradığınız elemanı bulamazsınız ve her zaman -1 döner. İlk olarak dizinin sıralı olduğundan emin olun. Örneğin, diziyi sıraladıktan sonra binary search fonksiyonunu çağırmalısınız:\n\nint arr[] = {3, 5, 7, 9, 11}; // sıralı dizi\nint size = sizeof(arr) / sizeof(arr[0]);\nint result = binarySearch(arr, size, 7); // 7'yi arama\nif (result != -1) {\n    printf(\"Eleman bulundu, indeks: %d\", result);\n} else {\n    printf(\"Eleman bulunamadı\");\n}",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:08.365586"
  },
  {
    "question": "Bir dizide tekrar eden elemanların en son indeksini bulmak için yazdığım kodda beklenmedik sonuçlar alıyorum. Kodum şöyle: \n\nint lastIndex(int arr[], int size, int target) {\n    for (int i = size - 1; i >= 0; i--) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}",
    "answer": "Kodu incelediğimizde, diziyi ters sırayla kontrol ettiğinizi görüyoruz. Bu, en son elemanın indeksini bulmak için doğru bir yaklaşım. Ancak, dizinin boyutunun 0 veya negatif bir değer olması durumunda bir hata alabilirsiniz. Ayrıca, dizinin elemanlarının sayısı kadar döngüye girmelisiniz. Ayrıca, fonksiyonu çağırmadan önce dizinin boyutunun doğru olduğundan emin olun. Örnek kullanım:\n\nint arr[] = {1, 2, 3, 2, 4};\nint size = sizeof(arr) / sizeof(arr[0]);\nint result = lastIndex(arr, size, 2); // 2'nin son indeksini bulma\nif (result != -1) {\n    printf(\"Son indeks: %d\", result);\n} else {\n    printf(\"Eleman bulunamadı\");\n} \n\nBu şekilde, dizinin geçerliliğini kontrol ettiğinizden emin olun ve hata mesajları ile kullanıcıyı bilgilendirin.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:08.365681"
  },
  {
    "question": "İkili arama algoritmasında, sıralı bir dizideki elemanları bulmak için yazılmış olan aşağıdaki kod parçasında bir hata var. Hatanın nedenini bul ve düzeltin. Kod: \n\n```\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```",
    "answer": "Hatanın nedeni, `right` değişkeninin başlangıç değeri olarak `size` verilmesidir. Dizi indeksleri 0'dan başladığı için `right` değeri `size - 1` olmalıdır. Ayrıca, döngü koşulunda `left <= right` ifadesi doğruyken, `right` değeri `size` olduğunda geçersiz bir indeks (dizinin sonundan bir sonraki) kontrol ediliyor. Düzeltmek için şu şekilde değişiklik yapmalıyız:\n\n```\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\nBu düzeltmeyle birlikte, algoritma doğru bir şekilde çalışacak ve hedef değeri içeren dizideki indeks değerini döndürecektir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:23.056452"
  },
  {
    "question": "Aşağıdaki kodda, genişletilmiş bir dizi arama algoritması olan sıralı arama (linear search) uygulanmıştır. Ancak kodda bir hata bulunmaktadır. Hatanın nedenini bulun ve düzeltin. Kod: \n\n```\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 1; i <= size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n```",
    "answer": "Hatanın nedeni, döngü başlangıç indeksinin 1 olarak ayarlanmasıdır. C dilinde diziler 0'dan başlar, bu nedenle erişim hatası verebilir. Ayrıca, döngü koşulu `i <= size` olarak ayarlandığı için `arr[size]` ifadesi geçersiz bir bellek erişimine neden olur. Düzeltmek için başlangıç değerini 0 olarak ayarlamalı ve döngü koşulunu `i < size` olarak değiştirmeliyiz:\n\n```\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\nBu düzeltme ile kod, dizideki hedef değerin indeksini doğru bir şekilde döndürecektir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:23.056564"
  },
  {
    "question": "Bir dizi içerisinde belirli bir sayıyı bulmak için hangi arama algoritmasını kullanabilirim ve bunun nasıl çalıştığını açıklayabilir misin?",
    "answer": "Dizi içerisinde belirli bir sayıyı bulmak için en basit yöntemlerden biri 'Doğrusal Arama' (Linear Search) algoritmasıdır. Bu algoritma, dizinin başlangıcından itibaren her bir elemanı sırayla kontrol ederek aranan sayıyı bulmaya çalışır. Eğer eleman aranan sayıya eşitse, algoritma o elemanın indeksini döndürür. Eğer dizinin sonuna kadar gidilir ve aranan sayı bulunamazsa, -1 döner. Bu yöntem dizinin sıralı olup olmadığına bakmaz ve dizinin her elemanını kontrol eder. Örnek kodu aşağıda görebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Elemanın indeksi döndürülüyor\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 4, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 4;\n    int result = linearSearch(arr, size, target);\n    if (result != -1) {\n        printf(\"%d sayısı dizide %d. indekste bulundu.\\n\", target, result);\n    } else {\n        printf(\"%d sayısı dizide bulunamadı.\\n\", target);\n    }\n    return 0;\n}\n```\nBu kodda, 'linearSearch' fonksiyonu, diziyi alır ve aranan sayıyı bulmaya çalışır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:40.183238"
  },
  {
    "question": "Sıralı bir dizide bir sayıyı en hızlı şekilde bulmak için hangi arama algoritmasını kullanmalıyım ve bu algoritmanın çalışma mantığını açıklayabilir misin?",
    "answer": "Sıralı bir dizide bir sayıyı en hızlı şekilde bulmak için 'İkili Arama' (Binary Search) algoritmasını kullanmalısınız. İkili arama, dizinin ortasında bulunan elemanı kontrol ederek başlar. Eğer aranan sayı, ortadaki elemandan küçükse, arama işlemi dizinin sol yarısında devam eder; eğer büyükse sağ yarısında devam eder. Bu süreç, aranan sayı bulunana kadar ya da kontrol edilecek eleman kalmayana kadar sürer. İkili arama, her adımda arama aralığını yarıya indirdiği için çok daha hızlıdır. Aşağıda örnek bir kod görebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;  // Orta elemanı hesapla\n        if (arr[mid] == target) {\n            return mid; // Elemanın indeksi döndürülüyor\n        } else if (arr[mid] < target) {\n            left = mid + 1; // Sağ yarıda devam et\n        } else {\n            right = mid - 1; // Sol yarıda devam et\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9}; // Sıralı dizi\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"%d sayısı dizide %d. indekste bulundu.\\n\", target, result);\n    } else {\n        printf(\"%d sayısı dizide bulunamadı.\\n\", target);\n    }\n    return 0;\n}\n```\nBu kodda, 'binarySearch' fonksiyonu sıralı bir dizi alarak aranan sayıyı bulmaya çalışır. İkili arama algoritmasının temel avantajı, her adımda arama alanını yarıya indirmesi ve bu sayede performansının doğrusal arama algoritmasından çok daha yüksek olmasıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:40.183379"
  },
  {
    "question": "Bir dizi içerisindeki belirli bir elemanı (örneğin 23) en etkili şekilde nasıl bulabilirim? Hangi arama algoritmasını kullanmalıyım ve neden?",
    "answer": "Dizi içerisindeki belirli bir elemanı bulmak için en etkili yöntemlerden biri ikili arama (binary search) algoritmasıdır. Ancak, ikili arama yöntemini kullanabilmemiz için dizinin sıralı olması gerekiyor. Örneğin, elimizde şu dizi olsun: [1, 5, 10, 15, 20, 23, 30, 35]. Bu dizinin sıralı olduğunu görebiliriz. İkili arama algoritmasını kullanarak 23'ü bulmak için şu adımları izleriz:\n\n1. Dizinin ortasını bul: (0 + 7) / 2 = 3 (15'in indexi)\n2. 15, 23'ten küçük olduğu için sağ tarafı (20, 23, 30, 35) inceleyeceğiz.\n3. Yeni dizi: [20, 23, 30, 35]. Yine ortayı bul: (4 + 7) / 2 = 5 (23'ün indexi)\n4. Bu noktada 23'ü bulmuş olduk. İkili arama, ortalamada dizi boyutunu yarıya indirdiği için O(log n) zaman karmaşıklığına sahiptir ve büyük diziler için oldukça etkilidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:56.076922"
  },
  {
    "question": "Bir metin içerisinde belirli bir kelimeyi (örneğin 'programlama') aramak için hangi algoritmayı kullanmalıyım? Klasik arama yöntemleri dışında bir çözüm var mı?",
    "answer": "Metin içerisinde belirli bir kelimeyi aramak için KMP (Knuth-Morris-Pratt) algoritması oldukça etkili bir yöntemdir. KMP algoritması, aramak istediğimiz kelimenin önceden hesaplanmış bir 'kendi kendine eşleştirme' tablosunu kullanarak, kelimenin metin içerisinde nerelerde geçtiğini bulur. Bu, klasik arama algoritmalarının tersine, metni tekrar tekrar taramak yerine, kelimenin bir kısmını atlayarak daha hızlı bir işlem yapmamızı sağlar. Örneğin, 'programlama' kelimesini 'ben programlama yapmayı seviyorum' cümlesinde aramak istediğimizde, KMP algoritması kelimenin kaçıncı karakterden itibaren başladığını hızlıca belirler. Bu algoritmanın zaman karmaşıklığı O(n + m) şeklindedir; burada n metnin uzunluğu, m ise aranan kelimenin uzunluğudur. Bu da KMP algoritmasını büyük metinlerde arama yapmak için oldukça verimli kılar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:36:56.076995"
  },
  {
    "question": "Binary Search algoritmasını kullanarak sıralı bir dizide bir öğenin bulunmasını nasıl gerçekleştirebiliriz? Örnek bir C kodu ile açıklayınız.",
    "answer": "Binary Search algoritması, sıralı bir dizide belirli bir öğeyi bulmak için kullanılan etkili bir arama yöntemidir. Çalışma mantığı, diziyi sürekli olarak ikiye ayırarak arama yapmaktır. Bu algoritmanın temel adımları şu şekildedir:\n\n1. Dizinin başlangıç (left) ve bitiş (right) indekslerini belirleyin.\n2. Orta (mid) indeksi hesaplayın: mid = (left + right) / 2.\n3. Eğer ortadaki öğe aradığınız öğeye eşitse, öğeyi bulun. Eğer aradığınız öğe ortadaki öğeden küçükse, sağ yarıda aramaya devam edin, büyükse sol yarıda aramaya devam edin.\n4. Bu işlemi, öğe bulunana kadar veya left > right olana kadar tekrarlayın.\n\nAşağıda Binary Search algoritmasının bir C kodu ile nasıl uygulanacağını görebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Öğeyi bulduk ve indeksini döndürüyoruz.\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Sağ yarıda aramaya devam et.\n        } else {\n            right = mid - 1; // Sol yarıda aramaya devam et.\n        }\n    }\n    return -1; // Öğe bulunamazsa -1 döndür.\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Öğe bulundu, indeksi: %%d\\n\", result);\n    } else {\n        printf(\"Öğe bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\n\nBu örnekte, 1'den 9'a kadar sıralı bir dizi üzerinde arama yapıyoruz. Eğer aranan öğe bulunursa, öğenin indeksi, bulunamazsa -1 sonucu döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:37:12.847389"
  },
  {
    "question": "Dizilerde Linear Search algoritmasının kullanılmasını ve bu yöntemin dezavantajlarını açıklayınız. Örnek bir C kodu ile gösteriniz.",
    "answer": "Linear Search (Doğrusal Arama) algoritması, bir dizide öğeleri sırayla kontrol ederek aradığınız öğeyi bulmaya çalışır. Bu algoritmanın temel mantığı, dizinin her bir öğesini tek tek kontrol etmektir. Yani, aranan öğe dizinin n'inci konumunda ise, arama işlemi en kötü durumda n adımda tamamlanır.\n\nBu algoritmanın avantajı, dizinin sıralı olup olmamasına gerek olmamasıdır, fakat dezavantajı ise büyük dizilerde yavaş çalışmasıdır. Çünkü her öğeyi kontrol etmek zorunda kalır. \n\nAşağıda Linear Search algoritmasının bir C kodu ile nasıl uygulanacağını görebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Öğeyi bulduk ve indeksini döndürüyoruz.\n        }\n    }\n    return -1; // Öğe bulunamazsa -1 döndür.\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 30;\n    int result = linearSearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Öğe bulundu, indeksi: %%d\\n\", result);\n    } else {\n        printf(\"Öğe bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\n\nBu örnekte, 10, 20, 30, 40 ve 50 değerlerinden oluşan bir dizi üzerinde 30 öğesini arıyoruz. Eğer öğe bulunursa, indeksi yazdırılır; bulunamazsa -1 sonucu gösterilir. Bu yöntem, küçük diziler için etkili olsa da, büyük dizilerde zaman kaybeder.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:37:12.847438"
  },
  {
    "question": "Bir dizi içinde belirli bir sayıyı bulmak için lineer arama algoritmasını nasıl uygularız?",
    "answer": "Lineer arama algoritması, bir dizideki elemanları teker teker kontrol ederek arama yapar. Basit bir örnekle açıklayalım: Aşağıdaki C kodunda bir dizi içinde belirli bir sayıyı arıyoruz. Eğer sayı bulunursa, dizideki indeksini döndürüyoruz; aksi takdirde -1 döndürüyoruz.\n\n```c\n#include <stdio.h>\n\nint lineerArama(int dizi[], int boyut, int hedef) {\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == hedef) {\n            return i; // Eleman bulundu, indeksini döndür\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 4, 2};\n    int hedef = 4;\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = lineerArama(dizi, boyut, hedef);\n    if (sonuc != -1) {\n        printf(\"Eleman bulundu, indeks: %d\\n\", sonuc);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda `lineerArama` fonksiyonu, verilen dizideki hedef sayıyı arar. Eğer bulursa, hedefin dizideki indeksini döner. Bulamazsa -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:37:30.093501"
  },
  {
    "question": "Sıralı bir dizide ikili arama algoritmasını nasıl uygularız?",
    "answer": "İkili arama algoritması, sıralı bir dizide daha verimli bir arama yapmamızı sağlar. Bu algoritma, dizinin ortasındaki elemanı kontrol ederek arama yapar ve arama alanını yarıya indirir. Aşağıdaki C kodunda bir dizi içinde belirli bir sayıyı ikili arama ile bulmaya çalışıyoruz:\n\n```c\n#include <stdio.h>\n\nint ikiliArama(int dizi[], int boyut, int hedef) {\n    int sol = 0, sag = boyut - 1;\n    while (sol <= sag) {\n        int orta = sol + (sag - sol) / 2;\n        if (dizi[orta] == hedef) {\n            return orta; // Eleman bulundu, indeksini döndür\n        }\n        if (dizi[orta] < hedef) {\n            sol = orta + 1; // Hedef sağ yarıda\n        } else {\n            sag = orta - 1; // Hedef sol yarıda\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6, 7};\n    int hedef = 5;\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = ikiliArama(dizi, boyut, hedef);\n    if (sonuc != -1) {\n        printf(\"Eleman bulundu, indeks: %d\\n\", sonuc);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda `ikiliArama` fonksiyonu, sıralı bir dizide verilen hedef sayıyı bulunana kadar arama yapar. Eğer hedef eleman mevcutsa, dizideki indeksini döner. Bulamazsa -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:37:30.093538"
  },
  {
    "question": "İkili arama algoritmasını kullanarak sıralı bir dizide belirli bir elemanı nasıl bulabilirim? Örnek bir C kodu ile açıklayınız.",
    "answer": "İkili arama algoritması, sıralı bir dizide eleman aramak için etkili bir yöntemdir. Bu algoritma, diziyi sürekli olarak yarıya bölerek arama yapar. İlk önce dizinin ortasındaki elemanı kontrol eder. Eğer aranan eleman ortadaki elemandan küçükse, sağ yarıyı göz ardı eder; büyükse, sol yarıyı göz ardı eder. Bu işlem, aranan eleman bulunana kadar devam eder. Aşağıda, ikili arama algoritmasının C dili ile bir örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2; // Ortayı hesapla\n\n        if (arr[mid] == target) { // Eleman bulundu\n            return mid;\n        }\n        if (arr[mid] < target) { // Eleman sağ yarıda\n            left = mid + 1;\n        } else { // Eleman sol yarıda\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 7;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, bir sıralı dizi tanımlanıyor ve `binarySearch` fonksiyonu ile belirli bir eleman aranıyor. Eğer eleman bulunursa, dizinin indeks numarası döndürülüyor, aksi takdirde bulunamadığına dair bir mesaj veriliyor.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:38:00.704616"
  },
  {
    "question": "Bir dizi içinde eleman ararken, sıralı dizi olmadığı durumda hangi arama algoritmasını kullanmalıyım? Bir örnek ile açıklayınız.",
    "answer": "Sıralı olmayan dizilerde eleman aramak için en yaygın kullanılan algoritma 'doğrusal arama' (linear search) algoritmasıdır. Bu algoritma, dizinin her bir elemanını sırayla kontrol eder ve aranan elemanla eşleşen ilk elemanı bulur. Aşağıda, doğrusal arama algoritmasının C dilinde nasıl uygulanacağına dair bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) { // Elemanı kontrol et\n            return i; // Eleman bulundu\n        }\n    }\n    return -1; // Eleman yok\n}\n\nint main() {\n    int arr[] = {4, 2, 8, 6, 1};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 6;\n    int result = linearSearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, `linearSearch` fonksiyonu ile dizi içinde arama yapılmakta. Dizi sıralı olmasa da, doğrusal arama ile elemanın indeksi bulunabiliyor. Eğer eleman bulunursa, indeks numarası döndürülüyor; aksi takdirde, bulunamadığına dair bir mesaj veriliyor.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:38:00.704668"
  },
  {
    "question": "Bir dizide sıralı arama algoritmasını (linear search) sıfırdan kodlayın. Dizi sıralı olmayabilir. Verilen bir değeri bulmak için kaç adımda sona ulaşabileceğimizi gösterin.",
    "answer": "Aşağıdaki kodda, sıralı arama algoritmasını sıfırdan yazıyoruz. Algoritma, diziyi baştan sona tarar ve aranan değeri buluncaya kadar devam eder. Eğer değer bulunamazsa, dizi sonuna ulaşıldığında -1 döner. Bu, dizi sıralı olmadığında da çalışır.\n\n```c\n#include <stdio.h>\n\nint linear_search(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Değer bulundu, index döndürülüyor\n        }\n    }\n    return -1; // Değer bulunamadı\n}\n\nint main() {\n    int arr[] = {4, 2, 7, 1, 9};\n    int target = 7;\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    int result = linear_search(arr, size, target);\n    if (result != -1) {\n        printf(\"Değer %d, dizinin %d. indexinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Değer bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte 7 değeri dizide bulunuyor ve indexi 2’dir. Fonksiyon, dizinin her elemanını tek tek kontrol eder ve arama işlemi dizinin uzunluğuna bağlıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:38:16.346180"
  },
  {
    "question": "Dizi üzerinde ikili arama algoritmasını (binary search) uygulayın. Dizi sıralı olduğunda arama işleminin nasıl hızlandığını gösterin. Kod ile açıklayınız.",
    "answer": "İkili arama algoritması, sıralı bir dizide arama yaparken daha hızlı bir çözüm sunar. Dizi her adımda yarıya bölünerek arama yapılır. Aşağıdaki kodda, bir dizi üzerinde ikili arama algoritmasını uyguluyoruz:\n\n```c\n#include <stdio.h>\n\nint binary_search(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2; // Orta noktayı bul\n        if (arr[mid] == target) {\n            return mid; // Hedef bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Hedef sağ yarıda\n        } else {\n            right = mid - 1; // Hedef sol yarıda\n        }\n    }\n    return -1; // Hedef bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 2, 4, 7, 9}; // Sıralı dizi\n    int target = 4;\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    int result = binary_search(arr, size, target);\n    if (result != -1) {\n        printf(\"Değer %d, dizinin %d. indexinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Değer bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, 4 değeri dizide bulunuyor ve indexi 2'dir. İkili arama, dizinin uzunluğu arttıkça arama süresini önemli ölçüde azaltır; çünkü her adımda diziyi yarıya indirir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:38:16.346236"
  },
  {
    "question": "Bir sıralı dizide ikili arama algoritmasını implement eden bir kod parçasını gözden geçir ve iyileştirme önerileri sun.",
    "answer": "Aşağıdaki ikili arama algoritması örneği, bir sıralı dizide arama yapmak için tasarlanmıştır:\n\n```c\nint binary_search(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```  \n\nGözden geçirme ve iyileştirme önerileri:\n1. **Dizi Boyutu Kontrolü**: Fonksiyonun başında dizinin boyutunu kontrol etmek, geçersiz bir diziyle karşılaşılmasını önleyebilir. Örneğin, `if (size <= 0) return -1;` ekleyebilirsiniz.\n2. **Orta Nokta Hesaplama**: `int mid = left + (right - left) / 2;` hesaplaması, taşma (overflow) riskine karşı daha güvenlidir. Bu hesaplamayı böyle bırakmak iyi bir pratiktir.\n3. **Sonuç Dönüşü**: -1 yerine bir hata kodu veya özel bir durum belirten bir değer döndürmek, daha anlaşılır olabilir. Örn. `return SIZE_MAX;` gibi bir tanım kullanılabilir.\n4. **Daha Fazla Yorum**: Kodun işleyişini açıklayan yorumlar eklemek, gelecekteki geliştiriciler için faydalı olacaktır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:39:26.641343"
  },
  {
    "question": "Bir dizi içinde belirli bir öğeyi aramak için doğrusal arama algoritmasını kullanan bir C kodu örneğini gözden geçir ve verimliliğini artırma yollarını öner.",
    "answer": "Aşağıdaki doğrusal arama algoritması örneği, bir dizide arama yapmak için tasarlanmıştır:\n\n```c\nint linear_search(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\nGözden geçirme ve iyileştirme önerileri:\n1. **Erken Dönüş**: Eğer aranan öğe dizinin başında bulunuyorsa, döngü başlatılmadan önce kontrol edip hemen dönebilirsiniz. Bu, belirli durumlar için performansı artırabilir.\n2. **Dizi Boyutu Kontrolü**: Fonksiyonun başında dizinin geçersiz olup olmadığını kontrol etmek ve uygun bir hata kodu döndürmek, programın daha sağlam olmasını sağlar. Örneğin, `if (size <= 0) return -1;` yazabilirsiniz.\n3. **Paralel Arama**: Eğer dizi çok büyükse, doğrusal arama yerine diziyi parçalara ayırarak çoklu iş parçacığı (thread) kullanarak arama yapmak daha verimli olabilir. Bu yöntem, büyük veri kümesi için aramayı hızlandırabilir.\n4. **Yorumlar ve Belgelendirme**: Kodda neyin yapıldığını açıklayan yorumlar eklemek, kodu okuyanların anlamasını kolaylaştırır. Bu, geliştirme sürecinde faydalı olacaktır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:39:26.641399"
  },
  {
    "question": "Büyük bir dizide belirli bir öğeyi bulmak için ikili arama (binary search) algoritmasını kullanırken, kodunuzu optimize etmek için ne tür iyileştirmeler yapabilirsiniz?",
    "answer": "İkili arama algoritması, sıralı bir dizi üzerinde çalıştığı için öncelikle dizinin sıralı olduğundan emin olmalıyız. Aşağıdaki gibi bir ikili arama uygulaması düşünelim:\n\n```c\nint binary_search(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2; // overflow önlemek için\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // öğe bulunamazsa\n}\n```\n\nBu kodda birkaç iyileştirme yapabiliriz:\n1. **Overflow Koruması:** `mid` hesaplamasında `mid = (left + right) / 2` yerine `mid = left + (right - left) / 2` kullanarak overflow riskini azaltıyoruz.\n2. **Fonksiyon İçin Geri Dönüş:** Öğenin bulunamaması durumunda -1 döndürmek, bu durumu daha iyi yönetmemizi sağlar.\n3. **Yinelenen Elementler:** Eğer dizimizde yinelenen öğeler varsa ve ilk bulduğumuz öğeyi değil de ilk bulduğumuz öğenin indeksini istiyorsak, arama tamamlandıktan sonra `left` veya `right` sınırını kontrol ederek daha küçük bir arama yapabiliriz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:39:44.025329"
  },
  {
    "question": "Bir metin içinde belirli bir kelimeyi bulmak için KMP (Knuth-Morris-Pratt) algoritması kullanıyorsanız, kodunuzda hangi optimizasyonları yaparak performansı artırabilirsiniz?",
    "answer": "KMP algoritması, metin arama işlemlerinde oldukça etkilidir ve zaman karmaşıklığı O(n + m) olan bir yapıya sahiptir (n: metin uzunluğu, m: kelime uzunluğu). Aşağıda KMP algoritmasının temel bir uygulaması verilmiştir:\n\n```c\nvoid compute_lps_array(char* pattern, int m, int* lps) {\n    int length = 0; // önceki en uzun eşleşen ön deseni\n    lps[0] = 0; // lps[0] her zaman 0'dır\n    int i = 1;\n\n    while (i < m) {\n        if (pattern[i] == pattern[length]) {\n            length++;\n            lps[i] = length;\n            i++;\n        } else {\n            if (length != 0) {\n                length = lps[length - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\nvoid KMP_search(char* text, char* pattern) {\n    int m = strlen(pattern);\n    int n = strlen(text);\n    int* lps = (int*)malloc(m * sizeof(int));\n    compute_lps_array(pattern, m, lps);\n\n    int i = 0; // text için\n    int j = 0; // pattern için\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n        if (j == m) {\n            printf(\"Pattern found at index %d\\n\", i - j);\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    free(lps);\n}\n```\n\nBu kodda optimize edilmesi gereken birkaç nokta vardır:\n1. **Bellek Yönetimi:** `lps` dizisini dinamik olarak tahsis ettik, fakat bunu bir yerel dizi olarak tanımlayıp stack bellek kullanımını artırabiliriz. Böylece bellek sızıntısından kaçınırız.\n2. **Fonksiyonel Ayrım:** `compute_lps_array` fonksiyonunu ayrı bir dosyaya almak, kodun okunabilirliğini artırır. Ayrıca, bu fonksiyonu başka projelerde de aynı şekilde kullanabiliriz.\n3. **Hata Yönetimi:** Kötü giriş durumları için hata kontrolü eklemek, algoritmanın daha sağlam çalışmasını sağlar. Örneğin, `text` veya `pattern` boşsa bir hata mesajı dönebiliriz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-05-31T17:39:44.025423"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya yazan eksik kodu tamamla: #include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    // Buraya kodu ekleyin\n    fclose(dosya);\n    return 0;\n}",
    "answer": "Eksik kod, kullanıcının girdiği metni dosyaya yazmak için 'fprintf' veya 'fputs' fonksiyonu ile tamamlanabilir. Aşağıda tamamlanmış hali verilmiştir:\n\n```c\nfputs(metin, dosya);\n```\n\nBu kod, kullanıcının girdiği metni 'metin.txt' dosyasına yazar. 'fputs' fonksiyonu, karakter dizisini dosyaya yazar. Kullanıcıdan alınan metin, 'fgets' ile okunur ve 'fputs' ile dosyaya aktarılır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:39:52.843934"
  },
  {
    "question": "Bir dosyadan metin okuma işlemini gerçekleştiren eksik kodu tamamla: #include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    char satir[100];\n    // Buraya kodu ekleyin\n    fclose(dosya);\n    return 0;\n}",
    "answer": "Eksik kod, dosyadan satır satır metin okumak için bir döngü ile tamamlanabilir. Aşağıda tamamlanmış hali verilmiştir:\n\n```c\nwhile (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir);\n    }\n```\n\nBu kod, 'metin.txt' dosyasındaki tüm satırları okur ve ekrana yazdırır. 'fgets' fonksiyonu, dosyadan bir satırı okur ve bu işlem dosyanın sonuna kadar devam eder.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:39:52.844049"
  },
  {
    "question": "Aşağıdaki eksik kod parçası ile bir metin dosyasına kullanıcıdan alınan bir metni yazdırın. Kodun eksik kısımlarını tamamlayın ve açıklayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Kullanıcıdan metin alıyoruz\n    printf(\"Lütfen bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyayı yazma modunda açıyoruz\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Kullanıcının girdiği metni dosyaya yazıyoruz\n    fprintf(dosya, \"%s\", metin);\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    printf(\"Metin dosyaya yazıldı.\\n\");\n    return 0;\n}\n\n// Açıklama: Bu kod parçası, kullanıcıdan bir metin alır ve bunu 'metin.txt' adlı dosyaya yazar. Dosya yazma modunda açılmakta ve yazma işlemi tamamlandıktan sonra dosya kapatılmaktadır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:03.975194"
  },
  {
    "question": "Aşağıdaki eksik kod parçası ile 'veriler.txt' dosyasından verileri okuyarak ekrana yazdırın. Kodun eksik kısımlarını tamamlayın ve açıklayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256];\n\n    // Dosyayı okuma modunda açıyoruz\n    dosya = fopen(\"veriler.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosya içeriğini satır satır okuyoruz\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    return 0;\n}\n\n// Açıklama: Bu kod parçası, 'veriler.txt' dosyasını okuma modunda açar. Dosya içeriğini satır satır okur ve her satırı ekrana yazdırır. Dosya okuma işlemi tamamlandıktan sonra dosya kapatılmaktadır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:03.975245"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya kaydeden ve ardından bu dosyayı okuyan bir C programı yazın. Dosya işlemlerinde hata kontrolü yapın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char metin[256];\n\n    // Kullanıcıdan metin alma\n    printf(\"Dosyaya yazmak için bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyayı yazma modunda açma\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Metni dosyaya yazma\n    fprintf(dosya, \"%s\", metin);\n    fclose(dosya);\n\n    // Dosyayı okuma modunda açma\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Dosyadan metni okuma\n    printf(\"Dosyadan okunan metin: \");\n    while (fgets(metin, sizeof(metin), dosya) != NULL) {\n        printf(\"%s\", metin);\n    }\n\n    fclose(dosya);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan metin alarak bunu 'metin.txt' adlı bir dosyaya yazar ve ardından dosyayı okuyarak ekrana yazdırır. Dosyaların açılmasında hata kontrolü yapılır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:17.676976"
  },
  {
    "question": "Bir dosyadaki sayıları okuyup topladıktan sonra sonucu başka bir dosyaya yazan C programını yazın. Dosya işlemlerinde hata kontrolü ekleyin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *input_dosya, *output_dosya;\n    int sayi, toplam = 0;\n\n    // Girdi dosyasını açma\n    input_dosya = fopen(\"sayilar.txt\", \"r\");\n    if (input_dosya == NULL) {\n        perror(\"Girdi dosyası açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Sayıları okuma ve toplama\n    while (fscanf(input_dosya, \"%d\", &sayi) == 1) {\n        toplam += sayi;\n    }\n    fclose(input_dosya);\n\n    // Çıktı dosyasını açma\n    output_dosya = fopen(\"toplam.txt\", \"w\");\n    if (output_dosya == NULL) {\n        perror(\"Çıktı dosyası açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Toplamı dosyaya yazma\n    fprintf(output_dosya, \"Toplam: %d\\n\", toplam);\n    fclose(output_dosya);\n\n    printf(\"Toplam başarıyla 'toplam.txt' dosyasına yazıldı.\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, 'sayilar.txt' adlı dosyadaki sayıları okur, toplar ve sonucu 'toplam.txt' adlı dosyaya yazar. Hata kontrolü ile dosya açılmadığında kullanıcıya hata mesajı gösterilir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:17.677043"
  },
  {
    "question": "C dilinde bir dosyayı açarken 'fopen' fonksiyonunu kullanıyorum ama dosya açılmıyor. Neden olabilir?",
    "answer": "Dosyanın açılmamasının birkaç nedeni olabilir. Öncelikle, dosya yolunun doğru olduğundan emin olun. Dosya yolu yanlışsa veya dosya mevcut değilse, 'fopen' fonksiyonu NULL dönecektir. Ayrıca, dosyaya yazma izniniz yoksa veya dosya başka bir işlem tarafından kullanılıyorsa, bu da dosyanın açılmamasına neden olabilir. Aşağıdaki gibi bir kod ile durumu kontrol edebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"dosya.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya işlemleri\n    fclose(file);\n    return 0;\n}\n```\nBurada 'perror' fonksiyonu, dosya açılamadığında hata mesajı vermektedir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:27.218047"
  },
  {
    "question": "Bir dosyaya veri yazmak için 'fprintf' fonksiyonunu kullanıyorum ama dosya boş olarak kalıyor. Hatanın nedeni ne olabilir?",
    "answer": "Eğer 'fprintf' fonksiyonunu kullanarak dosyaya veri yazdığınızda dosya boş kalıyorsa, muhtemel bir neden dosyanın açılış modunun yanlış olmasıdır. Dosyayı yazma modunda ('w' veya 'a') açmadığınız takdirde, yazma işlemi gerçekleşmeyecektir. Aşağıdaki örnek kodda bu durumu gözlemleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"dosya.txt\", \"w\"); // Dosya yazma modunda açıldı\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fprintf(file, \"Merhaba, dünya!\"); // Dosyaya veri yazılıyor\n    fclose(file); // Dosya kapatılıyor\n    return 0;\n}\n```\nBu kod her çalıştığında 'dosya.txt' dosyasını açar ve içine 'Merhaba, dünya!' yazacaktır. Dosyayı yazma modunda açmadığınızda, 'fprintf' ile yazmaya çalıştığınız veri kaydedilmeyecektir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:27.218106"
  },
  {
    "question": "Aşağıdaki C kodu bir dosyaya yazmaya çalışıyor, ancak dosya açıldıktan sonra yazma işlemi gerçekleşmiyor. Hatanın sebepleri nelerdir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    // Yazma işlemi burada eksik\n    fclose(file);\n    return 0;\n}\n```",
    "answer": "Kodda dosyaya yazma işlemi eksik. 'fwrite' veya 'fprintf' gibi bir fonksiyon kullanarak dosyaya veri yazmalısınız. Ayrıca, yazılacak veriyi belirtmek için uygun bir format kullanmalısınız. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fprintf(file, \"Hello, World!\\n\"); // Dosyaya yazma işlemi\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:45.553033"
  },
  {
    "question": "Aşağıdaki C kodu bir dosyadan okuma yapmaya çalışıyor, ancak okunan veriyi ekrana yazdırmıyor. Hatanın sebepleri nelerdir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[100];\n    file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fgets(buffer, sizeof(buffer), file);\n    // Ekrana yazdırma işlemi burada eksik\n    fclose(file);\n    return 0;\n}\n```",
    "answer": "Kodda dosyadan okunan veriyi ekrana yazdırma işlemi eksik. 'printf' fonksiyonunu kullanarak okunan veriyi ekrana yazdırmalısınız. Ayrıca, dosya kapatılmadan önce okunan veriyi ekrana bastığınızdan emin olmalısınız. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[100];\n    file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fgets(buffer, sizeof(buffer), file);\n    printf(\"Okunan veri: %s\", buffer); // Ekrana yazdırma işlemi\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:45.553248"
  },
  {
    "question": "Bir dosya açarken dosya adı geçersiz bir karakter içeriyorsa nasıl bir hata ile karşılaşırız ve bu hatayı nasıl düzeltebiliriz?",
    "answer": "Geçersiz karakterler içeren bir dosya adı kullanıldığında genellikle 'No such file or directory' (Böyle bir dosya veya dizin yok) hatası alırız. Bu hata, dosya sisteminin belirli karakterleri desteklememesinden kaynaklanır. Örneğin, Windows'ta dosya adları `*`, `?`, `:` gibi karakterleri içeremez. Bu hatayı düzeltmek için dosya adını geçerli karakterlerle yeniden yazmalıyız. Örnek bir kod parçası: \n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"invalid*name.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\"); // Hata mesajını yazdır\n        return 1;\n    }\n    fclose(file);\n    return 0;\n}\n```\nYukarıdaki kodda geçersiz bir dosya adı verildiği için fopen fonksiyonu NULL dönecek ve perror ile hata mesajı yazdırılacaktır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:55.906052"
  },
  {
    "question": "Bir dosyadan okuma işlemi yaparken, dosyanın sonuna gelindiğinde bir 'EOF' (End Of File) hatası almak yerine neden program '0' döndürüyor ve bunu nasıl yönetebiliriz?",
    "answer": "Dosya okuma işlemi sırasında 'fgetc' veya 'fscanf' gibi fonksiyonlar kullanıldığında, dosyanın sonuna gelindiğinde bu fonksiyonlar genellikle 'EOF' değerini döndürür. Ancak, eğer bu durumu doğru yönetmezsek, programımızın akışı bozulabilir. Örneğin, okuma işlemi sırasında döngü şartı 'EOF' kontrolü ile yapılmazsa, program sonsuz döngüye girebilir. Doğru yaklaşım, okuma işlemi yapmadan önce 'feof' fonksiyonu ile dosyanın sonuna ulaşılıp ulaşılmadığını kontrol etmektir. Aşağıda örnek bir kod verilmiştir: \n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int ch;\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n    if (feof(file)) {\n        printf(\"Dosyanın sonuna ulaşıldı.\");\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu kodda, dosyadan okuma işlemi yapılırken 'EOF' kontrolü ile dosyanın sonuna gelindiği düzgün bir şekilde yönetiliyor.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:40:55.906115"
  },
  {
    "question": "Bir metin dosyasını C dilinde nasıl okuyabilirim?",
    "answer": "Bir metin dosyasını okumak için C dilinde öncelikle dosyayı açmamız gerekiyor. Bu işlem için 'fopen' fonksiyonunu kullanırız. 'fopen' fonksiyonu iki parametre alır: dosya adı ve dosya açma modu. Metin dosyasını okumak için 'r' modunu kullanırız. Aşağıdaki örnekte, 'dosya.txt' isimli bir dosyanın içeriğini okuma işlemi yapılmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    // Dosyayı okuma modunda aç\n    dosya = fopen(\"dosya.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Dosyanın içeriğini oku ve ekrana yazdır\n    while ((ch = fgetc(dosya)) != EOF) {\n        putchar(ch);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}\n```\nBu örnekte, 'fgetc' fonksiyonu bir karakter okur ve 'EOF' (End Of File) karakterine kadar devam eder. Dosyayı okumayı bitirdikten sonra 'fclose' fonksiyonu ile dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:10.186884"
  },
  {
    "question": "C dilinde bir metin dosyasına nasıl yazabilirim?",
    "answer": "Bir metin dosyasına veri yazmak için yine 'fopen' fonksiyonunu kullanarak dosyayı açmamız gerekiyor. Bu sefer dosyayı yazma modu olan 'w' ile açarız. Eğer dosya mevcutsa, içeriği silinir; yoksa yeni bir dosya oluşturulur. Aşağıdaki örnekte, 'yazim.txt' isimli bir dosyaya 'Merhaba, Dünya!' yazma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    // Dosyayı yazma modunda aç\n    dosya = fopen(\"yazim.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Dosyaya yaz\n    fprintf(dosya, \"Merhaba, Dünya!\\n\");\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}\n```\nBu örnekte, 'fprintf' fonksiyonu ile dosyaya formatlanmış bir metin yazıyoruz. Yazma işlemi tamamlandığında 'fclose' fonksiyonu ile dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:10.186918"
  },
  {
    "question": "Bir metin dosyasını okuyarak içeriğini ekrana yazdırmak istiyorum. Bunu nasıl gerçekleştiririm?",
    "answer": "C dilinde bir metin dosyasını okumak için öncelikle dosyayı açmamız gerekiyor. Bunun için 'fopen' fonksiyonunu kullanacağız. Okuma modunda ('r') açtığımız dosyanın içeriğini 'fgets' fonksiyonu ile satır satır okuyabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100]; // Her satırın en fazla 99 karakter olacağını varsayıyoruz.\n\n    dosya = fopen(\"ornek.txt\", \"r\"); // 'ornek.txt' dosyasını okuma modunda açıyoruz.\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) { // Dosyadan satır okuma işlemi\n        printf(\"%s\", satir); // Okunan satırı ekrana yazdırıyoruz.\n    }\n\n    fclose(dosya); // Dosyayı kapatıyoruz.\n    return 0;\n}\n```\nBu kod, 'ornek.txt' adlı dosyayı açar, içindeki her satırı okur ve ekrana yazdırır. Dosya açılmadıysa bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:22.024010"
  },
  {
    "question": "Bir dizi sayıyı bir dosyaya yazmak istiyorum. C dilinde bunu nasıl yaparım?",
    "answer": "C dilinde bir dizi sayıyı dosyaya yazmak için yine 'fopen' fonksiyonunu kullanarak dosyayı yazma modunda ('w') açmalıyız. Ardından, 'fprintf' fonksiyonu ile dizideki her bir elemanı dosyaya yazabiliriz. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[] = {1, 2, 3, 4, 5}; // Yazmak istediğimiz dizi\n    int n = sizeof(sayilar) / sizeof(sayilar[0]); // Dizinin eleman sayısını buluyoruz.\n\n    dosya = fopen(\"sayilar.txt\", \"w\"); // 'sayilar.txt' dosyasını yazma modunda açıyoruz.\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    for (int i = 0; i < n; i++) { // Diziyi döngü ile yazıyoruz\n        fprintf(dosya, \"%d\\n\", sayilar[i]); // Her sayıyı yeni satıra yazıyoruz.\n    }\n\n    fclose(dosya); // Dosyayı kapatıyoruz.\n    return 0;\n}\n```\nBu kod, 'sayilar.txt' adlı bir dosya oluşturur ve içeriğine 1'den 5'e kadar olan sayıları yazar. Dosya açılmadıysa bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:22.024052"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları okuyarak, her satırın karakter sayısını hesaplayıp, sonucu başka bir dosyaya yazan bir C programı nasıl yazılır?",
    "answer": "Aşağıda, verilen bir metin dosyasını okuyarak her satırın karakter sayısını hesaplayıp sonucu başka bir dosyaya yazan bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *inputFile, *outputFile;\n    char line[256];\n\n    // Giriş ve çıkış dosyalarını aç\n    inputFile = fopen(\"input.txt\", \"r\");\n    outputFile = fopen(\"output.txt\", \"w\");\n\n    if (inputFile == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyayı satır satır oku\n    while (fgets(line, sizeof(line), inputFile) != NULL) {\n        // Satırın uzunluğunu hesapla\n        int length = strlen(line);\n        // Uzunluğu çıkış dosyasına yaz\n        fprintf(outputFile, \"Satır Uzunluğu: %d\\n\", length);\n    }\n\n    // Dosyaları kapat\n    fclose(inputFile);\n    fclose(outputFile);\n\n    return 0;\n}\n```\nBu program, \"input.txt\" dosyasını okur ve her satırın karakter sayısını \"output.txt\" dosyasına yazar. `fgets` fonksiyonu ile satırları okuyoruz ve `strlen` fonksiyonu ile her satırın karakter sayısını hesaplıyoruz. Dosya işlemleri sırasında hata kontrolü de yapıyoruz.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:38.451645"
  },
  {
    "question": "Bir binary dosyası okuma ve yazma işlemleri için C dilinde nasıl bir program yazılır? Özellikle, bir diziyi binary formatında dosyaya yazıp, ardından bu dosyadan okuyarak diziyi geri almak istiyorum.",
    "answer": "Aşağıda, bir diziyi binary formatında bir dosyaya yazan ve ardından bu dosyadan okuyarak diziyi geri alan bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    int arr[] = {1, 2, 3, 4, 5};\n    size_t arrSize = sizeof(arr);\n\n    // Diziyi binary formatında dosyaya yaz\n    file = fopen(\"array.bin\", \"wb\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fwrite(arr, sizeof(int), arrSize / sizeof(int), file);\n    fclose(file);\n\n    // Diziyi dosyadan oku\n    int readArr[5];\n    file = fopen(\"array.bin\", \"rb\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fread(readArr, sizeof(int), sizeof(readArr) / sizeof(int), file);\n    fclose(file);\n\n    // Okunan diziyi yazdır\n    for (int i = 0; i < 5; i++) {\n        printf(\"Dizinin %d. elemanı: %d\\n\", i + 1, readArr[i]);\n    }\n\n    return 0;\n}\n```\nBu program, bir tamsayı dizisini \"array.bin\" adlı bir binary dosyaya yazar ve ardından bu dosyadan okuyarak diziyi geri alır. `fwrite` fonksiyonu ile diziyi dosyaya yazarken, `fread` fonksiyonu ile bu diziyi dosyadan geri okuyabiliyoruz. Dosya açma işlemlerinde hata kontrolü yapmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:38.451712"
  },
  {
    "question": "C dilinde bir dosyaya nasıl yazılır? Örnek bir kod ile göster.",
    "answer": "C dilinde bir dosyaya yazmak için 'fopen', 'fprintf' ve 'fclose' fonksiyonlarını kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"ornek.txt\", \"w\"); // Dosyayı yazma modunda açıyoruz\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n    fprintf(dosya, \"Merhaba, bu bir dosya yazma örneğidir.\"); // Dosyaya yazıyoruz\n    fclose(dosya); // Dosyayı kapatıyoruz\n    return 0;\n}\n```\nBu kod, 'ornek.txt' adlı bir dosya oluşturur ve içine bir metin yazar. Dosya açılmadığında hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:53.536193"
  },
  {
    "question": "C dilinde bir dosyadan nasıl okunur? Örnek bir kod ile göster.",
    "answer": "C dilinde bir dosyadan okumak için 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n    dosya = fopen(\"ornek.txt\", \"r\"); // Dosyayı okuma modunda açıyoruz\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n    while (fgets(satir, sizeof(satir), dosya) != NULL) { // Dosyadan satır okuyarak döngüye giriyoruz\n        printf(\"Okunan satır: %s\", satir); // Okunan satırı ekrana yazdırıyoruz\n    }\n    fclose(dosya); // Dosyayı kapatıyoruz\n    return 0;\n}\n```\nBu kod, 'ornek.txt' adlı dosyadan satırları okuyarak ekrana yazdırır. Dosya açılamadığında hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:41:53.536229"
  },
  {
    "question": "Bir metin dosyasına kullanıcıdan alınan bir metni nasıl yazabilirim?",
    "answer": "C dilinde bir metin dosyasına yazmak için 'fopen', 'fprintf' ve 'fclose' fonksiyonlarını kullanabiliriz. Öncelikle, kullanıcıdan bir metin alırız. Ardından, dosyayı yazma modunda açarız ve kullanıcıdan aldığımız metni dosyaya yazarız. İşte örnek bir kod: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char input[100];\n\n    // Kullanıcıdan metin al\n    printf(\"Bir metin girin: \");\n    fgets(input, sizeof(input), stdin);\n\n    // Dosyayı yazma modunda aç\n    file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Metni dosyaya yaz\n    fprintf(file, \"%s\", input);\n\n    // Dosyayı kapat\n    fclose(file);\n    printf(\"Metin dosyaya yazıldı.\");\n    return EXIT_SUCCESS;\n}\n```\nBu kodda, kullanıcıdan bir metin alınıyor ve 'output.txt' adlı dosyaya yazılıyor. Dosya yazma modunda açıldığı için dosya her çalıştırıldığında üzerine yazılıyor.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:03.842229"
  },
  {
    "question": "Bir metin dosyasını okuyup içeriğini ekrana nasıl yazdırabilirim?",
    "answer": "C dilinde bir metin dosyasını okumak için 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanırız. Dosyayı okuma modunda açtıktan sonra, dosyadan satır satır okuyarak içeriği ekrana yazdırabiliriz. Aşağıda örnek bir kod bulunuyor:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char buffer[255];\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Dosyadan satır satır oku\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'input.txt' adlı dosyayı açıp, içerdiği satırları ekrana yazdırır. Eğer dosya açılamazsa, hata mesajı gösterir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:03.842266"
  },
  {
    "question": "Bir metin dosyasını satır satır okuyarak, her satırdaki kelime sayısını hesaplayıp başka bir dosyaya yazan bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, belirtilen bir metin dosyasını satır satır okuyarak her satırdaki kelime sayısını hesaplar ve bu sayıları başka bir dosyaya yazar. Program, 'input.txt' dosyasını okur ve 'output.txt' dosyasına sonuçları yazar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint kelimeSay(char *satir) {\n    int sayac = 0;\n    char *kelime;\n    kelime = strtok(satir, \" \\t\\n\"); // Kelimeleri ayırmak için boşluk, tab ve yeni satır karakterlerini kullan\n    while (kelime != NULL) {\n        sayac++;\n        kelime = strtok(NULL, \" \\t\\n\");\n    }\n    return sayac;\n}\n\nint main() {\n    FILE *inputFile, *outputFile;\n    char satir[256];\n\n    inputFile = fopen(\"input.txt\", \"r\");\n    outputFile = fopen(\"output.txt\", \"w\");\n\n    if (inputFile == NULL || outputFile == NULL) {\n        perror(\"Dosya açma hatası\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), inputFile) != NULL) {\n        int sayi = kelimeSay(satir);\n        fprintf(outputFile, \"Bu satırda %d kelime var.\\n\", sayi);\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n```\n\nBu kodda öncelikle 'input.txt' dosyası açılır ve her satır tek tek okunur. Her satır için kelime sayısı hesaplanır ve sonuç 'output.txt' dosyasına yazılır. Kodu çalıştırmadan önce 'input.txt' dosyasının mevcut olduğundan emin olun.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:24.152457"
  },
  {
    "question": "Bir ikili dosya (örneğin resim veya ses dosyası) okuma ve yazma işlemi gerçekleştiren C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, bir ikili dosyayı okur ve içeriğini başka bir ikili dosyaya yazar. Program, 'input.bin' adlı ikili dosyayı okur ve 'output.bin' adlı yeni bir dosyaya yazar.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *inputFile, *outputFile;\n    unsigned char *buffer;\n    size_t bytesRead;\n\n    inputFile = fopen(\"input.bin\", \"rb\"); // İkili dosya okuma modu\n    outputFile = fopen(\"output.bin\", \"wb\"); // İkili dosya yazma modu\n\n    if (inputFile == NULL || outputFile == NULL) {\n        perror(\"Dosya açma hatası\");\n        return 1;\n    }\n\n    // Dosyanın boyutunu öğrenmek için dosyanın sonuna gideriz\n    fseek(inputFile, 0, SEEK_END);\n    long fileSize = ftell(inputFile);\n    rewind(inputFile);\n\n    // Bellekte dosya boyutuna uygun bir tampon oluştur\n    buffer = (unsigned char *)malloc(fileSize);\n    if (buffer == NULL) {\n        perror(\"Bellek ayırma hatası\");\n        fclose(inputFile);\n        fclose(outputFile);\n        return 1;\n    }\n\n    // Dosyanın içeriğini okuruz\n    bytesRead = fread(buffer, 1, fileSize, inputFile);\n    if (bytesRead != fileSize) {\n        perror(\"Dosya okuma hatası\");\n    }\n\n    // Veriyi yeni dosyaya yazarız\n    fwrite(buffer, 1, bytesRead, outputFile);\n\n    // Belleği serbest bırakırız ve dosyaları kapatırız\n    free(buffer);\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n```\n\nBu kod, 'input.bin' dosyasını ikili modda okur ve okunan veriyi 'output.bin' dosyasına yazar. İlk olarak, dosyanın boyutu öğrenilir ve bu boyutta bir bellek alanı (tampon) ayırarak veriler okunur. Okunan veriler yeni dosyaya yazılır ve program sonunda bellek serbest bırakılır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:24.152504"
  },
  {
    "question": "Bir dosyadan verileri okumak için kullanılan aşağıdaki C kodunda iyileştirme önerileri nelerdir? Kod: \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char buffer[256];\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"Okunan: %s\", buffer);\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Bu kodda birkaç iyileştirme önerisi var: \n1. Dosya açma hatası durumunda daha açıklayıcı bir hata mesajı verebilirsiniz.\n2. Okunan verilerin boyutunu kontrol etmeniz, bellek taşmasını önleyebilmek için önemlidir.\n3. fopen fonksiyonu ile dosya açıldıktan sonra dosya kapatılmadan önce bir kontrol yapılabilir.\n4. Kodun daha okunabilir olması için hata kontrol işlemlerini ayrı bir fonksiyona taşıyabilirsiniz. Önerilen iyileştirilmiş kod:\n\n#include <stdio.h>\n\nvoid handleFileError(FILE *file) {\n    if (file == NULL) {\n        perror(\"Dosya açma hatası\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    handleFileError(file);\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"Okunan: %s\", buffer);\n    }\n    fclose(file);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:38.673414"
  },
  {
    "question": "Aşağıdaki C kodu, bir dosyaya veri yazmak için kullanılıyor. Ancak performans ve güvenilirlik açısından iyileştirilmesi gereken yerler var. Kod: \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    for (int i = 0; i < 100; i++) {\n        fprintf(file, \"%d\\n\", i);\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Bu kodda performansı ve güvenilirliği artırmak için bazı öneriler var:\n1. Dosya yazımları yerine tam bir veri kümesini bellekte toplamak ve en son bir kez dosyaya yazmak I/O işlemlerini azaltır ve bu da performansı artırır. \n2. Yazma işlemi sırasında hata kontrolü eklemek, yazma işleminin başarıyla gerçekleşip gerçekleşmediğini kontrol etmek için önemlidir. \n3. Dosya kapatılmadan önce açılış hatası kontrolü yapılmalıdır. İyileştirilmiş kod şöyle olabilir:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açma hatası\");\n        return EXIT_FAILURE;\n    }\n    int nums[100];\n    for (int i = 0; i < 100; i++) {\n        nums[i] = i;\n    }\n    for (int i = 0; i < 100; i++) {\n        if (fprintf(file, \"%d\\n\", nums[i]) < 0) {\n            perror(\"Yazma hatası\");\n            fclose(file);\n            return EXIT_FAILURE;\n        }\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n}",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:38.673542"
  },
  {
    "question": "Bir dosyayı satır satır okuyup içeriğini ters çevirerek başka bir dosyaya yazmak için yazılmış aşağıdaki kodu optimize edebilir misin? Hangi iyileştirmeleri önerirsin?",
    "answer": "Kodun temel yapısını inceleyelim. Aşağıdaki gibi bir kod olduğunu varsayıyorum:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverse_lines(const char *input_file, const char *output_file) {\n    FILE *in_file = fopen(input_file, \"r\");\n    FILE *out_file = fopen(output_file, \"w\");\n    if (in_file == NULL || out_file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    char *line = NULL;\n    size_t len = 0;\n    while (getline(&line, &len, in_file) != -1) {\n        size_t line_len = strlen(line);\n        for (size_t i = line_len; i > 0; i--) {\n            fputc(line[i - 1], out_file);\n        }\n    }\n\n    free(line);\n    fclose(in_file);\n    fclose(out_file);\n}\n```  \nÖneriler: 1. `getline` yerine `fgets` kullanarak bellek yönetimini daha iyi kontrol edebilirsin. Bu, bellek sızıntılarını önleyebilir. 2. Her satırı ters çevirmek yerine tüm dosyayı bellek içinde tutarak işlemi daha hızlı gerçekleştirebilirsin. 3. Hata kontrolü yapılmasını sağlamak için `ferror` kullanmak daha iyi olacaktır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:52.480617"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadan sayıları okuyup toplamını hesaplıyor. Ancak bellek yönetimi konusunda sorunları var. Bu kodu inceleyip iyileştirme yapar mısın?",
    "answer": "Kod şöyle olabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"numbers.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    int total = 0;\n    int number;\n    while (fscanf(file, \"%d\", &number) != EOF) {\n        total += number;\n    }\n\n    fclose(file);\n    printf(\"Toplam: %d\\n\", total);\n    return EXIT_SUCCESS;\n}\n```  \nÖneriler: 1. `fscanf` kullanımı yerine `fgets` ile satırı okuyup `sscanf` ile sayıları işlemek daha güvenli olacaktır. Bu, sayılardan önce veya sonra gelen boşlukları daha iyi yönetir. 2. Dosya açıldıktan sonra başarısızlık durumunda hata mesajlarını yazdırmak yerine çıkış yapmadan önce dosya kapanmalı. 3. Sayı okuma döngüsünde `EOF` kontrolü yanıltıcı olabilir, bu yüzden `fscanf` sonucunu `!= 1` şeklinde kontrol etmek daha sağlıklı.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-05-31T17:42:52.480702"
  },
  {
    "question": "Kullanıcıdan bir dosya adı alarak bu dosyayı binary modda açan ve içeriğini ekrana yazdıran bir C programının eksik kısmını tamamla. Dosya açma ve okuma işlemlerini yap.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char buffer[256];\n    printf(\"Bir dosya adı girin: \");\n    scanf(\"%s\", buffer);\n\n    // Dosyayı binary modda aç\n    dosya = fopen(buffer, \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyanın içeriğini okuma ve yazdırma\n    while (fread(buffer, sizeof(char), sizeof(buffer), dosya) > 0) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(dosya);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir dosya adı alır, belirtilen dosyayı binary modda açar ve içeriğini okur. fread fonksiyonu, belirtilen boyutta veriyi okuyarak buffer'a yazar. Eğer dosya açılamazsa, bir hata mesajı gösterilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:02.621090"
  },
  {
    "question": "Kullanıcıdan alınan bir tamsayıyı binary dosyaya yazan bir C programının eksik kısmını tamamla. Dosya yazma işlemini gerçekleştirin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Dosyayı binary modda yazmak için aç\n    dosya = fopen(\"sayilar.bin\", \"wb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Tamsayıyı dosyaya yaz\n    fwrite(&sayi, sizeof(int), 1, dosya);\n\n    fclose(dosya);\n    printf(\"Tamsayı dosyaya yazıldı.\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir tamsayı alır ve bunu 'sayilar.bin' adlı binary dosyaya yazar. fwrite fonksiyonu, belirtilen sayıda baytı dosyaya yazmak için kullanılır. Eğer dosya açılamazsa, bir hata mesajı gösterilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:02.621142"
  },
  {
    "question": "Bir binary dosyası oluşturmak ve içine bir dizi tam sayı yazmak için eksik kısmı tamamlayın. Dizi: {1, 2, 3, 4, 5}.",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    // Binary dosyası oluşturma\n    file = fopen(\"numbers.bin\", \"wb\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Tam sayıları dosyaya yazma\n    fwrite(numbers, sizeof(int), size, file);\n    fclose(file);\n\n    printf(\"Tam sayılar dosyaya yazıldı.\\n\");\n    return 0;\n}\n``` \nBu kod, 'numbers.bin' adında yeni bir binary dosyası oluşturur ve içine {1, 2, 3, 4, 5} dizisini yazar. 'fwrite' fonksiyonu, dizi elemanlarını binary formatında dosyaya kaydeder. Dosya açılmadığında bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:14.700378"
  },
  {
    "question": "Bir binary dosyasından tam sayı dizisini okuyup ekrana yazdırmak için eksik kısmı tamamlayın. Dosya adı: \"numbers.bin\".",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int numbers[5];\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    // Binary dosyasını açma\n    file = fopen(\"numbers.bin\", \"rb\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Tam sayıları dosyadan okuma\n    fread(numbers, sizeof(int), size, file);\n    fclose(file);\n\n    // Okunan sayıları ekrana yazdırma\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` \nBu kod, 'numbers.bin' dosyasından tam sayı dizisini okur ve ekrana yazdırır. 'fread' fonksiyonu, dosyadan binary formatında verileri okur. Dosya açılamazsa bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:14.700427"
  },
  {
    "question": "Bir binary dosyasına tam sayı dizisi yazan ve ardından bu dosyadan okuma yapan bir C programının eksik kısmını tamamlayın. Dosyaya yazma ve okuma işlemlerinde hata kontrolü yapmayı unutmayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[] = {1, 2, 3, 4, 5};\n    size_t sayi_adedi = sizeof(sayilar) / sizeof(sayilar[0]);\n\n    // Dosyaya yazma işlemi\n    dosya = fopen(\"sayilar.dat\", \"wb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fwrite(sayilar, sizeof(int), sayi_adedi, dosya);\n    fclose(dosya);\n\n    // Dosyadan okuma işlemi\n    int *okunan_sayilar = (int *)malloc(sayi_adedi * sizeof(int));\n    dosya = fopen(\"sayilar.dat\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        free(okunan_sayilar);\n        return 1;\n    }\n    fread(okunan_sayilar, sizeof(int), sayi_adedi, dosya);\n    fclose(dosya);\n\n    // Okunan sayıları yazdırma\n    for (size_t i = 0; i < sayi_adedi; i++) {\n        printf(\"Okunan sayı: %d\\n\", okunan_sayilar[i]);\n    }\n\n    free(okunan_sayilar);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:33.358667"
  },
  {
    "question": "Kullanıcıdan alınan bir metni, binary dosya olarak kaydeden ve ardından dosyadaki verileri okuyarak ekrana yazdıran bir programın eksik kısımlarını tamamlayın. Ayrıca, kullanıcıdan alınan metnin boyutunu dosyaya yazarken kontrol edin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char metin[256];\n\n    printf(\"Bir metin giriniz: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyaya yazma işlemi\n    dosya = fopen(\"metin.dat\", \"wb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    size_t metin_boyutu = strlen(metin) + 1; // +1 null karakter için\n    fwrite(metin, sizeof(char), metin_boyutu, dosya);\n    fclose(dosya);\n\n    // Dosyadan okuma işlemi\n    char okunan_metin[256];\n    dosya = fopen(\"metin.dat\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fread(okunan_metin, sizeof(char), metin_boyutu, dosya);\n    fclose(dosya);\n\n    // Okunan metni yazdırma\n    printf(\"Okunan metin: %s\", okunan_metin);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:33.358738"
  },
  {
    "question": "Bir binary dosyası okuma işlemi yaparken 'fopen' ile açılan dosyanın NULL döndürmesi durumunda ne yapmalıyım?",
    "answer": "Eğer 'fopen' fonksiyonu NULL döndürüyorsa, bu dosyanın açılamadığını gösterir. Bunun sebebi dosyanın mevcut olmaması, yeterli erişim iznine sahip olmamanız veya dosya yolu hatası olabilir. Öncelikle, dosya yolunu ve ismini kontrol edin. Ayrıca, dosyanın mevcut olup olmadığını ve gerekli izinlere sahip olup olmadığınızı doğrulamak için 'errno' değişkenini kullanabilirsiniz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.bin\", \"rb\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı: %s\\n\", strerror(errno));\n        return 1;\n    }\n    // Dosya işlemleri\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosya açılamadığında hata mesajı verir ve sorunu anlamanıza yardımcı olur.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:44.236655"
  },
  {
    "question": "Binary dosyadan veri yazarken 'fwrite' fonksiyonunu kullanıyorum ama dosya boş kalıyor. Neden olabilir?",
    "answer": "Eğer 'fwrite' fonksiyonu kullanarak dosyaya veri yazıyorsanız ve dosya boş kalıyorsa, bunun birkaç sebebi olabilir. Öncelikle, dosyanın yazma modunda (\"wb\" veya \"ab\") açıldığından emin olun. Ayrıca, fwrite fonksiyonunun döndürdüğü değer ile yazılan veri boyutunu karşılaştırarak, gerçekten veri yazılıp yazılmadığını kontrol edin. Aşağıda örnek bir kod verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"cikti.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    int veri = 42;\n    size_t yazilan = fwrite(&veri, sizeof(int), 1, file);\n    if (yazilan != 1) {\n        printf(\"Veri yazılamadı\\n\");\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu kod, bir tamsayıyı binary dosyasına yazıyor. Eğer yazılan veri sayısı beklenenle eşleşmiyorsa, dosya yazma işlemi başarısız olmuştur ve 'fwrite' döndürdüğü değer ile kontrol edilmelidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:44.236700"
  },
  {
    "question": "Bir binary dosyası açarken 'fopen' fonksiyonu ile dosyayı okuma modunda açtım fakat dosya içeriğini okuyamıyorum. Neden kaynaklanıyor olabilir?",
    "answer": "Bu durumda ilk olarak 'fopen' fonksiyonunun başarılı olup olmadığını kontrol etmelisiniz. Eğer dosya açılamıyorsa, muhtemel nedenlerden biri dosyanın mevcut olmaması veya yanlış bir yol belirtilmiş olmasıdır. Ayrıca, dosya açma modunu kontrol edin: 'rb' yerine 'r' gibi bir mod kullanıyorsanız, binary dosyası düzgün okunamayabilir. İşte örnek bir kod parçası:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosya okuma işlemleri\n    fclose(file);\n    return 0;\n}\n```\n\nBu kod, dosyanın açılamaması durumunda hata mesajı verecek ve programı durduracaktır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:59.038147"
  },
  {
    "question": "Bir binary dosyasında veri yazma işlemi yaptım ama dosyanın boyutu 0 çıkıyor. Hata nerede olabilir?",
    "answer": "Bu durumda, yazma işleminin gerçekleştirilip gerçekleştirilmediğini kontrol etmelisiniz. Genellikle bu durum dosyanın açılış modunun yanlış olmasından kaynaklanır. Dosyayı yazma modunda açmadıysanız ('wb'), dosya içine veri yazamazsınız. Ayrıca, 'fwrite' fonksiyonunu kullanarak veriyi yazdıktan sonra 'fclose' fonksiyonunu çağırdığınızdan emin olun; aksi takdirde, yazma işlemi tamamlanmayabilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    int veri = 42;\n    size_t result = fwrite(&veri, sizeof(int), 1, file);\n    if (result != 1) {\n        perror(\"Veri yazma işlemi başarısız\");\n    }\n\n    fclose(file);\n    return 0;\n}\n```\n\nBu kod, bir tamsayıyı binary dosyasına yazar ve yazma işleminin başarılı olup olmadığını kontrol eder.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:43:59.038195"
  },
  {
    "question": "Bir binary dosyasını okuma işlemi yaparken, dosyanın boyutunu kontrol etmeden okuma yaparsak ne gibi hatalarla karşılaşabiliriz? Bir örnekle açıklayınız.",
    "answer": "Eğer bir binary dosyasını okurken dosyanın boyutunu kontrol etmezseniz, dosyanın beklediğinizden daha kısa olması durumunda bellek taşması (buffer overflow) hatasıyla karşılaşabilirsiniz. Örneğin, aşağıdaki gibi bir kod düşünelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.bin\", \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    int *buffer = malloc(sizeof(int) * 10);\n    fread(buffer, sizeof(int), 15, file); // Hata burada, 15 eleman okumaya çalışıyoruz.\n    fclose(file);\n    free(buffer);\n    return 0;\n}\n```\n\nYukarıdaki kod, 10 elemanlık bir diziye 15 eleman yazmaya çalışıyor. Eğer dosya 15 elemanlık değilse, bu durum bellek taşmasına yol açabilir. Çözüm olarak, her zaman dosyanın boyutunu kontrol etmek ve okuma işlemini buna göre gerçekleştirmek önemlidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:13.385215"
  },
  {
    "question": "Binary dosya yazma işlemi sırasında, dosyanın açılma modunu yanlış belirtirsek hangi sorunlarla karşılaşabiliriz? Kod örneği ile açıklayınız.",
    "answer": "Eğer bir binary dosyası yazma işlemi sırasında dosyanın açılma modunu yanlış belirtirseniz, dosya içeriğiniz kaybolabilir veya beklenmedik sonuçlar ortaya çıkabilir. Aşağıdaki örneği inceleyelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"output.bin\", \"w\"); // Yanlış mod: 'w'\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    int data = 42;\n    fwrite(&data, sizeof(int), 1, file);\n    fclose(file);\n    return 0;\n}\n```\n\nYukarıdaki kodda, dosya \"w\" (yazma) modunda açılmıştır. Bu modda dosya, her açıldığında içeriği sıfırlanır; yani daha önceki veriler kaybolur. Bu durumda, eğer daha önceki bir veri saklanıyorsa, bu veri kaybolacak ve yalnızca son yazılan veri dosyada kalacaktır. Çözüm olarak, dosyayı \"wb\" (binary yazma) modunda açmak gerekmektedir: `fopen(\"output.bin\", \"wb\");`.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:13.385267"
  },
  {
    "question": "Bir binary dosyası nasıl açılır ve okunur? Örnek bir kod ile gösterir misin?",
    "answer": "Binary dosyası açmak ve okumak için C dilinde 'fopen' ve 'fread' fonksiyonlarını kullanabiliriz. Aşağıdaki örnek, bir binary dosyasından tam sayıları okuma işlemini göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    int sayi;\n\n    // Dosyayı binary modda aç\n    dosya = fopen(\"sayilar.bin\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyadan sayıları oku\n    while (fread(&sayi, sizeof(int), 1, dosya) == 1) {\n        printf(\"Okunan sayı: %d\\n\", sayi);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}\n```\nBu örnekte, 'sayilar.bin' isimli binary dosyası okunmaktadır. Dosya başarıyla açıldığında, döngü içerisinde 'fread' fonksiyonu kullanılarak her seferinde bir tam sayı okunmakta ve ekrana yazdırılmaktadır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:24.059553"
  },
  {
    "question": "Binary dosyasına veri yazmak için nasıl bir yöntem izlemeliyim? Örnek bir kod ile açıklayabilir misin?",
    "answer": "Binary dosyasına veri yazmak için C dilinde 'fopen' ve 'fwrite' fonksiyonları kullanılmaktadır. Aşağıdaki örnekte, bir dizi tam sayıyı binary dosyasına yazma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[] = {1, 2, 3, 4, 5};\n\n    // Dosyayı binary modda aç (yazma)\n    dosya = fopen(\"sayilar.bin\", \"wb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Diziyi dosyaya yaz\n    fwrite(sayilar, sizeof(int), 5, dosya);\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}\n```\nBu örnekte, 'sayilar' isimli bir tam sayı dizisi tanımlanmış ve bu dizi 'sayilar.bin' isimli binary dosyasına yazılmıştır. Dosya yazma modunda açıldığında, 'fwrite' fonksiyonu kullanılarak dizinin elemanları dosyaya aktarılmaktadır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:24.059600"
  },
  {
    "question": "Bir binary dosyadan veri okuma işlemi nasıl yapılır ve bu işlem sırasında nelere dikkat etmeliyiz?",
    "answer": "Binary dosyadan veri okuma, dosya sisteminden ikili verileri okumak için kullanılır. Örneğin, bir resim dosyasını okumak istiyorsak, aşağıdaki adımları izleyebiliriz:\n\n1. Dosyayı açma: `fopen` fonksiyonunu kullanarak dosyayı 'rb' modunda açmalıyız. Bu, dosyanın binary modda açılmasını sağlar.\n\n   ```c\n   FILE *file = fopen(\"resim.bin\", \"rb\");\n   if (file == NULL) {\n       perror(\"Dosya açılamadı\");\n       return 1;\n   }\n   ```\n\n2. Veriyi okuma: `fread` fonksiyonu ile dosyadan veri okuyabiliriz. Okuyacağımız veri miktarını ve bunun için gereken bellek alanını belirtmeliyiz.\n\n   ```c\n   unsigned char buffer[1024]; // 1024 byte'lık bir buffer tanımlıyoruz.\n   size_t bytesRead = fread(buffer, sizeof(unsigned char), sizeof(buffer), file);\n   if (bytesRead != sizeof(buffer)) {\n       if (feof(file)) {\n           printf(\"Dosya sonuna ulaşıldı.\");\n       } else {\n           perror(\"Okuma hatası\");\n       }\n   }\n   ```\n\n3. Dosyayı kapatma: İşlemlerimiz tamamlandıktan sonra dosyayı kapatmayı unutmamalıyız.\n   ```c\n   fclose(file);\n   ```\n\nDikkat edilmesi gereken husus, dosyayı açarken doğru modda açmak ve okunan verinin boyutunu kontrol ederek okuma işleminin başarıyla gerçekleşip gerçekleşmediğini kontrol etmektir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:41.985130"
  },
  {
    "question": "Bir binary dosyaya veri yazma işlemi nasıl gerçekleştirilir ve bu süreçte hangi hatalara karşı önlem alabiliriz?",
    "answer": "Binary dosyaya veri yazma işlemi, veri kaydetmek için kullanılır. Örneğin, bir yapı dosyası oluşturup bu yapıyı bir binary dosyaya yazmak için aşağıdaki adımları izleyebiliriz:\n\n1. Yazma amacıyla dosyayı açma: `fopen` fonksiyonunu 'wb' modunda kullanarak dosyayı açmalıyız. Bu mod, dosyanın yazma için açılmasını sağlar.\n\n   ```c\n   FILE *file = fopen(\"veriler.bin\", \"wb\");\n   if (file == NULL) {\n       perror(\"Dosya açılamadı\");\n       return 1;\n   }\n   ```\n\n2. Veri yazma: `fwrite` fonksiyonu ile bir yapıyı dosyaya yazabiliriz. Yazmak istediğimiz veri ve boyutları belirtmeliyiz.\n\n   ```c\n   struct Ogrenci {\n       char isim[50];\n       int numara;\n   } ogrenci;\n   strcpy(ogrenci.isim, \"Ali\");\n   ogrenci.numara = 123;\n   size_t yazilan = fwrite(&ogrenci, sizeof(struct Ogrenci), 1, file);\n   if (yazilan != 1) {\n       perror(\"Yazma hatası\");\n   }\n   ```\n\n3. Dosyayı kapatma: Veri yazma işlemi tamamlandıktan sonra dosyayı kapatmalıyız.\n   ```c\n   fclose(file);\n   ```\n\nYazma işlemi sırasında dikkat edilmesi gereken noktalar; dosyanın uygun modda açıldığından emin olmak, `fwrite` fonksiyonu ile gerçekten istenen veri miktarının yazılıp yazılmadığını kontrol etmek ve bellek yönetimine dikkat etmektir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:41.985178"
  },
  {
    "question": "Binary dosyası kullanarak bir resim dosyasında piksel verilerini nasıl okuyabiliriz?",
    "answer": "Binary dosya işlemleri ile resim dosyalarındaki piksel verilerini okumak için, öncelikle dosyayı ikili modda açmamız gerekiyor. Örneğin, bir BMP dosyası ele alalım. Aşağıdaki adımları takip edebiliriz:\n\n1. Dosyayı ikili modda açın:\n   ```c\n   FILE *file = fopen(\"resim.bmp\", \"rb\");\n   if (file == NULL) {\n       perror(\"Dosya açılamadı\");\n       return 1;\n   }\n   ```\n\n2. BMP dosyasının başlık bilgilerini okuyun:\n   ```c\n   unsigned char header[54]; // BMP dosyası için header boyutu 54 bayttır\n   fread(header, sizeof(unsigned char), 54, file); // Header'ı oku\n   ```\n\n3. Resmin genişliği ve yüksekliği gibi bilgileri header'dan çıkarın:\n   ```c\n   int width = *(int*)&header[18];\n   int height = *(int*)&header[22];\n   ```\n\n4. Piksel verilerini okuyun:\n   ```c\n   int size = 3 * width * height; // RGB için her piksel 3 byte\n   unsigned char *data = (unsigned char *)malloc(size);\n   fread(data, sizeof(unsigned char), size, file); // Piksel verilerini oku\n   ```\n\n5. Dosyayı kapatın ve bellek alanını serbest bırakın:\n   ```c\n   fclose(file);\n   free(data);\n   ```\n\nBu adımları takip ederek, bir BMP dosyasındaki piksel verilerini başarıyla okuyabilirsiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:56.598330"
  },
  {
    "question": "C dilinde bir ikili dosyaya yapı (struct) verisi nasıl yazılabilir ve okunabilir?",
    "answer": "Bir yapı (struct) verisini ikili dosyaya yazmak ve okumak, veri bütünlüğünü korumanız ve veri yapılarınızı disk üzerinde saklamanız için önemlidir. Aşağıdaki adımları izleyerek bir örnek yapıyı ikili dosyaya yazıp okuyabilirsiniz:\n\n1. Öncelikle, bir yapı tanımlayın:\n   ```c\n   typedef struct {\n       int id;\n       char name[50];\n       float score;\n   } Student;\n   ```\n\n2. Yapıyı bir dosyaya yazmak için, dosyayı ikili modda açın:\n   ```c\n   FILE *file = fopen(\"students.dat\", \"wb\");\n   if (file == NULL) {\n       perror(\"Dosya açılamadı\");\n       return 1;\n   }\n   ```\n\n3. Yapı verisini dosyaya yazın:\n   ```c\n   Student student;\n   student.id = 1;\n   strcpy(student.name, \"Ali\");\n   student.score = 85.5;\n   fwrite(&student, sizeof(Student), 1, file); // Yapıyı dosyaya yaz\n   ```\n\n4. Dosyayı kapatın:\n   ```c\n   fclose(file);\n   ```\n\n5. Veriyi okumak için dosyayı tekrar açın ve veriyi okuyun:\n   ```c\n   file = fopen(\"students.dat\", \"rb\");\n   if (file == NULL) {\n       perror(\"Dosya açılamadı\");\n       return 1;\n   }\n   fread(&student, sizeof(Student), 1, file); // Yapıyı dosyadan oku\n   printf(\"ID: %d, Name: %s, Score: %.2f\\n\", student.id, student.name, student.score);\n   fclose(file);\n   ```\n\nBu adımları takip ederek, bir ikili dosyaya yapı verisi yazabilir ve okuyabilirsiniz. Dikkat edilmesi gereken önemli bir nokta, yapıların bellekteki hizalanma (alignment) durumlarıdır; bu, dosya uyumluluğu bakımından önemli olabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:44:56.598371"
  },
  {
    "question": "Bir binary dosyasına basit bir yapı yazmak için nasıl bir C programı yazabilirim?",
    "answer": "Aşağıda bir yapıyı binary dosyasına yazmayı ve o dosyadan okumayı gösteren basit bir C programı bulunmaktadır. Bu program bir `Kisi` yapısını kullanarak, ad, yaş ve boy bilgilerini binary formatta dosyaya kaydediyor.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char ad[50];\n    int yas;\n    float boy;\n} Kisi;\n\nint main() {\n    Kisi kisi;\n    FILE *dosya;\n\n    // Kullanıcıdan bilgi al\n    printf(\"Ad: \");\n    scanf(\"%49s\", kisi.ad);\n    printf(\"Yaş: \");\n    scanf(\"%d\", &kisi.yas);\n    printf(\"Boy: \");\n    scanf(\"%f\", &kisi.boy);\n\n    // Binary dosyaya yazma\n    dosya = fopen(\"kisi.dat\", \"wb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fwrite(&kisi, sizeof(Kisi), 1, dosya);\n    fclose(dosya);\n\n    // Bilgiyi okuma\n    Kisi okunanKisi;\n    dosya = fopen(\"kisi.dat\", \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fread(&okunanKisi, sizeof(Kisi), 1, dosya);\n    fclose(dosya);\n\n    // Okunan bilgileri ekrana yazma\n    printf(\"Okunan Ad: %s\\n\", okunanKisi.ad);\n    printf(\"Okunan Yaş: %d\\n\", okunanKisi.yas);\n    printf(\"Okunan Boy: %.2f\\n\", okunanKisi.boy);\n\n    return 0;\n}\n```\n\nBu program, önce kullanıcıdan ad, yaş ve boy bilgilerini alır, ardından bu bilgileri binary dosyaya yazdırır. Daha sonra aynı bilgileri dosyadan okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:13.895784"
  },
  {
    "question": "Bir binary dosyasındaki verileri güncelleyip dosyaya yeniden yazmak için nasıl bir C programı yazabilirim?",
    "answer": "Aşağıda bir binary dosyasındaki mevcut bir yapıyı güncelleyip dosyaya yeniden yazmayı gösteren basit bir C programı bulunmaktadır. Bu program, `Kisi` yapısını kullanarak, dosyada kaydedilmiş olan bir kişinin yaşını güncelliyor.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char ad[50];\n    int yas;\n    float boy;\n} Kisi;\n\nint main() {\n    Kisi kisi;\n    FILE *dosya;\n    int yeniYas;\n\n    // İlk olarak dosyadan okuma yapalım\n    dosya = fopen(\"kisi.dat\", \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fread(&kisi, sizeof(Kisi), 1, dosya);\n    fclose(dosya);\n\n    // Okunan bilgileri ekrana yazma\n    printf(\"Okunan Ad: %s\\n\", kisi.ad);\n    printf(\"Okunan Yaş: %d\\n\", kisi.yas);\n    printf(\"Okunan Boy: %.2f\\n\", kisi.boy);\n\n    // Kullanıcıdan yeni yaşı al\n    printf(\"Yeni Yaş: \");\n    scanf(\"%d\", &yeniYas);\n    kisi.yas = yeniYas; // Yaşı güncelle\n\n    // Güncellenmiş veriyi tekrar binary dosyaya yazma\n    dosya = fopen(\"kisi.dat\", \"wb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fwrite(&kisi, sizeof(Kisi), 1, dosya);\n    fclose(dosya);\n\n    printf(\"Veri güncellendi!\\n\");\n    return 0;\n}\n```\n\nBu program, önce binary dosyadan mevcut `Kisi` bilgisini okur, ardından kullanıcıdan yeni yaşı alır ve bu bilgiyi güncelleyerek dosyaya yazar. Bu şekilde, kullanıcı bilgileri kolaylıkla güncellenebilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:13.895829"
  },
  {
    "question": "Bir binary dosyasına bir dizi tam sayıyı yazan ve ardından bu dosyadan okuyan bir C programı nasıl yazılır?",
    "answer": "Aşağıda, bir binary dosyasına tam sayı dizisi yazan ve bu diziyi daha sonra okuyan bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid yaz(int *dizi, int boyut) {\n    FILE *dosya = fopen(\"sayilar.bin\", \"wb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n    fwrite(dizi, sizeof(int), boyut, dosya);\n    fclose(dosya);\n}\n\nvoid oku(int *dizi, int boyut) {\n    FILE *dosya = fopen(\"sayilar.bin\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n    fread(dizi, sizeof(int), boyut, dosya);\n    fclose(dosya);\n}\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    yaz(dizi, 5);\n    int okunan[5];\n    oku(okunan, 5);\n\n    printf(\"Okunan sayılar: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", okunan[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\nBu programda, `yaz` fonksiyonu verilen diziyi `sayilar.bin` adlı bir binary dosyasına yazmaktadır. `oku` fonksiyonu ise bu dosyadan verileri okuyarak başka bir diziye yerleştirir. Programın sonunda, okunan sayılar ekrana yazdırılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:30.865338"
  },
  {
    "question": "Bir binary dosyasındaki belirli bir tam sayıyı güncellemek için nasıl bir C programı yazabilirim?",
    "answer": "Aşağıda, bir binary dosyasındaki belirli bir tam sayıyı güncelleyip dosyayı güncelleyen bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid guncelle(int yeni_sayi, int index) {\n    FILE *dosya = fopen(\"sayilar.bin\", \"r+b\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n    fseek(dosya, index * sizeof(int), SEEK_SET);\n    fwrite(&yeni_sayi, sizeof(int), 1, dosya);\n    fclose(dosya);\n}\n\nvoid oku() {\n    FILE *dosya = fopen(\"sayilar.bin\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n    int sayi;\n    while (fread(&sayi, sizeof(int), 1, dosya)) {\n        printf(\"%d \", sayi);\n    }\n    fclose(dosya);\n}\n\nint main() {\n    // Başlangıçta sayılar yazılıyor\n    int dizi[5] = {10, 20, 30, 40, 50};\n    FILE *dosya = fopen(\"sayilar.bin\", \"wb\");\n    fwrite(dizi, sizeof(int), 5, dosya);\n    fclose(dosya);\n\n    // 2. indeksteki sayıyı güncelle...\n    guncelle(99, 2);\n\n    // Güncellenmiş dosyayı oku\n    printf(\"Güncellenmiş sayılar: \");\n    oku();\n    printf(\"\\n\");\n    return 0;\n}\n```\n\nBu programda, `guncelle` fonksiyonu, verilen indeksteki sayıyı `yeni_sayi` ile günceller. `oku` fonksiyonu ise dosyadaki tüm sayıları ekrana yazdırır. Başlangıçta `sayilar.bin` dosyasına bazı sayılar yazılır ve ardından 2. indekste bulunan sayı 99 ile güncellenir. Sonuç olarak, güncellenmiş dizinin çıktısı ekrana yazdırılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:30.865466"
  },
  {
    "question": "Bir binary dosyasında resim verilerini saklamak için bir yapı tanımlayın ve bu yapıyı kullanarak dosyaya veri yazma ve dosyadan veri okuma işlemlerini gerçekleştirin.",
    "answer": "Aşağıda, bir resim dosyasının saklanması için kullanılacak bir yapı ve bu yapıyı kullanarak binary dosyaya veri yazma ve okuma işlemlerinin nasıl yapılacağını gösteren bir C kodu bulunmaktadır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Resim verilerini saklamak için yapı tanımı\ntypedef struct {\n    int width;\n    int height;\n    unsigned char *data; // Resim verisi\n} Image;\n\n// Resim dosyasına veri yazma fonksiyonu\nvoid write_image_to_file(const char *filename, Image *img) {\n    FILE *file = fopen(filename, \"wb\"); // Binary olarak açma\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    // Resim boyutunu yaz\n    fwrite(&img->width, sizeof(int), 1, file);\n    fwrite(&img->height, sizeof(int), 1, file);\n    // Resim verisini yaz\n    fwrite(img->data, sizeof(unsigned char), img->width * img->height, file);\n\n    fclose(file);\n}\n\n// Resim dosyasından veri okuma fonksiyonu\nImage read_image_from_file(const char *filename) {\n    Image img;\n    FILE *file = fopen(filename, \"rb\"); // Binary olarak açma\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        img.data = NULL;\n        return img;\n    }\n\n    // Resim boyutunu oku\n    fread(&img.width, sizeof(int), 1, file);\n    fread(&img.height, sizeof(int), 1, file);\n    // Bellekte yer aç\n    img.data = (unsigned char *)malloc(img.width * img.height);\n    // Resim verisini oku\n    fread(img.data, sizeof(unsigned char), img.width * img.height, file);\n\n    fclose(file);\n    return img;\n}\n\nint main() {\n    // Örnek kullanım\n    Image img;\n    img.width = 100;\n    img.height = 100;\n    img.data = (unsigned char *)malloc(img.width * img.height);\n    // Örnek olarak veriyi doldur\n    for (int i = 0; i < img.width * img.height; i++) {\n        img.data[i] = (unsigned char)(i % 256);\n    }\n\n    write_image_to_file(\"image.bin\", &img);\n    Image new_image = read_image_from_file(\"image.bin\");\n    // Okunan resim verisi kullanılarak işlemler yapılabilir\n    free(img.data);\n    free(new_image.data);\n    return 0;\n}\n``` \nBu kod, bir görüntü verisini binary dosyaya yazıp okuma işlemlerini gerçekleştirmektedir. Yapı tanımı ve dosya işlemleri detaylı bir şekilde ele alınmıştır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:54.773080"
  },
  {
    "question": "Bir binary dosyasında depolanan tam sayı dizisini ters çeviren bir C programı yazın. Dosyaya yazma ve okuma işlemleri ile birlikte dizinin boyutunu da saklayın.",
    "answer": "Aşağıda, tam sayı dizisini binary dosyasında saklayıp geri okuyarak ters çeviren bir C kodu örneği verilmiştir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Tam sayı dizisini saklayacak yapı\ntypedef struct {\n    int size;\n    int *data;\n} IntArray;\n\n// Diziyi dosyaya yazma fonksiyonu\nvoid write_array_to_file(const char *filename, IntArray *arr) {\n    FILE *file = fopen(filename, \"wb\"); // Binary olarak açma\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    // Dizinin boyutunu yaz\n    fwrite(&arr->size, sizeof(int), 1, file);\n    // Dizinin verisini yaz\n    fwrite(arr->data, sizeof(int), arr->size, file);\n\n    fclose(file);\n}\n\n// Diziyi dosyadan okuma fonksiyonu\nIntArray read_array_from_file(const char *filename) {\n    IntArray arr;\n    FILE *file = fopen(filename, \"rb\"); // Binary olarak açma\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        arr.data = NULL;\n        return arr;\n    }\n\n    // Dizinin boyutunu oku\n    fread(&arr.size, sizeof(int), 1, file);\n    // Bellekte yer aç\n    arr.data = (int *)malloc(arr.size * sizeof(int));\n    // Dizinin verisini oku\n    fread(arr.data, sizeof(int), arr.size, file);\n\n    fclose(file);\n    return arr;\n}\n\n// Diziyi ters çeviren fonksiyon\nvoid reverse_array(IntArray *arr) {\n    for (int i = 0; i < arr->size / 2; i++) {\n        int temp = arr->data[i];\n        arr->data[i] = arr->data[arr->size - 1 - i];\n        arr->data[arr->size - 1 - i] = temp;\n    }\n}\n\nint main() {\n    // Örnek kullanım\n    IntArray arr;\n    arr.size = 5;\n    arr.data = (int *)malloc(arr.size * sizeof(int));\n    // Dizi verisini doldur\n    for (int i = 0; i < arr.size; i++) {\n        arr.data[i] = i + 1; // 1, 2, 3, 4, 5\n    }\n\n    write_array_to_file(\"array.bin\", &arr);\n    IntArray new_array = read_array_from_file(\"array.bin\");\n    reverse_array(&new_array); // Okunan diziyi ters çevir\n    // new_array.data artık 5, 4, 3, 2, 1 olarak saklanır\n\n    free(arr.data);\n    free(new_array.data);\n    return 0;\n}\n``` \nBu kod, bir tam sayı dizisini binary dosyada saklamakta ve dosyadan okunan diziyi tersine çevirmekte. Bu örnek, veri işleme ve dosya işlemlerinin nasıl bir arada kullanılabileceğini göstermektedir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:45:54.773139"
  },
  {
    "question": "Bir binary dosyasını okuyup içeriğini bir struct yapısına yazan bir fonksiyonda, bellek yönetimi açısından nelere dikkat etmeliyiz? Örnek bir kod verin.",
    "answer": "Binary dosyası okuma işlemi yaparken, bellek yönetiminin doğru yapılması çok önemlidir. Aşağıdaki örnekte, 'data.bin' adlı bir binary dosyasından verileri okuyan bir fonksiyon bulunmakta. Struct yapısını kullanarak okunacak verilerin tanımını yapıyoruz ve bellekte doğru yerleştirmeye dikkat ediyoruz. Ayrıca, dosya açma, okuma ve kapatma işlemlerini de güvenli bir şekilde yönetiyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} Data;\n\nData* readBinaryFile(const char* filename, size_t* count) {\n    FILE* file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return NULL;\n    }\n\n    fseek(file, 0, SEEK_END);\n    size_t filesize = ftell(file);\n    rewind(file);\n\n    *count = filesize / sizeof(Data);\n    Data* data = (Data*)malloc(filesize);\n    if (!data) {\n        fclose(file);\n        perror(\"Bellek tahsisi başarısız\");\n        return NULL;\n    }\n\n    size_t readCount = fread(data, sizeof(Data), *count, file);\n    if (readCount != *count) {\n        free(data);\n        fclose(file);\n        perror(\"Veri okuma hatası\");\n        return NULL;\n    }\n\n    fclose(file);\n    return data;\n}\n```\n\nBu örnekte dikkat edilmesi gereken noktalar: dosyanın doğru bir şekilde açılması, okunan verilerin yapı ile uyumlu olup olmadığının kontrol edilmesi ve sonunda belleğin doğru bir şekilde serbest bırakılması. Ayrıca, okuma hataları için gerekli önlemleri almak, programın kararlılığını artırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:46:10.735174"
  },
  {
    "question": "Binary dosyalarına veri yazarken, veri kaybını önlemek için hangi yöntemleri kullanabiliriz? Örnek bir kod ile açıklayınız.",
    "answer": "Binary dosyalarına veri yazarken kaybı önlemek için, öncelikle dosya açma modunu 'wb' (yazma - binary) olarak belirlemeliyiz ki, dosya her seferinde temizlensin. Ayrıca, yazma işlemi sırasında hata kontrolü yapmak ve verilerin doğru bir şekilde yazıldığından emin olmak da önemlidir. Aşağıdaki örnek, 'output.bin' adlı bir binary dosyasına verileri yazan bir fonksiyonu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} Data;\n\nvoid writeBinaryFile(const char* filename, Data* data, size_t count) {\n    FILE* file = fopen(filename, \"wb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    size_t writtenCount = fwrite(data, sizeof(Data), count, file);\n    if (writtenCount != count) {\n        perror(\"Veri yazma hatası\");\n    }\n\n    fclose(file);\n}\n```\n\nBu örnekte, dosyanın yazma modunda açılması ve fwrite işlevinden dönen sonuç ile yazma işleminin başarılı olup olmadığının kontrol edilmesi önemlidir. Ayrıca, eğer yazma sırasında bir hata olursa, kullanıcıya bilgi vermek için perror kullanıyoruz. Bu, veri kaybını önleyecek ve uygulamanın güvenilirliğini artıracaktır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:46:10.735253"
  },
  {
    "question": "Bir binary dosyayı okumak için kullanılan kodda, bellek yönetimini iyileştirmek ve performansı artırmak için ne tür optimizasyonlar yapılabilir?",
    "answer": "Binary dosyayı okumak için kullanılan aşağıdaki kodu ele alalım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid readBinaryFile(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long filesize = ftell(file);\n    rewind(file);\n\n    char *buffer = (char *)malloc(filesize);\n    if (!buffer) {\n        perror(\"Bellek tahsis edilemedi\");\n        fclose(file);\n        return;\n    }\n\n    fread(buffer, 1, filesize, file);\n    // İşlem yapılacak kısım\n\n    free(buffer);\n    fclose(file);\n}\n```\n\nBu kodda birkaç iyileştirme yapılabilir:\n1. **Bellek Tahsisi:** `malloc` yerine `calloc` kullanarak, alanı sıfırlarla başlatabiliriz. Bu, bellek hatalarını önleyebilir.\n2. **Bütün Veri Okuma:** `fread` fonksiyonunun dönüş değerini kontrol ederek okuma hatalarını tespit edebiliriz.\n3. **Dosya Kapatma:** `fclose` çağrısını `free` öncesine alarak, program bir hata ile karşılaşsa bile dosyanın kapatılmasını sağlayabiliriz.\n\nİyileştirilmiş kod:\n```c\nvoid readBinaryFile(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long filesize = ftell(file);\n    rewind(file);\n\n    char *buffer = (char *)calloc(filesize, sizeof(char));\n    if (!buffer) {\n        perror(\"Bellek tahsis edilemedi\");\n        fclose(file);\n        return;\n    }\n\n    size_t bytesRead = fread(buffer, 1, filesize, file);\n    if (bytesRead != filesize) {\n        perror(\"Dosyadan okuma hatası\");\n    }\n\n    fclose(file);\n    free(buffer);\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:46:26.479514"
  },
  {
    "question": "Binary dosyaya veri yazma işlemi sırasında, veri bütünlüğünü sağlamak için ne tür önlemler alabiliriz?",
    "answer": "Aşağıdaki kod örneği, bir binary dosyaya veri yazmayı göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid writeBinaryFile(const char *filename, const char *data, size_t dataSize) {\n    FILE *file = fopen(filename, \"wb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fwrite(data, sizeof(char), dataSize, file);\n    fclose(file);\n}\n```\n\nBu kodda veri bütünlüğünü sağlamak için birkaç önlem alabiliriz:\n1. **Dönüş Değerlerini Kontrol Etmek:** `fwrite` fonksiyonunun geri dönüş değerini kontrol ederek, yazma işleminin başarılı olup olmadığını kontrol edebiliriz.\n2. **Geçici Dosya Kullanımı:** Veriyi önce geçici bir dosyaya yazıp, başarılı bir şekilde yazıldıysa ana dosyaya kopyalayarak veri kaybını önleyebiliriz.\n3. **Hata Kontrolü ve Loglama:** Hata durumunda log tutarak, sorunların izlenmesini sağlayabiliriz.\n\nİyileştirilmiş kod:\n```c\nvoid writeBinaryFile(const char *filename, const char *data, size_t dataSize) {\n    char tempFilename[] = \"tempfile.bin\";\n    FILE *tempFile = fopen(tempFilename, \"wb\");\n    if (!tempFile) {\n        perror(\"Geçici dosya açılamadı\");\n        return;\n    }\n\n    size_t bytesWritten = fwrite(data, sizeof(char), dataSize, tempFile);\n    if (bytesWritten != dataSize) {\n        perror(\"Yazma hatası\");\n        fclose(tempFile);\n        return;\n    }\n    fclose(tempFile);\n\n    // Ana dosyayı güncelle\n    if (remove(filename) == 0 && rename(tempFilename, filename) != 0) {\n        perror(\"Dosya yeniden adlandırılamadı\");\n    }\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-05-31T17:46:26.479584"
  },
  {
    "question": "Kullanıcının girdiği bir cümleyi bir metin dosyasına yazan C programının eksik kodunu tamamla: #include <stdio.h> int main() {     char cumle[100];     printf(\"Bir cümle girin: \");     gets(cumle);     FILE *dosya = fopen(\"cümle.txt\", \"w\");     /* Eksik kod buraya gelecek */     fclose(dosya);     return 0; }",
    "answer": "Eksik kod kısmını tamamlamak için, kullanıcının girdiği cümleyi dosyaya yazmamız gerekiyor. Bunun için fwrite veya fprintf fonksiyonunu kullanabiliriz. İşte tamamlanmış kod: \n\n```c\n#include <stdio.h>\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    gets(cumle);\n    FILE *dosya = fopen(\"cumle.txt\", \"w\");\n    fprintf(dosya, \"%s\", cumle); // Cümleyi dosyaya yaz\n    fclose(dosya);\n    return 0;\n}\n``` \n\nBu kod, kullanıcıdan bir cümle alır ve bunu 'cumle.txt' adında bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:46:37.304853"
  },
  {
    "question": "Bir metin dosyasından satırları okuyan ve ekrana yazdıran C programının eksik kodunu tamamla: #include <stdio.h> int main() {     char satir[256];     FILE *dosya = fopen(\"metin.txt\", \"r\");     /* Eksik kod buraya gelecek */     fclose(dosya);     return 0; }",
    "answer": "Eksik kod kısmını tamamlamak için, dosyadan satırları okumamız ve ekrana yazdırmamız gerekiyor. Bunun için fgets fonksiyonunu kullanabiliriz. İşte tamamlanmış kod: \n\n```c\n#include <stdio.h>\nint main() {\n    char satir[256];\n    FILE *dosya = fopen(\"metin.txt\", \"r\");\n    while (fgets(satir, sizeof(satir), dosya)) { // Satırları okur\n        printf(\"%s\", satir); // Okunan satırı ekrana yazdırır\n    }\n    fclose(dosya);\n    return 0;\n}\n``` \n\nBu kod, 'metin.txt' dosyasındaki her bir satırı okuyarak ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:46:37.304940"
  },
  {
    "question": "Kullanıcının bir metin dosyasını okuyup, içinde geçen kelimelerin sayısını hesaplayan bir C programı yaz. Dosya adı kullanıcıdan alınsın. Hesaplanan kelime sayısını ekrana yazdır.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char dosya_adi[100];\n    FILE *dosya;\n    char kelime[100];\n    int kelime_sayisi = 0;\n\n    printf(\"Metin dosyasının adını girin: \");\n    scanf(\"%s\", dosya_adi);\n\n    dosya = fopen(dosya_adi, \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fscanf(dosya, \"%s\", kelime) != EOF) {\n        kelime_sayisi++;\n    }\n\n    fclose(dosya);\n    printf(\"Dosyada toplam %d kelime bulunmaktadır.\\n\", kelime_sayisi);\n    return 0;\n}\n\n//Bu program, kullanıcıdan bir dosya adı alır, dosyayı okur ve içindeki kelime sayısını hesaplar. fgets yerine fscanf kullanarak kelimeleri okuyoruz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:46:55.643136"
  },
  {
    "question": "Kullanıcının verdiği bir metin dosyasını okuyup, her bir satırı ters çevirerek yeni bir dosyaya yazacak bir C programı oluştur. Girdinin dosya adı ve çıktının dosya adı kullanıcıdan alınsın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid ters_cevir(char *satir) {\n    int uzunluk = strlen(satir);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = satir[i];\n        satir[i] = satir[uzunluk - i - 1];\n        satir[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char girdi_dosya[100], cikti_dosya[100];\n    FILE *girdi, *cikti;\n    char satir[256];\n\n    printf(\"Girdi dosyasının adını girin: \");\n    scanf(\"%s\", girdi_dosya);\n    printf(\"Çıktı dosyasının adını girin: \");\n    scanf(\"%s\", cikti_dosya);\n\n    girdi = fopen(girdi_dosya, \"r\");\n    if (girdi == NULL) {\n        printf(\"Girdi dosyası açılamadı!\\n\");\n        return 1;\n    }\n\n    cikti = fopen(cikti_dosya, \"w\");\n    if (cikti == NULL) {\n        printf(\"Çıktı dosyası oluşturulamadı!\\n\");\n        fclose(girdi);\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), girdi)) {\n        ters_cevir(satir);\n        fprintf(cikti, \"%s\", satir);\n    }\n\n    fclose(girdi);\n    fclose(cikti);\n    printf(\"Başarıyla yazıldı.\\n\");\n    return 0;\n}\n\n//Bu program, kullanıcıdan bir girdi dosyası alır, her satırı okur ve ters çevirerek yeni bir dosyaya yazar. Ters çevirme işlemi için ayrı bir fonksiyon kullanılmıştır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:46:55.643204"
  },
  {
    "question": "Bir metin dosyasındaki tüm kelimeleri sayan bir C programı yazın. Ancak, programın sadece büyük harfle başlayan kelimeleri saymasını istiyorum. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int count = 0;\n    int inWord = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        // Eğer karakter bir boşluk veya yeni satır değilse\n        if (isalpha(ch)) {\n            // Eğer kelimeye yeni başladıysak ve karakter büyük harfse say\n            if (!inWord && isupper(ch)) {\n                count++;\n            }\n            inWord = 1; // Kelimedeyiz\n        } else {\n            inWord = 0; // Kelime sona erdi\n        }\n    }\n\n    fclose(file);\n    printf(\"Büyük harfle başlayan kelime sayısı: %d\\n\", count);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:10.456122"
  },
  {
    "question": "Bir metin dosyasındaki cümleleri ters sırada yazan bir C programı yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SENTENCES 100\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file;\n    char sentences[MAX_SENTENCES][MAX_LENGTH];\n    int count = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    // Cümleleri oku\n    while (fgets(sentences[count], MAX_LENGTH, file) != NULL && count < MAX_SENTENCES) {\n        count++;\n    }\n\n    fclose(file);\n\n    // Cümleleri ters sırada yaz\n    for (int i = count - 1; i >= 0; i--) {\n        printf(\"%s\", sentences[i]);\n    }\n\n    return 0;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:10.456178"
  },
  {
    "question": "Bir metin dosyasını okuma işlemi yaparken dosya açılmadığında programım hata veriyor. Neden böyle oluyor?",
    "answer": "Dosyayı açma işlemi sırasında, dosya var mı yok mu kontrol edilmediği için hata alıyorsunuz. Dosya açma işlemi için kullanılan 'fopen' fonksiyonu, dosya açılamadığında NULL döner. Bu durumu kontrol etmek için dosyayı açmadan önce bir kontrol eklemelisiniz. Örnek bir düzeltme şöyle olabilir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyayı işleme kodları buraya gelecek\n\n    fclose(file);\n    return 0;\n}\n```\nBu kodda, 'fopen' işlemi sonrası dosyanın başarıyla açılıp açılmadığını kontrol ederek, hata durumunda kullanıcıya daha anlamlı bir hata mesajı gösteriyoruz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:21.518686"
  },
  {
    "question": "Bir metin dosyasına yazma işlemi yaparken veri kaybı yaşıyorum. Neden bu sorunla karşılaşıyorum?",
    "answer": "Veri kaybı genellikle dosyayı açma moduyla ilgilidir. Eğer dosyayı 'w' (yazma) modunda açarsanız, dosya açıldığında içeriği silinir ve yeni veri yazılır. Eğer mevcut verinin üzerine yazmak istemiyorsanız 'a' (ekleme) modunu kullanmalısınız. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"a\"); // 'a' modu kullanıldı\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fprintf(file, \"Yeni veri ekleniyor.\\n\");\n    fclose(file);\n    return 0;\n}\n```\nBu kodda, dosya 'a' modunda açıldığı için mevcut verinin üzerine yazılmadan yeni veri eklenmiş olacak. Bu sayede veri kaybı yaşamazsınız.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:21.518757"
  },
  {
    "question": "Bir metin dosyasını okuyup içeriğini ekrana yazdıran bir C programım var. Ancak program çalıştığında hiçbir şey yazdırmıyor. Hata nedenini nasıl bulabilirim?",
    "answer": "Bu durumda, muhtemel sorun dosyanın açılmaması ya da okunamamasıdır. Öncelikle, dosyanın programın çalıştığı dizinde bulunduğundan emin olun. Aşağıdaki gibi bir kontrol ekleyerek dosyanın açılıp açılmadığını kontrol edebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n    fclose(file);\n    return 0;\n}\n```\n\n`perror()` fonksiyonu, dosya açılamıyorsa hata mesajı verecektir. Ayrıca, dosyanın doğru dizinde olup olmadığını kontrol edin ve dosya izinlerini gözden geçirin.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:37.851732"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları okuduktan sonra, satırların sayısını ve her satırın uzunluğunu ekrana yazdıran bir C programım var ama toplam satır sayısını yanlış hesaplıyor. Hata nerede olabilir?",
    "answer": "Bu tip durumlarda, satır sayısını artırmak için kullandığınız mantıkta bir hata olabilir. Örneğin, eğer sadece son satırın sonunda yeni bir satır bulunmuyorsa, son satırı saymayı atlayabilirsiniz. Aşağıdaki örnekte, satır sayısını doğru bir şekilde hesaplamak için `fgets()` kullanarak her satırı okuyup satır sayısını artırıyoruz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char line[256];\n    int lineCount = 0;\n    while (fgets(line, sizeof(line), file) != NULL) {\n        lineCount++;\n        printf(\"Satır %d: %lu karakter uzunluğunda\\n\", lineCount, strlen(line) - 1); // -1 for '\n'\n    }\n    printf(\"Toplam satır sayısı: %d\\n\", lineCount);\n    fclose(file);\n    return 0;\n}\n```\n\nBurada `fgets()` kullanarak her satırı okuyup, `strlen()` ile satır uzunluğunu hesaplıyoruz. `strlen(line) - 1` kullanarak sonundaki yeni satır karakterini çıkartıyoruz. Bu şekilde doğru satır sayısını elde etmiş olursunuz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:47:37.851799"
  },
  {
    "question": "Bir metin dosyasını okuyup içindeki kelimeleri sayan bir program yazdım ama kelime sayısı yanlış çıkıyor. Aşağıdaki kodda hata nedir ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int count = 0;\n    int inWord = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (isalpha(ch)) {\n            if (!inWord) {\n                inWord = 1;\n                count++;\n            }\n        } else {\n            inWord = 0;\n        }\n    }\n\n    fclose(file);\n    printf(\"Kelime sayısı: %d\\n\", count);\n    return 0;\n}\n```",
    "answer": "Hatanın kaynağı, kelimeyi belirlemek için kullanılan koşuldur. Şu anda sadece harfleri kontrol edip kelimeleri sayıyor, ancak özel karakterler veya sayılar da kelime olarak sayılabilir. Ayrıca, satır sonu ve boşluk gibi durumlar da kelime sonlarını etkileyebilir. Bu yüzden, kelime sayma algoritmasını, boşluk karakterlerini ve satır sonlarını da dikkate alacak şekilde düzenlemek gerekir. Örneğin, `isspace(ch)` fonksiyonunu kullanarak boşlukları kontrol edebiliriz. Güncellenmiş kod:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int count = 0;\n    int inWord = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (isalpha(ch) || isdigit(ch)) {\n            if (!inWord) {\n                inWord = 1;\n                count++;\n            }\n        } else {\n            inWord = 0;\n        }\n    }\n\n    fclose(file);\n    printf(\"Kelime sayısı: %d\\n\", count);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:00.046240"
  },
  {
    "question": "Bir metin dosyasını satır satır okuyan ve her satırdaki karakter sayısını bulan bir program yazdım ama sonuçlar beklediğim gibi değil. Kodda ne yanlış var ve nasıl düzeltilir?\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        int length = strlen(line);\n        printf(\"Karakter sayısı: %d\\n\", length);\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "answer": "Hatanın nedeni, `fgets` fonksiyonu ile okunan her satırın sonunda bir newline karakteri ('\\n') bırakmasıdır. Bu, `strlen` fonksiyonu ile ölçülen uzunluğa dahil edilir ve sonuçları yanıltır. Satır uzunluğunu doğru bir şekilde hesaplamak için, newline karakterini saymaktan kaçınmalıyız. Bunu yapmak için, `strlen` sonucundan 1 çıkarabiliriz, ancak daha iyi bir yaklaşım, satırın sonundaki newline karakterini kontrol edip onu kaldırmaktır. İşte düzeltilmiş kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        int length = strlen(line);\n        if (line[length - 1] == '\\n') {\n            line[length - 1] = '\\0'; // Yeni satır karakterini kaldır\n            length--;\n        }\n        printf(\"Karakter sayısı: %d\\n\", length);\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:00.046396"
  },
  {
    "question": "Bir metin dosyasını nasıl açıp içeriğini okuyabilirim?",
    "answer": "C dilinde bir metin dosyasını açmak ve içeriğini okumak için öncelikle 'fopen' fonksiyonunu kullanmalıyız. Bu fonksiyon, dosyayı açmak için bir dosya adı ve bir mod (okuma, yazma gibi) alır. Örneğin, 'dosya.txt' adındaki bir dosyayı okumak için şu kodu kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    dosya = fopen(\"dosya.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) { // Dosya açıldı mı kontrol et\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while ((ch = fgetc(dosya)) != EOF) { // Dosyadan karakter okuma\n        printf(\"%c\", ch); // Okunan karakteri ekrana yaz\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, 'dosya.txt' dosyasını açar, içindeki tüm karakterleri okur ve ekrana yazdırır. 'fgetc' fonksiyonu, her seferinde bir karakter okur ve 'EOF' (End Of File) değerine ulaşmadığı sürece döngü devam eder.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:13.856874"
  },
  {
    "question": "Bir metin dosyasına nasıl yazı yazabilirim?",
    "answer": "C dilinde bir metin dosyasına yazı yazmak için yine 'fopen' fonksiyonunu kullanırız, ancak bu sefer dosyayı yazma modunda açmalıyız. Yazma modunda açarken, dosya yoksa yeni bir dosya oluşturulur. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    dosya = fopen(\"yeni_dosya.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (dosya == NULL) { // Dosya açıldı mı kontrol et\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fprintf(dosya, \"Bu yeni bir dosya!\\n\"); // Dosyaya yazı yaz\n    fprintf(dosya, \"Bu dosyaya başka bir satır ekliyoruz.\\n\"); // Başka bir satır yaz\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, 'yeni_dosya.txt' adında bir dosya açar ve içine iki satır yazı yazar. 'fprintf' fonksiyonu, belirtilen dosyaya formatlı bir şekilde yazı yazmamızı sağlar. Dosya kapatılmadan önce yazma işlemi tamamlanır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:13.856920"
  },
  {
    "question": "Bir metin dosyasındaki kelimeleri saymak için C dilinde nasıl bir program yazabilirim?",
    "answer": "Bir metin dosyasındaki kelimeleri saymak için öncelikle dosyayı açmamız gerekiyor. Ardından dosyayı satır satır okuyarak, her satırdaki kelimeleri saymalıyız. Bunun için boşluk karakterlerini kullanarak kelimeleri ayırabiliriz. Aşağıda bu işlemi gerçekleştiren bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int wordCount = 0;\n    int inWord = 0;\n\n    file = fopen(\"metin.txt\", \"r\"); // Dosyayı aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) { // Dosyayı karakter karakter oku\n        if (isspace(ch)) { // Eğer karakter boşluksa\n            inWord = 0; // Kelime dışındayız\n        } else if (inWord == 0) { // Eğer kelimeye giriş yaptıysak\n            inWord = 1; // Kelime içindeyiz\n            wordCount++; // Kelime sayısını artır\n        }\n    }\n\n    fclose(file); // Dosyayı kapat\n    printf(\"Toplam kelime sayısı: %d\\n\", wordCount);\n    return 0;\n}\n```\nBu program, 'metin.txt' dosyasını okuyarak içindeki kelimelerin sayısını ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:30.547871"
  },
  {
    "question": "C dilinde bir metin dosyasına belirli bir formatta veri yazmak için nasıl bir yaklaşım izlemeliyim?",
    "answer": "Metin dosyasına veriyi belirli bir formatta yazmak için dosyayı yazma modunda açmamız gerekiyor. `fprintf` fonksiyonu ile formatlı bir şekilde veri yazabiliriz. Aşağıda, kullanıcıdan alınan verileri 'veri.txt' dosyasına yazan bir örnek program verilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char name[50];\n    int age;\n\n    file = fopen(\"veri.txt\", \"w\"); // Yazma modunda dosyayı aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"İsim girin: \");\n    scanf(\"%49s\", name); // İsim al\n\n    printf(\"Yaş girin: \");\n    scanf(\"%d\", &age); // Yaş al\n\n    fprintf(file, \"İsim: %s, Yaş: %d\\n\", name, age); // Formatlı yaz\n\n    fclose(file); // Dosyayı kapat\n    printf(\"Veri başarıyla yazıldı!\\n\");\n    return 0;\n}\n```\nBu program, kullanıcıdan bir isim ve yaş alarak bu bilgileri 'veri.txt' dosyasına 'İsim: [isim], Yaş: [yaş]' formatında yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:30.547937"
  },
  {
    "question": "C dilinde bir metin dosyasındaki kelimelerin sayısını nasıl bulabilirim?",
    "answer": "Bir metin dosyasındaki kelimeleri saymak için öncelikle dosyayı okumamız gerekmektedir. Ardından, her kelimeyi ayırmak için boşluk karakterlerini kullanabiliriz. İşte adım adım bir yaklaşım:\n\n1. Dosyayı açmak için 'fopen' fonksiyonunu kullanın ve 'r' modunda açın.\n2. Dosyanın içeriğini bir dizi değişkene veya doğrudan okuma işlemi sırasında işleyin.\n3. Bir döngü ile dosyayı satır satır okuyun ve her satırı boşluk karakterlerine göre ayırın.\n4. Her bir kelimeyi saymak için bir sayaç değişkeni kullanın. Boşluk karakterleri dışında her bir kelimeyi bulduğunuzda sayacı bir artırın.\n5. Dosyayı kapatmayı unutmayın.\n\nAşağıda bu işlemi gerçekleştiren bir C kodu örneği bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    int wordCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \\n\");\n        while (token != NULL) {\n            wordCount++;\n            token = strtok(NULL, \" \\n\");\n        }\n    }\n\n    fclose(file);\n    printf(\"Toplam kelime sayısı: %d\\n\", wordCount);\n    return 0;\n}\n```\nBu program, 'metin.txt' dosyasını okuyarak içindeki kelimeleri sayar ve sonucu ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:51.572770"
  },
  {
    "question": "C dilinde bir metin dosyasındaki belirli bir kelimenin kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Belirli bir kelimenin sayısını bulmak için, önce dosyayı okumalı ve ardından her kelimeyi kontrol ederek belirli kelime ile karşılaştırmalısınız. İşte bu süreci adım adım anlatan bir yaklaşım:\n\n1. Dosyayı 'fopen' fonksiyonu ile açın.\n2. Dosyanın içeriğini satır satır okuyun ve her satırı kelimelere ayırın.\n3. Her bir kelimeyi kontrol edin ve eğer kelime aradıgınız kelimeye eşitse, bir sayaç değişkenini artırın.\n4. Dosyayı kapatın ve sonucu ekrana yazdırın.\n\nAşağıda bu işlemi gerçekleştiren bir C kodu örneği bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    char *searchWord = \"example\";  // Aranacak kelime\n    int count = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \\n\");\n        while (token != NULL) {\n            if (strcmp(token, searchWord) == 0) {\n                count++;\n            }\n            token = strtok(NULL, \" \\n\");\n        }\n    }\n\n    fclose(file);\n    printf(\"'%%s' kelimesi %d kez bulundu.\\n\", searchWord, count);\n    return 0;\n}\n```\nBu program, 'metin.txt' dosyasını okuyarak belirli bir kelimenin kaç kez geçtiğini sayar ve sonucu ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:48:51.572815"
  },
  {
    "question": "Bir metin dosyasını okuyarak içeriğini ekrana yazdıran basit bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, bir metin dosyasını okuyarak içeriğini ekrana yazdırır. Bu program, kullanıcıdan dosya adını alır ve dosyayı satır satır okur.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char dosya_adi[100];\n    char satir[256];\n\n    printf(\"Okunacak dosyanın adını girin: \");\n    scanf(\"%s\", dosya_adi);\n\n    dosya = fopen(dosya_adi, \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) { // Satır satır oku\n        printf(\"%s\", satir); // Satırı ekrana yazdır\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu program, `fopen` fonksiyonu ile belirtilen dosyayı açar, `fgets` fonksiyonu ile satırları okur ve okunan her bir satırı ekrana yazdırır. Dosya işlemleri tamamlandıktan sonra `fclose` ile dosya kapatılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:04.800426"
  },
  {
    "question": "Bir metin dosyasına kullanıcıdan alınan verileri yazan basit bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, kullanıcıdan alınan verileri yeni bir metin dosyasına yazar. Program, kullanıcıdan metin girmesini ister ve bu metni dosyaya kaydeder.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char dosya_adi[100];\n    char metin[256];\n\n    printf(\"Yazılacak dosyanın adını girin: \");\n    scanf(\"%s\", dosya_adi);\n\n    dosya = fopen(dosya_adi, \"w\"); // Dosyayı yazma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"Dosyaya yazmak için bir metin girin (çıkmak için 'exit' yazın):\\n\");\n    while (1) {\n        fgets(metin, sizeof(metin), stdin);\n        if (strcmp(metin, \"exit\\n\") == 0) // 'exit' kelimesini kontrol et\n            break;\n        fprintf(dosya, \"%s\", metin); // Metni dosyaya yaz\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu programda, `fopen` ile yeni bir dosya oluşturulur veya mevcut bir dosya varsa üzerine yazılır. Kullanıcı metin girdikçe `fprintf` ile bu metin dosyaya kaydedilir. 'exit' yazıldığında döngüden çıkılır ve dosya kapatılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:04.800487"
  },
  {
    "question": "Bir metin dosyasındaki kelimelerin sayısını bulmak için C'de bir program yazın. Programın, dosya adı kullanıcıdan almalı ve kelimeleri saymak için boşlukları dikkate almalıdır.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan bir dosya adı alır ve dosyadaki kelimeleri sayar. Program, dosyayı satır satır okur ve her satırdaki boşluk karakterlerini kullanarak kelime sayısını hesaplar.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char dosyaAdi[100];\n    FILE *dosya;\n    char satir[256];\n    int kelimeSayisi = 0;\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", dosyaAdi);\n\n    dosya = fopen(dosyaAdi, \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        char *kelime = strtok(satir, \" \\\");\n        while (kelime != NULL) {\n            kelimeSayisi++;\n            kelime = strtok(NULL, \" \\\");\n        }\n    }\n\n    fclose(dosya);\n    printf(\"Toplam kelime sayısı: %d\\n\", kelimeSayisi);\n    return 0;\n}\n```\n\nBu kodda, `fgets` fonksiyonu ile her bir satır okunur. `strtok` fonksiyonu kullanılarak satırdaki kelimeler ayrıştırılır ve kelime sayısı artırılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:25.064654"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırların uzunluklarını hesaplayıp, her satır uzunluğunu yeni bir dosyaya yazmak için bir C programı yazın. Kullanıcıdan hem girdi dosyası hem de çıktı dosyası adı alınmalıdır.",
    "answer": "Aşağıdaki C kodu, bir metin dosyasındaki her satırın uzunluğunu hesaplar ve sonuçları başka bir dosyaya yazar. Kullanıcıdan girdi ve çıktı dosyası adları alınır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char girdiDosyasi[100];\n    char ciktiDosyasi[100];\n    FILE *girdi, *cikti;\n    char satir[256];\n\n    printf(\"Girdi dosyasının adını girin: \");\n    scanf(\"%s\", girdiDosyasi);\n    printf(\"Çıktı dosyasının adını girin: \");\n    scanf(\"%s\", ciktiDosyasi);\n\n    girdi = fopen(girdiDosyasi, \"r\");\n    if (girdi == NULL) {\n        printf(\"Girdi dosyası açılamadı!\\n\");\n        return 1;\n    }\n\n    cikti = fopen(ciktiDosyasi, \"w\");\n    if (cikti == NULL) {\n        printf(\"Çıktı dosyası açılamadı!\\n\");\n        fclose(girdi);\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), girdi)) {\n        fprintf(cikti, \"Satır uzunluğu: %lu\\n\", strlen(satir));\n    }\n\n    fclose(girdi);\n    fclose(cikti);\n    printf(\"Satır uzunlukları başarıyla yazıldı.\\n\");\n    return 0;\n}\n```\n\nBu kodda, `fgets` ile her satır okunur ve `strlen` fonksiyonu kullanılarak satır uzunluğu hesaplanır. Sonuç `fprintf` ile belirtilen çıktı dosyasına yazılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:25.064721"
  },
  {
    "question": "Bir metin dosyasındaki kelimelerin frekansını hesaplamak için bir C programı yazın. Program, dosyanın içeriğini okuyacak ve her kelimenin kaç kez geçtiğini sayarak sonuçları ekrana yazdıracak.",
    "answer": "Aşağıdaki C kodu, bir metin dosyasındaki kelimelerin frekansını hesaplamaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_WORD_LENGTH 100\n#define MAX_WORDS 1000\n\ntypedef struct {\n    char word[MAX_WORD_LENGTH];\n    int count;\n} WordCount;\n\nint main() {\n    FILE *file;\n    char filename[100];\n    WordCount words[MAX_WORDS];\n    int word_count = 0;\n    char temp[MAX_WORD_LENGTH];\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    if (!file) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%s\", temp) != EOF) {\n        // Kelimenin küçük harfe dönüştürülmesi\n        for (int i = 0; temp[i]; i++) {\n            temp[i] = tolower(temp[i]);\n        }\n\n        // Kelimenin var olup olmadığını kontrol et\n        int found = 0;\n        for (int i = 0; i < word_count; i++) {\n            if (strcmp(words[i].word, temp) == 0) {\n                words[i].count++;\n                found = 1;\n                break;\n            }\n        }\n\n        // Yeni kelime ekle\n        if (!found) {\n            strcpy(words[word_count].word, temp);\n            words[word_count].count = 1;\n            word_count++;\n        }\n    }\n\n    fclose(file);\n\n    // Sonuçları yazdır\n    printf(\"Kelime frekansları:\\n\");\n    for (int i = 0; i < word_count; i++) {\n        printf(\"%s: %d\\n\", words[i].word, words[i].count);\n    }\n\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir dosya adı alır, dosyayı okur ve her kelimenin frekansını hesaplayıp ekrana yazdırır. Ayrıca, kelimeleri küçük harfe dönüştürerek büyük-küçük harf ayrımını ortadan kaldırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:46.454169"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırların tersine çevrilmesi için bir C programı yazın. Program, dosyayı okuyacak, her bir satırı tersine çevirecek ve sonuçları yeni bir dosyaya yazacak.",
    "answer": "Aşağıdaki C kodu, bir metin dosyasındaki her satırı tersine çevirmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    FILE *inputFile, *outputFile;\n    char inputFilename[100], outputFilename[100];\n    char line[256];\n\n    printf(\"Giriş dosyasının adını girin: \");\n    scanf(\"%s\", inputFilename);\n    printf(\"Çıkış dosyasının adını girin: \");\n    scanf(\"%s\", outputFilename);\n\n    inputFile = fopen(inputFilename, \"r\");\n    if (!inputFile) {\n        printf(\"Giriş dosyası açılamadı!\\n\");\n        return 1;\n    }\n\n    outputFile = fopen(outputFilename, \"w\");\n    if (!outputFile) {\n        printf(\"Çıkış dosyası açılamadı!\\n\");\n        fclose(inputFile);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), inputFile)) {\n        // Satırı ters çevir\n        reverse_string(line);\n        // Ters çevrilen satırı çıkış dosyasına yaz\n        fprintf(outputFile, \"%s\", line);\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n\n    printf(\"Tersine çevrilmiş satırlar %s dosyasına yazıldı.\\n\", outputFilename);\n\n    return 0;\n}\n```\nBu kod, kullanıcıdan bir giriş dosyası adı alır, dosyayı okur, her bir satırı tersine çevirir ve sonuçları belirtilen çıkış dosyasına yazar. `reverse_string` fonksiyonu, verilen bir stringin tersine çevrilmesini sağlar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:49:46.454232"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları okuyup, her satırın karakter sayısını hesaplayan bir C kodu var. Ancak bu kod, dosyanın boyutu büyük olduğunda yavaş çalışıyor. Nasıl optimize edebilirim?",
    "answer": "Dosyayı satır satır okumak yerine bellek içinde daha büyük bir tampon (buffer) kullanarak verileri daha hızlı işleyebilirsiniz. Ayrıca, karakter sayısını hesaplamak için her bir satırı ayrı ayrı işlemek yerine, bir döngü içinde tüm veriyi tek seferde okuyup toplam karakter sayısını hesaplayabilirsiniz. İşte örnek bir kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char buffer[1024]; // Daha büyük bir tampon oluşturduk\n    size_t total_chars = 0;\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        total_chars += strlen(buffer);\n    }\n\n    fclose(file);\n    printf(\"Toplam karakter sayısı: %zu\\n\", total_chars);\n    return EXIT_SUCCESS;\n}\n```\nBu yöntemle dosyayı daha verimli bir şekilde okuyarak performansı artırabilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:50:01.667847"
  },
  {
    "question": "Bir metin dosyasındaki belirli kelimeleri arayan ve bu kelimelerin bulunduğu satırları ekrana yazdıran bir C kodu yazdım. Ancak, dosyada çok sayıda kelime aranıyorsa, bu kod verimsiz çalışıyor. Ne yapabilirim?",
    "answer": "Bu durumda, her arama işlemi için dosyayı baştan sona okumak yerine, dosyayı bir kez okuyup tüm satırları belleğe alarak bu satırlarla arama işlemlerini gerçekleştirebilirsiniz. Böylece dosyayı sadece bir kez okumuş olursunuz ve arama sırasında zaman kaybı yaşamazsınız. İşte örnek bir yaklaşım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 1000\n#define MAX_LINE_LENGTH 256\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char *lines[MAX_LINES];\n    int line_count = 0;\n    char line[MAX_LINE_LENGTH];\n\n    // Tüm satırları belleğe al\n    while (fgets(line, sizeof(line), file) != NULL && line_count < MAX_LINES) {\n        lines[line_count] = strdup(line);\n        line_count++;\n    }\n    fclose(file);\n\n    const char *keyword = \"aranacak_kelime\";\n    for (int i = 0; i < line_count; i++) {\n        if (strstr(lines[i], keyword) != NULL) {\n            printf(\"%s\", lines[i]);\n        }\n        free(lines[i]); // Belleği serbest bırak\n    }\n    return EXIT_SUCCESS;\n}\n```\nBu yöntem, dosyayı sadece bir kez okuyarak kelime arama işlemlerini hızlandıracaktır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:50:01.667914"
  },
  {
    "question": "Bir metin dosyasının içeriğini satır satır okuyup, her satırın kaç kelime içerdiğini döndüren bir C kodu var. Ancak, kodun performansı düşük ve bellek yönetimi hataları var. Bu kodu inceleyip optimize eder misin?",
    "answer": "Aşağıdaki örnek kod, bir dosyayı açarak satır satır okur ve her satırdaki kelimeleri sayar. İlk olarak bellek yönetimi hatalarını düzeltmek ve performansı artırmak için bir dizi üzerinde işlem yaparken dinamik bellek kullanmak yerine statik bir dizi kullanmak daha iyi bir yaklaşımdır. Ayrıca, her satırda kelime sayısını artıran bir fonksiyon yerine, satırı okurken kelime sayısını doğrudan hesaplamak performansı artırır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 1024\n\nint kelimeSay(char *satir) {\n    int sayim = 0;\n    char *token = strtok(satir, \" \");\n    while (token != NULL) {\n        sayim++;\n        token = strtok(NULL, \" \");\n    }\n    return sayim;\n}\n\nint main() {\n    FILE *dosya = fopen(\"metin.txt\", \"r\");\n    char satir[MAX_LINE_LENGTH];\n\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(satir, MAX_LINE_LENGTH, dosya)) {\n        int kelimeSayisi = kelimeSay(satir);\n        printf(\"Satır: %sKelime Sayısı: %d\\n\", satir, kelimeSayisi);\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```\n\nBu kodda, `strtok` fonksiyonu kullanılarak kelimeler ayrıştırılıyor. Ayrıca, dosya açma işlemi sırasında hata kontrolü yapılıyor. Performansı artırmak için `kelimeSay` fonksiyonu yerine, `fgets` ile okunan satır üzerinde döngü kurarak doğrudan kelime sayısını hesaplamak daha verimli olabilir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:50:22.621890"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi arayıp, bulunduğu satır numarasını ve satır metnini yazdıran bir C programı var. Ancak, bu program her kelime için dosyayı baştan sona okuyor, bu da gereksiz yere işlem yapmasına sebep oluyor. Bu durumu nasıl iyileştirirsin?",
    "answer": "Aşağıda, belirli bir kelimeyi metin dosyasında arayan, ancak dosyayı baştan sona tek bir geçişte okuyan bir C kodu örneği verilmiştir. Bu, performansı artırarak gereksiz okuma işlemlerini engeller.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 1024\n\nvoid kelimeAra(const char *dosyaAdi, const char *kelime) {\n    FILE *dosya = fopen(dosyaAdi, \"r\");\n    char satir[MAX_LINE_LENGTH];\n    int satirNumarasi = 0;\n\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    while (fgets(satir, MAX_LINE_LENGTH, dosya)) {\n        satirNumarasi++;\n        if (strstr(satir, kelime) != NULL) {\n            printf(\"Kelime: '%s' | Satır Numarası: %d | Satır: %s\", kelime, satirNumarasi, satir);\n        }\n    }\n\n    fclose(dosya);\n}\n\nint main() {\n    kelimeAra(\"metin.txt\", \"örnek\");\n    return 0;\n}\n```\n\nBu kodda, `strstr` fonksiyonu kullanılarak kelimenin bulunduğu satırlar tespit ediliyor. Her satırda kelime arama işlemi, dosya sadece bir kez okunduğunda yapılıyor. Ayrıca, `fgets` ile okunan satırların sonuna dikkat edilerek, `printf` ile çıktılar düzgün bir formatta sunuluyor. Bu yöntem, işlem süresini ve kaynak kullanımını önemli ölçüde azaltır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-05-31T17:50:22.621976"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya yazan bir C programının eksik kısmını tamamlayın: \n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    char metin[100];\n    printf(\"Bir metin giriniz: \");\n    fgets(metin, sizeof(metin), stdin);\n    /* Buraya kod ekleyin */\n    fclose(dosya);\n    return 0;\n}",
    "answer": "Eksik kısım dosyaya yazma işlemini gerçekleştirmektedir. 'fputs' fonksiyonu ile kullanıcıdan alınan metni dosyaya yazabiliriz. Kod, 'fputs(metin, dosya);' şeklinde tamamlanmalıdır. Böylece, kullanıcıdan alınan metin 'metin.txt' dosyasına yazılacaktır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:50:31.175568"
  },
  {
    "question": "Bir dosyadan okunan tam sayıları toplayan bir C programının eksik kısmını tamamlayın: \n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"sayılar.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    int sayi, toplam = 0;\n    /* Buraya kod ekleyin */\n    fclose(dosya);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Eksik kısım dosyadan okuma ve toplam hesaplama işlemleridir. 'while (fscanf(dosya, \"%d\", &sayi) != EOF)' döngüsü ile dosyadan her bir tam sayı okunabilir ve 'toplam += sayi;' ifadesi ile bu sayılar toplanabilir. Yani, döngü 'while (fscanf(dosya, \"%d\", &sayi) != EOF) { toplam += sayi; }' şeklinde tamamlanmalıdır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:50:31.175688"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak, bir dosyadan metin okuyup ekrana yazdıran bir C programı oluşturun. Kullanılan dosya adı 'metin.txt' olsun. Dosya açılamazsa uygun bir hata mesajı gösterin.\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    \n    // Eksik kısım: Dosya açılmadıysa hata mesajı ver ve çıkış yap.\n    \n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir);\n    }\n\n    fclose(dosya);\n    return 0;\n}",
    "answer": "Kodda eksik olan kısım, dosyanın başarıyla açılıp açılmadığını kontrol etmektir. Eğer dosya açılamazsa, uygun bir hata mesajı gösterilmeli ve programdan çıkılmalıdır. Eksik kısım şu şekilde tamamlanabilir:\n\n```c\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        exit(EXIT_FAILURE);\n    }\n```\n\nBu kontrol, dosya açma işleminin başarısız olması durumunda kullanıcıya hata mesajı verir ve programın düzgün bir şekilde sonlanmasını sağlar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:07.330238"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak, kullanıcının girdiği verileri bir dosyaya yazan bir C programı oluşturun. Kullanıcı 'çık' yazana kadar veriler alınacak ve dosya 'veriler.txt' olarak kaydedilecek. Dosya açma ve yazma işlemleri için gerekli kontrolleri yapmayı unutmayın.\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char girdi[100];\n\n    // Eksik kısım: Dosyayı aç\n    \n    while (1) {\n        printf(\"Veri girin (çıkmak için 'çık' yazın): \");\n        fgets(girdi, sizeof(girdi), stdin);\n        \n        // Kullanıcı 'çık' yazdıysa döngüden çık\n        if (strncmp(girdi, \"çık\", 3) == 0) {\n            break;\n        }\n        // Eksik kısım: Girilen veriyi dosyaya yaz\n    }\n\n    // Dosyayı kapat\n    return 0;\n}",
    "answer": "Kodda iki tane eksik kısım var. İlk olarak, dosyayı açma işlemi yapılmalıdır. İkinci olarak, girilen verinin dosyaya yazılması gerekmektedir. İlk eksik kısım şu şekilde tamamlanabilir:\n\n```c\n    dosya = fopen(\"veriler.txt\", \"w\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        exit(EXIT_FAILURE);\n    }\n```\n\nİkinci eksik kısım ise şu şekilde tamamlanmalıdır:\n\n```c\n        fprintf(dosya, \"%s\", girdi);\n```\n\nBu kod, kullanıcıdan alınan verileri 'veriler.txt' dosyasına yazacaktır. Program çıkış yapıldığında dosya kapatılmalıdır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:07.330433"
  },
  {
    "question": "Aşağıdaki kodun eksik kısımlarını tamamlayarak bir dosyayı satır satır okuyup, her satırı ekrana yazdıran C programını oluşturun. Dosya adı 'metin.txt' olsun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    // Dosyayı okumak için açıyoruz\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyayı satır satır okuyup yazdırıyoruz\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(file);\n    return 0;\n}\n\n/* Açıklama: Bu kod, 'metin.txt' adlı bir dosyayı açar ve içindeki satırları 'fgets' fonksiyonu ile okur. Her okunan satır ekrana yazdırılır. Dosya okuma işlemi tamamlandığında dosya kapatılır. */",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:22.612552"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayarak bir dosyaya kullanıcıdan alınan metni yazan C programını yazın. Dosya adı 'cikti.txt' olsun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char input[256];\n\n    // Kullanıcıdan metin alıyoruz\n    printf(\"Bir metin girin: \");\n    fgets(input, sizeof(input), stdin);\n\n    // Dosyayı yazma modunda açıyoruz\n    file = fopen(\"cikti.txt\", \"w\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Kullanıcının girdisini dosyaya yazıyoruz\n    fprintf(file, \"%s\", input);\n\n    // Dosyayı kapatıyoruz\n    fclose(file);\n    printf(\"Metin 'cikti.txt' dosyasına yazıldı.\\n\");\n    return 0;\n}\n\n/* Açıklama: Bu kod, kullanıcıdan bir metin alır ve 'cikti.txt' adlı dosyaya yazdırır. Dosya yazma modunda açıldığı için, eğer dosya zaten varsa içeriği silinir ve yeni içerik yazılır. */",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:22.612602"
  },
  {
    "question": "Aşağıdaki C kodu, bir dosyadan metin okuma işlemi yapıyor. Ancak, dosya açılırken hata mesajı vermiyor. Hatanın sebebini bulun ve düzeltin.",
    "answer": "Kodun başlangıç kısmında dosya açma işlemi yapılırken, dosyanın gerçekten açılıp açılmadığını kontrol etmek için bir hata kontrolü eksik. Aşağıdaki gibi bir kontrol ekleyerek hatayı düzeltebiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya okuma işlemleri buraya gelecek\n    fclose(file);\n    return 0;\n}\n```\n\nBurada `perror` fonksiyonu, dosya açma işlemi başarısız olduğunda hata mesajı verecek şekilde düzenlenmiştir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:30.936187"
  },
  {
    "question": "Aşağıdaki C kodu, bir dosyaya yazma işlemi yapıyor. Ancak, dosya açıldıktan sonra yazma işlemi gerçekleştirilmeden önce dosya kapatılıyor. Hatanın sebebini bulun ve düzeltin.",
    "answer": "Kodda `fclose(file);` satırı, yazma işlemi yapılmadan önce çağrılmaktadır. Bu, dosya kapatıldığı için yazma işleminin gerçekleştirilmemesine neden olur. Yazma işlemi yapılacak şekilde kodu aşağıdaki gibi güncelleyebiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"cikti.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fprintf(file, \"Merhaba, dünya!\"); // Yazma işlemi burada gerçekleşiyor\n    fclose(file); // Yazma işlemi tamamlandıktan sonra dosya kapatılıyor\n    return 0;\n}\n```\n\nBu şekilde dosya yazma işlemi başarılı bir şekilde yapılmış olur.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:30.936246"
  },
  {
    "question": "Bir dosyayı açıp içeriğini okuma işlemi yaparken, dosyanın var olup olmadığını kontrol etmiyorum. Kodum şu şekilde: \n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[100];\n\n    file = fopen(\"ornek.txt\", \"r\");\n    fscanf(file, \"%99s\", buffer);\n    printf(\"Okunan veri: %s\\n\", buffer);\n    fclose(file);\n    return 0;\n}\n``` \nBu kodda hangi hatalar var ve nasıl düzeltilmeli?",
    "answer": "Bu kodda dosyanın var olup olmadığını kontrol etmeden dosya okuma işlemi yapılmaya çalışıldığı için potansiyel bir hata oluşabilir. Eğer \"ornek.txt\" dosyası mevcut değilse, `fopen` işlevi `NULL` döner ve bu durumda `fscanf` çağrısı geçersiz bir işaretçiye uygulanır, bu da programın çökmesine neden olabilir. Hatanın önlenmesi için, `fopen` çağrısından sonra `file` işaretçisinin `NULL` olup olmadığını kontrol etmeliyiz. Düzeltilmiş kod aşağıdaki gibi olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[100];\n\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fscanf(file, \"%99s\", buffer);\n    printf(\"Okunan veri: %s\\n\", buffer);\n    fclose(file);\n    return 0;\n}\n``` \nBu değişiklikle, dosya açılamazsa bir hata mesajı basılacak ve program düzgün bir şekilde sonlanacaktır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:45.471293"
  },
  {
    "question": "Bir dosyaya veri yazmayı deniyorum ama dosyanın yazılabilir olup olmadığını kontrol etmiyorum. Kodum şu şekilde: \n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n\n    file = fopen(\"yeni_dosya.txt\", \"w\");\n    fprintf(file, \"Bu yeni bir dosya.\\n\");\n    fclose(file);\n    return 0;\n}\n``` \nBu kodda hangi hatalar var ve nasıl düzeltilmeli?",
    "answer": "Bu kodda dosyanın başarıyla açılıp açılmadığını kontrol etmemek ciddi bir hatadır. Eğer dosya açılmazsa, `fopen` `NULL` döner ve `fprintf` işlevi geçersiz bir işaretçiye erişmeye çalışır, bu da programın çökmesine neden olur. Dosyanın yazılabilir olup olmadığını kontrol etmek için `fopen` çağrısından sonra işaretçinin `NULL` olup olmadığını kontrol etmemiz gerekir. Düzeltilmiş kod aşağıdaki gibi olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n\n    file = fopen(\"yeni_dosya.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fprintf(file, \"Bu yeni bir dosya.\\n\");\n    fclose(file);\n    return 0;\n}\n``` \nBu değişiklikle, dosya açılamazsa bir hata mesajı basılacak ve program düzgün bir şekilde sonlanacaktır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:51:45.471397"
  },
  {
    "question": "Aşağıdaki C kodunda, bir dosyadan satır satır okuma yapmaya çalışıyorum. Ancak programım çalıştığında hiçbir çıktı vermiyor ve dosyayı düzgün bir şekilde okumuyor. Hatanın kaynağını bul ve düzelt.",
    "answer": "Kodunuzu gözden geçirirken, dosya açma ve okuma işlemlerinin dikkatli bir şekilde yapılmadığını görebiliriz. İşte hatalı kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char line[256];\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\n\nBu kodu çalıştırdığınızda, dosya açılmamışsa `file` işaretçisi `NULL` değerini alır ve bu durumdaki bir `while` döngüsü, programın çökmesine neden olur. Bunu düzeltmek için dosyanın başarıyla açılıp açılmadığını kontrol etmelisiniz. Düzgün çalışan versiyon:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char line[256];\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\n\nBurada `perror` fonksiyonu, hata mesajı döndürerek dosyanın neden açılamadığını anlamanızı sağlar. Bu nedenle dosya açılmadan önce kontrolü yapmak çok önemlidir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:06.992896"
  },
  {
    "question": "Aşağıdaki C kodunda, bir dosyaya veri yazmaya çalışıyorum. Ancak dosya açıldıktan sonra yazma işlemi gerçekleşmiyor. Hatanın nedenini ve çözümünü belirt.",
    "answer": "Verdiğiniz kodda, dosyaya yazma işlemi gerçekleştirilememektedir. Hatalı kod şu şekildedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    char *data = \"Merhaba, dünya!\";\n\n    fprintf(file, \"%s\", data);\n    fclose(file);\n    return 0;\n}\n```\n\nBu kodu çalıştırdığınızda, `output.txt` dosyası yazılamamış olabilir. Bunun nedeni dosyanın açılma modunun kontrol edilmemesidir. Eğer dosya açma işlemi başarısız olursa, `file` işaretçisi `NULL` olur ve `fprintf` çağrısı bu durumda geçersiz bir işaretçiyi kullanır. Düzeltmek için, dosyanın başarıyla açıldığını kontrol etmek gerekir. Düzgün çalışan versiyon:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char *data = \"Merhaba, dünya!\";\n\n    fprintf(file, \"%s\", data);\n    fclose(file);\n    return 0;\n}\n```\n\nBu kodda dosya açılmadan önce kontrol yapıldığı için, hata durumunda kullanıcıya bir mesaj gösterilir. Böylece dosyaya yazma işlemi güvenli bir şekilde gerçekleştirilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:06.992952"
  },
  {
    "question": "C dilinde bir dosyadan metin okuyarak ekrana yazdırmak için nasıl bir kod yazabilirim?",
    "answer": "C dilinde bir dosyadan metin okumak için öncelikle dosyayı açmamız gerekiyor. Bunun için 'fopen' fonksiyonunu kullanacağız. Dosyayı okuma modunda açtıktan sonra, 'fgets' fonksiyonu ile dosyadan satır satır veri okuyabiliriz. Aşağıdaki örnek, 'metin.txt' adlı bir dosyadan metin okuma işlemini göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100]; // Her satır için bir buffer oluşturuyoruz\n\n    // Dosyayı okuma modunda açıyoruz\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyadan satır oku ve ekrana yazdır\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    return 0;\n}\n```\nBu kodda, 'fopen' ile dosyayı açıyoruz. Eğer dosya açılamazsa, bir hata mesajı yazdırıyoruz. 'fgets' ile dosyayı satır satır okuyor ve okunan satırı ekrana yazdırıyoruz. Son olarak, dosyayı 'fclose' ile kapatıyoruz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:20.897453"
  },
  {
    "question": "C dilinde bir dizi sayıyı dosyaya nasıl yazabilirim?",
    "answer": "C dilinde bir dizi içerisindeki sayıları bir dosyaya yazmak için yine 'fopen' fonksiyonunu kullanarak dosyayı yazma modunda açarız. Ardından 'fprintf' veya 'fwrite' fonksiyonları ile verileri dosyaya yazabiliriz. Aşağıda, bir tamsayı dizisini 'sayilar.txt' adlı bir dosyaya yazma işlemini gösteren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[] = {10, 20, 30, 40, 50}; // Yazılacak dizi\n    int i;\n\n    // Dosyayı yazma modunda açıyoruz\n    dosya = fopen(\"sayilar.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Diziyi dosyaya yaz\n    for (i = 0; i < 5; i++) {\n        fprintf(dosya, \"%d\\n\", sayilar[i]);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    return 0;\n}\n```\nBu kodda, 'fopen' ile dosyayı yazma modunda açıyoruz. Eğer dosya açılamazsa, bir hata mesajı veriyoruz. For döngüsü ile dizideki her bir sayıyı 'fprintf' ile dosyaya yazıyoruz. Her sayıdan sonra bir yeni satır ekliyoruz. Son olarak, dosyayı 'fclose' ile kapatıyoruz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:20.897488"
  },
  {
    "question": "Bir metin dosyasını okumak için C programında nasıl dosya stream'i oluşturabilirim? Örnek bir kod ile göster.",
    "answer": "C dilinde bir metin dosyasını okumak için, önce bir dosya pointer'ı oluşturmalıyız. Bu dosya pointer'ı, fopen() fonksiyonu ile bir dosyaya bağlanır. Aşağıda örnek bir kod bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    // Dosyayı okuma modunda açıyoruz\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyadan satır satır okuma işlemi\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"Okunan Satır: %s\", satir);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    return 0;\n}\n```\n\nBu kodda, \"ornek.txt\" adlı dosyayı okumak için açıyoruz. fgets() fonksiyonu kullanarak dosyayı satır satır okuyup ekrana yazdırıyoruz. Dosya işlemleri tamamlandıktan sonra fclose() ile dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:33.667837"
  },
  {
    "question": "C dilinde bir binary dosyasını yazmak için dosya stream'leri nasıl kullanılır? Örnek bir uygulama ile açıkla.",
    "answer": "C dilinde binary dosyası yazmak için yine fopen() fonksiyonunu kullanarak dosyayı yazma modunda açmalıyız. Aşağıda, bir dizi tam sayıyı binary bir dosyaya yazan örnek bir kod bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[5] = {1, 2, 3, 4, 5};\n\n    // Dosyayı binary yazma modunda açıyoruz\n    dosya = fopen(\"sayilar.dat\", \"wb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dizi elemanlarını binary dosyaya yazıyoruz\n    size_t yazilan = fwrite(sayilar, sizeof(int), 5, dosya);\n    if (yazilan < 5) {\n        printf(\"Yazma işlemi başarısız oldu!\\n\");\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(dosya);\n    return 0;\n}\n```\n\nBu kodda, sayilar.dat adında bir binary dosya oluşturuyoruz ve içinde 5 tam sayı tutan bir dizi yazıyoruz. fwrite() fonksiyonu ile diziyi binary formatta dosyaya yazıyoruz. Her zaman olduğu gibi, dosyayı işlemlerimiz tamamlandıktan sonra kapatmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:33.667885"
  },
  {
    "question": "C dilinde büyük boyutlu bir dosyayı parça parça okuyarak belleğe almak istiyorum. Bu işlemi nasıl gerçekleştirebilirim?",
    "answer": "Büyük boyutlu dosyaları belleğe almak için, dosyayı parça parça okuyarak verimi artırmak önemlidir. Bunun için 'fread' fonksiyonu kullanılabilir. Aşağıda bu işlemi gerçekleştiren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define BUFFER_SIZE 1024 // 1 KB'lık bir buffer boyutu\n\nint main() {\n    FILE *file;\n    char buffer[BUFFER_SIZE];\n    size_t bytesRead;\n\n    // Dosyayı aç\n    file = fopen(\"buyuk_dosya.txt\", \"rb\"); // \"rb\" modunda açarak binary okuma yapıyoruz\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Dosyayı parça parça oku\n    while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {\n        // Okunan veriyi işleme al\n        // (örneğin, konsola yazdırabiliriz)\n        fwrite(buffer, 1, bytesRead, stdout);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu örnekte, \"buyuk_dosya.txt\" adında bir dosyayı 1 KB'lık parçalara ayırarak okuyoruz. 'fwrite' fonksiyonu kullanarak okunan veriyi standart çıkışa yazdırıyoruz. Bu yöntemle bellek yönetimini daha efektif kullanmış oluruz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:47.117731"
  },
  {
    "question": "C dilinde bir dosyaya yazarken, dosyanın mevcut içeriğini koruyarak yeni verileri eklemeyi nasıl sağlarım?",
    "answer": "C dilinde bir dosyaya ekleme yapmak için dosyayı \"a\" modunda açmalısınız. Bu mod, dosyayı 'append' yani ekleme modunda açar ve dosyaya yazılan veriler mevcut içeriğin sonuna eklenir. İşte bunu gösteren bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    const char *newData = \"Yeni veri ekleniyor!\\n\";\n\n    // Dosyayı ekleme modunda aç\n    file = fopen(\"veri.txt\", \"a\"); // \"a\" modunda açarak mevcut içeriği koruyoruz\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Yeni veriyi dosyaya yaz\n    if (fputs(newData, file) == EOF) {\n        perror(\"Yazma hatası\");\n        fclose(file);\n        return EXIT_FAILURE;\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kodda, \"veri.txt\" adında bir dosyaya \"Yeni veri ekleniyor!\" metnini ekliyoruz. 'fputs' fonksiyonu ile dosyaya yazma işlemini gerçekleştiriyoruz. Eğer dosya zaten mevcutsa, mevcut içeriği koruyarak bu veriyi ekliyoruz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:47.117775"
  },
  {
    "question": "Bir dosyadan metin okuyup, ekrana yazdıran basit bir C programı nasıl yazılır?",
    "answer": "Aşağıda, bir dosyadan metin okuyan ve bunu ekrana yazdıran basit bir C programı örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyadan karakterleri oku ve ekrana yazdır\n    while ((ch = fgetc(dosya)) != EOF) {\n        putchar(ch);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}\n```\n\nBu program, 'metin.txt' dosyasını okur ve içeriğini ekrana yazdırır. 'fopen' ile dosya açılır, 'fgetc' ile dosyadan karakterler okunur ve 'putchar' ile ekrana yazılır. Dosya işlemleri tamamlandıktan sonra 'fclose' ile dosya kapatılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:58.791812"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya yazan basit bir C programı nasıl yazılır?",
    "answer": "Aşağıda, kullanıcının girdiği metni bir dosyaya yazan basit bir C programı örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Dosyayı aç (yazma modunda)\n    dosya = fopen(\"cikti.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Kullanıcıdan veri al\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Kullanıcıdan alınan metni dosyaya yaz\n    fprintf(dosya, \"%s\", metin);\n\n    // Dosyayı kapat\n    fclose(dosya);\n    printf(\"Metin dosyaya yazıldı.\\n\");\n    return 0;\n}\n```\n\nBu program, kullanıcının girdiği metni 'cikti.txt' dosyasına yazar. 'fopen' ile dosya yazma modunda açılır, 'fgets' ile kullanıcıdan veri alınır ve 'fprintf' ile dosyaya yazılır. İşlemler tamamlandıktan sonra 'fclose' ile dosya kapatılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:52:58.791863"
  },
  {
    "question": "Bir metin dosyasını okuyarak içindeki satır sayısını bulan bir C programı yazın. Program, dosya açma, okuma ve kapama işlemlerini içermelidir.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    int line_count = 0;\n\n    // Dosyayı açıyoruz\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açma hatası\");\n        return 1;\n    }\n\n    // Dosyayı satır satır okuyoruz\n    while (fgets(line, sizeof(line), file)) {\n        line_count++;\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(file);\n\n    // Satır sayısını yazdırıyoruz\n    printf(\"Dosyadaki satır sayısı: %d\\n\", line_count);\n    return 0;\n}\n\n// Açıklama: Bu program, 'metin.txt' dosyasını okur ve içindeki satır sayısını hesaplar. fopen() ile dosya açılır, fgets() ile satırlar okunur ve her okunan satırda line_count değişkeni artırılır. Son olarak, fclose() ile dosya kapatılır ve sonuç ekrana yazdırılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:53:10.041676"
  },
  {
    "question": "Bir metin dosyasına kullanıcıdan alınan cümleleri ekleyen bir C programı yazın. Kullanıcı 'exit' yazarak çıkış yapabilir.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char sentence[256];\n\n    // Dosyayı açıyoruz\n    file = fopen(\"cümleler.txt\", \"a\");\n    if (file == NULL) {\n        perror(\"Dosya açma hatası\");\n        return 1;\n    }\n\n    printf(\"Cümlelerinizi girin (çıkmak için 'exit' yazın):\\n\");\n    while (1) {\n        fgets(sentence, sizeof(sentence), stdin);\n        // 'exit' kelimesini kontrol ediyoruz\n        if (strcmp(sentence, \"exit\\n\") == 0) {\n            break;\n        }\n        // Kullanıcının cümlesini dosyaya yazıyoruz\n        fputs(sentence, file);\n    }\n\n    // Dosyayı kapatıyoruz\n    fclose(file);\n\n    printf(\"Cümleler dosyaya kaydedildi.\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği cümleleri 'cümleler.txt' dosyasına ekler. Dosya açılırken 'a' modunda açılması, mevcut içeriğin üzerine yazılmadan yeni cümlelerin eklenmesini sağlar. Kullanıcı 'exit' yazana kadar döngü devam eder ve her cümle fputs() ile dosyaya yazılır. Son olarak dosya kapatılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:53:10.041752"
  },
  {
    "question": "Büyük bir dosyadaki belirli bir kelimeyi arayıp, bulunduğu satır numarasını ve konumunu yazdıran bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki kod, bir dosyada belirli bir kelimeyi arayıp, o kelimenin bulunduğu satır numarasını ve konumunu belirleyen bir C programı örneğidir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid search_word_in_file(const char *filename, const char *word) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    char line[256];\n    int line_number = 0;\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        char *pos = strstr(line, word);\n        if (pos != NULL) {\n            int column_number = (int)(pos - line) + 1; // +1 için 1 tabanlı konum\n            printf(\"Kelime '%s' satır %d, sütun %d' de bulundu.\\n\", word, line_number, column_number);\n        }\n    }\n\n    fclose(file);\n}\n\nint main() {\n    const char *filename = \"example.txt\";\n    const char *word = \"aramak\";\n    search_word_in_file(filename, word);\n    return 0;\n}\n```\n\nBu program, belirtilen dosyayı açar, satır satır okur ve her satırda aranan kelimeyi kontrol eder. Kelime bulunduğunda, satır ve sütun numarasını döndürür. `strstr` fonksiyonu, verilen string içinde aranan kelimenin yerini bulmak için kullanılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:53:57.116150"
  },
  {
    "question": "Bir dosyadan okunan bütün verileri ters sırayla başka bir dosyaya yazan bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, bir dosyadan okunan verileri ters sırayla başka bir dosyaya yazmak için kullanılabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reverse_file_content(const char *input_file, const char *output_file) {\n    FILE *infile = fopen(input_file, \"r\");\n    if (infile == NULL) {\n        perror(\"Girdi dosyası açılamadı\");\n        return;\n    }\n\n    fseek(infile, 0, SEEK_END);\n    long file_size = ftell(infile);\n    fseek(infile, 0, SEEK_SET);\n\n    char *buffer = malloc(file_size);\n    if (buffer == NULL) {\n        perror(\"Bellek ayıramadı\");\n        fclose(infile);\n        return;\n    }\n\n    fread(buffer, 1, file_size, infile);\n    fclose(infile);\n\n    FILE *outfile = fopen(output_file, \"w\");\n    if (outfile == NULL) {\n        perror(\"Çıktı dosyası açılamadı\");\n        free(buffer);\n        return;\n    }\n\n    for (long i = file_size - 1; i >= 0; i--) {\n        fputc(buffer[i], outfile);\n    }\n\n    free(buffer);\n    fclose(outfile);\n}\n\nint main() {\n    const char *input_file = \"input.txt\";\n    const char *output_file = \"output.txt\";\n    reverse_file_content(input_file, output_file);\n    return 0;\n}\n```\n\nBu program, önce girdi dosyasının boyutunu belirler ve ardından tüm içeriği bir buffer'a okur. Daha sonra, bu buffer'ı ters sırayla çıktı dosyasına yazar. `fseek` ve `ftell` fonksiyonları dosya boyutunu belirlemek için kullanılır. Bu yaklaşım, dosya içeriğinin bellekte tam olarak saklanmasına izin verir, böylece ters yazım işlemi kolaylıkla yapılabilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:53:57.116222"
  },
  {
    "question": "Bir dosyadan büyük miktarda veri okurken belleği etkili bir şekilde kullanmak için nasıl bir yöntem izlenebilir?",
    "answer": "Büyük dosyalarla çalışırken, tüm dosyayı belleğe yüklemek yerine dosyayı parça parça okumak daha etkili olacaktır. Bunun için 'fread' fonksiyonunu kullanabiliriz. Örneğin, 1 MB'lık bir tampon (buffer) oluşturarak dosyayı bu tampon ile okuyabiliriz. Bu sayede bellek tüketimini düşürüp performansı artırabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define BUFFER_SIZE 1024 * 1024 // 1 MB\n\nint main() {\n    FILE *file = fopen(\"büyük_dosya.txt\", \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    char *buffer = (char *)malloc(BUFFER_SIZE);\n    if (!buffer) {\n        perror(\"Bellek tahsis edilemedi\");\n        fclose(file);\n        return EXIT_FAILURE;\n    }\n    size_t bytesRead;\n    while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {\n        // Okunan veriyi işleyin\n    }\n    free(buffer);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:54:06.596098"
  },
  {
    "question": "Dosyaya yazarken, yazma işlemi sonrası dosyayı kapatmadan önce verilerin güvenli bir şekilde yazıldığından emin olmak için ne yapılmalı?",
    "answer": "Dosyaya veri yazdıktan sonra, 'fflush' fonksiyonu kullanarak tampon bellek içeriğini dosyaya yazdırmak önemlidir. Bu sayede, eğer program bir hata ile sonlanırsa veya bir kesinti olursa, verilerin kaybolma riski en aza indirilir. Aşağıdaki örnek, bir dosyaya veri yazma işlemini ve sonrasında 'fflush' kullanımı ile verilerin güvenliğini sağlamayı göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"çıktı.txt\", \"w\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fprintf(file, \"Bu bir test yazısıdır.\");\n    fflush(file); // Tamponu temizle ve veriyi yaz\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:54:06.596150"
  },
  {
    "question": "Bir dosyadan veri okurken bellek sızıntılarını engellemek için hangi önlemleri alabilirim? Örnek bir kod parçası ile açıklayınız.",
    "answer": "Bellek sızıntılarını önlemek için, dosya okumalarında dinamik bellek tahsisi kullanıyorsanız, bellek alanını serbest bırakmayı unutmamalısınız. Ayrıca, dosya açma ve kapama işlemlerini doğru yapmak önemlidir. Aşağıda, bir dosyadan verileri okuma ve bellek sızıntılarını önleme yöntemini gösteren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid readFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    char *buffer = (char *)malloc(256);\n    if (buffer == NULL) {\n        perror(\"Bellek tahsisi hatası\");\n        fclose(file);\n        return;\n    }\n\n    while (fgets(buffer, 256, file) != NULL) {\n        printf(\"Okunan: %s\", buffer);\n    }\n\n    free(buffer); // Belleği serbest bırak\n    fclose(file); // Dosyayı kapat\n}\n``` \nYukarıdaki örnekte, `malloc` ile bellek tahsis edilir ve `free` ile serbest bırakılır. Ayrıca, `fclose` ile dosya kapatılarak kaynak sızıntıları engellenir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:54:19.191114"
  },
  {
    "question": "Bir dosyaya veri yazarken, yazma işlemini optimize etmek için hangi yöntemleri kullanabilirim? Örnek bir kod ile açıklayınız.",
    "answer": "Dosyaya veri yazarken yazma işlemini optimize etmek için tamponlama kullanmak etkili bir yöntemdir. Böylece, verileri daha az sayıda sistem çağrısı ile yazabiliriz. Aşağıda, veri yazma işlemini optimize eden bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define BUFFER_SIZE 1024\n\nvoid writeFile(const char *filename) {\n    FILE *file = fopen(filename, \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    char buffer[BUFFER_SIZE];\n    for (int i = 0; i < 100; i++) {\n        snprintf(buffer, BUFFER_SIZE, \"Veri %d\\n\", i);\n        fputs(buffer, file);\n    }\n\n    fflush(file); // Tamponu temizle ve yaz\n    fclose(file); // Dosyayı kapat\n}\n```\nYukarıdaki örnekte, `fputs` kullanarak yazma işlemi yapılır ve `fflush` ile tampon içeriği dosyaya yazılır. Bu, yazma işlemini optimize ederek disk erişimini azaltır. Ayrıca, dosya açma ve kapama işlemlerini dikkatlice yönetmek de önemlidir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-05-31T17:54:19.191194"
  },
  {
    "question": "Bir öğrenci bilgilerini tutmak için 'Student' adında bir struct tanımlayın. Bu struct, öğrencinin adını, soyadını ve notunu içermelidir. Ardından, kullanıcıdan bu bilgileri alıp struct'ı dolduracak bir fonksiyon yazın.",
    "answer": "Aşağıda 'Student' adında bir struct tanımlanmıştır. Bu yapı, öğrencinin adını, soyadını ve notunu tutmaktadır. Kullanıcıdan bilgileri almak için ise 'getStudentInfo' isimli bir fonksiyon yazılmıştır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char firstName[50];\n    char lastName[50];\n    float grade;\n};\n\nvoid getStudentInfo(struct Student *student) {\n    printf(\"Öğrencinin adını girin: \");\n    scanf(\"%s\", student->firstName);\n    printf(\"Öğrencinin soyadını girin: \");\n    scanf(\"%s\", student->lastName);\n    printf(\"Öğrencinin notunu girin: \");\n    scanf(\"%f\", &student->grade);\n}\n\nint main() {\n    struct Student student;\n    getStudentInfo(&student);\n    printf(\"Öğrenci Bilgileri: %s %s, Not: %.2f\\n\", student.firstName, student.lastName, student.grade);\n    return 0;\n}\n```\nBu kod, 'Student' yapı tanımını ve kullanıcıdan bilgileri alarak bu yapıyı dolduran bir fonksiyonu içerir. Ardından, bilgileri ekrana yazdırmak için main fonksiyonu kullanılmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:54:35.580627"
  },
  {
    "question": "Bir kitap bilgilerini tutmak için 'Book' adında bir struct tanımlayın. Bu struct, kitabın başlığını, yazarını ve yayım yılını içermelidir. Kullanıcıdan bu bilgileri alıp struct'ı dolduracak bir fonksiyon yazın ve kitap bilgilerini ekrana yazdırın.",
    "answer": "Aşağıda 'Book' adında bir struct tanımlanmıştır. Bu yapı, kitabın başlığını, yazarını ve yayım yılını tutmaktadır. Kullanıcıdan bilgileri almak için ise 'getBookInfo' isimli bir fonksiyon yazılmıştır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Book {\n    char title[100];\n    char author[50];\n    int year;\n};\n\nvoid getBookInfo(struct Book *book) {\n    printf(\"Kitap başlığını girin: \");\n    scanf(\"%[^\n]%*c\", book->title);\n    printf(\"Yazarın adını girin: \");\n    scanf(\"%[^\n]%*c\", book->author);\n    printf(\"Yayım yılını girin: \");\n    scanf(\"%d\", &book->year);\n}\n\nint main() {\n    struct Book book;\n    getBookInfo(&book);\n    printf(\"Kitap Bilgileri: Başlık: %s, Yazar: %s, Yayım Yılı: %d\\n\", book.title, book.author, book.year);\n    return 0;\n}\n```\nBu kod, 'Book' yapı tanımını ve kullanıcıdan kitap bilgilerini alarak bu yapıyı dolduran bir fonksiyonu içerir. Kullanıcı bilgileri girdikten sonra, kitap bilgilerini ekrana yazdırmak için main fonksiyonu kullanılmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:54:35.580704"
  },
  {
    "question": "Bir öğrencinin bilgilerini tutmak için bir struct tanımlayın. Öğrencinin adı, soyadı, yaşı ve not ortalaması gibi bilgileri içermelidir. Daha sonra bu bilgileri kullanıcıdan alın ve ekrana yazdıran bir program yazın.",
    "answer": "#include <stdio.h>\n\n// Öğrenci yapısını tanımlıyoruz\nstruct Ogrenci {\n    char ad[50];\n    char soyad[50];\n    int yas;\n    float notOrt;\n};\n\nint main() {\n    struct Ogrenci ogr;\n\n    // Kullanıcıdan öğrenci bilgilerini alıyoruz\n    printf(\"Öğrencinin adını girin: \");\n    scanf(\"%s\", ogr.ad);\n    printf(\"Öğrencinin soyadını girin: \");\n    scanf(\"%s\", ogr.soyad);\n    printf(\"Öğrencinin yaşını girin: \");\n    scanf(\"%d\", &ogr.yas);\n    printf(\"Öğrencinin not ortalamasını girin: \");\n    scanf(\"%f\", &ogr.notOrt);\n\n    // Bilgileri ekrana yazdırıyoruz\n    printf(\"\\nÖğrenci Bilgileri:\\n\");\n    printf(\"Ad: %s\\n\", ogr.ad);\n    printf(\"Soyad: %s\\n\", ogr.soyad);\n    printf(\"Yaş: %d\\n\", ogr.yas);\n    printf(\"Not Ortalaması: %.2f\\n\", ogr.notOrt);\n\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:07.768802"
  },
  {
    "question": "Bir kitap bilgilerini tutmak için bir struct oluşturun. Kitap adı, yazar, yayın yılı ve fiyat gibi bilgileri içermelidir. Programda en fazla 5 kitabı depolayıp, kullanıcıdan bu bilgileri alarak sıralı bir şekilde ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\n// Kitap yapısını tanımlıyoruz\nstruct Kitap {\n    char ad[100];\n    char yazar[50];\n    int yayinYili;\n    float fiyat;\n};\n\nint main() {\n    struct Kitap kitaplar[5];\n\n    // Kullanıcıdan kitap bilgilerini alıyoruz\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d. Kitap adı: \", i+1);\n        scanf(\"%s\", kitaplar[i].ad);\n        printf(\"%d. Yazar adı: \", i+1);\n        scanf(\"%s\", kitaplar[i].yazar);\n        printf(\"%d. Yayın yılı: \", i+1);\n        scanf(\"%d\", &kitaplar[i].yayinYili);\n        printf(\"%d. Fiyat: \", i+1);\n        scanf(\"%f\", &kitaplar[i].fiyat);\n    }\n\n    // Kitap bilgilerini sıralı bir şekilde yazdırıyoruz\n    printf(\"\\nKitap Bilgileri:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"Kitap %d: %s, Yazar: %s, Yıl: %d, Fiyat: %.2f TL\\n\", i+1, kitaplar[i].ad, kitaplar[i].yazar, kitaplar[i].yayinYili, kitaplar[i].fiyat);\n    }\n\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:07.768889"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayın. Kod, bir öğrencinin bilgilerini (isim, yaş ve not) saklayan bir struct tanımlamalıdır. Ayrıca, bu struct kullanılarak bir öğrencinin bilgilerini ekrana yazdıran bir fonksiyon oluşturulmalıdır.",
    "answer": "// Öğrenci bilgilerini saklamak için struct tanımlıyoruz.\n#include <stdio.h>\n#include <string.h>\n\nstruct Ogrenci {\n    char isim[50];\n    int yas;\n    float not;\n};\n\n// Öğrenci bilgilerini yazdıran fonksiyon\nvoid ogrenciBilgileriniYazdir(struct Ogrenci ogrenci) {\n    printf(\"Isim: %s\\n\", ogrenci.isim);\n    printf(\"Yas: %d\\n\", ogrenci.yas);\n    printf(\"Not: %.2f\\n\", ogrenci.not);\n}\n\nint main() {\n    struct Ogrenci ogrenci1;\n    strcpy(ogrenci1.isim, \"Ahmet\");\n    ogrenci1.yas = 20;\n    ogrenci1.not = 85.5;\n    \n    // Öğrenci bilgilerini yazdırma\n    ogrenciBilgileriniYazdir(ogrenci1);\n\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:20.112654"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayın. Bir çalışan bilgilerini (isim, pozisyon, maaş) saklayan bir struct tanımlayın. Bu struct kullanılarak çalışanların toplam maaşını hesaplayan bir fonksiyon yazın.",
    "answer": "// Çalışan bilgilerini saklamak için struct tanımlıyoruz.\n#include <stdio.h>\n\nstruct Calisan {\n    char isim[50];\n    char pozisyon[50];\n    float maas;\n};\n\n// Toplam maaşı hesaplayan fonksiyon\nfloat toplamMaas(struct Calisan calisanlar[], int sayi) {\n    float toplam = 0;\n    for (int i = 0; i < sayi; i++) {\n        toplam += calisanlar[i].maas;\n    }\n    return toplam;\n}\n\nint main() {\n    struct Calisan calisanlar[3];\n    // Çalışan bilgilerini tanımlıyoruz.\n    strcpy(calisanlar[0].isim, \"Elif\");\n    strcpy(calisanlar[0].pozisyon, \"Mühendis\");\n    calisanlar[0].maas = 5000;\n    \n    strcpy(calisanlar[1].isim, \"Murat\");\n    strcpy(calisanlar[1].pozisyon, \"Analist\");\n    calisanlar[1].maas = 6000;\n    \n    strcpy(calisanlar[2].isim, \"Zeynep\");\n    strcpy(calisanlar[2].pozisyon, \"Yönetici\");\n    calisanlar[2].maas = 8000;\n    \n    // Toplam maaşı hesaplama ve yazdırma\n    float toplam = toplamMaas(calisanlar, 3);\n    printf(\"Toplam Maaş: %.2f\\n\", toplam);\n\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:20.112761"
  },
  {
    "question": "Aşağıdaki kodda, bir 'Kitap' yapısı tanımlanmıştır. Kod çalıştırıldığında beklenmeyen bir sonuç alıyorum. Nedenini ve çözümünü açıkla. Kod: \n\n#include <stdio.h>\n\nstruct Kitap {\n    char ad[50];\n    char yazar[50];\n    int sayfaSayisi;\n};\n\nint main() {\n    struct Kitap kitap1;\n    printf(\"Kitap adı: \");\n    scanf(\"%s\", kitap1.ad);\n    printf(\"Yazar adı: \");\n    scanf(\"%s\", kitap1.yazar);\n    printf(\"Sayfa sayısı: \");\n    scanf(\"%d\", kitap1.sayfaSayisi);\n    printf(\"Kitap: %s, Yazar: %s, Sayfa Sayısı: %d\\n\", kitap1.ad, kitap1.yazar, kitap1.sayfaSayisi);\n    return 0;\n}",
    "answer": "Kodda, 'scanf' fonksiyonu kullanılırken '%s' format belirleyicisi kullanılmış. Bu, kullanıcıdan alınan girdi için bir dizi bekler. Ancak, kullanıcı 'ad' veya 'yazar' için bir boşluk içeren bir isim girerse ('Ali Vefa' gibi) scanf, ilk boşluğa kadar olan kısmı okuyacak ve geri kalanını atlayacaktır. Bu durum, sadece ilk kelimenin okunmasına ve ikinci kelimenin kaybolmasına yol açar. Çözüm olarak, 'fgets' fonksiyonu kullanılabilir. Bu, boşluk içeren isimleri de düzgün bir şekilde okuyabilir. Örneğin:\n\n    fgets(kitap1.ad, sizeof(kitap1.ad), stdin);\n    fgets(kitap1.yazar, sizeof(kitap1.yazar), stdin);",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:35.377375"
  },
  {
    "question": "Aşağıdaki kodda 'Ogrenci' yapısını tanımlıyorum. Ancak kodda öğrenci bilgilerini ekrana yazdırırken sorun yaşıyorum. Kodda hata var mı? Hatanın sebebini ve çözümünü açıkla. Kod: \n\n#include <stdio.h>\n\nstruct Ogrenci {\n    char isim[30];\n    int numara;\n};\n\nint main() {\n    struct Ogrenci ogrenci1;\n    ogrenci1.numara = 12345;\n    printf(\"Öğrenci numarası: %d\\n\", ogrenci1.numara);\n    printf(\"Öğrenci ismi: %s\\n\", ogrenci1.isim);\n    return 0;\n}",
    "answer": "Kodda 'Ogrenci' yapısının 'isim' alanı tanımlanmış, ancak bu alana bir değer atanmadığı için 'printf' fonksiyonuyla yazdırırken belirsiz bir değer (çöp değer) çıkacaktır. C dilinde dizilere atanan değerler, tanımlandıklarında otomatikman sıfırlanmaz veya atanmaz, bu yüzden 'isim' alanını kullanmadan önce bir değer atamak gerekir. Çözüm olarak, 'isim' alanına bir değer atamak için şöyle bir ekleme yapmalısınız:\n\n    strcpy(ogrenci1.isim, \"Ahmet\");  // <string.h> kütüphanesi ile kullanılmalı\n\nBu ekleme ile 'isim' alanı doğru bir şekilde yazdırılacaktır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:35.377503"
  },
  {
    "question": "Bir kitap yapısını tanımladım ve kitapların bilgilerini tutmak için bir dizi oluşturdum. Ancak, dizideki kitapların sayısını doğru bir şekilde hesaplayamıyorum. Kodum şöyle: \n\n```c\n#include <stdio.h>\n\nstruct Book {\n    char title[50];\n    char author[50];\n    int year;\n};\n\nint main() {\n    struct Book books[5];\n    int count = 0;\n    for (int i = 0; i <= 5; i++) {\n        printf(\"Kitap başlığı: \");\n        fgets(books[i].title, 50, stdin);\n        printf(\"Yazar: \");\n        fgets(books[i].author, 50, stdin);\n        printf(\"Yıl: \");\n        scanf(\"%d\", &books[i].year);\n        count++;\n    }\n    printf(\"Toplam kitap sayısı: %d\\n\", count);\n    return 0;\n}\n``` \nKodda hangi hata var ve nasıl düzeltilir?",
    "answer": "Kodda bir hata var: `for (int i = 0; i <= 5; i++)` döngüsünde dizinin boyutunu aşan bir indeks kullanıyorsunuz. Dizi boyutu 5 olduğuna göre indeksler 0'dan 4'e kadar olmalıdır. Yani döngü koşulunu `i < 5` olarak değiştirmelisiniz. Ayrıca, `scanf` kullanıldığında `fgets` sonrası bir newline karakteri kalabilir, bu yüzden `scanf`'dan sonra `getchar()` ile bu karakteri temizlemeyi düşünebilirsiniz. Düzeltilmiş kod şöyle olmalı: \n\n```c\n#include <stdio.h>\n\nstruct Book {\n    char title[50];\n    char author[50];\n    int year;\n};\n\nint main() {\n    struct Book books[5];\n    int count = 0;\n    for (int i = 0; i < 5; i++) {\n        printf(\"Kitap başlığı: \");\n        fgets(books[i].title, 50, stdin);\n        printf(\"Yazar: \");\n        fgets(books[i].author, 50, stdin);\n        printf(\"Yıl: \");\n        scanf(\"%d\", &books[i].year);\n        getchar(); // newline temizleme\n        count++;\n    }\n    printf(\"Toplam kitap sayısı: %d\\n\", count);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:56.452329"
  },
  {
    "question": "Bir çalışanın bilgilerini tutmak için bir struct tanımladım. Ancak, çalışanın bilgilerini ekrana yazdırdığımda yanlış değerler görünüyor. Kodum şöyle: \n\n```c\n#include <stdio.h>\n\nstruct Employee {\n    int id;\n    char name[30];\n    float salary;\n};\n\nvoid printEmployee(struct Employee emp) {\n    printf(\"Çalışan ID: %d\\n\", emp.id);\n    printf(\"Çalışan Adı: %s\\n\", emp.name);\n    printf(\"Maaş: %.2f\\n\", emp.salary);\n}\n\nint main() {\n    struct Employee emp;\n    emp.id = 1;\n    strcpy(emp.name, \"Ali\");\n    emp.salary = 2500.50;\n    printEmployee(emp);\n    return 0;\n}\n``` \nHata nedir ve nasıl düzeltirim?",
    "answer": "Kodda bir hata var: `strcpy` fonksiyonu kullanıldığı için `string.h` kütüphanesini dahil etmelisiniz. Bu kütüphane, karakter dizilerini kopyalamak için gerekli olan `strcpy` fonksiyonunu içerir. Ayrıca, `printEmployee` fonksiyonu çağrıldığında, eğer `emp` yapısının bir elemanına erişirken bir hata olursa istenmeyen sonuçlar alabilirsiniz. Ancak bu kodda `strcpy` kütüphanesi eksik olduğu için çalışan adı yazdırılamaz. Düzeltmek için kodun başına `#include <string.h>` satırını eklemelisiniz. Düzeltme sonrası kod şöyle olmalı: \n\n```c\n#include <stdio.h>\n#include <string.h> // string.h kütüphanesini ekleyin\n\nstruct Employee {\n    int id;\n    char name[30];\n    float salary;\n};\n\nvoid printEmployee(struct Employee emp) {\n    printf(\"Çalışan ID: %d\\n\", emp.id);\n    printf(\"Çalışan Adı: %s\\n\", emp.name);\n    printf(\"Maaş: %.2f\\n\", emp.salary);\n}\n\nint main() {\n    struct Employee emp;\n    emp.id = 1;\n    strcpy(emp.name, \"Ali\");\n    emp.salary = 2500.50;\n    printEmployee(emp);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:55:56.452494"
  },
  {
    "question": "Bir 'Person' yapısını tanımladım ve bu yapı içinde 'name' (char array) ve 'age' (int) alanları var. Aşağıdaki kodu çalıştırdığımda beklenmedik sonuçlar alıyorum. Hatanın nedenini bul ve düzelt.",
    "answer": "Kodunuzu inceleyelim. Aşağıdaki gibi bir yapı tanımladığınızı düşünelim:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Person {\n    char name[50];\n    int age;\n};\n\nint main() {\n    struct Person p;\n    strcpy(p.name, \"Alice\");\n    p.age = 30;\n    printf(\"Name: %s, Age: %d\\n\", p.name, p.age);\n}\n```\n\nEğer bu kodu çalıştırdığınızda beklenmedik bir sonuç alıyorsanız, muhtemelen 'name' alanına atadığınız değerin boyutunu aşan bir kopyalama yapmaya çalışıyorsunuz. Örneğin, `strcpy(p.name, \"A very long name that exceeds the buffer size\");` yaparsanız, bu bellek taşmasına (buffer overflow) yol açar ve programınız çökebilir. Bunun önüne geçmek için, 'strncpy' fonksiyonunu kullanarak kopyalama işlemini sınırlandırmalısınız:\n\n```c\nstrncpy(p.name, \"A very long name that exceeds the buffer size\", sizeof(p.name) - 1);\n```\n\nBu şekilde, 'name' alanına sadece 49 karakter kopyalanacak ve sonuna null karakter ekleyerek diziyi güvenli bir şekilde sonlandırmış olacaksınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:08.646762"
  },
  {
    "question": "Aşağıdaki kodda kullanıcılardan bir dizi 'Book' yapısı oluşturuyorum. Ancak, kitapların sayfa sayılarını toplamak istediğimde sonuç her zaman sıfır çıkıyor. Hatanın sebebini bul ve düzelt.",
    "answer": "Kodunuz aşağıdaki gibi olabilir:\n\n```c\n#include <stdio.h>\n\nstruct Book {\n    char title[100];\n    int pages;\n};\n\nint main() {\n    struct Book books[3];\n    int total_pages = 0;\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"Enter book title: \");\n        scanf(\"%s\", books[i].title);\n        printf(\"Enter number of pages: \");\n        scanf(\"%d\", &books[i].pages);\n    }\n\n    for (int i = 0; i < 3; i++) {\n        total_pages += books[i].pages;\n    }\n\n    printf(\"Total pages: %d\\n\", total_pages);\n    return 0;\n}\n```\n\nEğer bu kodu çalıştırdığınızda toplam sayfa sayısının her zaman sıfır olduğunu görüyorsanız, muhtemelen kullanıcıdan alınan sayfa sayısını doğru bir şekilde okumuyorsunuz veya 'pages' alanını güncellemiyorsunuz. Bu durumda, 'scanf' fonksiyonunun format dizgisinin doğru olduğundan emin olmalısınız. Ayrıca, 'pages' alanını kontrol edin ve doğru bir değer atandığından emin olun. Önerilen düzeltme şu şekildedir:\n\n```c\nprintf(\"Enter number of pages: \");\nscanf(\"%d\", &books[i].pages);\n```\n\nEğer bu kodu doğru bir şekilde çalıştırırsanız, toplam sayfa sayısını doğru bir şekilde hesaplayabilirsiniz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:08.646837"
  },
  {
    "question": "C dilinde bir 'Öğrenci' struct'ı nasıl tanımlarım ve bu struct'ı kullanarak bir öğrencinin bilgilerini nasıl saklarım?",
    "answer": "C dilinde bir 'Öğrenci' struct'ı tanımlamak için öncelikle struct anahtar kelimesini kullanmalıyız. Aşağıda basit bir 'Öğrenci' struct'ı tanımı ve bu struct'ı kullanarak bir öğrencinin bilgilerini nasıl saklayacağımızı gösteren bir örnek var:\n\n```c\n#include <stdio.h>\n\n// Öğrenci struct'ı tanımlama\nstruct Ogrenci {\n    char isim[50];\n    int yas;\n    float notOrtalamasi;\n};\n\nint main() {\n    struct Ogrenci ogrenci1; // Ogrenci struct'ından bir örnek oluşturma\n\n    // Öğrenci bilgilerini atama\n    snprintf(ogrenci1.isim, sizeof(ogrenci1.isim), \"Ahmet\");\n    ogrenci1.yas = 20;\n    ogrenci1.notOrtalamasi = 3.5;\n\n    // Öğrenci bilgilerini ekrana yazdırma\n    printf(\"Öğrencinin Ismi: %s\\n\", ogrenci1.isim);\n    printf(\"Yaşı: %d\\n\", ogrenci1.yas);\n    printf(\"Not Ortalaması: %.2f\\n\", ogrenci1.notOrtalamasi);\n\n    return 0;\n}\n```\nBu örnekte, 'Ogrenci' adında bir struct tanımlıyoruz. Bu struct içerisinde öğrencinin ismi, yaşı ve not ortalaması için uygun veri tiplerini kullanıyoruz. Daha sonra, bu struct'tan bir örnek oluşturup, öğrencinin bilgilerini saklayabiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:19.756833"
  },
  {
    "question": "Bir 'Kitap' struct'ı tanımlayıp, bu struct ile kitap bilgilerini nasıl yönetebilirim?",
    "answer": "C dilinde kitap bilgilerini saklamak için bir 'Kitap' struct'ı tanımlayabiliriz. Bu struct, kitabın adını, yazarını ve sayfa sayısını tutabilir. Aşağıda bu yapıyı nasıl oluşturacağınız ve kullanacağınız ile ilgili bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\n// Kitap struct'ı tanımlama\nstruct Kitap {\n    char ad[100];\n    char yazar[50];\n    int sayfaSayisi;\n};\n\nint main() {\n    struct Kitap kitap1; // Kitap struct'ından bir örnek oluşturma\n\n    // Kitap bilgilerini atama\n    snprintf(kitap1.ad, sizeof(kitap1.ad), \"Sefiller\");\n    snprintf(kitap1.yazar, sizeof(kitap1.yazar), \"Victor Hugo\");\n    kitap1.sayfaSayisi = 1200;\n\n    // Kitap bilgilerini ekrana yazdırma\n    printf(\"Kitap Adı: %s\\n\", kitap1.ad);\n    printf(\"Yazar: %s\\n\", kitap1.yazar);\n    printf(\"Sayfa Sayısı: %d\\n\", kitap1.sayfaSayisi);\n\n    return 0;\n}\n```\nBu örnekte, 'Kitap' adında bir struct tanımlıyoruz. Kitabın adı, yazarı ve sayfa sayısını bu struct içerisinde saklıyoruz. Daha sonra, bu struct'tan bir örnek oluşturarak kitap bilgilerini atıyor ve ekrana yazdırıyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:19.756877"
  },
  {
    "question": "Bir öğrencinin notlarını ve bilgilerini tutmak için bir struct yapısı nasıl oluşturabilirim? Örnek bir kodla göster.",
    "answer": "C dilinde bir öğrencinin bilgilerini tutmak için bir struct yapısı tanımlayabiliriz. Örneğin, öğrencinin adı, soyadı ve notunu içeren bir struct oluşturalım. Bu yapıyı kullanarak bir öğrenci nesnesi oluşturabiliriz.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Öğrenci bilgilerini tutan struct yapısı\nstruct Ogrenci {\n    char ad[50];\n    char soyad[50];\n    float not;\n};\n\nint main() {\n    // Öğrenci nesnesi tanımlama\n    struct Ogrenci ogrenci1;\n\n    // Öğrenci bilgilerini atama\n    strcpy(ogrenci1.ad, \"Ali\");\n    strcpy(ogrenci1.soyad, \"Yılmaz\");\n    ogrenci1.not = 85.5;\n\n    // Öğrenci bilgilerini yazdırma\n    printf(\"Öğrenci Adı: %s %s\\n\", ogrenci1.ad, ogrenci1.soyad);\n    printf(\"Notu: %.2f\\n\", ogrenci1.not);\n\n    return 0;\n}\n```\nBu kodda bir `Ogrenci` struct'ı tanımladık. `ad`, `soyad` ve `not` adında üç alanı var. `main` fonksiyonu içinde bir `Ogrenci` nesnesi oluşturduk, ardından bu nesneye değer atayıp bilgileri ekrana yazdırdık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:33.503216"
  },
  {
    "question": "Bir araba bilgilerini tutmak için bir struct oluşturmak istiyorum. Arabanın marka, model, ve üretim yılını içeren bir yapı nasıl oluşturulur? Örnek bir kodla açıkla.",
    "answer": "Bir araba bilgilerini tutmak için benzer şekilde bir struct yapısı tanımlayabiliriz. Arabanın bilgilerini saklamak için `marka`, `model` ve `yil` alanlarını içeren bir struct oluşturmalıyız.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Araba bilgilerini tutan struct yapısı\nstruct Araba {\n    char marka[30];\n    char model[30];\n    int yil;\n};\n\nint main() {\n    // Araba nesnesi tanımlama\n    struct Araba araba1;\n\n    // Araba bilgilerini atama\n    strcpy(araba1.marka, \"Toyota\");\n    strcpy(araba1.model, \"Corolla\");\n    araba1.yil = 2020;\n\n    // Araba bilgilerini yazdırma\n    printf(\"Araba Markası: %s\\n\", araba1.marka);\n    printf(\"Model: %s\\n\", araba1.model);\n    printf(\"Üretim Yılı: %d\\n\", araba1.yil);\n\n    return 0;\n}\n```\nBu kodda `Araba` adında bir struct tanımladık. Bu struct içinde `marka`, `model` ve `yil` alanları var. `main` fonksiyonu içinde bir `Araba` nesnesi oluşturduk ve bu nesneye değer atadıktan sonra bilgileri ekrana yazdırdık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:33.503311"
  },
  {
    "question": "Bir oyun geliştirmekteyim ve oyundaki karakterlerin özelliklerini yönetmek için struct yapısını nasıl kullanabilirim?",
    "answer": "Oyun karakterleri için bir struct tanımlamak, karakterlerin özelliklerini düzenli bir şekilde saklamanızı sağlar. Örneğin, her karakterin adı, sağlığı ve gücü olabilir. Aşağıda bu yapıyı nasıl oluşturabileceğinizi görebilirsiniz:\n\n```c\n#include <stdio.h>\n\n// Karakter özelliklerini tanımlayan bir struct oluşturuyoruz.\ntypedef struct {\n    char name[30];\n    int health;\n    int power;\n} Character;\n\nint main() {\n    // İki karakter oluşturuyoruz.\n    Character hero, villain;\n\n    // Karakterleri dolduruyoruz.\n    snprintf(hero.name, sizeof(hero.name), \"Kahraman\");\n    hero.health = 100;\n    hero.power = 25;\n\n    snprintf(villain.name, sizeof(villain.name), \"Kötü Adam\");\n    villain.health = 80;\n    villain.power = 30;\n\n    // Karakterlerin bilgilerini yazdırıyoruz.\n    printf(\"Karakter: %s, Sağlık: %d, Güç: %d\\n\", hero.name, hero.health, hero.power);\n    printf(\"Karakter: %s, Sağlık: %d, Güç: %d\\n\", villain.name, villain.health, villain.power);\n\n    return 0;\n}\n```\nYukarıdaki kodda, iki karakter oluşturuyoruz ve onların özelliklerini tanımlıyoruz. Struct sayesinde, karakterlerin tüm özelliklerini tek bir yapı altında toplamak, kodun okunabilirliğini artırır ve yönetilmesini kolaylaştırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:47.294816"
  },
  {
    "question": "Bir öğrenci veritabanı uygulaması geliştiriyorum. Bu uygulamada öğrenci bilgilerini saklamak için struct yapısını nasıl kullanabilirim?",
    "answer": "Öğrenci bilgilerini saklamak için bir struct tanımlamak, her öğrencinin bilgilerini düzenli bir şekilde saklamanıza yardımcı olur. Örneğin, her öğrencinin adı, soyadı ve öğrenci numarası olabilir. İşte bu yapıyı nasıl oluşturabileceğinizi gösteren bir örnek:\n\n```c\n#include <stdio.h>\n\n// Öğrenci bilgilerini tutan bir struct tanımlıyoruz.\ntypedef struct {\n    char firstName[30];\n    char lastName[30];\n    int studentID;\n} Student;\n\nint main() {\n    // Bir öğrenci oluşturuyoruz.\n    Student student1;\n\n    // Öğrencinin bilgilerini dolduruyoruz.\n    snprintf(student1.firstName, sizeof(student1.firstName), \"Ali\");\n    snprintf(student1.lastName, sizeof(student1.lastName), \"Yılmaz\");\n    student1.studentID = 123456;\n\n    // Öğrencinin bilgilerini yazdırıyoruz.\n    printf(\"Öğrenci Adı: %s %s, Öğrenci No: %d\\n\", student1.firstName, student1.lastName, student1.studentID);\n\n    return 0;\n}\n```\nBu kod parçasında, bir öğrenci için gerekli bilgileri tutan bir struct tanımladık. Daha sonra, bu struct kullanarak bir öğrencinin bilgilerini oluşturup yazdırıyoruz. Struct yapıları, veritabanınızda her bir öğrencinin bilgilerini saklamak için mükemmel bir yol sunar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:56:47.294865"
  },
  {
    "question": "Bir öğrencinin isim, soyisim, ve not bilgilerini tutmak için bir struct yapısı oluşturun ve bu bilgileri ekrana yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'ogrenci' adında struct tanımlayalım. Bu struct, öğrencinin ismini, soyismini ve notunu tutacak. Daha sonra bu bilgileri ekrana yazdıran bir fonksiyon yazalım. \n\n```c\n#include <stdio.h>\n\n// Öğrenci bilgilerini tutacak struct tanımı\nstruct Ogrenci {\n    char isim[50];\n    char soyisim[50];\n    float not;\n};\n\n// Öğrenci bilgilerini ekrana yazdıran fonksiyon\nvoid ogrenciBilgileriniYazdir(struct Ogrenci ogrenci) {\n    printf(\"Öğrenci Ismi: %s\\n\", ogrenci.isim);\n    printf(\"Öğrenci Soyismi: %s\\n\", ogrenci.soyisim);\n    printf(\"Öğrenci Notu: %.2f\\n\", ogrenci.not);\n}\n\nint main() {\n    struct Ogrenci ogr;  // Öğrenci değişkeni oluştur\n    // Öğrenci bilgilerini al\n    snprintf(ogr.isim, sizeof(ogr.isim), \"Ahmet\");\n    snprintf(ogr.soyisim, sizeof(ogr.soyisim), \"Yılmaz\");\n    ogr.not = 85.5;\n    // Bilgileri yazdır\n    ogrenciBilgileriniYazdir(ogr);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:01.991702"
  },
  {
    "question": "Bir kitabın yazar, başlık ve sayfa sayısını tutmak için bir struct oluşturun ve bu struct'ı kullanarak birkaç kitap bilgisi girip ekrana yazdırın.",
    "answer": "İlk olarak bir 'kitap' adında struct tanımlayalım. Bu struct, kitabın yazarını, başlığını ve sayfa sayısını tutacak. Daha sonra birkaç kitap bilgisi girip ekrana yazdıracak bir fonksiyon yazalım. \n\n```c\n#include <stdio.h>\n\n// Kitap bilgilerini tutacak struct tanımı\nstruct Kitap {\n    char yazar[50];\n    char baslik[100];\n    int sayfaSayisi;\n};\n\n// Kitap bilgilerini ekrana yazdıran fonksiyon\nvoid kitapBilgileriniYazdir(struct Kitap kitap) {\n    printf(\"Yazar: %s\\n\", kitap.yazar);\n    printf(\"Başlık: %s\\n\", kitap.baslik);\n    printf(\"Sayfa Sayısı: %d\\n\", kitap.sayfaSayisi);\n}\n\nint main() {\n    struct Kitap kitap1, kitap2;  // İki kitap değişkeni oluştur\n    // Kitap 1 bilgilerini al\n    snprintf(kitap1.yazar, sizeof(kitap1.yazar), \"Orhan Pamuk\");\n    snprintf(kitap1.baslik, sizeof(kitap1.baslik), \"Beyaz Kale\");\n    kitap1.sayfaSayisi = 210;\n    // Kitap 2 bilgilerini al\n    snprintf(kitap2.yazar, sizeof(kitap2.yazar), \"J.K. Rowling\");\n    snprintf(kitap2.baslik, sizeof(kitap2.baslik), \"Harry Potter ve Felsefe Taşı\");\n    kitap2.sayfaSayisi = 320;\n    // Kitap bilgilerini yazdır\n    printf(\"Kitap 1 Bilgileri:\\n\");\n    kitapBilgileriniYazdir(kitap1);\n    printf(\"\\nKitap 2 Bilgileri:\\n\");\n    kitapBilgileriniYazdir(kitap2);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:01.991796"
  },
  {
    "question": "Bir kitap kütüphanesi uygulaması için kitapları temsil eden bir struct yapısı oluşturun. Her kitabın adı, yazarı, yayın yılı ve ISBN numarası olmalıdır. Ardından bu struct'ı kullanarak birkaç kitap oluşturun ve bilgilerini yazdırın.",
    "answer": "Aşağıda, kitapları temsil eden bir struct yapısı ve bu yapıyı kullanarak birkaç kitap oluşturan bir C kodu örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Kitap yapısını tanımlıyoruz.\nstruct Kitap {\n    char ad[100];\n    char yazar[100];\n    int yayinYili;\n    char isbn[20];\n};\n\nint main() {\n    // Kitapları tanımlıyoruz.\n    struct Kitap kitap1, kitap2;\n\n    // İlk kitabın bilgilerini dolduruyoruz.\n    strcpy(kitap1.ad, \"Sefiller\");\n    strcpy(kitap1.yazar, \"Victor Hugo\");\n    kitap1.yayinYili = 1862;\n    strcpy(kitap1.isbn, \"978-1234567890\");\n\n    // İkinci kitabın bilgilerini dolduruyoruz.\n    strcpy(kitap2.ad, \"Suç ve Ceza\");\n    strcpy(kitap2.yazar, \"Fyodor Dostoyevski\");\n    kitap2.yayinYili = 1866;\n    strcpy(kitap2.isbn, \"978-0987654321\");\n\n    // Kitap bilgilerini yazdırıyoruz.\n    printf(\"Kitap 1: %s, Yazar: %s, Yayın Yılı: %d, ISBN: %s\\n\", kitap1.ad, kitap1.yazar, kitap1.yayinYili, kitap1.isbn);\n    printf(\"Kitap 2: %s, Yazar: %s, Yayın Yılı: %d, ISBN: %s\\n\", kitap2.ad, kitap2.yazar, kitap2.yayinYili, kitap2.isbn);\n\n    return 0;\n}\n```\nBu örnek, kitap bilgilerini saklamak ve yönetmek için bir struct yapısı kullanmaktadır. Kitapların isimleri, yazarları, yayın yılları ve ISBN numaraları için gerekli alanları içerir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:23.319425"
  },
  {
    "question": "Bir çalışan veri tabanı uygulaması için çalışanları temsil eden bir struct yapısı oluşturun. Her çalışanın adı, soyadı, pozisyonu, maaşı ve çalıştığı departmanı içermelidir. Ardından birkaç çalışan oluşturun ve bunların toplam maaşını hesaplayın.",
    "answer": "Aşağıda, çalışanları temsil eden bir struct yapısı ve bu yapıyı kullanarak birkaç çalışan oluşturan ve toplam maaşı hesaplayan bir C kodu örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Çalışan yapısını tanımlıyoruz.\nstruct Calisan {\n    char ad[50];\n    char soyad[50];\n    char pozisyon[50];\n    double maas;\n    char departman[50];\n};\n\nint main() {\n    // Çalışanları tanımlıyoruz.\n    struct Calisan calisan1, calisan2, calisan3;\n\n    // İlk çalışanın bilgilerini dolduruyoruz.\n    strcpy(calisan1.ad, \"Ahmet\");\n    strcpy(calisan1.soyad, \"Yılmaz\");\n    strcpy(calisan1.pozisyon, \"Mühendis\");\n    calisan1.maas = 7000.0;\n    strcpy(calisan1.departman, \"Yazılım\");\n\n    // İkinci çalışanın bilgilerini dolduruyoruz.\n    strcpy(calisan2.ad, \"Ayşe\");\n    strcpy(calisan2.soyad, \"Kara\");\n    strcpy(calisan2.pozisyon, \"Yönetici\");\n    calisan2.maas = 10000.0;\n    strcpy(calisan2.departman, \"Yönetim\");\n\n    // Üçüncü çalışanın bilgilerini dolduruyoruz.\n    strcpy(calisan3.ad, \"Mehmet\");\n    strcpy(calisan3.soyad, \"Demir\");\n    strcpy(calisan3.pozisyon, \"Analist\");\n    calisan3.maas = 8000.0;\n    strcpy(calisan3.departman, \"İnsan Kaynakları\");\n\n    // Toplam maaşı hesaplıyoruz.\n    double toplamMaas = calisan1.maas + calisan2.maas + calisan3.maas;\n\n    // Çalışan bilgilerini yazdırıyoruz.\n    printf(\"Toplam Maaş: %.2f\\n\", toplamMaas);\n\n    return 0;\n}\n```\nBu örnek, çalışan bilgilerini saklamak ve toplam maaşı hesaplamak için bir struct yapısı kullanmaktadır. Her çalışanın adı, soyadı, pozisyonu, maaşı ve departmanı için gerekli alanları içermektedir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:23.319501"
  },
  {
    "question": "Bir kitaplığı temsil eden bir 'Book' yapısı oluşturun. Bu yapıda kitap adı, yazar adı, ISBN numarası ve yayınevi bilgilerini içermelidir. Ayrıca bu yapıyı kullanarak kitap ekleme, kitap silme ve kitap listesini görüntüleme işlevlerini içeren bir kitaplık yönetim sistemi yazın.",
    "answer": "Öncelikle 'Book' adında bir yapıyı tanımlıyoruz. Ardından, bir dizi oluşturarak kitapları saklayacağız. 'addBook', 'removeBook' ve 'displayBooks' fonksiyonlarını tanımlayıp bu işlevleri gerçekleştireceğiz. İşte kod örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_BOOKS 100\n\nstruct Book {\n    char title[100];\n    char author[100];\n    char isbn[20];\n    char publisher[100];\n};\n\nstruct Book library[MAX_BOOKS];\nint bookCount = 0;\n\nvoid addBook(char *title, char *author, char *isbn, char *publisher) {\n    if (bookCount < MAX_BOOKS) {\n        strcpy(library[bookCount].title, title);\n        strcpy(library[bookCount].author, author);\n        strcpy(library[bookCount].isbn, isbn);\n        strcpy(library[bookCount].publisher, publisher);\n        bookCount++;\n        printf(\"Kitap eklendi: %s\\n\", title);\n    } else {\n        printf(\"Kitap sayısı sınırını aştınız!\\n\");\n    }\n}\n\nvoid removeBook(char *isbn) {\n    int found = 0;\n    for (int i = 0; i < bookCount; i++) {\n        if (strcmp(library[i].isbn, isbn) == 0) {\n            found = 1;\n            for (int j = i; j < bookCount - 1; j++) {\n                library[j] = library[j + 1];\n            }\n            bookCount--;\n            printf(\"Kitap silindi: %s\\n\", library[i].title);\n            break;\n        }\n    }\n    if (!found) {\n        printf(\"Kitap bulunamadı!\\n\");\n    }\n}\n\nvoid displayBooks() {\n    printf(\"Kitap Listesi:\\n\");\n    for (int i = 0; i < bookCount; i++) {\n        printf(\"[%d] %s - %s (ISBN: %s, Yayınevi: %s)\\n\", i + 1, library[i].title, library[i].author, library[i].isbn, library[i].publisher);\n    }\n}\n\nint main() {\n    addBook(\"C Programlama Dili\", \"Brian W. Kernighan\", \"978-0131103627\", \"Prentice Hall\");\n    addBook(\"Temel Veri Yapıları\", \"Mark Allen Weiss\", \"978-0132321580\", \"Addison-Wesley\");\n    displayBooks();\n    removeBook(\"978-0131103627\");\n    displayBooks();\n    return 0;\n}\n```\nBu kodda önce kitap eklemek, silmek ve listelemek için gerekli fonksiyonları tanımladık. Yapı ve dizi kullanarak kitap bilgilerini saklıyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:46.574526"
  },
  {
    "question": "Bir öğrenci yönetim sistemi oluşturun. Bu sistemde her öğrenciyi temsil eden bir 'Student' yapısı oluşturun. Öğrenci adı, soyadı, numarası ve not ortalaması gibi bilgileri içermelidir. Ayrıca, belirli bir not ortalamasının üzerindeki öğrencileri listeleyen bir fonksiyon yazın.",
    "answer": "Öncelikle 'Student' adında bir yapı tanımlıyoruz. Öğrenci bilgilerini saklamak için bir dizi oluşturacağız. 'addStudent' ve 'listStudentsAboveAverage' fonksiyonları ile öğrencileri ekleme ve not ortalamasına göre listeleme işlemlerini gerçekleştireceğiz. İşte kod örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_STUDENTS 100\n\ntypedef struct {\n    char firstName[50];\n    char lastName[50];\n    int studentId;\n    float gpa;\n} Student;\n\nStudent students[MAX_STUDENTS];\nint studentCount = 0;\n\nvoid addStudent(char *firstName, char *lastName, int studentId, float gpa) {\n    if (studentCount < MAX_STUDENTS) {\n        strcpy(students[studentCount].firstName, firstName);\n        strcpy(students[studentCount].lastName, lastName);\n        students[studentCount].studentId = studentId;\n        students[studentCount].gpa = gpa;\n        studentCount++;\n        printf(\"Öğrenci eklendi: %s %s\\n\", firstName, lastName);\n    } else {\n        printf(\"Öğrenci sayısı sınırını aştınız!\\n\");\n    }\n}\n\nvoid listStudentsAboveAverage(float average) {\n    printf(\"Not ortalaması %.2f olan öğrenciler:\\n\", average);\n    for (int i = 0; i < studentCount; i++) {\n        if (students[i].gpa > average) {\n            printf(\"[%d] %s %s - GPA: %.2f\\n\", students[i].studentId, students[i].firstName, students[i].lastName, students[i].gpa);\n        }\n    }\n}\n\nint main() {\n    addStudent(\"Ali\", \"Yılmaz\", 101, 3.5);\n    addStudent(\"Ayşe\", \"Kara\", 102, 2.8);\n    addStudent(\"Mehmet\", \"Demir\", 103, 3.9);\n    listStudentsAboveAverage(3.0);\n    return 0;\n}\n```\nBu kodda 'Student' yapısını tanımladık ve öğrenci bilgilerini saklamak için bir dizi kullandık. Öğrenci eklemek ve belirli bir not ortalamasının üzerindeki öğrencileri listelemek için gerekli fonksiyonları oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:46.574610"
  },
  {
    "question": "Bir öğrenci kayıt sistemi için struct tanımlarken, öğrenci bilgilerini saklamak amacıyla bir struct oluşturdum. Ancak performans açısından nasıl iyileştirme yapabilirim?",
    "answer": "Öğrenci bilgilerini saklamak için oluşturduğunuz struct muhtemelen aşağıdaki gibi bir yapıya sahip olabilir:\n\n```c\ntypedef struct {\n    char name[50];\n    int age;\n    float gpa;\n} Student;\n```\n\nBu yapı, temel bilgileri saklamak için yeterli olabilir. Ancak, struct içinde kullanılan `char` dizilerinin sabit boyutlu olması, bellek israfına neden olabilir. Eğer öğrenci isimleri daha kısa ya da daha uzun olabiliyorsa, `char *name` şeklinde bir işaretçi kullanarak dinamik bellek yönetimini tercih edebilirsiniz. Bu şekilde, her öğrenci için yalnızca gerekli olan kadar bellek ayırmış olursunuz. Ayrıca, `gpa` gibi sayısal verilerin daha hızlı karşılaştırılması ve saklanması için struct'ınızı şu şekilde yeniden tasarlayabilirsiniz:\n\n```c\ntypedef struct {\n    char *name;\n    int age;\n    float gpa;\n} Student;\n```\n\nDinamik bellek kullanırken, ihtiyaç duyduğunuz yerlerde `malloc` ve `free` fonksiyonları ile bellek yönetimini iyi yapmayı unutmayın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:59.243413"
  },
  {
    "question": "Büyük bir veri kümesini saklamak için bir struct dizisi kullanıyorum. Ancak dizinin boyutunu değiştirmek istiyorum. Bu durumda nasıl bir yol izlemeliyim?",
    "answer": "Eğer bir struct dizisi kullanıyorsanız, dizinin boyutunu değiştirmek için genellikle statik diziler yerine dinamik bellek kullanmak daha uygundur. Örneğin, aşağıdaki gibi bir yapı tanımınız ve diziniz olabilir:\n\n```c\ntypedef struct {\n    int id;\n    char name[100];\n} Item;\n\nItem items[100]; // Statik dizi\n```\n\nBu durumda, dizinin boyutunu değiştirmek istediğinizde kodunuzu güncellemek zorunda kalırsınız. Bunun yerine, `malloc` ile dinamik bir dizi oluşturabilirsiniz:\n\n```c\nItem *items;\nint size = 0;\n\nvoid initialize_items(int new_size) {\n    items = (Item *)malloc(new_size * sizeof(Item));\n    size = new_size;\n}\n```\n\nDizinin boyutunu değiştirmek istediğinizde, `realloc` fonksiyonunu kullanabilirsiniz:\n\n```c\nitems = (Item *)realloc(items, new_size * sizeof(Item));\n```\n\nBu şekilde, dizi boyutunu değiştirmek istediğinizde daha esnek bir yapı elde edersiniz. Her zaman `malloc`, `realloc` ve `free` kullanımında bellek sızıntılarına dikkat etmeyi unutmayın!",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:57:59.243496"
  },
  {
    "question": "Bir oyun geliştirme projesinde, oyuncu bilgilerini tutan bir 'Player' struct'ı var. Ancak, bu struct içerisinde bazı alanlar gereksiz yere büyük yer kaplıyor. Bu durumu nasıl optimize edersiniz?",
    "answer": "Öncelikle, 'Player' struct'ının tanımını gözden geçirelim. Eğer struct içerisinde bazı alanlar fazla yer kaplıyorsa, bunları optimize etmek için uygun veri tiplerini kullanmak önemli. Örneğin, oyuncunun seviyesini tutan bir alan int yerine uint8_t olarak tanımlanabilir. Bu sayede 1 byte'lık bir alan kullanarak 0-255 arası değer tutabiliriz. Ayrıca, string gibi karakter dizilerini tutuyorsak, bu dizilerin uzunluklarını sınırlamak ve mümkünse sabit boyutlu diziler kullanmak da bellek tasarrufu sağlar. Örnek olarak: \n\n```\ntypedef struct {\n    char name[50]; \n    uint8_t level; \n    int score;\n} Player;\n```\n\nBu yapı, bellek kullanımını optimize eder ve oyuncu bilgilerinin daha verimli bir şekilde saklanmasını sağlar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:58:07.996917"
  },
  {
    "question": "Bir veri analizi uygulamasında, 'DataPoint' isimli bir struct içinde, farklı verilerin tutulduğu alanlar var. Ancak, verilerin türleri arasında sık sık dönüşümler yapılıyor. Bu durumu daha verimli hale getirmek için ne gibi iyileştirmeler yapabilirsiniz?",
    "answer": "Veri türleri arasında dönüşüm yapmak, hem performansı düşürebilir hem de kodun karmaşıklığını artırabilir. 'DataPoint' struct'ını gözden geçirerek, verilerin türlerini daha uygun şekilde seçmek önemlidir. Örneğin, yalnızca belirli bir aralıkta negatif ve pozitif değerler tutacak bir verimiz varsa, bu veriyi int yerine daha dar bir data tipi olan int16_t veya float yerine daha az yer kaplayan float kullanarak tanımlayabiliriz. Ayrıca, farklı veri türleri için bir union kullanarak bellek kullanımını optimize edebiliriz. Örnek: \n\n```\ntypedef union {\n    float floatValue;\n    int intValue;\n    char stringValue[20];\n} DataValue;\n\ntypedef struct {\n    DataValue value;\n    char type;\n} DataPoint;\n```\n\nBu yapı, yalnızca bir veri türünü aynı anda saklayarak bellek tasarrufu sağlarken, 'type' alanıyla hangi türde veri tutulduğunu kolayca belirlemenizi sağlar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-05-31T17:58:07.997012"
  },
  {
    "question": "Bir öğrenci bilgilerini tutmak için bir union tanımlayın. Öğrencinin yaşı veya notu ile ilgili bilgiye erişim sağlayacak bir program yazın.",
    "answer": "C dilinde bir union kullanarak öğrencinin yaşı veya notunu tutabiliriz. Aşağıdaki kodda, 'Student' adında bir union tanımlıyoruz. Bu union, öğrencinin yaşını veya notunu saklayabilir. Yapılan seçim, öğrencinin bilgi türüne göre değişiklik gösterir.\n\n```c\n#include <stdio.h>\n\nunion Student {\n    int age;\n    float grade;\n};\n\nint main() {\n    union Student student;\n\n    // Öğrencinin yaşını belirle\n    student.age = 20;\n    printf(\"Öğrencinin yaşı: %d\\n\", student.age);\n\n    // Öğrencinin notunu belirle\n    student.grade = 85.5;\n    printf(\"Öğrencinin notu: %.2f\\n\", student.grade);\n\n    // Yaş ve not birbirini etkileyecektir, son değer son atanan değerdir.\n    printf(\"Yaş: %d, Not: %.2f\\n\", student.age, student.grade);\n    return 0;\n}\n```\nBu örnekte, 'student' union'ı önce yaş değerini saklar, ardından not değerini saklamak için güncellenir. Ancak union kullanımı nedeniyle, sonuncu atanan değer her zaman geçerli olacaktır. Kullanıcı 'student.age' veya 'student.grade' değişkenlerini kullanırken dikkat etmelidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:24.393444"
  },
  {
    "question": "Bir renk modelini temsil eden bir union tanımlayın. RGB veya HSV değerlerini tutan bir program yazın. Kullanıcıdan hangi değeri girmek istediğini sorsun.",
    "answer": "C dilinde bir renk modelini temsil etmek için RGB ve HSV değerlerini saklayacak bir union tanımlayabiliriz. Aşağıdaki kodda 'Color' adında bir union tanımlıyoruz ve kullanıcıdan hangi değerleri girmek istediğini soruyoruz.\n\n```c\n#include <stdio.h>\n\nunion Color {\n    struct {\n        unsigned char r;\n        unsigned char g;\n        unsigned char b;\n    } rgb;\n    struct {\n        float h;\n        float s;\n        float v;\n    } hsv;\n};\n\nint main() {\n    union Color color;\n    int choice;\n\n    printf(\"1. RGB Değerleri\\n\");\n    printf(\"2. HSV Değerleri\\n\");\n    printf(\"Hangi değeri girmek istersiniz? (1 veya 2): \");\n    scanf(\"%d\", &choice);\n\n    if (choice == 1) {\n        printf(\"Renginin Kırmızı (0-255) değerini girin: \");\n        scanf(\"%hhu\", &color.rgb.r);\n        printf(\"Renginin Yeşil (0-255) değerini girin: \");\n        scanf(\"%hhu\", &color.rgb.g);\n        printf(\"Renginin Mavi (0-255) değerini girin: \");\n        scanf(\"%hhu\", &color.rgb.b);\n        printf(\"RGB Değeri: (%d, %d, %d)\\n\", color.rgb.r, color.rgb.g, color.rgb.b);\n    } else if (choice == 2) {\n        printf(\"Renginin Hue (0-360) değerini girin: \");\n        scanf(\"%f\", &color.hsv.h);\n        printf(\"Renginin Saturation (0-1) değerini girin: \");\n        scanf(\"%f\", &color.hsv.s);\n        printf(\"Renginin Value (0-1) değerini girin: \");\n        scanf(\"%f\", &color.hsv.v);\n        printf(\"HSV Değeri: (%.2f, %.2f, %.2f)\\n\", color.hsv.h, color.hsv.s, color.hsv.v);\n    } else {\n        printf(\"Geçersiz seçim!\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, kullanıcıdan RGB veya HSV değerlerini girmesini istiyoruz. Kullanıcı, '1' veya '2' seçerek hangi renk modelini girmek istediğini belirtiyor. Union, her iki renk modelini de tutmamızı sağlıyor, ancak yalnızca birinin değeri geçerli olacaktır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:24.393500"
  },
  {
    "question": "Bir öğrenci bilgilerini tutmak için bir union kullanarak bir C programı yazın. Union içinde öğrencinin adı, numarası ve notu olacak. Kısmi kodu tamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nunion OgrenciBilgileri {\n    char ad[50];\n    int numara;\n    float not;\n};\n\nstruct Ogrenci {\n    union OgrenciBilgileri bilgilere;\n    char bilgiTuru; // 'A' için ad, 'N' için numara, 'O' için not\n};\n\nint main() {\n    struct Ogrenci ogrenci;\n\n    // Öğrencinin adını tut\n    strcpy(ogrenci.bilgilere.ad, \"Ahmet Yılmaz\");\n    ogrenci.bilgiTuru = 'A';\n    printf(\"Öğrenci Adı: %s\\n\", ogrenci.bilgilere.ad);\n\n    // Öğrencinin numarasını tut\n    ogrenci.bilgilere.numara = 12345;\n    ogrenci.bilgiTuru = 'N';\n    printf(\"Öğrenci Numarası: %d\\n\", ogrenci.bilgilere.numara);\n\n    // Öğrencinin notunu tut\n    ogrenci.bilgilere.not = 85.5;\n    ogrenci.bilgiTuru = 'O';\n    printf(\"Öğrenci Notu: %.2f\\n\", ogrenci.bilgilere.not);\n\n    return 0;\n}\n\n// Açıklama: Bu programda, öğrenci bilgilerini tutmak için bir union ve bir yapı tanımlıyoruz. Union, öğrencinin adı, numarası veya notu için bellek alanını paylaşmasına olanak tanırken, yapı bu bilgileri ve bilgi türünü tutar. Her bir bilgi türü için farklı bir bilgi saklandığında, sadece en son atanan değer geçerli kalır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:39.326606"
  },
  {
    "question": "Bir araç bilgi sistemi oluşturun. Araç türü (motorlu, bisiklet, vb.) ve özellikleri (motor gücü, vites sayısı, vb.) için bir union kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nunion AracOzellikleri {\n    int motorGucu;\n    int vitesSayisi;\n};\n\nstruct Arac {\n    char aracTuru[20];\n    union AracOzellikleri ozellikler;\n};\n\nint main() {\n    struct Arac arac1;\n\n    // Motorlu araç bilgilerini tanımla\n    strcpy(arac1.aracTuru, \"Otomobil\");\n    arac1.ozellikler.motorGucu = 150;\n    printf(\"Araç Türü: %s\\n\", arac1.aracTuru);\n    printf(\"Motor Gücü: %d HP\\n\", arac1.ozellikler.motorGucu);\n\n    // Bisiklet bilgilerini tanımla\n    struct Arac arac2;\n    strcpy(arac2.aracTuru, \"Bisiklet\");\n    arac2.ozellikler.vitesSayisi = 21;\n    printf(\"Araç Türü: %s\\n\", arac2.aracTuru);\n    printf(\"Vites Sayısı: %d\\n\", arac2.ozellikler.vitesSayisi);\n\n    return 0;\n}\n\n// Açıklama: Bu program, farklı araç türleri için özelliklerini saklamak amacıyla bir union ve yapı kullanmaktadır. Union, motor gücü ve vites sayısını saklayarak belleği verimli bir şekilde kullanmamıza olanak tanır. Araç türüne göre uygun özellik atandığında, yalnızca son atanan değer geçerli kalır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:39.326671"
  },
  {
    "question": "Bir öğrencinin hem notlarını hem de burs bilgilerini tutmak için bir Union tanımlayın. Kullanıcıdan bu bilgileri alıp ekrana yazdıran bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nunion StudentInfo {\n    float grades[5]; // Öğrenci notları\n    char scholarship[20]; // Burs bilgisi\n};\n\nstruct Student {\n    char name[50];\n    union StudentInfo info;\n    int isScholarship; // Burs durumu: 1 burslu, 0 bursuz\n};\n\nint main() {\n    struct Student student;\n\n    printf(\"Öğrencinin adını girin: \");\n    scanf(\"%s\", student.name);\n\n    printf(\"Burslu mu? (1 için evet, 0 için hayır): \");\n    scanf(\"%d\", &student.isScholarship);\n\n    if (student.isScholarship) {\n        printf(\"Burs bilgisini girin: \");\n        scanf(\"%s\", student.info.scholarship);\n    } else {\n        printf(\"5 not girin: \");\n        for (int i = 0; i < 5; i++) {\n            scanf(\"%f\", &student.info.grades[i]);\n        }\n    }\n\n    printf(\"Öğrenci: %s\\n\", student.name);\n    if (student.isScholarship) {\n        printf(\"Burs Bilgisi: %s\\n\", student.info.scholarship);\n    } else {\n        printf(\"Notlar: \");\n        for (int i = 0; i < 5; i++) {\n            printf(\"%.2f \", student.info.grades[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n/* Açıklama: Bu kodda bir union kullanarak öğrencinin burs bilgisi veya notlarını tutabiliyoruz. Kullanıcıdan bilgileri alarak duruma göre gereken bilgiyi ekrana yazdırıyoruz. */",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:55.330705"
  },
  {
    "question": "Bir araç bilgilerini (otomobil veya motorsiklet) tutan bir yapı ve union tanımlayın. Kullanıcıdan bu bilgileri alarak ekrana yazdıran bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nunion VehicleInfo {\n    struct {\n        int doors; // Kapı sayısı\n        float engine_capacity; // Motor hacmi\n    } car;\n    struct {\n        float engine_capacity; // Motor hacmi\n    } motorcycle;\n};\n\nstruct Vehicle {\n    char type[20]; // Araç türü: otomobil/motorsiklet\n    union VehicleInfo info;\n};\n\nint main() {\n    struct Vehicle vehicle;\n\n    printf(\"Araç türünü girin (otomobil/motorsiklet): \");\n    scanf(\"%s\", vehicle.type);\n\n    if (strcmp(vehicle.type, \"otomobil\") == 0) {\n        printf(\"Kapı sayısını girin: \");\n        scanf(\"%d\", &vehicle.info.car.doors);\n        printf(\"Motor hacmini girin: \");\n        scanf(\"%f\", &vehicle.info.car.engine_capacity);\n    } else if (strcmp(vehicle.type, \"motorsiklet\") == 0) {\n        printf(\"Motor hacmini girin: \");\n        scanf(\"%f\", &vehicle.info.motorcycle.engine_capacity);\n    } else {\n        printf(\"Geçersiz araç türü!\\n\");\n        return 1;\n    }\n\n    printf(\"Araç Türü: %s\\n\", vehicle.type);\n    if (strcmp(vehicle.type, \"otomobil\") == 0) {\n        printf(\"Kapı Sayısı: %d\\n\", vehicle.info.car.doors);\n        printf(\"Motor Hacmi: %.2f\\n\", vehicle.info.car.engine_capacity);\n    } else if (strcmp(vehicle.type, \"motorsiklet\") == 0) {\n        printf(\"Motor Hacmi: %.2f\\n\", vehicle.info.motorcycle.engine_capacity);\n    }\n\n    return 0;\n}\n\n/* Açıklama: Bu örnekte bir araç bilgilerini tutacak bir union tanımlıyoruz. Araç türüne göre gerekli bilgileri alıyoruz ve ekrana yazdırıyoruz. Union ile bellek tasarrufu sağlıyoruz çünkü sadece bir tür bilgiyi aynı anda saklayabiliyoruz. */",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:58:55.330761"
  },
  {
    "question": "Bir union tanımlandı ama değişkenlere erişim yapılırken beklenmeyen sonuçlar alınıyor. Aşağıdaki kodda hata nedir?\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int integer;\n    float decimal;\n};\n\nint main() {\n    union Data data;\n    data.integer = 10;\n    printf(\"Decimal: %f\\n\", data.decimal);\n    return 0;\n}\n```",
    "answer": "Bu kodda bir union kullanılıyor ve integer türünde bir değer atandıktan sonra decimal türündeki alan okunmaya çalışılıyor. Ancak union, sadece bir değer tutabilir. Yani integer alanına 10 atandığında decimal alanı geçersiz hale gelir. Bu nedenle, `data.decimal` için beklenmeyen bir değer döndürülür. Doğru kullanım, bir alan kullanıldıktan sonra diğer alanın değerini okumamaktır. Eğer decimal değeriyle çalışmak isteniyorsa, uygun şekilde o alana değer ataması yapılmalıdır.\n\nDüzeltmek için: `data.decimal = 5.0;` şeklinde yeni bir atama yapılarak `printf` ifadesi bunun üzerine yazılmalıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:06.909875"
  },
  {
    "question": "Aşağıdaki kodda union kullanımı ile ilgili bir hata var. Hatanın nedeni nedir?\n\n```c\n#include <stdio.h>\n\nunion U {\n    char c;\n    int i;\n};\n\nint main() {\n    union U u;\n    u.i = 65;\n    printf(\"Character: %c\\n\", u.c);\n    return 0;\n}\n```",
    "answer": "Bu kodda yine bir union tanımlanmış ve int alanına 65 atandıktan sonra char alanı kullanılmaya çalışılıyor. Ancak, union bir anda sadece bir değer tutabildiğinden `u.c` için beklenen sonuç `A` karakteri değil, beklenmeyen bir değer olacaktır. Bunun nedeni, union içindeki bellek alanının paylaşıldığıdır. `u.i = 65;` ataması yapıldığında, `u.c` alanı `u.i` alanının bit dizilimi ile aynı bellek alanını paylaşır. Bu durumda `printf` çağrısı beklenmeyen bir sonuç verir.\n\nDoğru bir kullanım için `u.c = 'A';` şeklinde bir karakter ataması yapıldığında bu sorun ortadan kalkar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:06.909961"
  },
  {
    "question": "Aşağıdaki C kodunda bir union tanımı yapılmış. Ancak, 'getValue' fonksiyonu her zaman doğru sonuç döndürmüyor. Hatanın nedenini bul ve düzelt.",
    "answer": "Kodun hatası, union kullanımı ile ilgili. Union, sadece bir veri türünü saklayabilir; bu nedenle, hangi türün en son atandığını bilmek önemlidir. Aşağıdaki düzeltme ile doğru sonucu alırız.\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nvoid getValue(union Data data, char type) {\n    if (type == 'i') {\n        printf(\"Integer: %d\\n\", data.i);\n    } else if (type == 'f') {\n        printf(\"Float: %f\\n\", data.f);\n    } else if (type == 's') {\n        printf(\"String: %s\\n\", data.str);\n    }\n}\n\nint main() {\n    union Data data;\n    data.i = 10; // İnt türünün son değeri\n    getValue(data, 'i'); // Doğru çağrı\n\n    return 0;\n}\n```\nBurada 'data' union'ı için 'getValue' fonksiyonuna hangi türün en son atandığına dikkat etmeliyiz. Eğer daha önce float ya da string atarsak, int değerini doğru göremeyiz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:21.404881"
  },
  {
    "question": "Aşağıdaki C kodunda union kullanılarak bir veri yapısı tanımlanmış. Ancak program, string verisini doğru şekilde yazdırmıyor. Hatanın nedeni nedir ve nasıl düzeltilir?",
    "answer": "Hatanın nedeni, string'in doğru bir şekilde atanmaması ve ardından 'printf' ile kullanılmadan önce geçersiz bir hale gelmesidir. Aşağıda kodu düzelttim:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nvoid printData(union Data data, char type) {\n    if (type == 's') {\n        printf(\"String: %s\\n\", data.str);\n    } else {\n        printf(\"Veri türü desteklenmiyor.\\n\");\n    }\n}\n\nint main() {\n    union Data data;\n    strcpy(data.str, \"Hello, World!\"); // String ataması\n    printData(data, 's'); // Doğru çağrı\n\n    return 0;\n}\n```\nBurada 'strcpy' fonksiyonu kullanarak string değerini union'a atadık. Ayrıca, union kullanımı sebebiyle diğer alanlara atama yapmamaya dikkat etmeliyiz; aksi takdirde, beklenmedik sonuçlar elde edebiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:21.404972"
  },
  {
    "question": "Bir yapı içinde union kullanarak farklı türde verileri depolamak istiyorum. Aşağıdaki kodda bir hata var. Hatanın kaynağını bul ve düzelt: \n\n#include <stdio.h>\n\nunion Veri {\n    int sayi;\n    float ondalik;\n};\n\nstruct Kisi {\n    char isim[20];\n    union Veri bilgi;\n};\n\nint main() {\n    struct Kisi kisi;\n    kisi.bilgi.sayi = 42;\n    printf(\"Kişinin sayısı: %d\\n\", kisi.bilgi.ondalik);\n    return 0;\n}",
    "answer": "Kodda bir hata var çünkü union kullanırken yalnızca bir üye aynı anda geçerli olabilir. 'kisi.bilgi.sayi' atandıktan sonra 'kisi.bilgi.ondalik' kullanmak, 'sayi' değerini kaybettirir. Bu durumda, 'kisi.bilgi.ondalik' ifadesi geçerli bir değer döndürmeyecek. Düzeltmek için ya 'sayi' ya da 'ondalik' kullanmalısınız. Aşağıdaki düzeltmeyi yapabilirsiniz:\n\n#include <stdio.h>\n\nunion Veri {\n    int sayi;\n    float ondalik;\n};\n\nstruct Kisi {\n    char isim[20];\n    union Veri bilgi;\n};\n\nint main() {\n    struct Kisi kisi;\n    kisi.bilgi.sayi = 42;\n    printf(\"Kişinin sayısı: %d\\n\", kisi.bilgi.sayi);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:41.239505"
  },
  {
    "question": "Aşağıdaki kodda bir union kullanımında bellek hatası yaşıyorum. Hatanın kaynağını bul ve düzelt:\n\n#include <stdio.h>\n#include <string.h>\n\nunion Veri {\n    int sayi;\n    char metin[20];\n};\n\nvoid yazdir(union Veri v) {\n    printf(\"Veri: %s\\n\", v.metin);\n}\n\nint main() {\n    union Veri veri;\n    veri.sayi = 10;\n    yazdir(veri);\n    return 0;\n}",
    "answer": "Burada kodda bir hata var çünkü union'da sadece bir üye aynı anda geçerlidir. 'veri.sayi' atandıktan sonra, 'yazdir' fonksiyonu 'veri.metin' kısmını kullanmaya çalışıyor. Bu durumda, 'veri.metin' geçerli bir değer döndürmeyecek ve bellek hatası oluşabilir. Düzeltmek için ya 'sayi' ya da 'metin' kullanmalısınız. Aşağıdaki düzeltmeyi yapabilirsiniz:\n\n#include <stdio.h>\n#include <string.h>\n\nunion Veri {\n    int sayi;\n    char metin[20];\n};\n\nvoid yazdir(union Veri v) {\n    printf(\"Veri: %d\\n\", v.sayi);\n}\n\nint main() {\n    union Veri veri;\n    veri.sayi = 10;\n    yazdir(veri);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:41.239612"
  },
  {
    "question": "C dilinde bir union kullanarak bir öğrencinin hem int (yaş) hem de float (not) bilgilerini saklamak istiyoruz. Bu durumu nasıl kodlarız?",
    "answer": "Union, farklı veri türlerini aynı bellek alanında saklamamıza olanak tanır. Örneğin, bir öğrencinin yaşını ve notunu saklayacak bir union tanımlayabiliriz. Aşağıdaki kod örneğini inceleyelim:\n\n```c\n#include <stdio.h>\n\nunion Student {\n    int age;\n    float grade;\n};\n\nint main() {\n    union Student student;\n    student.age = 20; // Öğrencinin yaşı\n    printf(\"Öğrencinin yaşı: %d\\n\", student.age);\n\n    student.grade = 85.5; // Öğrencinin notu\n    printf(\"Öğrencinin notu: %.2f\\n\", student.grade);\n\n    // Burada dikkat edilmesi gereken, union sadece bir alanı saklayabilir.\n    printf(\"Öğrencinin yaşı: %d (notun üzerine yazıldı)\\n\", student.age); // Yaş bilgisi kaybolur, çünkü grade alanı kullanıldı.\n    return 0;\n}\n```\nBu örnekte, `Student` adında bir union tanımladık. Hem `age` (yaş) hem de `grade` (not) alanları mevcut, fakat aynı anda sadece bir tanesi kullanılabiliyor. `student.grade` atanırken `student.age` bilgisi kaybolur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:55.849026"
  },
  {
    "question": "Bir otomobilin özelliklerini saklamak için bir union tanımlamak istiyoruz. Hem aracın motor hacmini (int) hem de yakıt miktarını (float) saklamak için bir union kullanabilir miyiz? Örneğin kodu nasıl yazarsınız?",
    "answer": "Elbette! Bir otomobilin motor hacmi ve yakıt miktarını saklayacak bir union tanımlamak oldukça faydalı olabilir. İşte bu durumu gösteren bir kod örneği:\n\n```c\n#include <stdio.h>\n\nunion Car {\n    int engineCapacity; // Motor hacmi\n    float fuelAmount; // Yakıt miktarı\n};\n\nint main() {\n    union Car myCar;\n    myCar.engineCapacity = 1600; // Motor hacmi 1600 cm3\n    printf(\"Motor Hacmi: %d cm3\\n\", myCar.engineCapacity);\n\n    myCar.fuelAmount = 50.0; // Yakıt miktarı\n    printf(\"Yakıt Miktarı: %.2f litre\\n\", myCar.fuelAmount);\n\n    // Motor hacmi bilgisi artık kayboldu.\n    printf(\"Motor Hacmi: %d (yakıt miktarının üzerine yazıldı)\\n\", myCar.engineCapacity);\n    return 0;\n}\n```\nBu örnekte, `Car` adında bir union oluşturduk. `engineCapacity` (motor hacmi) ve `fuelAmount` (yakıt miktarı) alanları bulunuyor. Ancak sadece birini kullanmak mümkün; `fuelAmount` alanına bir değer atandığında `engineCapacity` bilgisi kaybolur. Bu özellik dikkatli bir şekilde kullanılmalıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T17:59:55.849147"
  },
  {
    "question": "Bir oyun yazılımında karakterlerin hem insan hem de hayvan türünde olabilmesi için nasıl bir union tanımlanır? Örnek kodla açıklayınız.",
    "answer": "C dilinde bir oyun yazılımında karakterlerin türlerini temsil etmek için union kullanabiliriz. Aşağıdaki örnekte, 'Character' adında bir union tanımlıyoruz. Bu union, bir 'Human' ve bir 'Animal' yapısını içerecek. 'Human' yapısı isim ve yaş bilgilerini, 'Animal' yapısı ise tür ve sesi içerecek. Bu sayede bir karakter hem insan hem de hayvan bilgilerini saklayabilir. \n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Human;\n\ntypedef struct {\n    char species[50];\n    char sound[50];\n} Animal;\n\nunion Character {\n    Human human;\n    Animal animal;\n};\n\nint main() {\n    union Character character;\n    // İnsan karakter oluştur\n    character.human = (Human) {\"Ahmet\", 30};\n    printf(\"İnsan: %s, Yaş: %d\\n\", character.human.name, character.human.age);\n\n    // Hayvan karakter oluştur\n    character.animal = (Animal) {\"Kedi\", \"Miyav\"};\n    printf(\"Hayvan: %s, Ses: %s\\n\", character.animal.species, character.animal.sound);\n\n    return 0;\n}\n```\nBu örnek, union kullanarak bir karakterin hem insan hem de hayvan türündeki bilgilerini saklayabilmemizi sağlar. Ancak dikkat edilmesi gereken nokta, union alanı sadece bir türde veri saklayabilir. Yani, 'character.human' kullanıldıktan sonra 'character.animal' kullanıldığında, eski 'human' verisi kaybolur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:00:08.168593"
  },
  {
    "question": "Bir veri bankasında kullanıcıların yaşı ve cinsiyeti gibi bilgileri saklamak için nasıl bir union kullanılabilir? Örnekle gösteriniz.",
    "answer": "C dilinde bir veri bankasında kullanıcı bilgilerini saklamak için union kullanmak, belleği verimli kullanmamıza olanak tanır. Aşağıdaki örnekte, 'UserInfo' adında bir union tanımlıyoruz. Bu union, 'age' ve 'gender' bilgilerini saklamak için kullanılacak. Cinsiyet bilgisi 'char' türünde (erkek ya da kadın), yaş ise 'int' türünde saklanacak. \n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    union {\n        int age;\n        char gender;\n    } info;\n} UserInfo;\n\nint main() {\n    UserInfo user;\n    // Kullanıcının yaşını sakla\n    user.info.age = 25;\n    printf(\"Kullanıcının Yaşı: %d\\n\", user.info.age);\n\n    // Cinsiyeti sakla, ancak yaş kaybolacak\n    user.info.gender = 'M';\n    printf(\"Kullanıcının Cinsiyeti: %c\\n\", user.info.gender);\n\n    return 0;\n}\n```\nBu örnekte, kullanıcı bilgileri için bir union tanımlandı. 'age' ve 'gender' alanları aynı bellek alanını paylaştığı için yalnızca bir tanesi kullanılabilir. Yani 'user.info.age' atandıktan sonra 'user.info.gender' atandığında yaş bilgisi kaybolacaktır. Bu, belleği daha verimli kullanmamızı sağlar ama dikkatli olunması gereken bir durumdur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:00:08.168668"
  },
  {
    "question": "C dilinde birden fazla veri türünü içeren bir yapıyı nasıl tanımlayabilirim? Union kullanarak bir örnek verir misiniz?",
    "answer": "C dilinde 'union' anahtar kelimesi, birden fazla veri türünü aynı bellek alanını paylaşacak şekilde tanımlamak için kullanılır. Bu özellik, bellek tasarrufu sağlamak için oldukça faydalıdır. Aşağıda bir örnek ile açıklayayım:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int intValue;\n    float floatValue;\n    char charValue;\n};\n\nint main() {\n    union Data data;\n\n    // int veri türünü atayalım\n    data.intValue = 42;\n    printf(\"Integer: %d\\n\", data.intValue);\n\n    // float veri türünü atayalım\n    data.floatValue = 3.14f;\n    printf(\"Float: %f\\n\", data.floatValue);\n\n    // char veri türünü atayalım\n    data.charValue = 'A';\n    printf(\"Character: %c\\n\", data.charValue);\n\n    // Burada dikkat edilmesi gereken, her atama sonrası önceki değerin kaybolmasıdır.\n    return 0;\n}\n```\n\nBu örnekte, `Data` isimli bir union tanımlıyoruz. Union'ın her bir elemanının boyutu, en büyük elemanının boyutu kadar bellek kaplar. Dolayısıyla, bir union içinde sadece bir veri türü aynı anda kullanılabilir. Yukarıdaki kodda, her bir veri türünü atadıktan sonra diğerlerinin değerlerini kaybettiğini göreceksiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:00:23.216339"
  },
  {
    "question": "Union yapısını kullanarak bir öğrencinin notunu ve durumunu nasıl tutabilirim? Bu yapıyı bir örnekle açıklayabilir misiniz?",
    "answer": "Union kullanarak bir öğrencinin notunu ve durumunu tutmak, farklı veri türlerini aynı bellek alanında saklamak için etkili bir yöntemdir. Aşağıda bu kullanım ile ilgili bir örnek veriyorum:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    union {\n        int grade;\n        char status[10];\n    } info;\n} Student;\n\nint main() {\n    Student student;\n\n    // Öğrenci adını atayalım\n    snprintf(student.name, sizeof(student.name), \"Ahmet\");\n    // Notu atayalım\n    student.info.grade = 85;\n\n    printf(\"Öğrenci: %s\\n\", student.name);\n    printf(\"Notu: %d\\n\", student.info.grade);\n\n    // Durumunu atayalım; bu durumda not kaybolacaktır.\n    snprintf(student.info.status, sizeof(student.info.status), \"Geçti\");\n    printf(\"Durum: %s\\n\", student.info.status);\n\n    // Not ve durumdan yalnızca birini kullanmalıyız; aksi takdirde önceki değer kaybolur.\n    return 0;\n}\n```\n\nBu örnekte, `Student` isimli bir yapı tanımlıyoruz ve içinde bir union kullanıyoruz. Union, öğrencinin notunu `grade` olarak saklayabilirken, aynı zamanda `status` ile öğrencinin durumunu (örneğin, 'Geçti' veya 'Kaldı') tutabilir. Ancak, dikkat edilmesi gereken nokta, bir union içinde yalnızca bir elemanın geçerli olduğudur. Not atandıktan sonra durum atandığında, `grade` değeri kaybolur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:00:23.216388"
  },
  {
    "question": "Bir eğitim kurumunda öğrencilerin hem lisans hem de yüksek lisans bilgilerini tutmak için bir union yapısı nasıl oluşturulur?",
    "answer": "Union, birden fazla veri tipinin aynı bellek alanını kullanmasını sağlar. Aşağıda bir union yapısı kullanarak hem lisans hem de yüksek lisans bilgilerini tutan bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\ntypedef union {\n    struct {\n        char isim[50];\n        int yas;\n        char bolum[30];\n    } lisans;\n    struct {\n        char isim[50];\n        int yas;\n        char konu[50];\n    } yuksek_lisans;\n} Ogrenci;\n\nint main() {\n    Ogrenci ogrenci;\n\n    // Lisans öğrencisi bilgileri\n    snprintf(ogrenci.lisans.isim, sizeof(ogrenci.lisans.isim), \"Ali Veli\");\n    ogrenci.lisans.yas = 20;\n    snprintf(ogrenci.lisans.bolum, sizeof(ogrenci.lisans.bolum), \"Bilgisayar Mühendisliği\");\n\n    printf(\"Lisans Öğrencisi: %s, Yaş: %d, Bölüm: %s\\n\", ogrenci.lisans.isim, ogrenci.lisans.yas, ogrenci.lisans.bolum);\n\n    // Yüksek lisans öğrencisi bilgileri (union sadece birine ait bilgiyi tutar)\n    snprintf(ogrenci.yuksek_lisans.isim, sizeof(ogrenci.yuksek_lisans.isim), \"Ayşe Yılmaz\");\n    ogrenci.yuksek_lisans.yas = 25;\n    snprintf(ogrenci.yuksek_lisans.konu, sizeof(ogrenci.yuksek_lisans.konu), \"Yapay Zeka\");\n\n    printf(\"Yüksek Lisans Öğrencisi: %s, Yaş: %d, Konu: %s\\n\", ogrenci.yuksek_lisans.isim, ogrenci.yuksek_lisans.yas, ogrenci.yuksek_lisans.konu);\n\n    return 0;\n}\n```\nBu örnekte, `Ogrenci` adında bir union tanımlıyoruz. Hem lisans hem de yüksek lisans bilgilerini tutabiliyoruz; ancak sadece birini aynı anda tutabiliyoruz. Kod çalıştığında, ilk olarak lisans öğrencisinin bilgileri yazdırılacak, ardından yüksek lisans öğrencisinin bilgileri yazdırılacak.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:01:59.380124"
  },
  {
    "question": "Bir otomobilin özelliklerini saklamak için bir union yapısı nasıl kullanılabilir?",
    "answer": "Otomobillerin farklı türde motor bilgileri (benzinli, dizel, elektrikli) gibi bilgilerini saklamak için union kullanabiliriz. Aşağıdaki kod örneği, bir otomobilin özelliklerini tutan bir union yapısı göstermektedir:\n\n```c\n#include <stdio.h>\n\ntypedef union {\n    struct {\n        char tip[20];\n        float hacim;\n    } benzinli;\n    struct {\n        char tip[20];\n        float guc;\n    } dizel;\n    struct {\n        char tip[20];\n        int batarya_kapasitesi;\n    } elektrikli;\n} Motor;\n\ntypedef struct {\n    char marka[30];\n    char model[30];\n    Motor motor;\n} Otomobil;\n\nint main() {\n    Otomobil otomobil;\n\n    // Benzinli motor bilgileri\n    snprintf(otomobil.marka, sizeof(otomobil.marka), \"Ford\");\n    snprintf(otomobil.model, sizeof(otomobil.model), \"Focus\");\n    snprintf(otomobil.motor.benzinli.tip, sizeof(otomobil.motor.benzinli.tip), \"Benzinli\");\n    otomobil.motor.benzinli.hacim = 1.6;\n\n    printf(\"Otomobil: %s %s, Motor Tipi: %s, Hacim: %.1fL\\n\", otomobil.marka, otomobil.model, otomobil.motor.benzinli.tip, otomobil.motor.benzinli.hacim);\n\n    // Elektrikli motor bilgileri (union sadece birine ait bilgiyi tutar)\n    snprintf(otomobil.motor.elektrikli.tip, sizeof(otomobil.motor.elektrikli.tip), \"Elektrikli\");\n    otomobil.motor.elektrikli.batarya_kapasitesi = 75;\n\n    printf(\"Otomobil: %s %s, Motor Tipi: %s, Batarya Kapasitesi: %d kWh\\n\", otomobil.marka, otomobil.model, otomobil.motor.elektrikli.tip, otomobil.motor.elektrikli.batarya_kapasitesi);\n\n    return 0;\n}\n```\nBu örnekte, `Motor` adında bir union tanımlıyoruz ve benzinli, dizel ve elektrikli motor bilgilerini tutabiliyoruz. Ancak bir seferde sadece bir motor türü bilgisi saklanabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:01:59.380163"
  },
  {
    "question": "Bir öğrenci kaydı yapacak bir yapı oluşturun. Öğrenci adı, yaşı ve notları için bir union kullanarak gerektiğinde notları integer veya float olarak saklayın. Örnek bir kullanım gösterin.",
    "answer": "C dilinde, öğrenci kaydı oluşturmak için bir struct ve union kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nunion Notlar {\n    int not_integer;\n    float not_float;\n};\n\nstruct Ogrenci {\n    char isim[50];\n    int yas;\n    union Notlar not;\n    int not_turu; // 0: int, 1: float\n};\n\nint main() {\n    struct Ogrenci ogrenci1;\n    strcpy(ogrenci1.isim, \"Ahmet\");\n    ogrenci1.yas = 20;\n    ogrenci1.not_turu = 0; // Integer not\n    ogrenci1.not.not_integer = 85;\n\n    printf(\"Öğrenci: %s, Yaş: %d, Not: %d\\n\", ogrenci1.isim, ogrenci1.yas, ogrenci1.not.not_integer);\n\n    struct Ogrenci ogrenci2;\n    strcpy(ogrenci2.isim, \"Fatma\");\n    ogrenci2.yas = 22;\n    ogrenci2.not_turu = 1; // Float not\n    ogrenci2.not.not_float = 90.5;\n\n    printf(\"Öğrenci: %s, Yaş: %d, Not: %.2f\\n\", ogrenci2.isim, ogrenci2.yas, ogrenci2.not.not_float);\n\n    return 0;\n}\n```\n\nBu kod, her öğrencinin adını, yaşını ve notunu saklamak için bir union kullanır. Notlar integer veya float olarak saklanabilir. Öğrencilerin not türüne göre doğru veri türü kullanılarak ekrana yazdırılır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:17.759522"
  },
  {
    "question": "Bir grafik uygulamasında, şekil tanımları için bir union kullanarak daire ve dikdörtgen tanımları oluşturun. Her şeklin alanını hesaplayacak bir fonksiyon yazın. Örnek bir kullanım gösterin.",
    "answer": "Grafik uygulamalarında, farklı şekilleri temsil etmek için union kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159\n\nunion Sekil {\n    struct {\n        float yaricap;\n    } daire;\n    struct {\n        float uzunluk;\n        float genislik;\n    } dikdortgen;\n};\n\nstruct SekilTanimi {\n    int sekil_turu; // 0: daire, 1: dikdörtgen\n    union Sekil sekil;\n};\n\nfloat alan_hesapla(struct SekilTanimi s) {\n    if (s.sekil_turu == 0) {\n        return PI * s.sekil.daire.yaricap * s.sekil.daire.yaricap; // Daire alanı\n    } else {\n        return s.sekil.dikdortgen.uzunluk * s.sekil.dikdortgen.genislik; // Dikdörtgen alanı\n    }\n}\n\nint main() {\n    struct SekilTanimi sekil1;\n    sekil1.sekil_turu = 0; // Daire\n    sekil1.sekil.daire.yaricap = 5.0;\n\n    printf(\"Dairenin Alanı: %.2f\\n\", alan_hesapla(sekil1));\n\n    struct SekilTanimi sekil2;\n    sekil2.sekil_turu = 1; // Dikdörtgen\n    sekil2.sekil.dikdortgen.uzunluk = 4.0;\n    sekil2.sekil.dikdortgen.genislik = 6.0;\n\n    printf(\"Dikdörtgenin Alanı: %.2f\\n\", alan_hesapla(sekil2));\n\n    return 0;\n}\n```\n\nBu kod, daire ve dikdörtgen gibi iki farklı şekil tanımını union ile birleştirir. `alan_hesapla` fonksiyonu, şekil türüne göre alanı hesaplar ve sonucu ekrana yazdırır. Union sayesinde bellek kullanımı optimize edilmiş olur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:17.759587"
  },
  {
    "question": "Birden fazla veri tipini depolayan bir yapı oluşturmak istiyorum. Kullanıcının hem tam sayıları hem de ondalıklı sayıları girebildiği bir program yazın. Bu programda union kullanarak kullanıcıdan alınan verileri depolayın ve kullanıcıya her iki türdeki verileri ekrana yazdırın.",
    "answer": "Aşağıda, tam sayılar ve ondalıklı sayılar için bir union kullanan bir C programı örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunion Number {\n    int intval;\n    float floatval;\n};\n\nstruct Data {\n    int type; // 0: int, 1: float\n    union Number value;\n};\n\nint main() {\n    struct Data input;\n    printf(\"Hangi türde bir sayı girmek istersiniz? (0: tam sayı, 1: ondalıklı sayı): \");\n    scanf(\"%d\", &input.type);\n\n    if (input.type == 0) {\n        printf(\"Tam sayıyı girin: \");\n        scanf(\"%d\", &input.value.intval);\n        printf(\"Girdiğiniz tam sayı: %d\\n\", input.value.intval);\n    } else if (input.type == 1) {\n        printf(\"Ondalıklı sayıyı girin: \");\n        scanf(\"%f\", &input.value.floatval);\n        printf(\"Girdiğiniz ondalıklı sayı: %.2f\\n\", input.value.floatval);\n    } else {\n        printf(\"Geçersiz tür seçimi.\\n\");\n    }\n    return 0;\n}\n```\nBu program, kullanıcının seçimine göre bir tam sayı veya bir ondalık sayı alır. Union kullanarak, yalnızca bir türdeki veriyi saklayacak şekilde yapılandırılmıştır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:37.351316"
  },
  {
    "question": "Bir veri kaynağından gelen verilerin durumunu depolamak için bir sistem tasarlamak istiyorum. Bu sistemde, bir kullanıcı bilgisi, bir hata durumu veya bir bilgi mesajı olabilir. Union kullanarak bu bilgileri nasıl yönetebilirim?",
    "answer": "Aşağıdaki C programı, bir union ve struct kullanarak kullanıcı bilgisi, hata durumu veya bilgi mesajlarını depolayan bir sistem örneği sunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MSG_LEN 100\n\nunion MessageData {\n    char userInfo[MAX_MSG_LEN];\n    char errorMsg[MAX_MSG_LEN];\n    char infoMsg[MAX_MSG_LEN];\n};\n\nstruct Message {\n    int messageType; // 0: kullanıcı bilgisi, 1: hata, 2: bilgi\n    union MessageData data;\n};\n\nvoid displayMessage(struct Message msg) {\n    switch (msg.messageType) {\n        case 0:\n            printf(\"Kullanıcı Bilgisi: %s\\n\", msg.data.userInfo);\n            break;\n        case 1:\n            printf(\"Hata Mesajı: %s\\n\", msg.data.errorMsg);\n            break;\n        case 2:\n            printf(\"Bilgi Mesajı: %s\\n\", msg.data.infoMsg);\n            break;\n        default:\n            printf(\"Geçersiz mesaj türü.\\n\");\n            break;\n    }\n}\n\nint main() {\n    struct Message msg;\n\n    // Kullanıcı bilgisi\n    msg.messageType = 0;\n    strcpy(msg.data.userInfo, \"Kullanıcı: Ahmet, Yaş: 25\");\n    displayMessage(msg);\n\n    // Hata mesajı\n    msg.messageType = 1;\n    strcpy(msg.data.errorMsg, \"Bir hata oluştu: Bağlantı hatası.\");\n    displayMessage(msg);\n\n    // Bilgi mesajı\n    msg.messageType = 2;\n    strcpy(msg.data.infoMsg, \"Başarılı giriş.\");\n    displayMessage(msg);\n\n    return 0;\n}\n```\nBu programda, kullanıcı bilgisi, hata ve bilgi mesajları için bir union kullanıyoruz. Kullanıcı, farklı türdeki mesajları depolayıp ekrana yazdırabilmektedir. Her mesaj türü için bir durum kontrolü yapılmaktadır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:37.351389"
  },
  {
    "question": "Bir yapı (struct) içerisinde birden fazla veri tipi barındırmak için union kullanımını nasıl optimize edebilirim?",
    "answer": "Union, birden fazla veri tipini aynı bellekte tutmak için kullanılır. Ancak, bu durum bellekte yer tasarrufu sağlasa da, kullanırken dikkatli olmalısınız. Örneğin, bir 'data' yapısı oluşturalım:\n\n```c\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nstruct DataHolder {\n    enum { INT, FLOAT, STRING } type;\n    union Data data;\n};\n```\nBu yapıyı kullanarak bir veri tutabilirsiniz. Ancak, veri tutarken hangi tipin kullanıldığını bilmek önemlidir. 'type' adında bir enum eklemek, bu durumu iyileştirir. 'data' union'ını kullanırken sadece gerekli alanı kullanarak bellek israfını önlemiş olursunuz. Ayrıca, her bir veri tipi için bir kontrol fonksiyonu yazmak, kodun okunabilirliğini artırır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:47.188103"
  },
  {
    "question": "Union ve enum kombinasyonunu kullanarak bir protokol mesajı oluşturmak istiyorum. Nasıl bir yapı geliştirebilirim?",
    "answer": "Union ve enum kombinasyonu, farklı türde mesajları tek bir yapı içinde saklamak için mükemmeldir. Örneğin, bir iletişim protokolü için şu yapıyı geliştirebiliriz:\n\n```c\ntypedef enum { TEXT, IMAGE, VIDEO } MessageType;\n\nunion Message {\n    char text[100];\n    struct { int width, height; char data[1024]; } image;\n    struct { int duration; char url[256]; } video;\n};\n\nstruct ProtocolMessage {\n    MessageType type;\n    union Message message;\n};\n```\nBu yapıda, bir 'ProtocolMessage' oluşturarak farklı türlerde mesajlar gönderebiliriz. Herhangi bir mesaj türünü kullanırken, ilk önce 'type' alanını kontrol etmek önemlidir. Ayrıca, bu yapı ile farklı türdeki mesajlar için bellek kullanımını optimize etmiş oluruz. İletişim sırasında bir 'ProtocolMessage' örneği oluşturup türüne göre gönderim yapabilirsiniz. Kodun okunabilirliğini artırmak için her tür mesaj için ayrı işleme fonksiyonları yazmak da faydalı olacaktır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:02:47.188150"
  },
  {
    "question": "Bir veri yapısında hem tamsayı hem de ondalıklı sayıları saklamak için bir union kullanmak istiyorum. Ancak union kullanımında veri kaybını önlemek için ne tür bir yaklaşım izlemeliyim?",
    "answer": "Union kullanırken, hangi tür verinin en son kullanıldığını takip etmek için bir etiket (enum veya bir tamsayı) eklemek iyi bir yaklaşımdır. Bu sayede, doğru türün kullanıldığından emin olabiliriz ve veri kaybını önleyebiliriz. Aşağıda örnek bir yapı verilmiştir:\n\n```c\n#include <stdio.h>\ntypedef enum { INTEGER, FLOAT } DataType;\ntypedef struct {\n    DataType type;\n    union {\n        int intValue;\n        float floatValue;\n    } value;\n} Data;\n\nvoid printData(Data data) {\n    switch (data.type) {\n        case INTEGER:\n            printf(\"Tamsayı: %d\\n\", data.value.intValue);\n            break;\n        case FLOAT:\n            printf(\"Ondalık: %.2f\\n\", data.value.floatValue);\n            break;\n    }\n}\n\nint main() {\n    Data d1;\n    d1.type = INTEGER;\n    d1.value.intValue = 10;\n    printData(d1);\n\n    Data d2;\n    d2.type = FLOAT;\n    d2.value.floatValue = 3.14;\n    printData(d2);\n    return 0;\n}\n```\nBu yapı sayesinde, hangi türün kullanıldığını bilerek doğru şekilde veri yazdırabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:03:06.857180"
  },
  {
    "question": "Bir ağ uygulamasında farklı türde mesajları (örneğin, veri mesajı, hata mesajı) işlemek için bir union kullanmayı düşünüyorum. Bu durumda, mesajların boyutunu nasıl kontrol etmeliyim?",
    "answer": "Union kullanırken, veri yapısının boyutunu kontrol etmek ve tür güvenliğini sağlamak için yine bir etiket kullanılmalıdır. Mesaj yapısı aşağıdaki gibi tanımlanabilir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef enum { DATA_MESSAGE, ERROR_MESSAGE } MessageType;\ntypedef struct {\n    MessageType type;\n    union {\n        struct {\n            char data[256];\n        } dataMsg;\n        struct {\n            int errorCode;\n            char errorMsg[128];\n        } errorMsg;\n    } message;\n} NetworkMessage;\n\nvoid handleMessage(NetworkMessage msg) {\n    switch (msg.type) {\n        case DATA_MESSAGE:\n            printf(\"Veri Mesajı: %s\\n\", msg.message.dataMsg.data);\n            break;\n        case ERROR_MESSAGE:\n            printf(\"Hata Kodu: %d, Hata Mesajı: %s\\n\", msg.message.errorMsg.errorCode, msg.message.errorMsg.errorMsg);\n            break;\n    }\n}\n\nint main() {\n    NetworkMessage msg1;\n    msg1.type = DATA_MESSAGE;\n    strcpy(msg1.message.dataMsg.data, \"Hello World\");\n    handleMessage(msg1);\n\n    NetworkMessage msg2;\n    msg2.type = ERROR_MESSAGE;\n    msg2.message.errorMsg.errorCode = 404;\n    strcpy(msg2.message.errorMsg.errorMsg, \"Not Found\");\n    handleMessage(msg2);\n\n    return 0;\n}\n```\nBu yapıda, her iki mesaj türü için ayrı alanlar olduğu için veri kaybını önleyebiliriz ve her mesaj türünü doğru bir şekilde işleyebiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-05-31T18:03:06.857248"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak 5 sayısının ikili gösteriminde 1. bitini (en sağdaki 0. bit) 1 yapacak şekilde güncelleyin. Kod: \n\n#include <stdio.h>\n\nint main() {\n    int sayi = 5; // 5 sayısı: 0101\n    int bit_index = 0;\n    // Buraya bit işlemi ekleyin\n    printf(\"Güncellenmiş sayı: %d\\n\", sayi);\n    return 0;\n}",
    "answer": "Aşağıdaki gibi bit işlemi ile sayının belirtilen bitini güncelleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 5; // 5 sayısı: 0101\n    int bit_index = 0;\n    sayi |= (1 << bit_index); // 1. bitini 1 yapar (0101 | 0001 = 0101)\n    printf(\"Güncellenmiş sayı: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kodda, `sayi` değişkeninin 0. bitini 1 yapmak için `|=` (bitwise OR assignment) operatörü kullanıyoruz. `1 << bit_index` ifadesi, `bit_index`'in değeri 0 olduğu için 1'i sola kaydırarak 0001 elde eder ve bu da sayının en sağdaki bitini 1 yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:18.824573"
  },
  {
    "question": "Aşağıdaki eksik C kodunu tamamlayarak bir sayının en yüksek bitini 0 yapın. Kod:\n\n#include <stdio.h>\n\nint main() {\n    int sayi = 12; // 12 sayısı: 1100\n    // Buraya bit işlemi ekleyin\n    printf(\"Güncellenmiş sayı: %d\\n\", sayi);\n    return 0;\n}",
    "answer": "Aşağıdaki gibi bit işlemi ile sayının en yüksek bitini 0 yapabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 12; // 12 sayısı: 1100\n    sayi &= ~(1 << 3); // 3. bitini 0 yapar (1100 & 0111 = 0100)\n    printf(\"Güncellenmiş sayı: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kodda, `sayi` değişkeninin 3. bitini 0 yapmak için `&=` (bitwise AND assignment) operatörünü kullanıyoruz. `~(1 << 3)` ifadesi, 3. bitin dışında kalan tüm bitleri 1 yaparken, 3. biti 0 yapar. Sonuç olarak 12'nin en yüksek biti 0'a dönüşür.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:18.824656"
  },
  {
    "question": "Aşağıdaki kodu tamamlayın. Kullanıcının girdiği bir tam sayının en yüksek bitini (1 bitini) bulmak için bir fonksiyon yazın. Tamamlanmamış kod: \n\n#include <stdio.h>\n\nint enYuksekBit(int num) {\n    // Burayı tamamlayın\n}\n\nint main() {\n    int sayi;\n    printf('Bir tam sayı girin: ');\n    scanf('%d', &sayi);\n    int sonuc = enYuksekBit(sayi);\n    printf('En yüksek bit: %d\\n', sonuc);\n    return 0;\n}",
    "answer": "Tamamlanmış kod:\n\n#include <stdio.h>\n\nint enYuksekBit(int num) {\n    int bit = 0;\n    while (num > 0) {\n        num >>= 1; // num'yi sağa kaydırarak en yüksek biti buluyoruz\n        bit++;\n    }\n    return bit - 1; // bit sayısı en yüksek bitin indeksini verir\n}\n\nint main() {\n    int sayi;\n    printf('Bir tam sayı girin: ');\n    scanf('%d', &sayi);\n    int sonuc = enYuksekBit(sayi);\n    printf('En yüksek bit: %d\\n', sonuc);\n    return 0;\n}\n\n// Açıklama: enYuksekBit fonksiyonu, 'num' değişkenini sağa kaydırarak 0'a ulaşana kadar döngü çalıştırır. Her kaydırma işlemi, sayının bit uzunluğunu artırır. Sonuç olarak, 'bit' değişkeni, en yüksek bitin pozisyonunu döndürür.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:30.703633"
  },
  {
    "question": "Aşağıdaki kodu tamamlayın. İki sayının bit düzeyinde AND işlemi sonucunu döndüren bir fonksiyon yazın. Tamamlanmamış kod: \n\n#include <stdio.h>\n\nint bitAnd(int a, int b) {\n    // Burayı tamamlayın\n}\n\nint main() {\n    int sayi1, sayi2;\n    printf('İki tam sayı girin: ');\n    scanf('%d %d', &sayi1, &sayi2);\n    int sonuc = bitAnd(sayi1, sayi2);\n    printf('AND sonucu: %d\\n', sonuc);\n    return 0;\n}",
    "answer": "Tamamlanmış kod:\n\n#include <stdio.h>\n\nint bitAnd(int a, int b) {\n    return a & b; // Bit düzeyinde AND işlemi\n}\n\nint main() {\n    int sayi1, sayi2;\n    printf('İki tam sayı girin: ');\n    scanf('%d %d', &sayi1, &sayi2);\n    int sonuc = bitAnd(sayi1, sayi2);\n    printf('AND sonucu: %d\\n', sonuc);\n    return 0;\n}\n\n// Açıklama: bitAnd fonksiyonu, iki sayının bit düzeyinde AND işlemini gerçekleştirir. '&' operatörü, her iki sayının bitlerinin karşılaştırılmasını sağlar ve sadece her iki bit de 1 olduğunda 1 döner. Bu, bit manipülasyonu uygulamalarında sıkça kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:30.703755"
  },
  {
    "question": "Verilen bir tamsayıda, belirli bir bitin (n. bit) 1 olup olmadığını kontrol eden bir fonksiyon yazın. Fonksiyonun adı 'isBitSet' olmalı ve iki parametre almalı: int num ve int n.",
    "answer": "#include <stdio.h>\n\nint isBitSet(int num, int n) {\n    // 1 << n işlemi, n. bit'i 1 yapar\n    return (num & (1 << n)) != 0;\n}\n\nint main() {\n    int num = 5; // 5'in ikilik gösterimi 0101\n    int n = 2;\n    if (isBitSet(num, n)) {\n        printf(\"%d. bit set.\", n);\n    } else {\n        printf(\"%d. bit not set.\", n);\n    }\n    return 0;\n}\n\n// Açıklama: 'isBitSet' fonksiyonu, verilen 'num' değişkeninde 'n' numaralı bitin 1 olup olmadığını kontrol eder. '1 << n' ifadesi, 1 sayısını n kadar sola kaydırarak, n. bit'i 1 yapar. Ardından, 'num & (1 << n)' işlemi ile bu bitin durumu kontrol edilir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:43.794034"
  },
  {
    "question": "İki tamsayı arasındaki tüm bitlerin farklı olduğu pozisyonları tespit eden bir fonksiyon yazın. Fonksiyonun adı 'countBitDifferences' olmalı ve iki parametre almalı: int a ve int b. Fonksiyon, farklı bitlerin sayısını döndürmelidir.",
    "answer": "#include <stdio.h>\n\nint countBitDifferences(int a, int b) {\n    int xor = a ^ b; // a ve b'nin bitleri arasındaki farklılıkları bulmak için XOR kullanılır\n    int count = 0;\n    while (xor > 0) {\n        count += (xor & 1); // XOR'un en sağdaki biti kontrol edilir\n        xor >>= 1; // XOR'un bitleri sola kaydırılır\n    }\n    return count;\n}\n\nint main() {\n    int a = 29; // 29'un ikilik gösterimi 11101\n    int b = 15; // 15'in ikilik gösterimi 01111\n    int differentBits = countBitDifferences(a, b);\n    printf(\"Farklı bit sayısı: %d\", differentBits);\n    return 0;\n}\n\n// Açıklama: 'countBitDifferences' fonksiyonu, verilen 'a' ve 'b' tamsayıları arasındaki farklı bit sayısını hesaplar. Öncelikle, 'a' ve 'b' XOR işlemine tabi tutulur ve farklı olan bitler belirlenir. Daha sonra, bu farklı bitlerin sayısını saymak için döngü kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:43.794116"
  },
  {
    "question": "Aşağıdaki C kodunda bit işlemleri ile ilgili bir hata var. Hatanın sebebini bul ve düzelt: int a = 5; int b = 3; int c = a & b; printf('%d', c);",
    "answer": "Kodda çift tırnak işareti (') kullanılmış. C dilinde stringleri belirtmek için çift tırnak (\" \") kullanılmalıdır. Ayrıca, '&' işlemi bit düzeyinde AND işlemi yapar. 5 (101) ve 3 (011) sayıları için bu işlem sonucu 1 (001) olacaktır. Düzeltme ile kod şu şekilde olmalıdır: int a = 5; int b = 3; int c = a & b; printf('%d', c);. Çıktı 1 olacaktır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:51.369573"
  },
  {
    "question": "Aşağıdaki C kodunda bir mantıksal hata var. Hatanın sebebini bul ve düzelt: int x = 12; int y = 5; int result = x | y; printf('%d', result);",
    "answer": "Kodda yine çift tırnak işareti sorunu var. Üstelik '&' yerine '|' işlemi kullanıldığında bit düzeyinde OR işlemi yapılıyor. 12 (1100) ve 5 (0101) sayıları için bu işlem sonucu 13 (1101) olacaktır. Düzeltme ile kod şu şekilde olmalıdır: int x = 12; int y = 5; int result = x | y; printf('%d', result);. Çıktı 13 olacaktır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:03:51.369631"
  },
  {
    "question": "Bir tamsayı değişkeninin en son 4 bitini sıfırlamak istiyorum. Bunun için bit işlemleri yaparken bir hata yapmışım. Aşağıdaki kodda hata var mı? 'num &= 0xFFFFFFF0;'",
    "answer": "Evet, kodda bir hata var. Bu kod, 'num' değişkeninin en son 4 bitini sıfırlamak için doğru bir yöntem değil. Ancak '0xFFFFFFF0' değeri, en son 4 bit sıfır yapılırken doğru şekilde kullanılmış. Burada dikkat edilmesi gereken nokta, sayının 32 bitlik bir tamsayı olduğunu varsayıyoruz. Eğer 'num' değişkeni 32 bitlik bir tamsayı ise bu işlem doğru. Fakat, eğer farklı bir bit genişliği kullanıyorsanız (örneğin, 16 bit veya 8 bit), o zaman maske değerini de buna göre ayarlamanız gerekir. Örneğin, 16 bit için doğru maske '0xFFFC' olmalıdır. Yani, num değişkeninin doğru bit genişliğine göre maskelenmesi gerektiğini unutmayın.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:05.332503"
  },
  {
    "question": "Bir tamsayıda belirli bir bitin değerini değiştirmek istiyorum ama bir hata yaptım. Aşağıdaki kodu incelediğimde, bit 3'ü değiştirmek için kullandığım işlemin yanlış olduğunu gördüm: 'num ^= (1 << 3);'. Bu kod doğru mu?",
    "answer": "Evet, verilen kod doğru bir kullanım. 'num ^= (1 << 3);' ifadesi, 'num' değişkeninin 3. bitini tersine çevirmek için kullanılıyor. Burada '1 << 3' ifadesi, 1 sayısını 3 bit sola kaydırarak 8 (binary olarak 00001000) yapıyor. Daha sonra XOR işlemi ile ilgili bitin değeri değiştirilmiş oluyor. Ancak, burada dikkat edilmesi gereken bir nokta var: Eğer 3. bit zaten 1 ise, bu işlem onu 0 yapacak; eğer 3. bit 0 ise, bu işlem onu 1 yapacak. Eğer amacınız sadece bir bitin değerini belirlemekse (0'dan 1 yapmak veya 1'den 0 yapmak), o zaman XOR yerine bitwise OR veya AND işlemi kullanmalısınız. Örneğin, bit 3'ü 1 yapmak için 'num |= (1 << 3);' veya bit 3'ü 0 yapmak için 'num &= ~(1 << 3);' kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:05.332582"
  },
  {
    "question": "Aşağıdaki kodda, bir sayının çift ya da tek olduğunu kontrol eden bir fonksiyon var. Ancak, fonksiyon her zaman yanlış sonuç veriyor. Hatanın kaynağını bul ve düzelt.",
    "answer": "Kod şu şekilde olsun:\n\n```c\n#include <stdio.h>\n\nint isEven(int num) {\n    return num & 1;  // Hata burada\n}\n\nint main() {\n    int number = 5;\n    if (isEven(number)) {\n        printf(\"Çift\");\n    } else {\n        printf(\"Tek\");\n    }\n    return 0;\n}\n``` \n\nHatanın kaynağı, `isEven` fonksiyonundaki bit işlemi. `num & 1` ifadesi, sayının tek mi yoksa çift mi olduğunu kontrol etmek için kullanılıyor. Ancak bu ifade, sayının çift olup olmadığını kontrol etmek için ters sonuç veriyor. Doğru kontrol `!(num & 1)` ya da `(num & 1) == 0` olarak değiştirilmeli. Böylece, `isEven` fonksiyonu düzeltildiğinde, kod doğru sonuç verecektir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:20.821376"
  },
  {
    "question": "Aşağıdaki kodda, iki sayının bit düzeyinde AND işlemi yapılarak sonuç döndüren bir fonksiyon var. Ancak beklenen sonuç alınamıyor. Hatanın kaynağını bul ve düzelt.",
    "answer": "Kod şu şekilde olsun:\n\n```c\n#include <stdio.h>\n\nint bitwiseAnd(int a, int b) {\n    return a | b;  // Hata burada\n}\n\nint main() {\n    int x = 5; // 0101\n    int y = 3; // 0011\n    printf(\"AND sonucu: %d\", bitwiseAnd(x, y));\n    return 0;\n}\n``` \n\nHatanın kaynağı, `bitwiseAnd` fonksiyonundaki bit işlemi. `a | b` ifadesi bit düzeyinde OR işlemi yapmaktadır ve bu nedenle beklenen AND sonucu verilmiyor. Doğru işlem, `a & b` olarak değiştirilmelidir. Böylece, `bitwiseAnd` fonksiyonu iki sayının bit düzeyinde AND işlemini doğru bir şekilde gerçekleştirecektir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:20.821437"
  },
  {
    "question": "C dilinde iki tam sayıyı bit düzeyinde 've' işlemiyle nasıl birleştiririm?",
    "answer": "Bit düzeyinde 've' işlemi, '&' operatörü ile yapılır. Örneğin, iki tam sayıyı alalım: 'a' ve 'b'. Aşağıdaki kod ile bu iki sayının bit düzeyinde 've' işlemini gerçekleştirebiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;  // 0101 ikilik sistemde\n    int b = 3;  // 0011 ikilik sistemde\n    int sonuc = a & b;  // 0001 (1) ikilik sistemde\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBurada 'a' ve 'b' sayılarının bit düzeyinde 've' işlemi yapıldığında, sadece her iki sayıda da 1 olan bitlerin sonucu 1 olur. Bu durumda 'sonuç' değişkeni 1 olarak atanır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:31.850322"
  },
  {
    "question": "C dilinde bir sayının en düşük bitini nasıl kontrol ederim?",
    "answer": "Bir sayının en düşük bitini kontrol etmek için bit düzeyinde 've' işlemi kullanabiliriz. Örneğin, bir tam sayının en düşük bitinin 1 olup olmadığını kontrol etmek istiyorsak, sayıyı 1 ile 've' işlemine tabi tutabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi = 6;  // 0110 ikilik sistemde\n    if (sayi & 1) {\n        printf(\"En düşük bit 1'dir.\\n\");\n    } else {\n        printf(\"En düşük bit 0'dır.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, 'sayi' değişkeninin en düşük biti kontrol ediliyor. Eğer en düşük bit 1 ise \"En düşük bit 1'dir.\" yazılır, aksi takdirde \"En düşük bit 0'dır.\" mesajı yazdırılır. Bu tür kontroller, genellikle sayının tek mi çift mi olduğunu anlamak için kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:31.850359"
  },
  {
    "question": "C dilinde bir sayının çift mi tek mi olduğunu kontrol etmek için bit işlemlerini nasıl kullanabiliriz?",
    "answer": "Bir sayının çift ya da tek olduğunu kontrol etmek için en son bitini kontrol edebiliriz. C dilinde, bir sayının en son bitini belirlemek için bit AND (&) işleci kullanılabilir. Örneğin, bir sayının çift olup olmadığını kontrol etmek için sayının 1 ile AND'ını alırız. Eğer sonuç 0 ise sayı çifttir, aksi takdirde tek olur. Aşağıda bir örnek kod verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n\n    // Sayının çift mi tek mi olduğunu kontrol et\n    if (sayi & 1) {\n        printf(\"Bu sayi tektir.\\n\");\n    } else {\n        printf(\"Bu sayi ciftir.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, kullanıcıdan bir sayı alıyoruz ve bit işlemi ile sayının tek mi çift mi olduğunu belirliyoruz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:40.667236"
  },
  {
    "question": "C dilinde iki sayının ortak bitlerini bulmak için bit işlemlerini nasıl kullanırız?",
    "answer": "İki sayının ortak bitlerini bulmak için bit AND (&) işlemini kullanabiliriz. Bu işlem, her iki sayının aynı pozisyondaki bitlerinin 1 olduğu durumları bulmamıza yardımcı olur. Aşağıda iki sayının ortak bitlerini bulmak için bir örnek kod verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2, ortakBitler;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n\n    // Ortak bitleri bulmak için bit AND işlemi yap\n    ortakBitler = sayi1 & sayi2;\n\n    printf(\"Ortak bitler: %d\\n\", ortakBitler);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan iki sayı alıyoruz ve bu sayılar arasındaki ortak bitleri buluyoruz. Ortak bitlerin değeri, bu iki sayının bit seviyesinde AND işlemi ile hesaplanarak elde ediliyor.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:40.667277"
  },
  {
    "question": "Bit işlemleri ile bir sayının tek mi çift mi olduğunu nasıl kontrol edebilirim? Örnek bir kod ile açıkla.",
    "answer": "Bir sayının tek mi çift mi olduğunu kontrol etmek için bit işlemlerini kullanabiliriz. Sayının en düşük bitini kontrol etmek yeterli olacaktır. Eğer bu bit 1 ise sayı tektir, 0 ise çifttir. Bunu sağlamak için bit AND işlemi kullanırız. Örneğin, aşağıdaki kodu inceleyelim:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi & 1) {\n        printf(\"%d sayısı tektir.\\n\", sayi);\n    } else {\n        printf(\"%d sayısı çifttir.\\n\", sayi);\n    }\n    return 0;\n}\n```\nBu kodda kullanıcıdan bir sayı alıyoruz ve `sayi & 1` ifadesiyle en düşük bitini kontrol ediyoruz. Eğer sonuç 1 ise sayı tektir, aksi takdirde çifttir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:52.802034"
  },
  {
    "question": "Bir grup bayrağı (flags) kullanarak bir nesnenin durumu (örn. aktif, pasif, silinmiş) nasıl temsil edebilirim? Detaylı bir açıklama ile örnek ver.",
    "answer": "Bir nesnenin birden fazla durumunu bit bayrağı (flags) kullanarak temsil edebiliriz. Her bir durum için bir bit ayırırız. Örneğin, 3 durumumuz olsun: Aktif (0. bit), Pasif (1. bit), Silinmiş (2. bit). Her bir durumu temsil eden bitleri kullanarak bir tamsayı oluşturabiliriz. Aşağıdaki kod örneğini inceleyelim:\n\n```c\n#include <stdio.h>\n\n#define AKTIF 0x01   // 0001\n#define PASIF 0x02   // 0010\n#define SILINMIS 0x04 // 0100\n\nint main() {\n    int durum = AKTIF | PASIF; // Nesne hem aktif hem pasif durumda.\n\n    // Durum kontrolü\n    if (durum & AKTIF) {\n        printf(\"Nesne aktiftir.\\n\");\n    }\n    if (durum & PASIF) {\n        printf(\"Nesne pasif durumdadır.\\n\");\n    }\n    if (durum & SILINMIS) {\n        printf(\"Nesne silinmiştir.\\n\");\n    }\n\n    // Durumu silinmiş olarak güncelleyelim\n    durum |= SILINMIS;\n\n    // Güncellenmiş durumu kontrol edelim\n    if (durum & SILINMIS) {\n        printf(\"Nesne artık silinmiştir.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, durumu temsil etmek için bir tamsayı (`durum`) kullanılıyor. `AKTIF`, `PASIF`, ve `SILINMIS` durumları için bit maskeleri tanımlıyoruz. `|` (bit OR) işlemi ile bir durumu ekleyebiliriz ve `&` (bit AND) işlemi ile durumları kontrol edebiliriz. Bu şekilde bir nesnenin birden fazla durumu etkili bir şekilde yönetilebilir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:04:52.802093"
  },
  {
    "question": "Verilen bir tamsayıda (int) en düşük bit (least significant bit) değerini bulmak için bir fonksiyon yazın. Örneğin, girdi 6 ise, çıktı 0 olmalı çünkü 6'nın ikilik gösterimi 110'dur ve en düşük bit 0'dır.",
    "answer": "#include <stdio.h>\n\nint enDusukBit(int sayi) {\n    return sayi & 1; // Sayının en düşük bitini bulmak için bitwise AND işlemi\n}\n\nint main() {\n    int sayi = 6;\n    printf(\"En düşük bit: %d\\n\", enDusukBit(sayi)); // Çıktı 0\n    return 0;\n}\n\n// Açıklama: Burada 'sayi & 1' işlemi ile sayının en düşük bitini buluyoruz. Eğer sonuç 1 ise en düşük bit 1'dir, 0 ise 0'dır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:00.883602"
  },
  {
    "question": "Bir tamsayıda (int) belirli bir bitin değerini set etmek (1 yapmak) için bir fonksiyon yazın. Örneğin, girdi 5 ve 1. bit set edilirse, çıktı 7 olmalıdır (5'in ikilik gösterimi 101, 1. bit set edildiğinde 111 olur).",
    "answer": "#include <stdio.h>\n\nint bitSet(int sayi, int bitIndex) {\n    return sayi | (1 << bitIndex); // Bitin değerini set etmek için bitwise OR ve shift işlemi\n}\n\nint main() {\n    int sayi = 5;\n    int bitIndex = 1;\n    printf(\"Yeni değer: %d\\n\", bitSet(sayi, bitIndex)); // Çıktı 7\n    return 0;\n}\n\n// Açıklama: '1 << bitIndex' işlemi ile ilgili bitin konumunu belirliyoruz, ardından bu değeri sayının mevcut değeri ile birleştiriyoruz. Bu şekilde, belirtilen bitin değeri 1 olur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:00.883680"
  },
  {
    "question": "İki tam sayının bit düzeyinde AND işlemi ile sonucunu döndüren bir C fonksiyonu yazın. Örnek: 12 ve 10 için sonuç nedir?",
    "answer": "Aşağıdaki C fonksiyonu, iki tam sayının bit düzeyinde AND işlemini gerçekleştirir. AND işlemi, iki bitin ikisi de 1 olduğunda 1 döner, diğer durumlarda 0 döner.\n\n```c\n#include <stdio.h>\n\nint bitwise_and(int a, int b) {\n    return a & b;\n}\n\nint main() {\n    int a = 12; // 1100\nt    int b = 10; // 1010\n    int result = bitwise_and(a, b);\n    printf(\"%d AND %d = %d\\n\", a, b, result); // 8 yazmalıdır (1000)\n    return 0;\n}\n```\n\nYukarıdaki örnekte, 12 ve 10 sayılarının binary temsilini göz önünde bulundurursak:\n\n12 = 1100\n10 = 1010\n\nAND işlemi sonucunda elde edilen değer:\n\n```\n   1100\nAND 1010\n-------\n   1000 (Bu da 8'e denk gelir)\n```\n\nSonuç olarak, 12 ve 10 sayılarının bit düzeyinde AND işleminin sonucu 8'dir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:17.605919"
  },
  {
    "question": "Verilen bir tam sayının en düşük bitini (LSB) ayıran bir fonksiyon yazın. Bu bit 1 ise sayının tek olduğunu, 0 ise çift olduğunu belirtecektir.",
    "answer": "Aşağıdaki C fonksiyonu, bir tam sayının en düşük bitini ayırarak sayının tek veya çift olduğunu belirler.\n\n```c\n#include <stdio.h>\n\nvoid check_even_odd(int num) {\n    if (num & 1) {\n        printf(\"%d sayısı tektir.\\n\", num);\n    } else {\n        printf(\"%d sayısı çifttir.\\n\", num);\n    }\n}\n\nint main() {\n    int number = 5;\n    check_even_odd(number); // 5 sayısı tektir.\n    number = 8;\n    check_even_odd(number); // 8 sayısı çifttir.\n    return 0;\n}\n```\n\nBu fonksiyonda, `num & 1` ifadesi kullanılarak `num` değişkeninin en düşük biti kontrol edilir. Eğer sonuç 1 ise, sayı tektir, 0 ise sayının çift olduğu sonucuna varılır. Örneğin, 5 sayısının binary karşılığı 101 olduğundan, en düşük bit 1'dir ve bu nedenle 5 tektir. 8 sayısı ise binary olarak 1000'dir ve en düşük bit 0 olduğundan, 8 çifttir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:17.605993"
  },
  {
    "question": "Bitwise işlemler kullanarak bir sayının bitlerini tersine çeviren bir C fonksiyonu yazın. Örneğin, 5 (0000 0101) girişi için 2 (0000 0010) çıktısını vermelidir.",
    "answer": "#include <stdio.h>\n\nunsigned int reverseBits(unsigned int num) {\n    unsigned int reverse_num = 0;\n    int bit_count = sizeof(num) * 8; // Sayının bit sayısını al\n    for (int i = 0; i < bit_count; i++) {\n        // En sağdaki biti al ve tersine ekle\n        if (num & (1 << i)) {\n            reverse_num |= (1 << (bit_count - 1 - i));\n        }\n    }\n    return reverse_num;\n}\n\nint main() {\n    unsigned int num = 5; // 0000 0101\n    unsigned int reversed = reverseBits(num);\n    printf(\"%u sayısının tersine çevrilmiş hali: %u\\n\", num, reversed); // Çıktı: 2\n    return 0;\n}\n\n// Açıklama: Bu fonksiyon, verilen bir sayının bitlerini tersine çevirir. Önce sayının bit sayısını hesaplarız, ardından her bit için döngü kurarak en sağdaki bitin değerini kontrol ederiz. Eğer bit 1 ise, tersine çevrilen sayının doğru pozisyona 1 yazarız.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:29.042825"
  },
  {
    "question": "Bir tamsayı dizisindeki tüm elemanların bitwise OR işlemi sonucu elde edilen değeri hesaplayan bir C fonksiyonu yazın. Örneğin, dizi {1, 2, 3} için sonuç 3 olmalıdır.",
    "answer": "#include <stdio.h>\n\nint bitwiseOrArray(int arr[], int size) {\n    int result = 0;\n    for (int i = 0; i < size; i++) {\n        result |= arr[i]; // Her elemanın bitwise OR'unu al\n    }\n    return result;\n}\n\nint main() {\n    int arr[] = {1, 2, 3};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int result = bitwiseOrArray(arr, size);\n    printf(\"Dizinin bitwise OR sonucu: %d\\n\", result); // Çıktı: 3\n    return 0;\n}\n\n// Açıklama: Bu fonksiyon, verilen bir dizinin tüm elemanlarının bitwise OR işlemini hesaplar. Her bir elemanın bitwise OR işlemi ile `result` değişkenine eklenmesi sağlanır. Sonuç olarak dizinin elemanları arasındaki bitwise OR işleminin sonucu döndürülür.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:29.042896"
  },
  {
    "question": "Bit mask kullanarak bir sayıdan belirli bir bitin değerini nasıl alabilirim? Örnek bir kod verin.",
    "answer": "Belirli bir bitin (örneğin 3. bit) değerini almak için bit mask kullanabiliriz. Aşağıdaki örnek, bir sayının 3. bitinin değerini alır:\n\n```c\n#include <stdio.h>\n\nint get_bit(int number, int bit_position) {\n    return (number >> bit_position) & 1;\n}\n\nint main() {\n    int number = 10; // Binary: 1010\n    int bit_position = 3;\n    int bit_value = get_bit(number, bit_position);\n    printf(\"%d. bitin değeri: %d\\n\", bit_position, bit_value);\n    return 0;\n}\n```\n\nBu kodda `get_bit` fonksiyonu, verilen sayıdan belirtilen bit pozisyonunu alır. Önce sayıyı sağa kaydırırız ve ardından 1 ile AND işlemi yaparak o bitin değerini elde ederiz. Örnekte `10` sayısının 3. bitinin değeri `0`'dır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:39.834957"
  },
  {
    "question": "İki sayının bitwise XOR işlemini kullanarak birbirlerinin bitlerini değiştiren bir fonksiyon yazın. Fonksiyonu optimize edin.",
    "answer": "İki sayının bitlerini değiştirmek için bitwise XOR işlemi kullanılabilir. Aşağıdaki kod, iki sayının bitlerini değiştiren bir fonksiyonu göstermektedir:\n\n```c\n#include <stdio.h>\n\nvoid swap_bits(int *a, int *b) {\n    *a = *a ^ *b; // 1. adım: a = a XOR b\n    *b = *a ^ *b; // 2. adım: b = (a XOR b) XOR b = a\n    *a = *a ^ *b; // 3. adım: a = (a XOR b) XOR a = b\n}\n\nint main() {\n    int x = 5; // Binary: 0101\n    int y = 9; // Binary: 1001\n    printf(\"Önce: x = %d, y = %d\\n\", x, y);\n    swap_bits(&x, &y);\n    printf(\"Sonra: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```\n\nBu fonksiyonda, `swap_bits` fonksiyonu kullanılarak iki sayının bitleri XOR işlemi ile değiştirilir. Bu yöntem, geçici bir değişken kullanmadan, sadece birkaç bit işlemi ile bitlerin yerlerini değiştirmemizi sağlar. Örnekte `x` ve `y` değerleri değiştikten sonra `x` değeri `9`, `y` değeri ise `5` olacaktır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:39.835020"
  },
  {
    "question": "Verilen bir tam sayının en yüksek bitini (most significant bit) bulmak için bir fonksiyon yazın. Ancak bu işlemi bit işlemleri kullanarak optimize edin.",
    "answer": "Aşağıdaki fonksiyon, verilen bir tam sayının en yüksek bitini bulmak için bit işlemlerini kullanır. Yüksek bitin bulunması, sayının hangi aralıkta bulunduğunu belirlemeye yardımcı olur. Bu işlem, sayının pozitif olduğunu varsayar.\n\n```c\n#include <stdio.h>\n\nint highest_bit(int num) {\n    if (num <= 0) return -1;  // Geçersiz giriş\n    int bit = 0;\n    while (num > 1) {\n        num >>= 1;  // Sayıyı sağa kaydır\n        bit++;\n    }\n    return bit;\n}\n\nint main() {\n    int number = 18;  // Örnek sayı (10010 binary)\n    int result = highest_bit(number);\n    printf(\"En yüksek bit: %d\\n\", result);\n    return 0;\n}\n```\n\nBu fonksiyon, sayıyı her seferinde sağa kaydırarak en yüksek biti bulur. Performansı artırmak için, bu işlemi bitwise AND ve XOR gibi diğer bit işlemleri ile de birleştirebiliriz, ancak bu örnek temel işlemi göstermektedir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:51.575323"
  },
  {
    "question": "İki tam sayının bit düzeyinde XOR işlemini kullanarak toplamını hesaplayan bir fonksiyon yazın. Bu yaklaşım, toplama işleminin iki bitin toplamından ve taşıma bitinden nasıl oluştuğunu da göstermelidir.",
    "answer": "Aşağıdaki fonksiyon, iki sayının toplamını bit düzeyinde XOR işlemi ve AND işlemi kullanarak hesaplar. Bu yöntem, taşıma bitlerini de hesaba katarak çalışır.\n\n```c\n#include <stdio.h>\n\nint bitwise_add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;  // Taşıma bitlerini bul\n        a = a ^ b;          // XOR ile toplama işlemi\n        b = carry << 1;     // Taşımayı sola kaydır\n    }\n    return a;\n}\n\nint main() {\n    int num1 = 15; // Örnek sayı 1\n    int num2 = 27; // Örnek sayı 2\n    int result = bitwise_add(num1, num2);\n    printf(\"Toplam: %d\\n\", result);\n    return 0;\n}\n```\n\nBu fonksiyon, iki sayıyı toplamak için bit düzeyinde işlemleri kullanır. Öncelikle, taşıma bitlerini bulur ve toplamı hesaplar. Sonra taşıma bitini sola kaydırarak işlemi devam ettirir. Bu yöntem, bit manipülasyonları ile aritmetik işlemlerini optimize etmek için sıkça kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-05-31T18:05:51.575392"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarının toplamını özyinelemeli bir fonksiyon kullanarak hesaplamak için eksik kodu tamamlayın. Fonksiyonun adı 'arraySum' olmalıdır.",
    "answer": "Aşağıda 'arraySum' fonksiyonu, dizinin elemanlarının toplamını özyinelemeli olarak hesaplamak için tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint arraySum(int arr[], int n) {\n    // Taban durumu: Dizi elemanı kalmadıysa 0 döndür\n    if (n <= 0) {\n        return 0;\n    }\n    // Özyineleme: Son elemanı topla ve geri kalan diziyi hesapla\n    return arr[n-1] + arraySum(arr, n-1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int sum = arraySum(arr, n);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", sum);\n    return 0;\n}\n```\nBu kodda, 'arraySum' fonksiyonu dizinin son elemanını alır ve onu dizinin geri kalanı ile toplar. Taban durumu dizinin boyutu sıfır olduğunda '0' döndürmektir. Özyinelemeli çağrılar dizinin boyutu azaldıkça devam eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:18.961956"
  },
  {
    "question": "Verilen bir pozitif tamsayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon tamamlayın. Fonksiyon adı 'factorial' olmalıdır.",
    "answer": "Aşağıda 'factorial' fonksiyonu, verilen bir pozitif tamsayının faktöriyelini özyinelemeli olarak hesaplamak için tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint factorial(int n) {\n    // Taban durumu: 0! = 1 ve 1! = 1\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    // Özyineleme: n! = n * (n-1)! hesapla\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int num = 5;\n    int result = factorial(num);\n    printf(\"%d sayısının faktöriyeli: %d\\n\", num, result);\n    return 0;\n}\n```\nBu kodda, 'factorial' fonksiyonu, n sayısının faktöriyelini hesaplamak için kendini çağırmaktadır. Taban durumu 0 veya 1 için '1' döndürmektir. Özyineleme ile hesaplama 'n * (n-1)!' şeklinde yapılmaktadır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:18.962020"
  },
  {
    "question": "Bir dizideki elemanların toplamını bulmak için özyinelemeli bir fonksiyon yazın. Dizi ve boyut parametrelerini alarak toplamı döndüren fonksiyonu tamamlayın.",
    "answer": "Aşağıdaki kod, bir dizideki elemanların toplamını bulmak için özyinelemeli bir fonksiyon kullanmaktadır:\n\n```c\n#include <stdio.h>\n\nint arraySum(int arr[], int size) {\n    // Taban durum: Eğer boyut 0 ise toplam 0'dır.\n    if (size <= 0) {\n        return 0;\n    } else {\n        // Özyineleme: Son elemanı ekleyip, dizinin geri kalanıyla tekrar çağırıyoruz.\n        return arr[size - 1] + arraySum(arr, size - 1);\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int total = arraySum(arr, size);\n    printf(\"Dizinin elemanlarının toplamı: %d\\n\", total);\n    return 0;\n}\n```\n\nBu kodda, `arraySum` fonksiyonu, dizinin boyutunu kontrol ederek özyinelemeli bir şekilde çalışır. Eğer dizinin boyutu 0'dan küçük veya eşitse, toplam 0 olarak döner. Aksi takdirde, son elemanı alarak, geri kalan elemanların toplamını bulmak için kendisini tekrar çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:30.878265"
  },
  {
    "question": "Bir pozitif tam sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon yazın. Kullanıcıdan bir sayı alarak bu sayının faktöriyelini hesaplayacak şekilde kodu tamamlayın.",
    "answer": "Aşağıdaki kod, bir pozitif tam sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon kullanmaktadır:\n\n```c\n#include <stdio.h>\n\nint factorial(int n) {\n    // Taban durum: 0 veya 1'in faktöriyeli 1'dir.\n    if (n == 0 || n == 1) {\n        return 1;\n    } else {\n        // Özyineleme: n * (n-1)'in faktöriyelini hesaplıyoruz.\n        return n * factorial(n - 1);\n    }\n}\n\nint main() {\n    int number;\n    printf(\"Bir pozitif tam sayi girin: \");\n    scanf(\"%d\", &number);\n    if (number < 0) {\n        printf(\"Negatif sayılar için faktöriyel tanımlı değildir.\\n\");\n    } else {\n        printf(\"%d sayısının faktöriyeli: %d\\n\", number, factorial(number));\n    }\n    return 0;\n}\n```\n\nBu kodda, `factorial` fonksiyonu, bir sayının faktöriyelini hesaplamak için özyineleme kullanır. Eğer sayı 0 veya 1 ise, faktöriyel 1 olarak döner. Aksi takdirde, `n` ile `n-1` sayısının faktöriyelini çarparak işlemi sürdürür. Kullanıcıdan alınan pozitif tam sayı için faktöriyel hesaplanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:30.878362"
  },
  {
    "question": "Aşağıdaki özyinelemeli fonksiyonun hatalı olduğunu düşünüyorum. Bu fonksiyon, verilen bir pozitif tam sayının faktöriyelini hesaplamalı. Ancak doğru çalışmıyor. Hatanın ne olduğunu bulabilir misin?\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * faktoriyel(n - 1);\n    }\n}\n\nint main() {\n    int sayi = 5;\n    printf(\"%d! = %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```",
    "answer": "Bu kod, pozitif bir tam sayının faktöriyelini doğru bir şekilde hesaplamaktadır. Ancak dikkat edilmesi gereken nokta, faktöriyel fonksiyonunun 0 için 1 döndüğü durumdur. Burada hata yok, fakat kullanıcı negatif bir sayı girdiği takdirde program sonsuz döngüye girer. Bu durumu kontrol etmek için, fonksiyonda n < 0 durumu için uygun bir hata mesajı eklemek faydalı olacaktır. Aşağıdaki gibi güncelleyebiliriz:\n\n```c\nint faktoriyel(int n) {\n    if (n < 0) {\n        printf(\"Negatif sayıların faktöriyelini hesaplayamam.\\n\");\n        return -1; // Hata durumu\n    }\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * faktoriyel(n - 1);\n    }\n}\n```\nBu güncelleme, kullanıcıdan alınan sayının negatif olması durumunda bir hata mesajı gösterir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:43.497377"
  },
  {
    "question": "Aşağıdaki C kodunda özyinelemeli bir fonksiyon kullanarak Fibonacci sayısını hesaplıyorum. Ancak bazı durumlarda beklenmedik sonuçlar alıyorum. Hatanın nerede olduğunu bulabilir misin?\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n    int n = 7;\n    printf(\"Fibonacci(%d) = %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```",
    "answer": "Kod genel olarak doğru bir şekilde Fibonacci sayılarını hesaplıyor. Ancak `fibonacci` fonksiyonunun 0 ve 1 durumu için tanımlanması gerekirken, negatif sayılar için bir kontrol yok. Eğer kullanıcı negatif bir sayı girerse fonksiyon hatalı bir sonuç döndürecektir. Aşağıdaki gibi bir güncelleme yaparak bu durumu düzeltebiliriz:\n\n```c\nint fibonacci(int n) {\n    if (n < 0) {\n        printf(\"Negatif sayılar için Fibonacci tanımlı değildir.\\n\");\n        return -1; // Hata durumu\n    } else if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n```\nBu güncelleme ile negatif sayılar için bir uyarı mesajı ekleyerek, programın daha güvenilir çalışmasını sağlarız.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:43.497589"
  },
  {
    "question": "Aşağıdaki kodda, bir sayının faktöriyelini hesaplamak için yazılmış bir özyinelemeli fonksiyon var. Ancak, kod çalıştırıldığında sonsuz döngüye giriyor. Hatanın nedenini bul ve düzelt.",
    "answer": "Kod şu şekilde: \n\n```c\nint factorial(int n) {\n    return n * factorial(n - 1);\n}\n```\n\nHatanın nedeni, 'n' sıfıra ulaştığında duracak bir temel durum (base case) olmaması. Bu durum, fonksiyonun her zaman 'n' değerini azaltarak devam etmesine ve en sonunda bir yığılma (stack overflow) hatasına neden olmasına yol açar. Düzgün çalışan bir versiyon için temel durumu eklemeliyiz:\n\n```c\nint factorial(int n) {\n    if (n == 0) return 1; // Temel durum\n    return n * factorial(n - 1);\n}\n```\n\nBu değişiklikle, 'n' sıfır olduğunda fonksiyon 1 dönecek ve bu da özyinelemeyi sonlandıracaktır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:55.719590"
  },
  {
    "question": "Aşağıdaki C kodunda, bir dizinin toplamını özyinelemeli olarak hesaplamak için bir fonksiyon yazılmış. Ancak, bu kodda bir hata var ve beklenmedik sonuçlar veriyor. Hatanın kaynağını bul ve düzelt.",
    "answer": "Kod şu şekilde: \n\n```c\nint sum(int arr[], int n) {\n    return arr[n] + sum(arr, n - 1);\n}\n```\n\nHatanın kaynağı, 'n' sıfıra ulaştığında dizinin sınırlarının aşılmasıdır. Bu, 'arr[n]' ifadesinin geçersiz bir bellek adresine erişmesine neden olabilir. Ayrıca, temel durum da eksik. Düzgün çalışan bir versiyon için temel durum eklemeliyiz:\n\n```c\nint sum(int arr[], int n) {\n    if (n < 0) return 0; // Temel durum\n    return arr[n] + sum(arr, n - 1);\n}\n```\n\nBu değişiklikle, 'n' sıfırın altına düştüğünde fonksiyon 0 dönecek ve dizinin toplamını doğru bir şekilde hesaplayacak.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:06:55.719660"
  },
  {
    "question": "Aşağıdaki özyinelemeli fonksiyon, bir tamsayının faktöriyelini hesaplamak için yazılmıştır. Ancak, programın doğru çalışmadığını ve sonsuz döngüye girdiğini fark ettim. Hataları bul ve düzelt.",
    "answer": "Fonksiyonun kodu şu şekildedir:\n\n```c\nint factorial(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n);\n}\n```\n\nBurada dikkat edilmesi gereken en önemli hata, 'return n * factorial(n);' ifadesidir. Bu ifade, 'n' değeri her seferinde aynı kalacağı için sonsuz döngüye girmektedir. Doğru olan, 'return n * factorial(n - 1);' şeklinde güncellenmektir. Bu değişiklik ile her özyinelemeli çağrıda 'n' değeri bir azaltılmış olacak ve sonunda 'n' 1 veya daha küçük bir değere ulaştığında fonksiyon doğru bir şekilde dönecektir. Düzgün çalışan versiyonu şu şekildedir:\n\n```c\nint factorial(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:07.380037"
  },
  {
    "question": "Aşağıdaki kod parçası, Fibonacci dizisinin n'inci elemanını bulmak için yazılmıştır. Ancak, kod beklenenden daha uzun sürede çalışıyor. Hataları bul ve düzelt.",
    "answer": "Verilen kod şu şekildedir:\n\n```c\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\n\nBu kod, Fibonacci dizisini özyinelemeli olarak hesaplamak için doğru bir yapıdadır. Ancak, büyük 'n' değerlerinde aşırı sayıda tekrar hesaplama yapılmaktadır, bu da performansı olumsuz etkilemektedir. Örneğin, fibonacci(5) çağrıldığında, fibonacci(3) ve fibonacci(4) tekrar tekrar hesaplanmaktadır. Bu durumu düzeltmek için, Dinamik Programlama (Dynamic Programming) veya Memoization yöntemlerini uygulamak en iyisidir. Memoization ile hesaplanan değerleri saklayarak gereksiz hesaplamaları önleyebiliriz. İşte güncellenmiş bir versiyon:\n\n```c\nint memo[100];\n\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    if (memo[n] != -1) {\n        return memo[n];\n    }\n    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);\n    return memo[n];\n}\n\nvoid initializeMemo() {\n    for (int i = 0; i < 100; i++) {\n        memo[i] = -1;\n    }\n}\n```  \n\nBu şekilde hesaplanan değerler 'memo' dizisinde saklanır ve tekrar hesaplamalarından kaçınılarak performans artırılır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:07.380096"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon yazabilir misiniz? Özyinelemeli yapıyı nasıl açıklarsınız?",
    "answer": "Tabii ki! Bir sayının faktöriyeli, o sayının kendisi dahil, 1'e kadar olan tüm pozitif tamsayıların çarpımıdır. Özyinelemeli bir fonksiyon olarak, n! = n * (n-1)! şeklinde tanımlanabilir. Bu tanımda, (n-1)! ifadesi, aynı fonksiyonun bir alt problemi olarak kendisiyle tekrar çağrıldığını gösterir. Örneğin, faktöriyel hesaplamak için aşağıdaki kodu kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) { // Temel durum\n        return 1;\n    } else { // Özyineleme durumu\n        return n * faktoriyel(n - 1);\n    }\n}\n\nint main() {\n    int sayi = 5;\n    printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```\n\nBu kodda, faktoriyel fonksiyonu n'in 0 olduğu temel durumda 1 döner. Eğer n 0'dan büyükse, fonksiyon kendisini n-1 ile tekrar çağırır. Bu şekilde, her çağrıda n değeri bir azalır ve son olarak temel duruma ulaşır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:18.803787"
  },
  {
    "question": "Bir dizideki tüm elemanların toplamını hesaplamak için özyinelemeli bir fonksiyon yazabilir misiniz? Özyinelemeli yapı nasıl çalışır?",
    "answer": "Elbette! Dizi öğelerinin toplamını bulmak için özyineleme kullanılabilir. Özyinelemeli bir fonksiyon, dizinin ilk elemanını toplama dahil edip, kalan elemanlar için kendisini tekrar çağırabilir. Örneğin, toplam hesaplamak için aşağıdaki kodu yazabiliriz:\n\n```c\n#include <stdio.h>\n\nint diziToplam(int dizi[], int boyut) {\n    if (boyut == 0) { // Temel durum\n        return 0;\n    } else { // Özyineleme durumu\n        return dizi[0] + diziToplam(dizi + 1, boyut - 1);\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin toplamı: %d\\n\", diziToplam(dizi, boyut));\n    return 0;\n}\n```\n\nBu kodda, diziToplam fonksiyonu, dizinin boyutu 0 olduğunda 0 döner. Eğer boyut 0'dan büyükse, dizinin ilk elemanı dizi[0] toplanır ve fonksiyon kendisini dizinin geri kalan kısmı için tekrar çağırır. Bu şekilde, dizinin tüm elemanları toplanmış olur.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:18.803836"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon nasıl yazılır? Örnek olarak 5! hesaplamak istiyoruz.",
    "answer": "Faktöriyel, bir pozitif tam sayının kendisi ve öncesindeki tüm pozitif tam sayıların çarpımını temsil eder. Özyinelemeli bir fonksiyon kullanarak bu hesaplamayı yapabiliriz. Aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0 || n == 1) {\n        return 1;  // Temel durum: 0! = 1 ve 1! = 1\n    } else {\n        return n * faktoriyel(n - 1);  // Özyineleme\n    }\n}\n\nint main() {\n    int sayi = 5;\n    printf(\"%d! = %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```\nBu kodda, `faktoriyel` fonksiyonu, `n` sıfır veya bir olduğunda 1 döndürüyor. Aksi takdirde, `n` değeri `faktoriyel(n - 1)` ile çarpılıyor, yani kendisi ile bir alt faktöriyel çarpılıyor. Örneğin, 5! hesaplanırken `5 * faktoriyel(4)` hesaplanır ve bu da `5 * 4 * 3 * 2 * 1` sonucunu verir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:31.753942"
  },
  {
    "question": "Bir dizideki elemanların toplamını özyineleme kullanarak nasıl hesaplayabiliriz? Örnek olarak [2, 4, 6, 8] dizisinin toplamını bulalım.",
    "answer": "Bir dizinin elemanlarını özyinelemeli bir fonksiyon ile toplamak için dizinin ilk elemanını alıp, dizinin geri kalan elemanlarını toplamak üzere fonksiyonu çağırabiliriz. İşte bu yaklaşımı gösteren bir C kodu:\n\n```c\n#include <stdio.h>\n\nint diziToplam(int dizi[], int boyut) {\n    if (boyut == 0) {\n        return 0;  // Temel durum: dizinin boyutu 0 ise toplam 0'dır.\n    } else {\n        return dizi[0] + diziToplam(dizi + 1, boyut - 1);  // Özyineleme: ilk eleman + geri kalan\n    }\n}\n\nint main() {\n    int dizi[] = {2, 4, 6, 8};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin toplamı: %d\\n\", diziToplam(dizi, boyut));\n    return 0;\n}\n```\nBu kodda, `diziToplam` fonksiyonu, dizinin boyutu sıfır olduğunda 0 döndürüyor. Aksi takdirde, dizinin ilk elemanı `dizi[0]` ile `diziToplam(dizi + 1, boyut - 1)` çağrısının sonucunu topluyor. Bu şekilde, dizinin her bir elementi tek tek toplanarak toplam değeri elde edilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:31.754029"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını hesaplamak için özyinelemeli bir fonksiyon nasıl yazılır ve bu fonksiyonun nasıl çalıştığını açıkla.",
    "answer": "Özyinelemeli bir fonksiyon, kendisini çağırarak bir problemi daha küçük parçalara ayırarak çözer. Dizi elemanlarının toplamını hesaplamak için, dizinin ilk elemanını alıp, geri kalan elemanların toplamını bulmak için kendisini çağırabiliriz. İşte bu yaklaşımı kullanan bir fonksiyon: \n\n```c\n#include <stdio.h>\n\nint diziToplam(int dizi[], int boyut) {\n    if (boyut == 0) // Temel durum: Hiçbir eleman kalmadıysa toplam 0'dır.\n        return 0;\n    return dizi[0] + diziToplam(dizi + 1, boyut - 1); // İlk elemanı al ve geri kalanı ile rekürsif çağrı yap.\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizi elemanlarının toplamı: %d\\n\", diziToplam(dizi, boyut));\n    return 0;\n}\n``` \nBu kodda, `diziToplam` fonksiyonu dizinin ilk elemanını toplar ve geri kalan elemanlar için kendisini çağırır. Temel durum, dizinin boyutunun 0 olduğu durumu kontrol eder ve bu durumda toplam 0 döner. Böylece, tüm elemanlar toplandıktan sonra, sonuç kullanıcıya gösterilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:44.194064"
  },
  {
    "question": "Fibonacci dizisinin n'inci elemanını özyinelemeli olarak hesaplamak için bir fonksiyon yaz ve bu fonksiyonun nasıl işlediğini anlat.",
    "answer": "Fibonacci dizisi, her elemanın kendisinden önceki iki elemanın toplamı olduğu bir dizidir. Özyinelemeli bir fonksiyon, Fibonacci dizisinin n'inci elemanını hesaplamak için kendisini çağırarak bu diziyi oluşturabilir. İşte bu yaklaşımı kullanan bir fonksiyon: \n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n == 0) // Temel durum: 0. eleman 0'dır.\n        return 0;\n    else if (n == 1) // Temel durum: 1. eleman 1'dir.\n        return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2); // n'inci elemanı hesaplamak için önceki iki elemanı topla.\n}\n\nint main() {\n    int n = 10; // Fibonacci dizisinin 10. elemanını hesaplayacağız.\n    printf(\"Fibonacci dizisinin %d. elemanı: %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```  \nBu fonksiyonda, `fibonacci` fonksiyonu, n'inci elemanı bulmak için önce n-1 ve n-2 elemanlarını hesaplayarak kendisini çağırır. Temel durumlar (n=0 ve n=1) ayarlanmıştır, böylece işlem sona erer. Bu yaklaşım, dizinin elemanlarını hesaplamak için oldukça basit ama etkin bir yol sağlar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:44.194121"
  },
  {
    "question": "Faktöriyel hesaplamak için özyinelemeli bir fonksiyon yazın. Örneğin, 5! = 5 x 4 x 3 x 2 x 1 = 120 olmalıdır.",
    "answer": "Aşağıdaki C kodu, bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon kullanmaktadır:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    // Temel durum: 0! ve 1! her ikisi de 1'dir.\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    // Özyineleme: n! = n * (n-1)! şeklinde hesaplanır.\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int sayi = 5;\n    printf(\"%d! = %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```\n\nBu kodda, `faktoriyel` fonksiyonu, `n` sayısının faktöriyelini hesaplar. Temel durum olarak, `n` 0 veya 1 olduğunda 1 döner. Eğer `n` daha büyükse, fonksiyon kendisini `n-1` ile çağırarak faktöriyeli hesaplar. Örneğin, `faktoriyel(5)` çağrıldığında, 5 * `faktoriyel(4)` ifadesine geçer ve bu şekilde devam eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:59.667939"
  },
  {
    "question": "Bir sayının Fibonacci dizisi değerini hesaplamak için özyinelemeli bir fonksiyon yazın. Örneğin, Fibonacci dizisinde 6. terim 8 olmalıdır.",
    "answer": "Aşağıdaki C kodu, Fibonacci dizisindeki bir terimi hesaplamak için özyinelemeli bir fonksiyon kullanmaktadır:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    // Temel durumlar: fibonacci(0) = 0 ve fibonacci(1) = 1'dir.\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    }\n    // Özyineleme: fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) şeklinde hesaplanır.\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int terim = 6;\n    printf(\"Fibonacci dizisinde %d. terim: %d\\n\", terim, fibonacci(terim));\n    return 0;\n}\n```\n\nBu kodda, `fibonacci` fonksiyonu, `n` sayısının Fibonacci dizisindeki karşılık gelen terimini hesaplar. Temel durum olarak, `n` 0 olduğunda 0 ve `n` 1 olduğunda 1 döner. Eğer `n` daha büyükse, fonksiyon kendisini `n-1` ve `n-2` ile çağırarak sonuçları toplar. Örneğin, `fibonacci(6)` çağrıldığında, `fibonacci(5)` ve `fibonacci(4)`'ün toplamı olan 8 döndürülür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:08:59.668009"
  },
  {
    "question": "Bir dizideki elemanların toplamını hesaplamak için özyinelemeli bir fonksiyon yazın.",
    "answer": "Aşağıda, bir dizinin elemanlarının toplamını hesaplamak için yazılmış bir özyinelemeli fonksiyon örneği bulunmaktadır. Fonksiyon, dizinin her bir elemanını toplamak için kendisini çağırır. Eğer dizinin boyutu sıfıra inerse, toplam olarak sıfır döner. Aksi takdirde, dizinin son elemanını toplama ekleyerek, dizinin geri kalanını işlemek için kendisini tekrar çağırır.\n\n```c\n#include <stdio.h>\n\nint dizininToplami(int dizi[], int boyut) {\n    if (boyut == 0) {\n        return 0; // Dizi boşsa toplam sıfırdır.\n    } else {\n        return dizi[boyut - 1] + dizininToplami(dizi, boyut - 1); // Son elemanı ekle ve geri kalan diziyi işle.\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int toplam = dizininToplami(dizi, boyut);\n    printf(\"Dizinin toplamı: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kodda, `dizininToplami` fonksiyonu dizinin elemanlarını özyinelemeli olarak toplar. `main` fonksiyonunda ise bir dizi tanımlanmış ve toplam hesaplanarak ekrana yazdırılmıştır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:17.466476"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon yazın.",
    "answer": "Aşağıda, bir sayının faktöriyelini hesaplamak için yazılmış bir özyinelemeli fonksiyon örneği bulunmaktadır. Faktöriyel, pozitif bir tamsayı n için n! = n * (n-1)! şeklinde tanımlanır. Temel durum olarak, 0! = 1'dir.\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) {\n        return 1; // 0! = 1\n    } else {\n        return n * faktoriyel(n - 1); // n! = n * (n-1)!\n    }\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (sayi < 0) {\n        printf(\"Negatif sayıların faktöriyeli tanımlı değildir.\\n\");\n    } else {\n        printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, faktoriyel(sayi));\n    }\n    return 0;\n}\n```\nBu kodda, `faktoriyel` fonksiyonu verilen sayının faktöriyelini özyinelemeli olarak hesaplar. Kullanıcıdan bir tamsayı alır ve bu sayının faktöriyelini ekrana yazdırır. Ayrıca negatif sayılar için bir kontrol mekanizması bulunmaktadır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:17.466513"
  },
  {
    "question": "Fibonacci sayılarını hesaplamak için özyinelemeli bir fonksiyon yazın. Ancak, bu fonksiyonun 0'dan n'e kadar olan tüm Fibonacci sayılarını bir dizi içerisinde döndürmesini sağlayın. Bunun yanı sıra, Fibonacci sayılarını hesaplamak için yalnızca özyineleme kullanarak optimizasyon yapın.",
    "answer": "Aşağıda, Fibonacci sayılarını hesaplamak için özyinelemeyi kullanan bir C fonksiyonu bulunmaktadır. Bu fonksiyon, verilen n değerine kadar olan Fibonacci sayılarını bir diziye kaydeder. Ayrıca, daha önce hesaplanmış Fibonacci sayılarını saklamak için bir yardımcı dizi kullanarak optimizasyon sağlanmıştır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint fibonacci(int n, int *memo) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n];\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}\n\nint* fibonacci_series(int n, int *size) {\n    int *series = malloc((n + 1) * sizeof(int));\n    int *memo = malloc((n + 1) * sizeof(int));\n    for (int i = 0; i <= n; i++) {\n        memo[i] = -1; // -1 ile başlat \n    }\n    for (int i = 0; i <= n; i++) {\n        series[i] = fibonacci(i, memo);\n    }\n    free(memo);\n    *size = n + 1;\n    return series;\n}\n\nint main() {\n    int n = 10;\n    int size;\n    int *fibonacci_numbers = fibonacci_series(n, &size);\n    printf(\"Fibonacci sayıları:\");\n    for (int i = 0; i < size; i++) {\n        printf(\" %d\", fibonacci_numbers[i]);\n    }\n    printf(\"\\n\");\n    free(fibonacci_numbers);\n    return 0;\n}\n```\n\nBu kodda, `fibonacci` fonksiyonu özyinelemeli olarak Fibonacci sayılarını hesaplar. `memo` dizisi, daha önce hesaplanmış Fibonacci sayılarını saklayarak zaman karmaşıklığını azaltır. `fibonacci_series` fonksiyonu ise belirtilen n sayısına kadar olan Fibonacci sayılarını hesaplayarak bir dizi olarak döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:33.360373"
  },
  {
    "question": "Bir dizideki tüm permutasyonları özyinelemeli bir yöntemle yazdıran bir C fonksiyonu geliştirin. Ayrıca, bu fonksiyonun yalnızca benzersiz permutasyonları yazdırmasını sağlamak için bir kontrol mekanizması ekleyin.",
    "answer": "Aşağıda, özyineleme kullanarak bir dizinin tüm benzersiz permutasyonlarını yazdıran bir C fonksiyonu verilmiştir. `used` dizisi, belirli bir elemanın daha önce kullanılıp kullanılmadığını takip edebilmek için kullanılır:\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid permute(char *str, int l, int r) {\n    if (l == r) {\n        printf(\"%s\\n\", str);\n    } else {\n        for (int i = l; i <= r; i++) {\n            bool shouldSwap = true;\n            for (int j = l; j < i; j++) {\n                if (str[j] == str[i]) {\n                    shouldSwap = false;\n                    break;\n                }\n            }\n            if (shouldSwap) {\n                swap(&str[l], &str[i]);\n                permute(str, l + 1, r);\n                swap(&str[l], &str[i]); // geri çevir\n            }\n        }\n    }\n}\n\nint main() {\n    char str[] = \"AAB\";\n    int n = strlen(str);\n    permute(str, 0, n - 1);\n    return 0;\n}\n```\n\nBu kod, verilen bir karakter dizisinin tüm permutasyonlarını özyinelemeli olarak hesaplar ve yazdırır. `swap` fonksiyonu, karakterlerin yer değiştirmesini sağlar. `permute` fonksiyonu, özyineleme ile her bir karakter pozisyonu için permutasyonları oluşturur. `shouldSwap` kontrolü, dizide bulunan benzer karakterler için tekrar eden permutasyonların engellenmesini sağlar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:33.360440"
  },
  {
    "question": "Fibonacci dizisinin n'inci elemanını hesaplayan bir özyinelemeli fonksiyon mevcut. Ancak performans sorunları var. Bu fonksiyonu nasıl optimize edersiniz?",
    "answer": "Fibonacci dizisini hesaplamak için kullanılan klasik özyinelemeli yöntem, O(2^n) zaman karmaşıklığına sahiptir. Bu, özellikle büyük n değerlerinde oldukça yavaş çalışmasına neden olur. Bu durumu optimize etmek için aşağıdaki yöntemleri kullanabiliriz:\n\n1. **Memoization**: Hesaplanan her Fibonacci sayısını bir dizi veya harita içinde saklayarak tekrar hesaplamaktan kaçınabiliriz. Bu yöntem zaman karmaşıklığını O(n) düzeyine indirecektir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint fibonacci(int n, int *memo) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n];\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}\n\nint main() {\n    int n = 10;\n    int *memo = malloc((n + 1) * sizeof(int));\n    for (int i = 0; i <= n; i++) memo[i] = -1;\n    printf(\"%d. Fibonacci: %d\\n\", n, fibonacci(n, memo));\n    free(memo);\n    return 0;\n}\n```\n\n2. **Dinamik Programlama**: Fibonacci dizisini hesaplama işlemlerini döngü ile gerçekleştirebiliriz. Bu da benzer bir O(n) zaman karmaşıklığı sağlar fakat daha az bellek kullanır.\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\nint main() {\n    int n = 10;\n    printf(\"%d. Fibonacci: %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:49.914401"
  },
  {
    "question": "Bir dizide belirli bir elemanın kaç kez tekrar ettiğini sayan özyinelemeli bir fonksiyon var. Ancak bu fonksiyon, dizi içinde diğer elemanları da kontrol ederken gereksiz yere bellekte yer kaplıyor. Bunu nasıl iyileştirirsiniz?",
    "answer": "Özyinelemeli fonksiyonun dizi içinde tekrar eden elemanları sayarken her zaman tüm diziyi kontrol etmesi, zaman ve bellek açısından verimsizdir. Bu durumu iyileştirmek için birkaç önerim var:\n\n1. **Başlangıç ve Bitiş İndeksleri**: Özyinelemeli fonksiyonumuzun hangi elemanları kontrol edeceğini belirtmek için başlangıç ve bitiş indeksleri kullanabiliriz. Böylece her çağrıda sadece ilgili alt dizi kontrol edilir.\n\n```c\n#include <stdio.h>\n\nint countOccurrences(int arr[], int size, int element, int index) {\n    if (index >= size) return 0;\n    return (arr[index] == element) + countOccurrences(arr, size, element, index + 1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 1, 2, 4};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int element = 2;\n    int count = countOccurrences(arr, size, element, 0);\n    printf(\"%d elemanının dizideki sayısı: %d\\n\", element, count);\n    return 0;\n}\n```\n\n2. **Tail Recursion (Kuyruk Özyinelemesi)**: Eğer sisteminizin desteklediği bir derleyici varsa, tail recursion optimizasyonu kullanarak bellek kalıntılarını azaltabiliriz. Böylece her çağrıda yeni bir yığın çerçevesi oluşturulmaz ve mevcut çerçeve güncellenir.\n\n```c\n#include <stdio.h>\n\nint countOccurrencesHelper(int arr[], int size, int element, int index, int count) {\n    if (index >= size) return count;\n    return countOccurrencesHelper(arr, size, element, index + 1, count + (arr[index] == element));\n}\n\nint countOccurrences(int arr[], int size, int element) {\n    return countOccurrencesHelper(arr, size, element, 0, 0);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 1, 2, 4};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int element = 2;\n    int count = countOccurrences(arr, size, element);\n    printf(\"%d elemanının dizideki sayısı: %d\\n\", element, count);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:09:49.914520"
  },
  {
    "question": "Bir dosya sistemindeki tüm dosyaların boyutunu hesaplayan özyinelemeli bir fonksiyon yazdım. Ancak performans sorunları yaşıyorum. Aşağıdaki kodu inceleyebilir misiniz?",
    "answer": "Elbette, örnek kodu inceleyelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <sys/stat.h>\n\nlong get_total_size(const char *path) {\n    long total_size = 0;\n    struct dirent *entry;\n    struct stat statbuf;\n    DIR *dir = opendir(path);\n\n    if (dir == NULL) {\n        return -1; // Hata durumu\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        char full_path[1024];\n        snprintf(full_path, sizeof(full_path), \"%s/%s\", path, entry->d_name);\n\n        if (stat(full_path, &statbuf) == 0) {\n            if (S_ISDIR(statbuf.st_mode)) {\n                // Özyinelemeli çağrı\n                total_size += get_total_size(full_path);\n            } else {\n                total_size += statbuf.st_size;\n            }\n        }\n    }\n\n    closedir(dir);\n    return total_size;\n}\n```\n\nBu kod, dosya sistemindeki her dizini ve dosyayı gezerek toplam boyutu hesaplıyor. Ancak, birkaç iyileştirme önerim var:\n\n1. **Bellek Yönetimi**: `full_path` dizisinin boyutunu sabit bir değerle sınırlamak yerine, dinamik bellek kullanarak büyük dosya isimlerini da destekleyebilirsiniz. `malloc` ve `free` kullanarak bellek yönetimini daha etkili yapabilirsiniz.\n\n2. **Performans**: `snprintf` fonksiyonu yerine `strcat` kullanarak `full_path` oluşturma işlemini optimize edebilirsiniz, ancak bu dikkatli yapılmalıdır. Ayrıca, `stat` fonksiyonunu her dosya için çağırmak yerine, `lstat` kullanarak sembolik bağlantılar için de kontrol yapabilirsiniz.\n\n3. **Hata Yönetimi**: Hata durumlarını daha iyi yönetmek için, hata mesajları ve durum kodları eklemeyi düşünebilirsiniz. Bu, hataların tanımlanmasını kolaylaştırır.\n\nBu değişikliklerle kodunuzun performansını artırabilir ve daha sağlam hale getirebilirsiniz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:10:15.118407"
  },
  {
    "question": "Fibonacci sayılarını hesaplamak için yazdığım özyinelemeli fonksiyon çok yavaş çalışıyor. Kodun altında yatan nedenleri açıklayabilir misiniz?",
    "answer": "Elbette, Fibonacci sayılarını hesaplamak için yazılmış basit bir özyinelemeli fonksiyon aşağıdaki gibidir:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\n\nBu kod, Fibonacci sayılarını hesaplamak için çalışıyor, ancak yüksek `n` değerleri için çok yavaş çalışmasının birkaç nedeni var:\n\n1. **Fazla Hesaplama**: Bu kod, aynı Fibonacci sayısını birden fazla kez hesaplar. Örneğin, `fibonacci(5)` çağrıldığında, `fibonacci(3)` ve `fibonacci(2)` gibi alt işlemlere ihtiyaç duyar. Bu alt işlemler, kendi içinde tekrar tekrar çağrılar yapar. Bu, büyük `n` değerlerinde zaman karmaşıklığını üstel hale getirir.\n\n2. **Daha Etkili Bir Yaklaşım**: Bu durumu optimize etmek için dinamik programlama veya memoizasyon tekniğini kullanabilirsiniz. Aşağıda memoizasyon uygulaması ile güncellenmiş bir versiyonunu görebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint memo[100];\n\nint fibonacci(int n) {\n    if (memo[n] != -1) return memo[n];\n    if (n <= 1) {\n        return n;\n    }\n    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);\n    return memo[n];\n}\n\nvoid initialize() {\n    for (int i = 0; i < 100; i++) {\n        memo[i] = -1;\n    }\n}\n```\n\nBu değişiklikle, Fibonacci hesaplamalarını hızlandırabilir ve bellekte daha az yer kaplayarak işlem performansını artırabilirsiniz. Özellikle büyük `n` değerlerinde bu değişim belirgin bir hız artışı sağlayacaktır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-05-31T18:10:15.118459"
  },
  {
    "question": "Kullanıcının girdiği iki sayıyı toplayan bir C programının eksik kodunu tamamlayın. Girdi sayıları komut satırından alınmalı.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    // Kullanıcıdan gelen argüman sayısının yeterli olup olmadığını kontrol et\n    if (argc != 3) {\n        printf(\"Lütfen iki sayi giriniz!\\n\");\n        return 1;\n    }\n\n    // Komut satırından alınan argümanları tam sayıya dönüştür\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n\n    // Sayıları topla\n    int toplam = sayi1 + sayi2;\n\n    // Sonucu ekrana yazdır\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n/* Bu program, komut satırından iki tam sayı alır ve bu sayıların toplamını hesaplayarak ekrana yazdırır. 'atoi' fonksiyonu, string olarak alınan argümanları tam sayıya dönüştürür. */",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:25.869103"
  },
  {
    "question": "Kullanıcının girdiği bir kelimeyi tersine çeviren bir C programının eksik kısmını tamamlayın. Kelime komut satırından alınmalı.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    // Kullanıcıdan gelen argüman sayısını kontrol et\n    if (argc != 2) {\n        printf(\"Lütfen bir kelime giriniz!\\n\");\n        return 1;\n    }\n\n    // Girdi kelimesini al\n    char *kelime = argv[1];\n    int uzunluk = strlen(kelime);\n\n    // Kelimeyi tersine çevir\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = kelime[i];\n        kelime[i] = kelime[uzunluk - 1 - i];\n        kelime[uzunluk - 1 - i] = temp;\n    }\n\n    // Ters çevrilmiş kelimeyi yazdır\n    printf(\"Ters kelime: %s\\n\", kelime);\n    return 0;\n}\n\n/* Bu program, komut satırından bir kelime alır ve bu kelimeyi tersine çevirerek ekrana yazdırır. 'strlen' fonksiyonu kelimenin uzunluğunu bulmak için kullanılır. */",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:25.869151"
  },
  {
    "question": "Bir kullanıcıdan komut satırı argümanları ile bir sayı alarak bu sayının faktöriyelini hesaplayan bir C programının eksik kodunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Faktöriyel hesaplama fonksiyonu\nunsigned long long faktoriyel(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    // Argüman sayısını kontrol et\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n\n    int sayi = atoi(argv[1]); // Komut satırı argümanını tam sayıya çevir\n    if (sayi < 0) {\n        printf(\"Lütfen negatif olmayan bir sayı girin.\\n\");\n        return 1;\n    }\n\n    unsigned long long sonuc = faktoriyel(sayi);\n    printf(\"%d sayısının faktöriyeli: %llu\\n\", sayi, sonuc);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir tam sayı alır ve bu sayının faktöriyelini hesaplar. Komut satırından bir argüman alınır, bu argüman negatifse kullanıcıya bir uyarı verilir. Pozitif bir sayı verilirse faktöriyel hesaplanır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:42.966102"
  },
  {
    "question": "Kullanıcıdan komut satırı argümanları ile bir dosya adı alarak dosyanın satır sayısını sayan bir C programının eksik kodunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    // Argüman sayısını kontrol et\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *dosya = fopen(argv[1], \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı: %s\\n\", argv[1]);\n        return 1;\n    }\n\n    char ch;\n    int satirSayisi = 0;\n    // Dosyadaki her karakteri oku\n    while ((ch = fgetc(dosya)) != EOF) {\n        if (ch == '\\n') satirSayisi++; // Yeni satır bulduğunda sayacı artır\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    printf(\"%s dosyasındaki satır sayısı: %d\\n\", argv[1], satirSayisi);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir dosya adı alır ve belirtilen dosyanın satır sayısını hesaplar. Komut satırında dosya adı verilmezse veya dosya açılamazsa kullanıcıya uygun mesajlar verir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:42.966150"
  },
  {
    "question": "Aşağıda verilen eksik kod parçasını tamamlayarak, komut satırından alınan iki sayıyı toplayan bir C programı yazın. eksik kod: #include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n    int sayi1 = ;\n    int sayi2 = ;\n    int toplam = ;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Tamamlanmış kod:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int toplam = sayi1 + sayi2;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\n\nAçıklama: Bu program, komut satırından iki sayı alır. İlk olarak, `argc` değişkeni ile argüman sayısını kontrol eder. Eğer kullanıcı iki sayı girmezse, bir hata mesajı verir. `atoi` fonksiyonunu kullanarak argümanları tam sayılara dönüştürür ve bu sayıları toplar. Sonuç, ekrana yazdırılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:57.691737"
  },
  {
    "question": "Aşağıdaki eksik kod parçasını tamamlayarak, komut satırından bir dosya adı alan ve bu dosyanın boyutunu hesaplayan bir C programı yazın. eksik kod: #include <stdio.h>\n#include <sys/stat.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n    struct stat st;\n    if (stat(, &st) == -1) {\n        perror(\"Dosya bulunamadı\");\n        return 1;\n    }\n    printf(\"Dosya boyutu: %ld bayt\\n\", st.st_size);\n    return 0;\n}",
    "answer": "Tamamlanmış kod:\n```c\n#include <stdio.h>\n#include <sys/stat.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n    struct stat st;\n    if (stat(argv[1], &st) == -1) {\n        perror(\"Dosya bulunamadı\");\n        return 1;\n    }\n    printf(\"Dosya boyutu: %ld bayt\\n\", st.st_size);\n    return 0;\n}\n```\n\nAçıklama: Bu program, komut satırından bir dosya adı alır. `stat` fonksiyonu ile dosya bilgilerini alır. Eğer dosya bulunamazsa, `perror` fonksiyonu ile hata mesajı görüntülenir. Dosya boyutu `st_size` kullanılarak hesaplanır ve ekrana yazdırılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:10:57.691893"
  },
  {
    "question": "Bir C programım var, ancak komut satırından argümanları alırken programım beklenmedik bir şekilde çalışıyor. Aşağıdaki kodda bir hata var mı? \n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Lütfen bir argüman girin.\");\n        return 1;\n    }\n    printf(\"Girdiğiniz argüman: %s\\n\", argv[1]);\n    return 0;\n}\n```",
    "answer": "Evet, kodu incelediğimizde bir sorun göze çarpıyor. Kullanıcıdan en az bir argüman bekliyoruz ve eğer argüman yoksa bir hata mesajı veriyoruz. Ancak, \"Lütfen bir argüman girin.\" mesajında yeni bir satıra geçmek için '\\n' karakteri eklenmemiş. Bu durumda, mesaj ekrana yazıldığında bir alt satıra geçmeyecek ve çıktıyı biraz daha karışık görebiliriz. Düzgün bir çıktı almak için mesajı şu şekilde güncelleyebiliriz:\n\n```c\nprintf(\"Lütfen bir argüman girin.\\n\");\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:07.957632"
  },
  {
    "question": "Aşağıdaki C kodu, komut satırından bir sayı alıp onun karesini hesaplaması gereken bir program. Ancak, çalıştırdığımda beklenen sonucu vermiyor. Hatanın kaynağı ne olabilir? \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir sayı girin.\\n\");\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    printf(\"Sayının karesi: %d\\n\", sayi * sayi);\n    return 0;\n}\n```",
    "answer": "Kodda temel bir hata yok, ancak kullanıcıdan alınan argümanın tam olarak bir sayı olup olmadığını kontrol etmiyoruz. Eğer kullanıcı geçersiz bir değer girerse (örneğin, 'abc'), `atoi` fonksiyonu bu değeri 0 olarak işleyecek ve sonuç beklenenden farklı olacaktır. Bu durumu düzeltmek için `atoi` yerine `strtol` gibi bir fonksiyon kullanarak hata kontrolü yapabiliriz. İşte önerilen güncelleme:\n\n```c\nchar *endptr;\nint sayi = strtol(argv[1], &endptr, 10);\nif (*endptr != '\\0') {\n    printf(\"Geçersiz bir sayı girdiniz.\\n\");\n    return 1;\n}\n``` \nBu şekilde, kullanıcı geçerli bir sayı girmezse hata mesajı vereceğiz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:07.957765"
  },
  {
    "question": "Bir program, komut satırından bir sayı almalı ve bu sayının karesini hesaplamalı. Ancak programda girilen argümanın tam sayı olup olmadığını kontrol eden bir hata var. Aşağıdaki kodu inceleyin ve oluşan hatayı düzeltin: \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir tam sayı girin.\\n\");\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    printf(\"%d sayısının karesi: %d\\n\", sayi, sayi * sayi);\n    return 0;\n}",
    "answer": "Program, sadece bir argüman alması gerektiğini kontrol ediyor ama girilen argümanın tam sayı olup olmadığını kontrol etmiyor. Örneğin, kullanıcı bir harf girdiğinde, atoi() fonksiyonu 0 dönecektir. Bunun için, atoi() fonksiyonu yerine sscanf() kullanarak girilen değerin tam sayı olup olmadığını kontrol edebiliriz. Düzeltme şu şekilde yapılabilir:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir tam sayı girin.\\n\");\n        return 1;\n    }\n    int sayi;\n    if (sscanf(argv[1], \"%d\", &sayi) != 1) {\n        printf(\"Lütfen geçerli bir tam sayı girin.\\n\");\n        return 1;\n    }\n    printf(\"%d sayısının karesi: %d\\n\", sayi, sayi * sayi);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:22.174275"
  },
  {
    "question": "Aşağıdaki C kodu, komut satırında verilen iki sayıyı toplayıp sonucu ekrana yazdırmalı. Ancak, programda bir hata var ve beklenmedik sonuçlar üretiyor. Kodu inceleyin ve hatayı düzeltin:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n    int toplam = argv[1] + argv[2];\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "answer": "Programda yapılan hata, argv dizisine atanan değerlerin int yerine string (char dizisi) olarak kullanılmasıdır. Bu nedenle, doğrudan toplamak yerine atoi() fonksiyonu ile string değerleri tam sayıya çevirmek gerekiyor. Düzeltme şu şekildedir:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n    int toplam = atoi(argv[1]) + atoi(argv[2]);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:22.174491"
  },
  {
    "question": "Bir C programı, kullanıcıdan iki tam sayı alıp bunların toplamını hesaplamak için komut satırı argümanlarını kullanıyor. Ancak, program bazen 'Segmentation fault' hatası veriyor. Hatanın sebebi nedir ve nasıl düzeltilir?",
    "answer": "Bu hatanın nedeni, komut satırından alınan argümanların sayısının beklenenden az olmasıdır. C dilinde argümanlar, 'argc' ve 'argv' ile işlenir. Kullanıcıdan iki tam sayı bekleniyorsa, 'argc' değişkeninin 3 olması gerekir (program adı ve iki argüman). Eğer kullanıcı yeterli argüman sağlamazsa, program 'argv' dizisine erişmeye çalışırken bellek hatası alır. Hatanın düzeltilmesi için 'argc' kontrolü eklenmelidir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayi1> <sayi2>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    printf(\"Toplam: %d\\n\", sayi1 + sayi2);\n    return 0;\n}\n```\nBu kodda, eğer kullanıcı yeterli argüman sağlamazsa uygun bir mesaj gösterilecektir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:33.354290"
  },
  {
    "question": "Bir C programı, komut satırında verilen dosya adını okumak ve dosyayı açarak içeriğini yazdırmak için tasarlandı. Ancak, dosya adının geçerli olup olmadığını kontrol etmiyor. Program geçersiz bir dosya adı verildiğinde 'File not found' mesajı yerine 'Segmentation fault' hatası veriyor. Bu hatanın sebebi nedir ve nasıl düzeltilir?",
    "answer": "Bu sorun, 'fopen' fonksiyonu ile geçersiz bir dosya adı açılmaya çalışıldığında, geri dönen 'NULL' değerinin kontrol edilmemesinden kaynaklanmaktadır. Eğer 'fopen' çağrısı başarısız olursa ve program 'NULL' göstericisine erişmeye çalışırsa, 'Segmentation fault' hatası meydana gelir. Bu hatayı düzeltmek için dosya açma işlemi sonrasında 'NULL' kontrolü eklenmelidir:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya okuma işlemleri\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosya başarıyla açılamazsa uygun bir hata mesajı gösterir. 'perror' fonksiyonu, hata hakkında daha fazla bilgi sağlar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:33.354455"
  },
  {
    "question": "C dilinde komut satırı argümanlarını nasıl kullanabilirim? Örnek bir program gösterir misin?",
    "answer": "Elbette! C dilinde komut satırı argümanlarını kullanmak için 'main' fonksiyonunuzu aşağıdaki gibi tanımlayabilirsiniz: 'int main(int argc, char *argv[])'. Burada 'argc' komut satırından gelen argüman sayısını, 'argv' ise bu argümanların bir dizi halinde depolandığı gösterir. İşte basit bir örnek:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"Argüman sayısı: %d\\n\", argc);\n    for (int i = 0; i < argc; i++) {\n        printf(\"Argüman %d: %s\\n\", i, argv[i]);\n    }\n    return 0;\n}\n```\n\nBu programı derleyip çalıştırdığınızda, komut satırında yazdığınız argümanların sayısını ve her birini ekrana yazdırır. Örneğin, `./program 1 2 3` komutunu çalıştırırsanız, programın çıktısı 4 argüman olduğunu (program adı 'argv[0]' dahil) ve her bir argümanı gösterecektir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:43.215954"
  },
  {
    "question": "C dilinde komut satırı argümanlarını kullanarak basit bir toplama işlemi yapabilir miyim? Nasıl yaparım?",
    "answer": "Evet, komut satırı argümanlarını kullanarak toplama işlemi yapabilirsiniz! Bu işlem için argümanları sayıya dönüştürmeniz gerekir. İşte bu işlemi gerçekleştiren basit bir program:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n\n    int sayi1 = atoi(argv[1]); // İlk argümanı tam sayıya çevir\n    int sayi2 = atoi(argv[2]); // İkinci argümanı tam sayıya çevir\n    int toplam = sayi1 + sayi2;\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\n\nBu kodda, program iki argüman alır. Eğer kullanıcı iki sayı girmezse hata mesajı verir. 'atoi' fonksiyonu, argümanları tam sayıya çevirir ve ardından bu sayıları toplar. Örneğin, `./program 5 10` komutunu çalıştırdığınızda, çıktınız 'Toplam: 15' olacaktır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:43.216013"
  },
  {
    "question": "C dilinde bir program yazmak istiyorum. Kullanıcıdan bir dosya adı alarak, bu dosyanın içeriğini ekrana yazdıracak bir program nasıl yazabilirim? Komut satırı argümanlarını kullanarak nasıl yapabilirim?",
    "answer": "C dilinde komut satırı argümanlarını kullanarak kullanıcıdan dosya adı almak oldukça basittir. Programın `main` fonksiyonunda iki parametre alırız: `int argc` (argüman sayısı) ve `char *argv[]` (argümanlar dizisi). Aşağıda, belirtilen dosya adını alıp dosya içeriğini ekrana yazdıran bir program örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\n\nBu örnekte, önce `argc`'yi kontrol ederek doğru sayıda argüman alındığından emin oluyoruz. Ardından, `fopen` ile dosyayı açıyoruz. Eğer dosya açılamazsa, `perror` ile hata mesajı yazdırıyoruz. Son olarak, dosyayı okur ve içeriğini ekrana yazdırırız.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:57.783274"
  },
  {
    "question": "Bir C programında, komut satırından birkaç sayı alarak bu sayıların toplamını ve ortalamasını hesaplamak istiyorum. Bunu nasıl gerçekleştirebilirim?",
    "answer": "Komut satırı argümanları ile kullanıcıdan sayı alıp bunların toplamını ve ortalamasını hesaplamak için yine `main` fonksiyonundaki `argc` ve `argv` parametrelerini kullanırız. Aşağıda bu işlemi gerçekleştiren bir örnek program verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir sayı girin. Kullanım: %s <sayı1> <sayı2> ...\\n\", argv[0]);\n        return 1;\n    }\n\n    double toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atof(argv[i]); // Atof ile string'i double'a çeviriyoruz.\n    }\n\n    double ortalama = toplam / (argc - 1);\n    printf(\"Toplam: %.2f\\n\", toplam);\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n\n    return 0;\n}\n```\n\nBu program kullanıcıdan bir veya daha fazla sayı alır. `atof` fonksiyonu ile argümanları `double` türüne çeviriyoruz ve bunların toplamını hesaplıyoruz. Son olarak, toplamı ve ortalamayı ekrana yazdırıyoruz. Bu tür bir program, komut satırında `./program 10 20 30` şeklinde çalıştırıldığında, bu sayıların toplamı ve ortalamasını hesaplayacaktır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:11:57.783363"
  },
  {
    "question": "C dilinde bir program yazıyorum ve kullanıcıdan komut satırı argümanları alıp bu argümanları kullanarak iki sayının toplamını hesaplamak istiyorum. Programımda nasıl bir yapı kullanmalıyım?",
    "answer": "C dilinde komut satırı argümanlarını kullanmak için 'main' fonksiyonunu şu şekilde tanımlamalısınız: 'int main(int argc, char *argv[])'. Burada 'argc', argümanların sayısını, 'argv' ise argümanların değerlerini tutar. Örneğin, kullanıcı programı şu şekilde çalıştırır: './program 5 10'. Bu durumda, 'argc' 3 olacaktır (program adı dahil). 'argv[1]' ve 'argv[2]' ise sırasıyla '5' ve '10' değerlerini tutar. Bu değerleri 'atoi' fonksiyonu ile tam sayıya dönüştürerek toplama işlemi yapabilirsiniz. Örnek kod: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayı1> <sayı2>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int toplam = sayi1 + sayi2;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:28.857122"
  },
  {
    "question": "Bir dosya yöneticisi uygulaması geliştiriyorum ve kullanıcıdan bir dosya yolu alıp bu dosyanın içeriğini okumak istiyorum. Komut satırı argümanları ile nasıl bir yaklaşım izlemeliyim?",
    "answer": "Kullanıcıdan bir dosya yolunu komut satırı argümanı olarak almak için yine 'int main(int argc, char *argv[])' fonksiyonunu kullanmalısınız. Kullanıcı programı './dosya_yonetici dosya.txt' şeklinde çalıştırdığında, 'argc' 2 olacaktır. 'argv[1]' ise 'dosya.txt' değerini tutar. Dosyanın içeriğini okumak için 'fopen' fonksiyonunu kullanarak dosyayı açabilir ve 'fgets' veya 'fread' fonksiyonları ile içeriğini okuyabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir örnek kod verilmiştir: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_yolu>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char satir[256];\n    while (fgets(satir, sizeof(satir), dosya)) {\n        printf(\"%s\", satir);\n    }\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:28.857183"
  },
  {
    "question": "Bir kullanıcıdan komut satırı argümanları alarak verilen iki sayının toplamını hesaplayan bir C programı nasıl yazılır?",
    "answer": "Aşağıda iki sayının toplamını hesaplayan bir C programı örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    // Komut satırından argüman sayısını kontrol et\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayi1> <sayi2>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Argümanları tam sayıya çevir\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n\n    // Toplama işlemi\n    int toplam = sayi1 + sayi2;\n\n    // Sonucu ekrana yazdır\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\n\nBu program, kullanıcıdan iki tam sayı alır ve bu sayıların toplamını hesaplayarak ekrana yazdırır. `atoi` fonksiyonu, string tipindeki argümanları tam sayıya dönüştürmek için kullanılır. Kullanıcıdan yeterli argüman alınmadıysa bir hata mesajı gösterilmektedir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:44.731323"
  },
  {
    "question": "Bir C programı yazın ve komut satırından kullanıcının girdiği bir dosyanın içeriğini okuyarak, dosyadaki satır sayısını hesaplayın.",
    "answer": "Aşağıda belirtilen C programı, bir dosyanın içeriğini okuyarak satır sayısını hesaplamaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    // Argüman sayısını kontrol et\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *dosya;\n    char ch;\n    int satirSayisi = 0;\n\n    // Dosyayı aç\n    dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosya içeriğini oku ve satır sayısını hesapla\n    while ((ch = fgetc(dosya)) != EOF) {\n        if (ch == '\\n') {\n            satirSayisi++;\n        }\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n\n    // Sonucu ekrana yazdır\n    printf(\"Dosyadaki satır sayısı: %d\\n\", satirSayisi);\n    return 0;\n}\n```\n\nBu program, kullanıcının komut satırında belirttiği dosyayı açar ve içindeki satır sayısını hesaplar. `fgetc` fonksiyonu dosyadan bir karakter okurken, eğer okunan karakter yeni bir satır (`\\n`) ise satır sayısını artırır. Dosya açılmazsa, `perror` fonksiyonu ile hata mesajı gösterilir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:44.731374"
  },
  {
    "question": "Bir dosya adını komut satırı argümanı olarak alıp, dosyanın içeriğini ekrana yazdıran bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, komut satırı argümanları kullanarak verilen bir dosya adının içeriğini ekrana yazdırmaktadır. Program, dosyanın açılmasında bir hata olursa kullanıcıya hata mesajı verir. \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s dosya_adı\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\n\nBu programda, `argc` değişkeni komut satırındaki argümanların sayısını tutar. Eğer argüman sayısı 2 değilse (program adı ve dosya adı), kullanıcıya doğru kullanım hakkında bilgi verilir. `fopen` fonksiyonu, belirtilen dosyayı okumak için açar. Eğer dosya açılamazsa, `perror` fonksiyonu ile hata mesajı gösterilir. Son olarak, dosya içeriği karakter karakter okunarak ekrana yazdırılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:58.039118"
  },
  {
    "question": "Komut satırı argümanları ile bir sayının faktöriyelini hesaplayan bir C programı nasıl yazılır?",
    "answer": "Aşağıdaki C kodu, komut satırı argümanı olarak verilen bir tam sayının faktöriyelini hesaplamakta ve sonucu ekrana yazdırmaktadır. Program, negatif bir sayı verilirse hata mesajı gösterir. \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s sayı\\n\", argv[0]);\n        return 1;\n    }\n\n    int number = atoi(argv[1]);\n    if (number < 0) {\n        printf(\"Negatif sayının faktöriyeli hesaplanamaz!\\n\");\n        return 1;\n    }\n\n    unsigned long long result = factorial(number);\n    printf(\"%d sayısının faktöriyeli: %llu\\n\", number, result);\n    return 0;\n}\n```\n\nBu programda, kullanıcıdan alınan argüman `atoi` fonksiyonu ile tam sayıya dönüştürülür. Eğer sayı negatifse, hata mesajı verilir. Faktöriyel hesaplaması için `factorial` adlı bir rekürsif fonksiyon tanımlanmıştır. Hesaplanan faktöriyel sonucu ekrana yazdırılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:12:58.039160"
  },
  {
    "question": "Bir komut satırı aracı geliştirerek, kullanıcıdan bir dosya adı ve dizin alarak belirtilen dizindeki dosyanın içeriğini ekrana yazdıran bir C programı yazın. Dosya yoksa uygun bir hata mesajı verin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    // Komut satırı argüman sayısını kontrol et\n    if (argc != 3) {\n        printf(\"Kullanım: %s <dosya_adı> <dizin>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Argümanları al\n    char *file_name = argv[1];\n    char *directory = argv[2];\n\n    // Dosya yolunu oluştur\n    char file_path[512];\n    snprintf(file_path, sizeof(file_path), \"%s/%s\", directory, file_name);\n\n    // Dosyayı aç\n    FILE *file = fopen(file_path, \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosya içeriğini oku ve ekrana yazdır\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:11.355449"
  },
  {
    "question": "Kullanıcıdan bir sayı alarak, bu sayının faktöriyelini hesaplayan ve sonucu ekrana yazdıran bir C programı yazın. Kullanıcı negatif bir sayı girerse uygun bir hata mesajı gösterin.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long factorial(int n) {\n    if (n < 0) return 0; // Negatif sayılar için hata\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    // Komut satırı argüman sayısını kontrol et\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Argümanı sayıya çevir\n    int number = atoi(argv[1]);\n\n    // Negatif sayı kontrolü\n    if (number < 0) {\n        printf(\"Hata: Negatif sayının faktöriyeli hesaplanamaz.\\n\");\n        return 1;\n    }\n\n    // Faktöriyeli hesapla ve yazdır\n    unsigned long long result = factorial(number);\n    printf(\"%d sayısının faktöriyeli: %llu\\n\", number, result);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:11.355512"
  },
  {
    "question": "Bir dosya üzerinde işlem yapmak için komut satırı argümanlarını kullanan bir C programını inceledim. Ancak, kullanıcıdan alınan dosya adının geçerliliğini kontrol etmek için yeterli kontroller yapılmamış. Bu kodu optimize etmek ve geliştirici olarak hangi iyileştirmeleri önerebilirsin?",
    "answer": "Öncelikle, dosya adının geçerliliğini kontrol etmek için programda kontrol mekanizmaları eklemek önemlidir. Kullanıcıdan alınan dosya adını kontrol etmek için `fopen` fonksiyonunu kullanarak dosyanın gerçekten mevcut olup olmadığını kontrol edebiliriz. Ayrıca, komut satırı argümanlarının sayısını kontrol ederek, kullanıcıdan yeterli sayıda argüman alındığından emin olabiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosya ile işlemler...\n    fclose(file);\n    return 0;\n}\n```\n\nBu kodda, ilk olarak kullanıcıdan beklenen argüman sayısını kontrol ediyoruz. Daha sonra, dosya adının geçerli olup olmadığını kontrol etmek için `fopen` kullanıyoruz. Böylece, programın hata verme olasılığını azaltmış oluyoruz. Ayrıca, `perror` fonksiyonu ile hata mesajı veriyoruz, bu da kullanıcıya daha fazla bilgi sunar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:28.641116"
  },
  {
    "question": "Bir C uygulaması, komut satırından bir sayı alarak bu sayının faktöriyelini hesaplıyor. Ancak, argüman olarak alınan sayının negatif olup olmadığını kontrol etmiyor ve daha sonra bu durum programda hata oluşturuyor. Bu durumu nasıl iyileştirebiliriz?",
    "answer": "Negatif sayılar için bir kontrol eklemek önemlidir, çünkü faktöriyel negatif sayılar için tanımlı değildir. Ayrıca, kullanıcıdan alınan argümanın bir tam sayıya dönüştürülmesi gerektiğini de unutmamak gerekir. `strtol` fonksiyonunu kullanarak, kullanıcıdan alınan değeri güvenli bir şekilde tam sayıya dönüştürebiliriz. Aşağıdaki örnekte bu kontrolleri nasıl yapabileceğimizi gösteriyorum:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long int faktoryel(int n) {\n    if (n < 0) return 0;  // Negatif sayılar için faktöriyel tanımsızdır.\n    unsigned long long int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Kullanım: %s <pozitif_tamsayı>\\n\", argv[0]);\n        return 1;\n    }\n\n    char *endptr;\n    long number = strtol(argv[1], &endptr, 10);\n    if (*endptr != '\\0' || number < 0) {\n        fprintf(stderr, \"Lütfen geçerli bir pozitif tam sayı girin.\\n\");\n        return 1;\n    }\n\n    printf(\"%ld sayısının faktöriyeli: %llu\\n\", number, faktoryel(number));\n    return 0;\n}\n```\n\nBu örnekte, `strtol` fonksiyonu ile kullanıcıdan alınan değeri dönüştürüyoruz ve geçerliliğini kontrol ediyoruz. Eğer kullanıcı negatif bir sayı girerse veya geçerli bir tam sayı girmezse, hata mesajı gönderiyoruz. Böylece, programın daha sağlam çalışmasını sağlıyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:28.641191"
  },
  {
    "question": "C dilinde bir program, kullanıcının girdiği dosya adını komut satırı argümanı olarak alıyor. Ancak, dosya adını almak için sadece bir `argv[1]` kontrolü yapılıyor. Bu yaklaşımda ne gibi potansiyel sorunlar var ve nasıl iyileştirilebilir?",
    "answer": "Dosya adını almak için sadece `argv[1]` kontrolü yapmak, bazı önemli durumları göz ardı edebilir. Öncelikle, kullanıcı dosya adını girmeyi unuttuğunda veya yanlış bir şekilde girdiğinde program hata verebilir. Ayrıca, `argv[1]`'in geçerli bir dosya adı olup olmadığını kontrol etmemek, programın beklenmedik şekilde davranmasına neden olabilir. Bu durumu iyileştirmek için, öncelikle `argc` değişkenini kontrol ederek en az iki argümanın girilip girilmediğini doğrulayabiliriz. Eğer yeterli argüman yoksa, kullanıcıya bir hata mesajı gösterilir. Ayrıca, belirtilen dosya adının var olup olmadığını kontrol etmek için `fopen` fonksiyonu kullanılabilir. Aşağıda bu iyileştirmeleri gösteren bir örnek verilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Hata: Kullanıcı bir dosya adı girmedi.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Hata: Dosya açılamadı: %s\\n\", argv[1]);\n        return EXIT_FAILURE;\n    }\n\n    // Dosya işlemleri burada yapılır.\n\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:40.219488"
  },
  {
    "question": "Bir C programında, komut satırı argümanları ile belirli bir sayıda değer girişi almak istiyorum. Ancak, kullanıcıdan alınan değerlerin geçerliliğini kontrol etmeden doğrudan kullanmak istiyorum. Bu yaklaşımın sorunları neler olabilir ve hangi önlemleri almalıyım?",
    "answer": "Kullanıcıdan alınan değerleri geçerliliğini kontrol etmeden kullanmak, programınızda beklenmeyen hatalara yol açabilir. Örneğin, kullanıcı bir sayı yerine harf girerse, bu durum programın çökmesine veya yanlış sonuçlar üretmesine neden olabilir. Ayrıca, yanlış bir türde argüman alındığında (örneğin, negatif bir sayı beklenirken pozitif bir sayı alınması gibi), mantıksal hatalara yol açabilir. Bu durumu iyileştirmek için, kullanıcıdan alınan her argümanı doğrulamak önemlidir. `strtol` gibi bir fonksiyon kullanarak, sayısal girişlerin gerçekten sayıya dönüştürülebilir olup olmadığını kontrol edebilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Hata: En az bir sayı girmelisiniz.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    for (int i = 1; i < argc; i++) {\n        char *endptr;\n        errno = 0;\n        long val = strtol(argv[i], &endptr, 10);\n\n        if (errno != 0 || *endptr != '\\0') {\n            fprintf(stderr, \"Hata: Geçersiz sayısal değer: %s\\n\", argv[i]);\n            return EXIT_FAILURE;\n        }\n\n        // Geçerli bir sayı olduğunda işlemler yapılabilir.\n    }\n\n    return EXIT_SUCCESS;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-05-31T18:13:40.219565"
  }
]