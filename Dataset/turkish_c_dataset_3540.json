[
  {
    "question": "Kullanıcının girdiği iki sayıyı toplayan bir C programının başlangıç kısmını tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2, toplam;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n    toplam = sayi1 + sayi2;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n// Yukarıdaki kod, kullanıcıdan iki tam sayı alır ve bu sayıların toplamını ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.996880"
  },
  {
    "question": "Kullanıcının girdiği bir sayının karekökünü hesaplayan bir C programının başlangıç kısmını tamamla.",
    "answer": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double sayi, karekok;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%lf\", &sayi);\n    karekok = sqrt(sayi);\n    printf(\"%f sayısının karekökü: %f\\n\", sayi, karekok);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir sayı alır ve bu sayının karekökünü hesaplar ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.996966"
  },
  {
    "question": "Bir kullanıcının adını ve yaşını saklayan değişkenleri tanımla ve bunları ekrana yazdır.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char isim[50];\n    int yas;\n    printf(\"Adınızı girin: \");\n    scanf(\"%s\", isim);\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n    printf(\"Adınız: %s, Yaşınız: %d\\n\", isim, yas);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan adını ve yaşını alır ve bu bilgileri ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997012"
  },
  {
    "question": "Bir dikdörtgenin alanını hesaplayan bir C programı yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float uzunluk, genislik, alan;\n    printf(\"Dikdörtgenin uzunluğunu girin: \");\n    scanf(\"%f\", &uzunluk);\n    printf(\"Dikdörtgenin genişliğini girin: \");\n    scanf(\"%f\", &genislik);\n    alan = uzunluk * genislik;\n    printf(\"Dikdörtgenin alanı: %f\\n\", alan);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir dikdörtgenin uzunluğunu ve genişliğini alır ve alanını hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997053"
  },
  {
    "question": "Kullanıcının verdiği 3 sayının ortalamasını hesaplayan bir C programının temelini yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float sayi1, sayi2, sayi3, ortalama;\n    printf(\"Üç sayı girin: \");\n    scanf(\"%f %f %f\", &sayi1, &sayi2, &sayi3);\n    ortalama = (sayi1 + sayi2 + sayi3) / 3;\n    printf(\"Ortalama: %f\\n\", ortalama);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan 3 sayı alır ve bu sayıların ortalamasını hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997098"
  },
  {
    "question": "Bir kullanıcının 5 adet notunu alarak ortalamasını hesaplayan C programını yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float notlar[5], toplam = 0, ortalama;\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d. notu girin: \", i + 1);\n        scanf(\"%f\", &notlar[i]);\n        toplam += notlar[i];\n    }\n    ortalama = toplam / 5;\n    printf(\"Notların ortalaması: %f\\n\", ortalama);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan 5 not alır ve bu notların ortalamasını hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997140"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki karakter sayısını hesaplayan bir C programı yaz.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    int karakterSayisi = strlen(cumle);\n    printf(\"Cümledeki karakter sayısı: %d\\n\", karakterSayisi);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir cümle alır ve bu cümledeki karakter sayısını hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997181"
  },
  {
    "question": "Kullanıcının girdiği bir tam sayının pozitif mi negatif mi olduğunu kontrol eden bir C programı yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tam sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if(sayi > 0) {\n        printf(\"Bu sayı pozitif.\\n\");\n    } else if(sayi < 0) {\n        printf(\"Bu sayı negatif.\\n\");\n    } else {\n        printf(\"Bu sayı sıfır.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir tam sayı alır ve sayının pozitif, negatif veya sıfır olup olmadığını kontrol ederek ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997239"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayıyı karşılaştıran ve hangisinin büyük olduğunu belirten bir C programı yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İki tam sayı girin: \");\n    scanf(\"%d %d\", &sayi1, &sayi2);\n    if(sayi1 > sayi2) {\n        printf(\"Büyük sayı: %d\\n\", sayi1);\n    } else if(sayi2 > sayi1) {\n        printf(\"Büyük sayı: %d\\n\", sayi2);\n    } else {\n        printf(\"Her iki sayı eşit.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan iki tam sayı alır ve bu sayıların hangisinin büyük olduğunu belirleyerek ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997292"
  },
  {
    "question": "Kullanıcının girdiği bir sıcaklık değerini Celsius'tan Fahrenheit'a çeviren bir C programı yaz.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    printf(\"Celsius değerini girin: \");\n    scanf(\"%f\", &celsius);\n    fahrenheit = (celsius * 9 / 5) + 32;\n    printf(\"%.2f Celsius = %.2f Fahrenheit\\n\", celsius, fahrenheit);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir Celsius değeri alır ve bu değeri Fahrenheit'a çevirerek ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:03:47.997342"
  },
  {
    "question": "C dilinde bir tamsayı değişkenini tanımlayıp, bu değişkenin değerini kullanıcıdan alacak bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi; // Tamsayı değişkeni tanımlandı\n    printf(\"Bir tamsayi girin: \");\n    scanf(\"%d\", &sayi); // Kullanıcıdan değer al\n    printf(\"Girdiğiniz sayi: %d\\n\", sayi);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.846827"
  },
  {
    "question": "C dilinde bir float değişkeni tanımlayıp, bu değişkene kullanıcıdan alınan bir değeri atamak için eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float pi; // Float değişkeni tanımlandı\n    printf(\"Pi sayısını girin: \");\n    scanf(\"%f\", &pi); // Kullanıcıdan float değer al\n    printf(\"Girdiğiniz pi sayisi: %.2f\\n\", pi);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.846878"
  },
  {
    "question": "Kullanıcının girdiği iki tamsayıyı toplayarak sonucu ekrana yazdıran kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2, toplam; // Değişkenler tanımlandı\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n    toplam = sayi1 + sayi2; // Toplama işlemi\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.846905"
  },
  {
    "question": "C dilinde bir karakter dizisi (string) oluşturup, bu diziyi kullanıcıdan alacak bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[50]; // Karakter dizisi tanımlandı\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin); // Kullanıcıdan string al\n    printf(\"Girdiğiniz isim: %s\", isim);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.846950"
  },
  {
    "question": "Kullanıcının girdiği bir sayının karesini hesaplayacak bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n    int kare = sayi * sayi; // Karesini hesapla\n    printf(\"%d sayisinin karesi: %d\\n\", sayi, kare);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.846975"
  },
  {
    "question": "C dilinde bir boolean değişkeni tanımlayıp, kullanıcıdan alınan bir değer ile bu değişkenin atamasını yapacak kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    bool durum; // Boolean değişkeni tanımlandı\n    int girdi;\n    printf(\"0 veya 1 girin: \");\n    scanf(\"%d\", &girdi);\n    durum = (girdi == 1); // Boolean ataması\n    printf(\"Durum: %s\\n\", durum ? \"Dogru\" : \"Yanlış\");\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.847010"
  },
  {
    "question": "Kullanıcının girdiği üç tane float değeri alıp, ortalamasını hesaplayacak bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float a, b, c, ortalama;\n    printf(\"Üç float sayı girin: \");\n    scanf(\"%f %f %f\", &a, &b, &c);\n    ortalama = (a + b + c) / 3; // Ortalama hesapla\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.847039"
  },
  {
    "question": "Bir kullanıcıdan aldığı ismi ve yaşını ekrana yazdıran bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[50];\n    int yas;\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n    printf(\"İsim: %s, Yaş: %d\\n\", isim, yas);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.847068"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif olup olmadığını kontrol edecek bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n    if (sayi > 0) {\n        printf(\"Sayi pozitif.\\n\");\n    } else {\n        printf(\"Sayi pozitif değil.\\n\");\n    }\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.847099"
  },
  {
    "question": "Bir dizideki en büyük sayıyı bulacak bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[5];\n    int enBüyük;\n    printf(\"5 tane sayi girin: \");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    enBüyük = dizi[0]; // İlk elemanı en büyük olarak kabul et\n    for (int i = 1; i < 5; i++) {\n        if (dizi[i] > enBüyük) {\n            enBüyük = dizi[i]; // Yeni en büyük bulunursa güncelle\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", enBüyük);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:04:17.847124"
  },
  {
    "question": "C dilinde bir dizi tanımlayın ve bu dizinin elemanlarının toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[5] = {2, 4, 6, 8, 10}; // 5 elemanlı bir dizi tanımlıyoruz.\n    int toplam = 0;\n\n    for (int i = 0; i < 5; i++) {\n        toplam += dizi[i]; // Her bir elemanı toplama ekliyoruz.\n    }\n\n    printf(\"Toplam: %d\\n\", toplam); // Sonucu ekrana yazdırıyoruz.\n    return 0;\n}\n// Bu kod, dizinin elemanlarının toplamını hesaplar ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.190892"
  },
  {
    "question": "C dilinde bir float değişken tanımlayın ve kullanıcıdan bir değer alarak bu değeri iki katına çıkarın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float sayi;\n\n    printf(\"Bir sayı girin: \");\n    scanf(\"%f\", &sayi); // Kullanıcıdan float değer alıyoruz.\n\n    printf(\"İki katı: %.2f\\n\", sayi * 2); // Değeri iki katına çıkarıp yazdırıyoruz.\n    return 0;\n}\n// Kullanıcıdan alınan float değeri iki katına çıkarılarak ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.190949"
  },
  {
    "question": "C dilinde bir karakter dizisi oluşturun ve bu dizinin uzunluğunu hesaplayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char metin[] = \"Merhaba Dünya!\"; // Karakter dizisi tanımlanıyor.\n    int uzunluk = strlen(metin); // strlen fonksiyonu ile dizinin uzunluğu hesaplanıyor.\n\n    printf(\"Uzunluk: %d\\n\", uzunluk); // Uzunluk ekrana yazdırılıyor.\n    return 0;\n}\n// Bu kod, belirtilen karakter dizisinin uzunluğunu hesaplar ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.190976"
  },
  {
    "question": "C dilinde bir struct tanımlayın ve bu struct'ın elemanlarını kullanarak bir nesne oluşturun.",
    "answer": "#include <stdio.h>\n\nstruct Kişi {\n    char isim[50];\n    int yas;\n};\n\nint main() {\n    struct Kişi kisi1; // Kişi struct'ından bir nesne oluşturuyoruz.\n\n    printf(\"İsim girin: \");\n    scanf(\"%s\", kisi1.isim);\n    printf(\"Yaş girin: \");\n    scanf(\"%d\", &kisi1.yas);\n\n    printf(\"İsim: %s, Yaş: %d\\n\", kisi1.isim, kisi1.yas); // Oluşturulan nesnenin elemanlarını yazdırıyoruz.\n    return 0;\n}\n// Bu kod, bir struct kullanarak kişiyi temsil eden bir nesne oluşturur ve bilgileri alarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191004"
  },
  {
    "question": "C dilinde bir tamsayı değişkeni tanımlayın ve bu değişkenin bellekteki adresini yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi = 42; // Bir tamsayı değişkeni tanımlanıyor.\n\n    printf(\"Sayının değeri: %d\\n\", sayi); // Değeri yazdırılıyor.\n    printf(\"Sayının adresi: %p\\n\", (void*)&sayi); // Bellekteki adresi yazdırılıyor.\n    return 0;\n}\n// Bu kod, bir tamsayı değişkeninin değerini ve bellekte saklandığı adresi gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191031"
  },
  {
    "question": "C dilinde iki float değişkeni tanımlayın ve bu değişkenlerin toplamını ve çarpımını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float a = 5.5, b = 2.0; // İki float değişken tanımlanıyor.\n    float toplam = a + b; // Toplam hesaplanıyor.\n    float carpim = a * b; // Çarpım hesaplanıyor.\n\n    printf(\"Toplam: %.2f, Çarpım: %.2f\\n\", toplam, carpim); // Sonuçlar yazdırılıyor.\n    return 0;\n}\n// Bu kod, iki float değişkenin toplamını ve çarpımını hesaplayıp yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191060"
  },
  {
    "question": "C dilinde bir enum tanımlayın ve bu enum değerlerini kullanarak bir değişken oluşturun.",
    "answer": "#include <stdio.h>\n\nenum Günler {\n    Pazartesi,\n    Salı,\n    Çarşamba,\n    Perşembe,\n    Cuma,\n    Cumartesi,\n    Pazar\n};\n\nint main() {\n    enum Günler bugun = Cuma; // Enum kullanarak bir değişken tanımlanıyor.\n\n    printf(\"Bugün: %d\\n\", bugun); // Enum değerinin sayısal gösterimi yazdırılıyor.\n    return 0;\n}\n// Bu kod, bir gün enum'u kullanarak bugünün hangi gün olduğunu temsil eder ve sayısal değerini yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191087"
  },
  {
    "question": "C dilinde bir işaretçi (pointer) tanımlayın ve bir tamsayı değişkeninin değerini bu işaretçi aracılığıyla değiştirin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi = 10; // Tamsayı değişkeni tanımlanıyor.\n    int *ptr = &sayi; // İşaretçi tanımlanıyor ve sayının adresi atanıyor.\n\n    printf(\"Eski Değer: %d\\n\", sayi); // Eski değer yazdırılıyor.\n    *ptr = 20; // İşaretçi aracılığıyla sayının değeri değiştiriliyor.\n    printf(\"Yeni Değer: %d\\n\", sayi); // Yeni değer yazdırılıyor.\n    return 0;\n}\n// Bu kod, bir işaretçi kullanarak bir tamsayı değişkeninin değerini değiştirme işlemini gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191121"
  },
  {
    "question": "C dilinde iki tamsayı değişkenini karşılaştırın ve küçük olanı belirleyin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a = 15, b = 10; // İki tamsayı değişkeni tanımlanıyor.\n\n    if (a < b) {\n        printf(\"Küçük olan: %d\\n\", a); // a b'den küçükse yazdırılıyor.\n    } else {\n        printf(\"Küçük olan: %d\\n\", b); // b a'dan küçükse yazdırılıyor.\n    }\n    return 0;\n}\n// Bu kod, iki tamsayıyı karşılaştırarak küçük olanını bulur ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191146"
  },
  {
    "question": "C dilinde bir dizi tanımlayın ve bu diziyi sıralamak için bir algoritma uygulayın.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j]; // Değişken değişimi.\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 2, 9, 1, 5, 6}; // Dizi tanımlanıyor.\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n\n    sirala(dizi, boyut); // Sıralama fonksiyonu çağrılıyor.\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]); // Sıralanmış dizi yazdırılıyor.\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu kod, bir dizi tanımlar ve basit bir sıralama algoritması uygular.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:03.191173"
  },
  {
    "question": "int a = 5; float b = 4.5; int c = a + b; Hata nedir?",
    "answer": "C dilinde int ve float veri tipleri farklıdır. 'b' float bir değişken olduğundan, 'a + b' ifadesinin sonucu float türündedir. Bu nedenle, sonucu int bir değişkene atamak hatalıdır. Düzeltmek için c'yi float olarak tanımlamalıyız: float c = a + b;",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585414"
  },
  {
    "question": "char ch = 'A'; ch = ch + 1; printf('%c', ch); Hata nedir?",
    "answer": "Bu kodda, 'ch' karakter değişkenine 1 ekleniyor. Ancak, 'ch' float gibi bir sayısal değerle işlem gördüğünde, ASCII değerine göre 1 artırılır. Bu işlem geçerlidir, ancak 'ch' karakterini ekrana yazdırmak için '%c' formatını kullanmalıyız. Düzeltme gerekmez, fakat sonuç 'B' olacaktır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585457"
  },
  {
    "question": "double x = 3.14; x += 'a'; Hata var mı?",
    "answer": "Evet, burada bir hata var. 'a' karakteri, int olarak ASCII değeriyle temsil edilir (97). Bu nedenle, x'ye 97 eklenir. Ancak, bu işlem mantıksal olarak doğru olmayabilir. Eğer 'a' bir sayısal ifade olarak kullanılamayacaksa, bir hata oluşur. Düzeltmek için 'a' yerine uygun bir sayısal değer kullanmalıyız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585486"
  },
  {
    "question": "int num = 10; num = num / 3; printf('%d', num); Beklenen çıktı nedir?",
    "answer": "Bu kodda beklenen çıktı 3'tür çünkü C dilinde tam sayılarla yapılan bölme işlemi sonucu tam sayı olarak hesaplanır. Yani, 10/3 işlemi 3.33... sonucu 3'e yuvarlanır. Eğer ondalık sonucu almak istiyorsanız, num değişkenini float veya double olarak tanımlamalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585535"
  },
  {
    "question": "bool flag = 1; if (flag = 0) { printf('False'); } else { printf('True'); } Hata nedir?",
    "answer": "Burada bir hata var. 'if (flag = 0)' ifadesinde '=' atama operatörü kullanılmış. Bu, flag değişkeninin değerini 0 yapar, dolayısıyla if koşulu her zaman false döner. Eğer '==' karşılaştırma operatörünü kullanırsanız, doğru sonucu alırsınız: 'if (flag == 0)'.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585568"
  },
  {
    "question": "int a = 5; a = a + '5'; printf('%d', a); Beklenen çıktı nedir?",
    "answer": "Bu kodda beklenen çıktı 10'dur, çünkü '5' karakteri ASCII değeri olarak 53'e sahiptir. Bu nedenle, a = a + 53 olarak işlem yapılır ve sonuç 58 olur. Eğer '5' karakterini sayıya dönüştürmek istiyorsanız, atoi('5') gibi bir fonksiyon kullanmalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585604"
  },
  {
    "question": "float f = 10.5; int i = f; printf('%d', i); Beklenen çıktı nedir?",
    "answer": "Bu kodda, float türündeki 'f' değişkeni int türüne atanıyor. Ancak, bu işlem sırasında ondalık kısımlar kaybolacağı için sonuç 10 olur. Eğer 'f' float olarak kullanılmaya devam edilecekse, bu atama tehlikeli olabilir ve dikkat edilmelidir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585633"
  },
  {
    "question": "short s = 32768; printf('%d', s); Hata var mı?",
    "answer": "Evet, burada bir hata var. 'short' veri tipi -32768 ile 32767 arasında değer alabilir. 32768 değeri atandığında taşma durumu oluşur ve bu, beklenmeyen bir sonuç doğurur. Bu durumu önlemek için 'short' yerine 'int' kullanmalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585656"
  },
  {
    "question": "int *ptr; *ptr = 10; printf('%d', *ptr); Hata nedir?",
    "answer": "Burada bir hata var. 'ptr' işaretçisi, bir bellek alanına işaret etmemektedir. 'ptr' kullanmadan önce ona bir bellek adresi atamalısınız. Örneğin, int x; ptr = &x; şeklinde bir atama yapmalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585680"
  },
  {
    "question": "unsigned int u = -1; printf('%u', u); Beklenen çıktı nedir?",
    "answer": "Bu kodda, unsigned int değişkeni negatif bir değere atanıyor. C dilinde, negatif bir değer unsigned bir değişken için pozitif bir değere dönüşür. Bu durumda beklenen çıktı 4294967295 (32 bit için) olacaktır. Bu durum, unsigned veri tipi için negatif değerlerin nasıl işlendiğini gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:28.585714"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmeyen bir sonuç alıyorum? Kod: int a = 5; int b = 2; float c = a / b; printf(\"%f\", c);",
    "answer": "Bu kodda, 'a' ve 'b' tam sayılardır. 'a / b' işlemi yapıldığında, C dilinde tam sayı bölmesi gerçekleşir ve sonuç 2 olur. Ardından bu sonuç float değişkenine atanıyor. Çıktı '2.000000' olacak. Beklenen sonuç float türünde bir bölme (2.5) olmalıydı. Çözüm: float c = (float)a / b; şeklinde yazmalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935255"
  },
  {
    "question": "Aşağıdaki kodda neden 'segmentation fault' alıyorum? Kod: int *ptr; *ptr = 10; printf(\"%d\", *ptr);",
    "answer": "Bu kodda, 'ptr' değişkeni bir işaretçi olarak tanımlanmış ancak bellekte herhangi bir adrese işaret etmiyor. 'ptr' değişkenine herhangi bir bellek adresi atanmadan dereferencing yapmaya çalıştığınız için 'segmentation fault' hatası alıyorsunuz. Çözüm: 'ptr' için bir bellek alanı ayırmalısınız. Örnek: 'int *ptr = malloc(sizeof(int));' ile bellekte bir alan ayırıp sonrasında dereferencing yapmalısınız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935311"
  },
  {
    "question": "Kodda neden 'undefined behavior' var? Kod: char str[5]; strcpy(str, \"Hello\"); printf(\"%s\", str);",
    "answer": "Bu kodda, 'str' dizisi 5 karakter uzunluğunda tanımlanmış ancak 'Hello' stringi 6 karakter (5 harf + null terminator) içeriyor. Bu durumda, 'str' dizisi taşma yaparak bellek hatasına neden olur. Çözüm: Dizinin boyutunu artırmak. Örnek: 'char str[6];' şeklinde tanımlayarak hatayı düzeltebilirsiniz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935367"
  },
  {
    "question": "Bu kodda 'float' değişkeni beklenen değeri vermiyor. Kod: float x = 1.0; x += 0.1; printf(\"%.1f\", x);",
    "answer": "Bu kodda, 'float' veri tipinin ondalık hassasiyeti nedeniyle 1.0 ve 0.1'in toplamı tam olarak 1.1 olarak saklanmaz. Ancak, '%.1f' formatı ile yazdırıldığında beklenmedik bir sonuç verebilir. Çözüm: 'double' veri tipi kullanarak daha yüksek bir hassasiyet elde edebilirsiniz. Örnek: 'double x = 1.0;' şeklinde değiştirin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935409"
  },
  {
    "question": "Aşağıdaki kodda neden 'incompatible types' hatası alıyorum? Kod: int a = 5; float b = a + \"2.5\";",
    "answer": "Bu kodda, 'a' değişkeni bir tam sayı iken \"2.5\" bir stringdir. Bu iki farklı veri tipini toplamak C dilinde mümkün değildir. Çözüm: String'i float'a dönüştürerek toplama işlemini gerçekleştirin. Örnek: 'float b = a + atof(\"2.5\");' şeklinde düzenleyebilirsiniz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935444"
  },
  {
    "question": "Bu kodda neden beklenmeyen bir değer alıyorum? Kod: int a = 1; printf(\"%d\", ++a + a++);",
    "answer": "Bu kodda '++a' ve 'a++' ifadeleri aynı anda kullanılıyor. C dilinde bu tür ifadelerde hangi işlemin önce gerçekleşeceği belirsizdir (undefined behavior). Bu nedenle sonuç beklenmedik bir şekilde değişebilir. Çözüm: Değişkeni yalnızca bir kez güncellemeli ve sonucu bir değişkene atamalısınız. Örnek: 'int temp = ++a; printf(\"%d\", temp + a);' şeklinde düzenleyin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935479"
  },
  {
    "question": "Kodda neden 'value too large for defined data type' hatası alıyorum? Kod: long long int bigNum = 9223372036854775807; bigNum++;",
    "answer": "Bu kodda, 'bigNum' değişkeni, long long int türünde tanımlanmış ancak bu türün sınırlarına ulaşarak bir artırma işlemi gerçekleştiriyorsunuz. Bu durumda 'overflow' meydana gelir ve 'value too large for defined data type' hatası ortaya çıkar. Çözüm: Değişkenin türünü 'unsigned long long int' olarak değiştirebilir veya daha büyük bir veri tipi ile yönetin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935533"
  },
  {
    "question": "Aşağıdaki kodda neden 'wrong format specifier' hatası alıyorum? Kod: int a = 10; printf(\"%f\", a);",
    "answer": "Bu kodda, 'a' bir tamsayıdır ancak printf fonksiyonunda '%f' format belirleyici ile yazdırılmaya çalışılıyor. 'f' format belirleyicisi sadece float ve double veri tipleri için geçerlidir. Çözüm: Tamsayıyı yazdırmak için '%d' format belirleyicisini kullanmalısınız. Örnek: 'printf(\"%d\", a);' şeklinde düzenleyin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935569"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmedik bir değer alıyorum? Kod: int a = 10; int *p = &a; *p += 5; printf(\"%d\", a);",
    "answer": "Bu kodda, 'p' işaretçisi 'a' değişkeninin adresini tutuyor ve işaretçi üzerinden 'a' değerini 5 artırıyorsunuz. Ancak, işaretçiyi başka bir değere atamadığınız sürece bu beklenen bir sonuçtur. Eğer beklenmedik bir değer alıyorsanız, işaretçi 'NULL' veya belirsiz bir bellek adresine işaret ediyordur. Çözüm: 'p' işaretçisini doğru bir şekilde başlatmaya ve kullanmaya dikkat edin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935609"
  },
  {
    "question": "Kodda neden 'floating point exception' hatası alıyorum? Kod: float result = 5.0 / 0.0; printf(\"%f\", result);",
    "answer": "Bu kodda, sıfıra bölme işlemi yapılıyor. C dilinde sıfıra bölme işlemi bir 'floating point exception' hatasına yol açar. Çözüm: Bölme işleminden önce, bölenin sıfır olup olmadığını kontrol etmelisiniz. Örnek: 'if (b != 0) result = a / b; else printf(\"Bölme hatası\");' şeklinde bir kontrol ekleyin.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:05:58.935648"
  },
  {
    "question": "C dilinde bir 'int' değişkeni nasıl tanımlanır ve ne amaçla kullanılır?",
    "answer": "C dilinde bir 'int' değişkeni tanımlamak için 'int' anahtar kelimesini kullanırız. Örneğin: 'int sayi;'. Bu, tam sayıları saklamak için kullanılır. Örneğin, bir kullanıcının yaşını saklamak için int değişkeni kullanılabilir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434062"
  },
  {
    "question": "C dilinde bir 'float' değişkeninin örneği nedir ve ne için kullanılır?",
    "answer": "C dilinde 'float' değişkeni ondalıklı sayıları saklamak için kullanılır. Örneğin: 'float pi = 3.14;'. Bu, matematiksel hesaplamalarda, özellikle de kesirli değerlerin ihtiyaç duyulduğu durumlarda kullanışlıdır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434104"
  },
  {
    "question": "C dilinde bir 'char' değişkeni nasıl tanımlanır ve hangi durumlarda kullanılır?",
    "answer": "Bir 'char' değişkeni tek bir karakteri saklamak için kullanılır. Örneğin: 'char harf = 'A';'. Bu tür değişkenler, kullanıcıdan alınan karakter girdilerini veya metinleri temsil etmek için sıkça kullanılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434132"
  },
  {
    "question": "C dilinde birden fazla değişkeni aynı satırda nasıl tanımlarız?",
    "answer": "C dilinde birden fazla değişkeni aynı satırda tanımlamak için virgül kullanabiliriz. Örneğin: 'int a = 5, b = 10, c = 15;'. Bu yöntem, kodun daha derli toplu olmasını sağlar ve okunabilirliği artırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434155"
  },
  {
    "question": "C dilindeki 'double' veri tipi ne işe yarar?",
    "answer": "'double' veri tipi 'float' değişkenine göre daha yüksek hassasiyet sunar ve genellikle ondalıklı sayılar için kullanılır. Örneğin: 'double pi = 3.14159265359;'. Çok hassas hesaplamalar, özellikle bilimsel uygulamalarda kullanılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434177"
  },
  {
    "question": "C dilinde bir boolean değişkeni nasıl tanımlanır?",
    "answer": "C dilinde boolean değişkenler için genellikle 'int' tipi kullanılır; 1 true (doğru), 0 ise false (yanlış) değerini temsil eder. Örneğin: 'int durum = 1;'. Bu, bir koşulun doğru mu yanlış mı olduğunu belirtmek için kullanılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434197"
  },
  {
    "question": "C dilinde bir dizi (array) nasıl tanımlanır?",
    "answer": "C dilinde bir dizi, aynı türdeki birden fazla değeri tutmak için kullanılır. Örneğin: 'int sayilar[5];' ile 5 elemanlı bir tam sayı dizisi tanımlanır. Diziler, bir grup veriyi tek bir değişkenle yönetmek için oldukça kullanışlıdır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434216"
  },
  {
    "question": "C dilinde bir 'string' değişkeni nasıl oluşturulur?",
    "answer": "C dilinde string, karakter dizisi olarak temsil edilir. Örneğin: 'char isim[20] = 'Ahmet';' şeklinde tanımlanabilir. Stringler, metin verilerini saklamak için kullanılır ve kullanıcı etkileşimlerinde sıklıkla kullanılır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434236"
  },
  {
    "question": "C dilinde sabit bir değer nasıl tanımlanır?",
    "answer": "C dilinde sabit bir değer tanımlamak için 'const' anahtar kelimesi kullanılır. Örneğin: 'const int MAX_DEGER = 100;'. Sabitler, programda değişmeyecek değerleri kullanmak için önemlidir ve kodun güvenliğini artırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434254"
  },
  {
    "question": "C dilinde değişkenlerin veri tiplerini nasıl belirleriz?",
    "answer": "C dilinde değişkenlerin veri tipleri, değişken tanımlanırken belirlenir. Örneğin, 'int', 'float', 'char' gibi anahtar kelimelerle veri tiplerini belirleriz. Bu, değişkenin ne tür veriler saklayacağını ve nasıl işleneceğini gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434274"
  },
  {
    "question": "C dilinde bir değişkenin değerini nasıl güncelleyebiliriz?",
    "answer": "C dilinde bir değişkenin değerini güncellemek için o değişkenin adını kullanarak yeni bir değer atarız. Örneğin: 'sayi = 10;' ifadesi, 'sayi' değişkeninin önceki değerini 10 ile günceller. Bu, dinamik veri işlemleri için önemlidir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:06:55.434294"
  },
  {
    "question": "C dilinde bir tamsayı değişkeni nasıl tanımlanır ve kullanılabilir?",
    "answer": "C dilinde bir tamsayı değişkeni tanımlamak için 'int' anahtar kelimesini kullanırız. Örneğin: 'int sayi;' ifadesiyle 'sayi' adında bir tamsayı değişkeni tanımlayabiliriz. Bu değişkenin değerini atamak için şu şekilde yazabiliriz: 'sayi = 10;'. Daha sonra bu değeri kullanmak için 'printf(\"Sayı: %d\", sayi);' şeklinde ekrana yazdırabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429058"
  },
  {
    "question": "C dilinde ondalıklı sayı (float) değişkeni nasıl tanımlanır ve kullanılır?",
    "answer": "Ondalık sayı (float) değişkeni tanımlamak için 'float' anahtar kelimesini kullanırız. Örneğin: 'float pi;' ifadesiyle 'pi' adlı bir ondalıklı sayı değişkeni tanımlayabiliriz. Daha sonra bu değişkene değer atayabiliriz: 'pi = 3.14;'. Kullanımında ise 'printf(\"Pi sayısı: %.2f\", pi);' şeklinde kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429102"
  },
  {
    "question": "C dilinde bir karakter dizisi (string) nasıl tanımlanır ve kullanılır?",
    "answer": "C dilinde karakter dizisi tanımlamak için 'char' anahtar kelimesi kullanılır. Örneğin: 'char isim[20];' ifadesiyle 20 karakter uzunluğunda 'isim' adında bir karakter dizisi tanımlayabiliriz. Değer atamak için 'strcpy(isim, \"Ahmet\");' kullanabiliriz ve bu diziyi yazdırmak için 'printf(\"İsim: %s\", isim);' kullanırız.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429129"
  },
  {
    "question": "C dilinde bir değişkenin değerini nasıl artırabiliriz?",
    "answer": "Bir değişkenin değerini artırmak için '++' operatörünü kullanabiliriz. Örneğin, 'int sayi = 5;' tanımladıysak, 'sayi++;' ifadesi ile 'sayi' değişkeninin değeri 6 olur. Alternatif olarak 'sayi += 1;' şeklini de kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429153"
  },
  {
    "question": "C dilinde bir boolean değişkeni nasıl tanımlanır ve kullanılır?",
    "answer": "C dilinde boolean veri tipi için genellikle 'stdbool.h' kütüphanesi kullanılır. Boolean değişkeni tanımlamak için 'bool' anahtar kelimesini kullanırız. Örneğin: 'bool durum = true;' ifadesiyle bir boolean değişken tanımlayabiliriz. Bu değişkeni kontrol etmek için 'if (durum) { printf(\"Durum doğru.\"); }' yazabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429176"
  },
  {
    "question": "C dilinde bir değişkenin bellekteki boyutunu nasıl öğrenebiliriz?",
    "answer": "Bir değişkenin bellekte kapladığı boyutu öğrenmek için 'sizeof' operatörünü kullanabiliriz. Örneğin, 'int sayi;' tanımladıysak, 'printf(\"int boyutu: %zu\", sizeof(sayi));' ifadesi ile tamsayı değişkeninin bellekte kapladığı alanı öğrenebiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429198"
  },
  {
    "question": "C dilinde bir değişkenin veri tipini kontrol edebilir miyiz?",
    "answer": "C dilinde bir değişkenin veri tipini kontrol etmek doğrudan mümkün değildir. Ancak, değişkenin değerine göre işlem yaparak dolaylı bir kontrol gerçekleştirebiliriz. Örneğin, 'int sayi = 10;' ve 'if (sayi == (int)sayi) { printf(\"Değişken bir tamsayıdır.\"); }' ifadesi kullanarak değişkenin tamsayı olup olmadığını kontrol edebiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429221"
  },
  {
    "question": "C dilinde birden fazla değişkeni nasıl aynı anda tanımlayabiliriz?",
    "answer": "Birden fazla değişkeni aynı türde tanımlamak için virgül ile ayırarak tanımlama yapabiliriz. Örneğin, 'int a = 1, b = 2, c = 3;' şeklinde birden fazla tamsayı değişkeni aynı anda tanımlayabiliriz. Bu değişkenlerin değerlerine erişim için 'printf(\"A: %d, B: %d\", a, b);' yazabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429243"
  },
  {
    "question": "C dilinde bir değişkenin başlangıç değerini atamadan kullanmanın sonucu nedir?",
    "answer": "Bir değişkeni başlangıç değerini atamadan kullanmak, rastgele bir değer kullanmanıza neden olur ve bu durum bellek hatalarına yol açabilir. Örneğin, 'int sayi;' tanımlayıp 'printf(\"Sayı: %d\", sayi);' derseniz, 'sayi' değişkeni bellek üzerindeki eski veya rastgele bir değeri gösterebilir, bu da beklenmeyen sonuçlara yol açar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429267"
  },
  {
    "question": "C dilinde veri tipleri arasında dönüşüm nasıl yapılır?",
    "answer": "Veri tipleri arasında dönüşüm, 'cast' işlemi ile yapılır. Örneğin, bir 'float' değeri 'int' olarak kullanmak istiyorsak, 'int sayi = (int)pi;' şeklinde yazabiliriz. Bu durumda 'pi' değişkeninin ondalık kısmı kaybolur ve sadece tam kısım alınır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:07:16.429288"
  },
  {
    "question": "C dilinde bir tamsayı değişkeni nasıl tanımlanır ve bu değişkenin değeri nasıl atanır?",
    "answer": "C dilinde bir tamsayı değişkeni tanımlamak için 'int' anahtar kelimesi kullanılır. Örneğin: 'int sayi;' şeklinde bir değişken tanımlayabiliriz. Daha sonra bu değişkene bir değer atamak için '=' operatörünü kullanırız. Örnek: 'sayi = 10;' şeklinde. Bu kod, 'sayi' değişkenine 10 değerini atar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588632"
  },
  {
    "question": "C dilinde bir ondalıklı sayıyı nasıl tanımlayıp kullanabiliriz?",
    "answer": "Ondalık sayılar için C dilinde 'float' veya 'double' veri tiplerini kullanabiliriz. 'float'  tek hassasiyetli ondalıklı sayılar için, 'double' ise çift hassasiyetli ondalıklı sayılar için kullanılır. Örneğin: 'float pi = 3.14;' veya 'double pi = 3.14159265359;' şeklinde ondalıklı sayılar tanımlayabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588687"
  },
  {
    "question": "Karakter veri tipini C dilinde nasıl tanımlarız ve kullanırız?",
    "answer": "C dilinde karakter veri tipi 'char' ile tanımlanır. Örneğin, bir karakter değişkeni tanımlamak için 'char harf;' yazabiliriz. Bir karakterin atamasını yapmak için ise yine '=' operatörünü kullanırız. Örnek: 'harf = 'A';' Bu kod, 'harf' değişkenine 'A' karakterini atar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588714"
  },
  {
    "question": "C dilinde bir dizi değişkeni nasıl tanımlanır ve ilk değerleri nasıl atanır?",
    "answer": "C dilinde bir dizi tanımlamak için veri tipinin yanına köşeli parantezler eklenir. Örneğin, 'int sayilar[5];' ile 5 elemanlı bir tamsayı dizisi tanımlanabilir. İlk değerleri atamak için süslü parantezler içinde değerler yazılır: 'int sayilar[5] = {1, 2, 3, 4, 5};'.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588740"
  },
  {
    "question": "C dilinde 'bool' veri tipi nasıl kullanılır ve hangi kütüphane gereklidir?",
    "answer": "C dilinde boolean (doğru/yanlış) değerleri için 'stdbool.h' kütüphanesi kullanılır. 'bool' veri tipinden bir değişken tanımlamak için 'bool durum;' yazabiliriz. Daha sonra bu değişkene 'true' veya 'false' değerlerini atayabiliriz. Örnek: 'durum = true;'",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588770"
  },
  {
    "question": "C dilinde bir string (karakter dizisi) nasıl tanımlanır?",
    "answer": "C dilinde karakter dizileri 'char' veri tipi kullanılarak tanımlanır. Örneğin, 'char isim[20];' ile 20 karakter uzunluğunda bir string oluşturabiliriz. İlk değer ataması ise 'strcpy(isim, \"Ahmet\");' gibi bir fonksiyon kullanarak yapılabilir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588804"
  },
  {
    "question": "C dilinde farklı veri tiplerini bir arada kullanarak bir yapı (struct) nasıl tanımlanır?",
    "answer": "C dilinde bir yapı tanımlamak için 'struct' anahtar kelimesi kullanılır. Örneğin: 'struct Ogrenci { char isim[50]; int yas; };'. Bu yapı içinde hem string hem de tamsayı veri tiplerini bir arada kullanmış olduk. Kullanımda ise: 'struct Ogrenci ogr;' ile bir değişken tanımlayıp, 'strcpy(ogr.isim, \"Ali\"); ogr.yas = 20;' şeklinde değer atayabiliriz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588832"
  },
  {
    "question": "C dilinde uzunlukları farklı dizileri nasıl tanımlayıp kullanabiliriz?",
    "answer": "C dilinde dizilerin boyutları sabit olmalıdır. Ancak, farklı uzunluklarda diziler tanımlamak için farklı isimlerle tanımlama yapabiliriz. Örneğin, 'int dizi1[5]; int dizi2[10];' ile iki farklı uzunlukta dizi oluşturabiliriz. Her iki dizi için de eleman ataması yapabiliriz: 'dizi1[0] = 1; dizi2[0] = 2;'",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588854"
  },
  {
    "question": "C dilinde bir değişkenin değerini klavyeden nasıl alabiliriz?",
    "answer": "C dilinde kullanıcıdan veri almak için 'scanf' fonksiyonu kullanılır. Örneğin, 'int sayi;' tanımladıktan sonra 'scanf(\"%d\", &sayi);' yazarak kullanıcıdan bir tam sayı alabiliriz. '&' operatörü, 'sayi' değişkeninin adresini belirtir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:04.588874"
  },
  {
    "question": "Kullanıcının girdiği iki sayının toplamını hesaplayan bir C programı nasıl yazılır?",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2, toplam;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n    toplam = sayi1 + sayi2;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}``` Bu program, kullanıcıdan iki tam sayı girmesini ister, bu sayıları toplar ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.959780"
  },
  {
    "question": "Bir float değişkenini kullanarak bir dairenin alanını hesaplayan bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n#define PI 3.14159\n\nint main() {\n    float yaricap, alan;\n    printf(\"Dairenin yarıçapını girin: \");\n    scanf(\"%f\", &yaricap);\n    alan = PI * yaricap * yaricap;\n    printf(\"Dairenin alanı: %.2f\\n\", alan);\n    return 0;\n}``` Bu program, kullanıcının girdiği daire yarıçapına göre alanı hesaplar ve sonucu iki ondalık basamakla gösterir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.959842"
  },
  {
    "question": "Bir karakter dizisi (string) kullanarak kullanıcıdan bir isim alıp, bu ismi tersine çevirecek bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[100];\n    printf(\"Bir isim girin: \");\n    scanf(\"%s\", isim);\n    int uzunluk = strlen(isim);\n    printf(\"Ters ismi: \");\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        printf(\"%c\", isim[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}``` Bu program, kullanıcıdan bir isim alır ve bu ismin karakterlerini ters sırayla ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.959895"
  },
  {
    "question": "Bir tam sayının çift mi tek mi olduğunu kontrol eden bir C programı nasıl yazılır?",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tam sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (sayi % 2 == 0) {\n        printf(\"%d çift bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d tek bir sayıdır.\\n\", sayi);\n    }\n    return 0;\n}``` Bu program, kullanıcıdan bir tam sayı alır ve bu sayının çift veya tek olduğunu kontrol eder.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.959937"
  },
  {
    "question": "Bir dizi ile kullanıcıdan alınan notların ortalamasını hesaplayan bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    int notlar[10];\n    int toplam = 0;\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d. notu girin: \", i + 1);\n        scanf(\"%d\", &notlar[i]);\n        toplam += notlar[i];\n    }\n    float ortalama = toplam / 10.0;\n    printf(\"Notların ortalaması: %.2f\\n\", ortalama);\n    return 0;\n}``` Bu program, kullanıcıdan 10 not alır ve bu notların ortalamasını hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.959978"
  },
  {
    "question": "Kullanıcının girdiği bir sayının faktöriyelini hesaplayan bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    long long faktoriyel = 1;\n    printf(\"Bir pozitif tam sayı girin: \");\n    scanf(\"%d\", &sayi);\n    for (int i = 1; i <= sayi; i++) {\n        faktoriyel *= i;\n    }\n    printf(\"%d sayısının faktöriyeli: %lld\\n\", sayi, faktoriyel);\n    return 0;\n}``` Bu program, kullanıcıdan pozitif bir tam sayı alınır ve bu sayının faktöriyeli hesaplanır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.960016"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki harf sayısını hesaplayan bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[256];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    int harfSayisi = 0;\n    for (int i = 0; i < strlen(cumle); i++) {\n        if ((cumle[i] >= 'A' && cumle[i] <= 'Z') || (cumle[i] >= 'a' && cumle[i] <= 'z')) {\n            harfSayisi++;\n        }\n    }\n    printf(\"Cümledeki harf sayısı: %d\\n\", harfSayisi);\n    return 0;\n}``` Bu program, kullanıcıdan bir cümle alır ve o cümledeki harfleri sayar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.960052"
  },
  {
    "question": "Bir C programı yazarak kullanıcıdan alınan bir sayının, 100 ile 1000 arasında olup olmadığını kontrol edin.",
    "answer": "```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (sayi >= 100 && sayi <= 1000) {\n        printf(\"%d sayısı 100 ile 1000 arasındadır.\\n\", sayi);\n    } else {\n        printf(\"%d sayısı 100 ile 1000 arasında değildir.\\n\", sayi);\n    }\n    return 0;\n}``` Bu program, kullanıcıdan bir sayı alır ve bu sayının belirli bir aralıkta olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.960100"
  },
  {
    "question": "Bir C programı yazarak kullanıcıdan alınan bir kelimenin uzunluğunu hesaplayın.",
    "answer": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n    int uzunluk = strlen(kelime);\n    printf(\"Kelimenin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}``` Bu program, kullanıcıdan bir kelime alır ve bu kelimenin uzunluğunu hesaplayarak ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.960136"
  },
  {
    "question": "Kullanıcının girdiği bir tam sayının karekökünü hesaplayan bir C programı yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double sayi;\n    printf(\"Bir pozitif tam sayı girin: \");\n    scanf(\"%lf\", &sayi);\n    if (sayi < 0) {\n        printf(\"Negatif sayılar için karekök hesaplanamaz.\\n\");\n        return 1;\n    }\n    double karekok = sqrt(sayi);\n    printf(\"%lf sayısının karekökü: %lf\\n\", sayi, karekok);\n    return 0;\n}``` Bu program, kullanıcıdan bir pozitif tam sayı alır ve bu sayının karekökünü hesaplar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:08:27.960176"
  },
  {
    "question": "C dilinde, bir değişkenin bellekte kapladığı alanı nasıl belirleyebilirim ve bu bilgiyi nasıl optimize edebilirim?",
    "answer": "Değişkenlerin bellekte kapladığı alanı 'sizeof' operatörü ile öğrenebiliriz. Örneğin, int x; yazdığımızda 'sizeof(x)' ifadesi bize x'in kaç bayt kapladığını verir. Bellek optimizasyonu için, daha az yer kaplayan veri tiplerini kullanmak önemlidir. Örneğin, eğer değişkeninizin alabileceği değer aralığı -128 ile 127 arasındaysa 'char' veri tipini kullanmak, bellek tasarrufu sağlar.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178152"
  },
  {
    "question": "C dilinde 'float' ve 'double' veri tipleri arasındaki farklar nelerdir ve hangi durumda hangisini kullanmalıyım?",
    "answer": "Float, 4 baytlık, double ise 8 baytlık bir veri tipidir. Float, daha düşük hassasiyetle sayı tutarken, double yüksek hassasiyet gerektiren hesaplamalar için idealdir. Örneğin, finansal uygulamalarda genellikle 'double' kullanmak tercih edilirken, grafik uygulamalarında float yeterli olabilir. Ancak dikkate alınması gereken, float kullanıldığında yuvarlama hatalarının daha fazla olabileceğidir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178203"
  },
  {
    "question": "C dilinde, bir dizinin boyutunu nasıl dinamik olarak yönetebilirim?",
    "answer": "Dizinin boyutunu dinamik olarak yönetmek için 'malloc' ve 'realloc' fonksiyonlarını kullanabilirsiniz. Örneğin, 'int *dizi = malloc(boyut * sizeof(int));' ile bellek ayırabilir ve ihtiyaç duyulduğunda 'dizi = realloc(dizi, yeni_boyut * sizeof(int));' ile yeniden boyutlandırabilirsiniz. Ancak, her malloc çağrısından sonra belleği serbest bırakmayı unutmayın ('free(dizi);').",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178228"
  },
  {
    "question": "C dilinde 'enum' yapısını kullanmanın avantajları nelerdir?",
    "answer": "Enum, sabit değerleri tanımlamak ve anlamlı isimler vermek için kullanılır. Bu, kodun okunabilirliğini artırır. Örneğin, 'enum renkler {KIRMIZI, YESIL, MAVI};' yazdığınızda, KIRMIZI'nın 0, YESIL'in 1, MAVI'nin ise 2 değerini almasını sağlarsınız. Bunun avantajı, kodunuzu daha anlamlı hale getirmek ve hata ihtimalini azaltmaktır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178251"
  },
  {
    "question": "C dilinde 'const' anahtar kelimesinin işlevi nedir ve ne zaman kullanılmalıdır?",
    "answer": "Const, bir değişkenin değerinin değiştirilemeyeceğini belirtir. 'const int a = 10;' yazarsanız, a'nın değeri daha sonra değiştirilemez. Bu, hata yapma olasılığını azaltır ve kodun güvenliğini artırır. Genellikle sabit değerler ya da fonksiyon parametreleri için kullanılması önerilir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178277"
  },
  {
    "question": "C dilinde göstericilerin (pointers) kullanımı ve bellek yönetimi nasıl optimize edilir?",
    "answer": "Göstericiler bellek üzerinde daha fazla kontrol sağlar, ancak bellek sızıntılarını önlemek için dikkatli kullanılmalıdır. 'malloc' ile bellek ayırdıktan sonra, kullanımı bitince 'free' ile serbest bırakmayı unutmayın. Ayrıca, gösterici değişkenleri kullanırken NULL kontrolü yapmak da önemlidir. Örneğin, 'if (ptr != NULL) { // kullan }' şeklinde kontrol yaparak bellek hatalarından kaçınabilirsiniz.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178305"
  },
  {
    "question": "C dilinde yapıların (struct) kullanımı ve performans optimizasyonu nasıl yapılır?",
    "answer": "Yapılar, birden fazla veri tipinin bir arada tutulmasını sağlar. Yapıların boyutunu optimize etmek için, veri üyelerinin sıralamasına dikkat etmek gerekir. Örneğin, 'int' değerlerini önce koyup ardından 'char' değerlerini koymak, bellek hizalamasını iyileştirir. Ayrıca, yapılarla çalışırken göstericileri kullanmak, kopyalamaktan kaçınarak performansı artırır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178331"
  },
  {
    "question": "C dilinde dizi ve işaretçi (pointer) arasındaki fark nedir ve hangi durumda hangisi tercih edilmelidir?",
    "answer": "Dizi, sabit bir boyuta sahipken, işaretçi dinamik olarak bellek yönetimi yapmanıza olanak tanır. Dizi kullanmak, daha az bellek yönetimi gerektirirken, işaretçiler daha esnek bir yapı sunar. Örneğin, büyük veri setleri ile çalışırken işaretçileri kullanmak daha verimli olabilir. Ancak, gösterici kullanırken bellek sızıntılarına dikkat etmek önemlidir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178362"
  },
  {
    "question": "C dilinde 'typedef' anahtar kelimesi ne işe yarar ve nasıl kullanılır?",
    "answer": "'typedef', mevcut veri tiplerine yeni isimler vermek için kullanılır. Bu, kodun okunabilirliğini artırır. Örneğin, 'typedef struct { int x; int y; } Nokta;' şeklinde bir yapı tanımlayarak 'Nokta' adında yeni bir veri tipi oluşturabilirsiniz. Böylece, bu yapıyı kullanmak daha kolay ve anlaşılır hale gelir.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178394"
  },
  {
    "question": "C dilinde değişkenlerin başlangıç değerlerini nasıl etkili bir şekilde yönetebilirim?",
    "answer": "Değişkenlerin başlangıç değerlerini yönetmek için, her değişken tanımlandığında bir başlangıç değeri atamak iyi bir uygulamadır. Örneğin, 'int sayi = 0;' ile varsayılan bir değer atamak, daha sonra bu değişkenin kullanılabilirliğini artırır. Ayrıca, global değişkenleri kullanmaktan kaçınmak, programın karmaşıklığını azaltır ve değişkenlerin daha kolay yönetilmesine olanak tanır.",
    "category": "basic_syntax",
    "topic": "variables_datatypes",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Değişkenler ve veri tipleri",
    "timestamp": "2025-06-01T14:09:48.178432"
  },
  {
    "question": "Aşağıdaki kodda eksik operatörü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 5, b = 10;\n    int toplam = a ____ b;\n    printf(\"Toplam: %d\", toplam);\n    return 0;\n}",
    "answer": "Yukarıdaki kodda, 'toplam' değişkeninin değerini bulmak için '+' operatörünü kullanmamız gerekiyor. Tamamlanmış hali şu şekildedir:\n\nint toplam = a + b;\n\nBu durumda toplam değişkeni 15 olacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653038"
  },
  {
    "question": "Aşağıdaki kodda eksik karşılaştırma operatörünü tamamlayın: \n#include <stdio.h>\nint main() {\n    int x = 20, y = 30;\n    if (x ____ y) {\n        printf(\"x, y'den küçüktür.\");\n    } else {\n        printf(\"x, y'den küçük değildir.\");\n    }\n    return 0;\n}",
    "answer": "Burada x'in y'den küçük olup olmadığını kontrol etmek için '<' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nif (x < y) {\n    // işlem\n}\n\nBu durumda 'x, y'den küçüktür.' mesajı yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653133"
  },
  {
    "question": "Aşağıdaki kodda eksik aritmetik operatörü nedir? \n#include <stdio.h>\nint main() {\n    int sayi1 = 8, sayi2 = 4;\n    int sonuc = sayi1 ____ sayi2;\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}",
    "answer": "Burada iki sayının bölümü hesaplanıyor. Bu yüzden '/' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nint sonuc = sayi1 / sayi2;\n\nSonuç 2 olacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653192"
  },
  {
    "question": "Aşağıdaki kodda eksik mantıksal operatörü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 1, b = 0;\n    if (a ____ b) {\n        printf(\"Koşul sağlandı.\");\n    } else {\n        printf(\"Koşul sağlanmadı.\");\n    }\n    return 0;\n}",
    "answer": "Bu durumda 'a' ve 'b' değişkenlerinin mantıksal 've' koşulunu kontrol etmemiz gerekiyor, bu yüzden '&&' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nif (a && b) {\n    // işlem\n}\n\nBu durumda 'Koşul sağlanmadı.' mesajı yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653272"
  },
  {
    "question": "Aşağıdaki kodda eksik atama operatörünü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 5;\n    a ____= 3;\n    printf(\"Yeni a: %d\", a);\n    return 0;\n}",
    "answer": "Burada 'a' değişkenine 3 eklemek için '+=' operatörünü kullanmalıyız. Tamamlanmış hali:\n\na += 3;\n\nBu durumda 'Yeni a: 8' mesajı yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653326"
  },
  {
    "question": "Aşağıdaki kodda eksik bit düzeyinde operatörü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 5; // 0101\n    int b = 3; // 0011\n    int sonuc = a ____ b;\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}",
    "answer": "Burada bit düzeyinde 've' işlemi yapmak için '&' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nint sonuc = a & b;\n\nBu durumda 'Sonuç: 1' yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653390"
  },
  {
    "question": "Aşağıdaki kodda eksik işlemi tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 10;\n    int b = a ____ 2;\n    printf(\"B: %d\", b);\n    return 0;\n}",
    "answer": "Burada 'a' değişkenini 2 bit sağa kaydırmak için '>>' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nint b = a >> 2;\n\nBu durumda 'B: 2' yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653438"
  },
  {
    "question": "Aşağıdaki kodda eksik artırma operatörünü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 7;\n    a ____;\n    printf(\"A: %d\", a);\n    return 0;\n}",
    "answer": "Burada 'a' değişkenini 1 artırmak için '++' operatörünü kullanmalıyız. Tamamlanmış hali:\n\na++;\n\nBu durumda 'A: 8' yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653500"
  },
  {
    "question": "Aşağıdaki kodda eksik mantıksal operatörü tamamlayın: \n#include <stdio.h>\nint main() {\n    int x = 5;\n    if (x > 0 ____ x < 10) {\n        printf(\"x 0 ile 10 arasında.\");\n    }\n    return 0;\n}",
    "answer": "Burada 'x'in 0 ile 10 arasında olup olmadığını kontrol etmek için mantıksal 'veya' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nif (x > 0 || x < 10) {\n    // işlem\n}\n\nBu durumda 'x 0 ile 10 arasında.' mesajı yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653572"
  },
  {
    "question": "Aşağıdaki kodda eksik operatörü tamamlayın: \n#include <stdio.h>\nint main() {\n    int a = 6;\n    int sonuc = a ____ 3;\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}",
    "answer": "Burada 'a' değişkeninin 3 ile çarpılması gerekiyor. Bu yüzden '*' operatörünü kullanmalıyız. Tamamlanmış hali:\n\nint sonuc = a * 3;\n\nBu durumda 'Sonuç: 18' yazdırılacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:13.653621"
  },
  {
    "question": "Kullanıcının girdiği iki sayı arasındaki en büyük sayıyı bulan bir C programında, eksik olan kısmı tamamla: int a, b; ...",
    "answer": "int a, b; \nif (a > b) {\n    printf(\"En büyük sayı: %d\", a);\n} else {\n    printf(\"En büyük sayı: %d\", b);\n}\n\n// Bu kod, iki sayıyı karşılaştırarak en büyük olanı bulur. 'if' yapısı, '>' operatörü ile a'nın b'den büyük olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724026"
  },
  {
    "question": "Bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir programda eksik kısmı tamamla: int num; ...",
    "answer": "int num; \nif (num > 0) {\n    printf(\"Pozitif\");\n} else if (num < 0) {\n    printf(\"Negatif\");\n} else {\n    printf(\"Sıfır\");\n}\n\n// Burada 'if', 'else if' ve 'else' yapıları kullanılarak sayının durumu belirleniyor. '>' ve '<' operatörleri, sayının pozitif veya negatif olduğunu kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724083"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının tek mi çift mi olduğunu bulan bir programda eksik kısmı tamamla: int num; ...",
    "answer": "int num; \nif (num % 2 == 0) {\n    printf(\"Çift\");\n} else {\n    printf(\"Tek\");\n}\n\n// Burada '%' operatörü kullanılarak sayının 2'ye bölümünden kalan kontrol edilir. Eğer kalan 0 ise sayı çifttir; aksi durumda tektir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724120"
  },
  {
    "question": "Bir dizideki en küçük elemanı bulan bir programda eksik kısmı tamamla: int arr[5]; ...",
    "answer": "int min = arr[0]; \nfor (int i = 1; i < 5; i++) {\n    if (arr[i] < min) {\n        min = arr[i];\n    }\n}\nprintf(\"En küçük sayı: %d\", min);\n\n// Bu kodda, 'for' döngüsü ile dizi elemanları kontrol edilir ve '<' operatörü ile her bir elemanın en küçük elemandan küçük olup olmadığı belirlenir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724152"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayının toplamının 10'dan büyük olup olmadığını kontrol eden programda eksik kısmı tamamla: int a, b; ...",
    "answer": "int sum = a + b; \nif (sum > 10) {\n    printf(\"Toplam 10'dan büyük\");\n} else {\n    printf(\"Toplam 10 veya 10'dan küçük\");\n}\n\n// 'sum' değişkeni ile a ve b'nin toplamı hesaplanır. '>' operatörü ile toplamın 10'dan büyük olup olmadığı kontrol edilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724191"
  },
  {
    "question": "Bir kullanıcının girdiği üç sayının en küçüğünü bulan bir programın eksik kısmı: int a, b, c; ...",
    "answer": "int min = a; \nif (b < min) {\n    min = b;\n}\nif (c < min) {\n    min = c;\n}\nprintf(\"En küçük sayı: %d\", min);\n\n// Bu kodda, ilk olarak a sayısı en küçük olarak varsayılır. Sonra b ve c'nin min'den küçük olup olmadığı kontrol edilerek en küçük değer güncellenir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724224"
  },
  {
    "question": "Bir kullanıcının girdiği bir karakterin sesli harf olup olmadığını kontrol eden programda eksik kısmı tamamla: char ch; ...",
    "answer": "if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || \n    ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n    printf(\"Sesli harf\");\n} else {\n    printf(\"Sessiz harf\");\n}\n\n// Bu kodda '||' (veya) operatörü kullanılarak bir karakterin sesli harf olup olmadığı kontrol edilmektedir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724258"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının mutlak değerini hesaplayan programda eksik kısmı tamamla: int num; ...",
    "answer": "if (num < 0) {\n    num = -num;\n}\nprintf(\"Mutlak değer: %d\", num);\n\n// Burada '<' operatörü ile sayının negatif olup olmadığı kontrol edilir. Eğer negatif ise, num'un işareti değiştirilerek mutlak değeri hesaplanır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724289"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının 100'e bölünüp bölünmediğini kontrol eden programda eksik kısmı tamamla: int num; ...",
    "answer": "if (num % 100 == 0) {\n    printf(\"100'e bölünebilir\");\n} else {\n    printf(\"100'e bölünemez\");\n}\n\n// '%' operatörü kullanılarak sayının 100'e bölümünden kalan kontrol edilir. Eğer kalan 0 ise sayı 100'e tam bölünebilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724323"
  },
  {
    "question": "Bir kullanıcının girdiği yılın artık yıl olup olmadığını kontrol eden programda eksik kısmı tamamla: int year; ...",
    "answer": "if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n    printf(\"Artık yıl\");\n} else {\n    printf(\"Artık yıl değil\");\n}\n\n// Burada iki koşul '&&' (ve) operatörü ile birleştirilmiştir. Yıl 4'e bölünüp 100'e bölünemiyorsa veya 400'e bölünebiliyorsa, artık yıl olarak kabul edilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:41.724356"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan operatörü tamamlayın: int a = 10; int b = 20; int c; c = a ___ b;",
    "answer": "c = a + b; // Burada, c değişkenine a ve b'nin toplamını atıyoruz. Bu, 'toplama' işlemi gerçekleştiren bir operatördür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013344"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan operatörü tamamlayın: int x = 5; int y = 2; int z; z = x ___ y;",
    "answer": "z = x % y; // Bu operatör, x'in y'ye bölümünden kalanı hesaplar. Sonuç z değişkenine atanır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013397"
  },
  {
    "question": "Aşağıdaki kodda eksik olan karşılaştırma operatörünü tamamlayın: if (a ___ b) { printf(\"Eşit\"); }",
    "answer": "if (a == b) { // Burada, a ve b'nin eşit olup olmadığını kontrol eden 'eşitlik' operatörünü kullanıyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013436"
  },
  {
    "question": "Aşağıdaki kodda eksik olan mantıksal operatörü tamamlayın: if (x > 0 ___ y < 10) { printf(\"Geçerli\"); }",
    "answer": "if (x > 0 && y < 10) { // Burada, x'in pozitif ve y'nin 10'dan küçük olup olmadığını kontrol eden 've' mantıksal operatörünü kullanıyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013541"
  },
  {
    "question": "Aşağıdaki kodda eksik olan bit düzeyinde operatörü tamamlayın: int result = a ___ b;",
    "answer": "int result = a & b; // Bu bit düzeyinde 've' operatörüdür. a ve b'nin bitlerini karşılaştırarak sonuç döndürür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013583"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan artırma operatörünü tamamlayın: int count = 5; count ___;",
    "answer": "count++; // Bu, count değişkeninin değerini 1 artıran 'artırma' operatörüdür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013660"
  },
  {
    "question": "Aşağıdaki kodda eksik olan azaltma operatörünü tamamlayın: int value = 10; value ___;",
    "answer": "value--; // Bu, value değişkeninin değerini 1 azaltan 'azaltma' operatörüdür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013692"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan atama operatörünü tamamlayın: int score = 100; score ___ 50;",
    "answer": "score += 50; // Bu, score değişkenine 50 ekleyerek güncellenmesini sağlayan bir 'atama' operatörüdür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013725"
  },
  {
    "question": "Aşağıdaki kodda eksik olan koşullu operatörü tamamlayın: int max = (a ___ b) ? a : b;",
    "answer": "int max = (a > b) ? a : b; // Burada, a'nın b'den büyük olup olmadığını kontrol eden 'koşullu' operatör kullanıyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013758"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan bit kaydırma operatörünü tamamlayın: int shifted = a ___ 2;",
    "answer": "int shifted = a << 2; // Bu, a'nın bitlerini 2 basamak sola kaydıran bir 'bit kaydırma' operatörüdür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013791"
  },
  {
    "question": "Aşağıdaki kodda eksik olan birleşik atama operatörünü tamamlayın: int total = 0; total ___ 10;",
    "answer": "total *= 10; // Bu, total değişkenini 10 ile çarparak güncellemeyi sağlayan bir 'birleşik atama' operatörüdür.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:10:57.013823"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmedik bir çıktı alıyorum? `int a = 5; int b = 10; printf('%d', a + b * 2);`",
    "answer": "Burada, `b * 2` işlemi önce hesaplandığı için `a + b * 2` ifadesi `5 + 20` olarak değerlendirilir. Sonuç `25` olur. Eğer `a` ve `b` toplamının iki katını almak istiyorsanız, parantez kullanmalısınız: `printf('%d', (a + b) * 2);` Bu durumda çıktı `30` olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356726"
  },
  {
    "question": "Aşağıdaki kodda neden `1` yerine `0` değeri alıyorum? `int x = 10; if (x > 5 && x < 15) { printf('1'); } else { printf('0'); }`",
    "answer": "Bu kodda mantıksal `&&` operatörü doğru bir şekilde kullanılmış. Ancak, `printf` fonksiyonunda `'%d'` yerine `'%s'` kullanılmış. Doğru format string ile kod şöyle olmalı: `printf('%d', (x > 5 && x < 15));`. Bu durumda çıktı `1` olur, çünkü koşul sağlanıyor.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356792"
  },
  {
    "question": "Kodda beklenmedik bir şekilde `a` değişkeninin değeri `0` çıkıyor. `int a = 5; a = a++; printf('%d', a);`",
    "answer": "Burada `a++` ifadesi, `a`'nın mevcut değerini döner ve sonra artırır. Ancak `a = a++;` satırında `a`'ya `a++` ifadesinin önceki değeri atanmış olur. `a` değişkeni `5` olarak kalır. Doğru kullanım `a++; printf('%d', a);` olmalıdır. Bu durumda çıktı `6` olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356834"
  },
  {
    "question": "Aşağıdaki kod neden daima `0` döndürüyor? `int a = 3; int b = 7; printf('%d', a < b ? a : b);`",
    "answer": "Kod burada doğru çalışıyor. Koşul `a < b` doğru olduğu için `a` değeri döner. Eğer çıktı `0` ise, ya başka bir kod parçası hatalı ya da kodun çıktısı doğru bir biçimde gösterilmiyor. Doğru beklenen çıktı `3` olmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356873"
  },
  {
    "question": "Aşağıdaki kodda neden `-5` beklerken `5` alıyorum? `int a = 5; int b = -10; printf('%d', a - b);`",
    "answer": "Burada `a - b` işlemi `5 - (-10)` şeklinde değerlendirilir ve bu da `5 + 10` demektir. Sonuç olarak `15` çıkar. Eğer `a - b` yerine `b - a` yazsaydınız, sonuç `-15` olacaktı. Doğru işleme dikkat etmelisiniz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356937"
  },
  {
    "question": "Neden `printf('%d', 5 > 10);` ifadesi `1` döndürüyor?",
    "answer": "Bu ifade yanlış. `5 > 10` koşulu yanlıştır, dolayısıyla `printf('%d', 5 > 10);` ifadesi `0` döndürmelidir. Eğer `1` alıyorsanız, muhtemelen başka bir kod parçası etkiliyor. `0` beklenmektedir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.356968"
  },
  {
    "question": "Aşağıdaki kodda neden `0` alıyorum? `int a = 0; int b = 1; printf('%d', a && b);`",
    "answer": "Burada `&&` (mantıksal ve) operatörü kullanılıyor. `a` değişkeni `0` olduğu için koşul sağlanmaz ve sonuç `0` döner. Eğer `a` değişkenini `1` yaparsanız, sonuç `1` olur, çünkü her iki operand da `true` durumu sağlar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.357002"
  },
  {
    "question": "Kodun bu kısmında neden division by zero hatası alıyorum? `int a = 5; int b = 0; printf('%d', a / b);`",
    "answer": "Bu hata, `0` ile bölme işlemi yapıldığında ortaya çıkar. `b`'nin `0` olup olmadığını kontrol etmelisiniz. Şöyle bir kontrol ekleyebilirsiniz: `if (b != 0) printf('%d', a / b); else printf('Bölme hatası!');` Bu, hatanın önüne geçer.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.357045"
  },
  {
    "question": "Aşağıdaki kodda neden yanlış sonuç alıyorum? `int x = 9; x %= 5; printf('%d', x);`",
    "answer": "Burada `x %= 5` ifadesi `x = x % 5` anlamına gelir, yani `9 % 5` işlemi yapılır. Kalan `4` olduğu için sonuç `4` olur. Eğer başka bir sonuç bekliyorsanız, kodun mantığını kontrol etmelisiniz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.357078"
  },
  {
    "question": "Kodda neden `a` değişkeninin değeri -1 çıkıyor? `int a = 0; a = a - 1; printf('%d', a);`",
    "answer": "Burada `a` değişkeninin başlangıç değeri `0`. `a - 1` işlemi yapıldığında `a`'nın yeni değeri `-1` olur. Eğer `0` bekliyorsanız, `a` üzerinde başka bir işlem yapılıyor olabilir. Kodun tamamını gözden geçirmek gerekebilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.357113"
  },
  {
    "question": "Aşağıdaki kodda neden `0` yerine `1` çıkıyor? `int a = 10; if (a == 10) { printf('1'); } else { printf('0'); }`",
    "answer": "Bu kod doğru çalışıyor. `if` koşulu sağlandığı için `1` yazdırılır. Eğer `0` bekliyorsanız, muhtemelen `a` değişkeninin değeri değişmiş veya başka bir hata var demektir. Kodun değişikliklerini ve değerlerini kontrol etmelisiniz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:11:22.357157"
  },
  {
    "question": "Aşağıdaki kod parçasında neden beklenen sonuç alınmıyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 20;\n    int c;\n    c = a + b * 2;\n    printf(\"Sonuç: %d\", c);\n    return 0;\n}\n```",
    "answer": "Kodda çarpma ve toplama işlemleri arasında bir öncelik sırası vardır. Öncelik sırasına göre, \"b * 2\" işlemi önce yapılır ve ardından \"a\" ile toplanır. Bu nedenle, \"c = 10 + 20 * 2;\" ifadesi \"c = 10 + 40;\" olarak değerlendirilir ve sonuç 50 olur. Eğer beklenen sonuç 60 ise, \"c = (a + b) * 2;\" şeklinde parantez eklenmelidir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974214"
  },
  {
    "question": "Aşağıdaki kodda neden 'a' değişkeninin değeri değişmiyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    a = (b > 5) ? b : 0;\n    printf(\"a: %d\", a);\n    return 0;\n}\n```",
    "answer": "Kodda kullanılan ternary operatör \"(b > 5) ? b : 0;\" ifadesi, \"b\" 5'ten büyük olduğu için \"a\"'ya \"b\" değerini atar. Ancak burada beklenen sonuç, 'a' değişkeninin 0 olması ise, bu koşul doğru olmadığından 'a' değişmez. Eğer beklenen sonuç 10 ise, kod doğrudur. Herhangi bir hata yoktur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974298"
  },
  {
    "question": "Aşağıdaki kod parçasında neden yanlış sonuç alıyorum?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 3, y = 4;\n    if (x = y) {\n        printf(\"Eşit\");\n    } else {\n        printf(\"Eşit Değil\");\n    }\n    return 0;\n}\n```",
    "answer": "Kodda 'x = y' ifadesi, 'x' değişkenine 'y' değerini atar ve bu atama işlemi gerçekleştikten sonra koşul her zaman doğru (true) olur, çünkü atama işlemi sonucunda 'x' değeri 4'tür. Doğru kontrol için '==' operatörü kullanılmalıdır: 'if (x == y)'.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974388"
  },
  {
    "question": "Aşağıda verilen kod parçasında beklenen sonuç neden alınmıyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    int c = a++ + ++b;\n    printf(\"Sonuç: %d\", c);\n    return 0;\n}\n```",
    "answer": "Kodun sonucunu etkileyen öncelik sırasıdır. 'a++' ifadesi, 'c' atamasında mevcut değeri kullanır (5) ve ardından 'a' 6 olur. '++b' ise 'b' değerini artırarak 11 yapar. Dolayısıyla 'c = 5 + 11' olur ve sonuç 16'dır. Beklenen sonuç farklı ise, 'a' ve 'b' üzerindeki işlemlerin sırasını değiştirmek gerekebilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974453"
  },
  {
    "question": "Aşağıdaki C kodunda neden beklenen değer 0 değil?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 3;\n    int b = 4;\n    int result = (a < b) && (b < a);\n    printf(\"Sonuç: %d\", result);\n    return 0;\n}\n```",
    "answer": "Kodda mantıksal '&&' (ve) operatörü kullanılmaktadır. Bu operatör, her iki koşulun da doğru olması durumunda doğru (true) döndürür. Burada 'a < b' koşulu doğru, ancak 'b < a' koşulu yanlıştır. Dolayısıyla sonucu '0' (false) bekliyorsanız, bu doğrudur. Eğer her iki koşulun da doğru olmasını bekliyorsanız, 'result' ifadesini gözden geçirmeniz gerekmektedir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974553"
  },
  {
    "question": "Aşağıdaki kod parçasında neden beklenen sonucu elde edemiyorum?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 5;\n    num += 3 * 2;\n    printf(\"Sonuç: %d\", num);\n    return 0;\n}\n```",
    "answer": "Kodda 'num' değişkenine '3 * 2' işlemi yapılmadan önce '+= 3 * 2' ifadesi uygulanır. Çarpma işlemi önce yapılır ve sonucunda 6 elde edilir. Bu nedenle 'num' değeri 5 + 6 = 11 olur. Eğer beklenen 8 ise, kodun 'num += 3;' ile değiştirilmesi gerekirdi.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974634"
  },
  {
    "question": "Aşağıdaki kod parçasında neden beklenen değer 1 değil?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 0;\n    int b = 1;\n    int result = a | b;\n    printf(\"Sonuç: %d\", result);\n    return 0;\n}\n```",
    "answer": "Kodda bit düzeyindeki '|' (veya) operatörü kullanılmaktadır. 'a | b' işlemi, 'a' ve 'b' bitlerinin karşılaştırılmasıdır. '0' (0000) ve '1' (0001) için sonuç '0001' yani 1 olur. Eğer beklenen sonuç 0 ise, 'result' ifadesinde bit düzeyindeki operatörlerin yerine mantıksal operatörler kullanılmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974696"
  },
  {
    "question": "Aşağıdaki kodda neden beklenen sonuç alınmıyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 10;\n    int y = 20;\n    int z = x-- + --y;\n    printf(\"Sonuç: %d\", z);\n    return 0;\n}\n```",
    "answer": "Kodda 'x--' ifadesi 'z' hesaplanırken mevcut değeri kullanır (10) ve ardından 'x' 9 olur. 'y' ise '20' değerinden 1 azaltılarak 19 olur. Dolayısıyla işlem sonunda 'z = 10 + 19' olur ve sonuç 29'dur. Eğer beklenen sonuç 30 ise, 'x' ve 'y' üzerindeki işlemler gözden geçirilmelidir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974756"
  },
  {
    "question": "Aşağıdaki kodda neden beklenen sonuç alınmıyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 5;\n    if (a && b) {\n        printf(\"Her ikisi de doğru\");\n    } else {\n        printf(\"En az biri yanlış\");\n    }\n    return 0;\n}\n```",
    "answer": "Kodda 'if (a && b)' ifadesi, 'a' ve 'b' değerlerinin her ikisinin de sıfırdan farklı olduğuna bakar. Bu durumda her iki değer de doğru olduğundan 'Her ikisi de doğru' yazdırılır. Eğer beklenen sonuç 'En az biri yanlış' ise, 'a' veya 'b' değerlerinden en az birinin sıfır yapılması gerekmektedir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974828"
  },
  {
    "question": "Aşağıdaki kodda neden beklenen sonuç alınmıyor?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5;\n    if (++a > 5) {\n        printf(\"Büyüktür\");\n    } else {\n        printf(\"Küçüktür veya Eşittir\");\n    }\n    return 0;\n}\n```",
    "answer": "Kodda '++a' ifadesi, 'a' değerini 5'ten 6'ya artırır. Bu nedenle koşul '6 > 5' olarak değerlendirilir ve 'Büyüktür' yazdırılır. Eğer beklenen sonuç 'Küçüktür veya Eşittir' ise, 'if' koşulunun kontrol edilmesi gerekmektedir. Örneğin, 'if (a >= 5)' şeklinde bir kontrol kullanılabilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:07.974894"
  },
  {
    "question": "Bir değişkeni birden fazla kez artırıp azaltırken yanlış sonuç alınıyor. Aşağıdaki kodda problem nedir? \n\n int a = 5; \n a++ + a-- + ++a; \n printf(\"%d\", a);",
    "answer": "Bu kodda, 'a' değişkeni üzerinde birden fazla operatör kullanılıyor. 'a++' ifadesi '5' döndürür, sonra 'a' 6 olur. 'a--' ifadesi '6' döndürdükten sonra 'a' 5'e döner. Son olarak '++a' ifadesi '6' döndürür. Toplamda 5 + 6 + 6 = 17 olur, ama 'a' değişkeninin son değeri 6'dır. Değişkenin son değeri ile toplamın farklı olması, işlem sırasının ve operatör önceliklerinin dikkate alınmamasından kaynaklanmaktadır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330407"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmeyen bir sonuç alınıyor? \n\n int x = 10; \n int y = 20; \n int z = (x == y) ? x : y; \n printf(\"%d\", z);",
    "answer": "Bu kodda 'z' değişkeni, 'x' ve 'y' değişkenlerinin eşit olup olmadığına bağlı olarak atanıyor. 'x' ve 'y' birbirine eşit olmadığı için (10 != 20), 'y' değeri olan 20 'z'ye atanıyor. Eğer beklenen sonuç 10 olsaydı, 'x' ve 'y' değerlerinin eşit olması gerekirdi. Yani, koşulun yanlış değerlendirilmesi bu sonucu doğurmuştur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330468"
  },
  {
    "question": "Aşağıdaki kodda neden sonsuz döngü oluşuyor? \n\n int i = 0; \n while (i < 10) { \n i++; \n if (i == 5) \n i--; \n } \n printf(\"%d\", i);",
    "answer": "Bu kodda 'i' değişkeni 0'dan 10'a kadar artırılıyor. Ancak 'if' koşulunda 'i' 5 olduğunda 'i' bir azaltılıyor. Bu durumda 'i' değeri hep 4 ile 5 arasında döner ve sonsuz döngü oluşur. Bu hatayı düzeltmek için 'if' koşulunu kaldırabilir ya da 'i' değeri 5'e ulaştığında döngüyü kıracak bir kontrol eklenmelidir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330532"
  },
  {
    "question": "Aşağıdaki ifadede neden beklenmedik davranışlar gözlemlenir? \n\n int a = 10; \n int b = 20; \n int c = 30; \n if (a = b) { \n c = a + b; \n } \n printf(\"%d\", c);",
    "answer": "Burada 'if (a = b)' ifadesi aslında 'a' değişkenine 'b' değerini atamaktadır. Bu durumda 'a' artık 20 olur ve koşul doğru kabul edilir, bu nedenle 'c' değeri 40 olur. Koşul ifadesinin atama operatörü yerine karşılaştırma operatörü (==) kullanılması gerektiği için bu beklenmeyen duruma yol açmıştır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330582"
  },
  {
    "question": "Aşağıdaki kodda mantıksal operatörler doğru kullanılmamış. Neden sonuç beklediğiniz gibi değil? \n\n int x = 5; \n if (x > 0 && x < 10 || x == 5) { \n printf(\"True\"); \n } else { \n printf(\"False\"); \n }",
    "answer": "Bu kodda '&&' ve '||' operatörleri bir arada kullanılmıştır. Öncelik sırası gereği '&&' operatörü önce değerlendirilir, dolayısıyla koşul 'x > 0 && x < 10' olarak değerlendirildikten sonra '|| x == 5' kısmı eklenir. 'x' 5 olduğu için bu koşul 'True' döner. Ancak eğer sadece '&&' kullanılsaydı, bu tam olarak beklediğiniz sonucu vermezdi çünkü 'x == 5' koşulunun '&&' ile birlikte kullanılmadığı durumlarda, koşul 'False' dönebilirdi. Bu durumda parantez kullanmak gerekebilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330666"
  },
  {
    "question": "Aşağıdaki kodda operatör önceliği nedeniyle yanlış bir sonuç alınıyor. Sorunu düzeltin: \n\n int a = 5; \n int b = 3; \n int c = 2; \n int result = a + b * c; \n printf(\"%d\", result);",
    "answer": "Bu kodda 'b * c' işlemi öncelikli olarak yapıldığı için öncelikle 3 * 2 = 6 işlemi gerçekleştirilir ve ardından 'a' ile toplandığında 5 + 6 = 11 sonucu elde edilir. Eğer beklenen sonuç '5 + 3' yani 8 ise, 'result' hesaplamasında parantez kullanarak 'int result = a + (b * c);' şeklinde yazılmalıdır. Bu durumda işlem sırası netleşir ve beklenilen sonuç elde edilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330723"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmeyen bir değer alınıyor? \n\n int a = 10; \n int b = 20; \n int c = (a < b) ? a : b; \n b = c; \n printf(\"%d\", b);",
    "answer": "Bu kodda 'b', 'c' değerine atanmış durumda, ancak 'c' değişkeninin değeri 'a' veya 'b' arasında en küçük olanıdır. 'a' < 'b' olduğu için 'c' değeri '10' olur ve bu sonuç daha sonra 'b' değişkenine atanır. Eğer beklenen sonuç '20' olsaydı, 'c' tanımının değiştirilmesi gerekebilirdi. Örneğin, 'int c = (a > b) ? a : b;' şeklinde değiştirilmelidir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330769"
  },
  {
    "question": "Aşağıdaki kodda bitwise operatörler yanlış kullanılmış. Neden beklenmeyen bir sonuç çıkıyor? \n\n int x = 3; \n int y = 5; \n int result = x & y; \n printf(\"%d\", result);",
    "answer": "Bu kodda '&' operatörü bitwise AND işlemidir. '3' ve '5' değerlerinin ikili karşılıkları '0011' ve '0101' şeklindedir. Bitwise AND uygulandığında sonuç '0001' yani 1'dir. Eğer beklenen sonuç '8' ise, bu durumda bitwise OR operatörü ('|') kullanılmalıdır. Yani 'int result = x | y;' şeklinde olmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330817"
  },
  {
    "question": "Aşağıdaki kodda neden yanlış değer alınıyor? \n\n int i = 5; \n int j = 10; \n int k = i += j; \n printf(\"%d\", k);",
    "answer": "Yukarıdaki kodda 'i += j' ifadesi aslında 'i = i + j' demektir. Bu durumda 'i' 15 olur. Ancak 'k' değişkenine atanan değer 'i' değişkeninin yeni değeri değil, atama işleminin sonucu olan '15' değil, 'i' değişkeninin değeri olarak 15 olur. Yani bu durumda 'k' 15 olurken, 'i' değişkeni de 15 olacaktır. Eğer 'k' değişkeninin 'i' değişkeninin önceki değerini almak istenirse, atama işleminden önce 'k' değişkenine 'i' değerinin atanması gerekir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330861"
  },
  {
    "question": "Aşağıdaki kodda neden beklenmeyen bir sonuç alınıyor? \n\n int a = 10; \n int b = 20; \n if (a > 5 && b < 15) { \n printf(\"Valid\"); \n } else { \n printf(\"Invalid\"); \n }",
    "answer": "Bu kodda 'a' 10 ve 'b' 20'dir. Koşul 'a > 5' doğru (true), ancak 'b < 15' yanlış (false) olduğu için '&&' operatörü nedeniyle tamamı yanlış olur. Böylece 'Invalid' sonucu döner. Eğer 'b' değerinin 15'ten küçük olmasını bekliyorsanız, 'b' değişkeninin değeri değiştirilmelidir. Aksi takdirde mantıksal operatör kullanımı ve koşulun mantıksal değerleri üzerinde dikkatle durulmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:12:41.330912"
  },
  {
    "question": "Aritmetik operatörler nedir ve nasıl kullanılır?",
    "answer": "Aritmetik operatörler, sayısal değerler üzerinde matematiksel işlemler yapmak için kullanılır. C dilinde temel operatörler şunlardır: '+' (toplama), '-' (çıkartma), '*' (çarpma) ve '/' (bölme). Örneğin, 'int a = 5; int b = 3; int toplam = a + b;' ifadesi, a ve b değişkenlerini toplar ve sonucu toplam değişkenine atar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930668"
  },
  {
    "question": "Karşılaştırma operatörleri nelerdir?",
    "answer": "Karşılaştırma operatörleri, iki değer arasında karşılaştırma yapmak için kullanılır. C dilinde bu operatörler şunlardır: '==' (eşitlik), '!=' (eşit olmama), '>' (büyüktür), '<' (küçüktür), '>=' (büyük eşittir) ve '<=' (küçük eşittir). Örneğin, 'if (a > b)' ifadesi, a'nın b'den büyük olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930705"
  },
  {
    "question": "Mantıksal operatörler ne işe yarar?",
    "answer": "Mantıksal operatörler, boolean değerler (doğru veya yanlış) üzerinde işlem yapar. C dilinde '&&' (ve), '||' (veya) ve '!' (değil) operatörleri kullanılır. Örneğin, 'if (x > 0 && y > 0)' ifadesi, x ve y'nin de pozitif olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930727"
  },
  {
    "question": "Artırma ve azaltma operatörleri nasıl çalışır?",
    "answer": "Artırma ve azaltma operatörleri, bir değişkenin değerini 1 artırmak veya 1 azaltmak için kullanılır. '++' artırma, '--' ise azaltma operatörüdür. Örneğin, 'int sayi = 5; sayi++;' ifadesi sayi değişkeninin değerini 6 yapar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930750"
  },
  {
    "question": "Atama operatörleri nedir?",
    "answer": "Atama operatörleri, bir değeri bir değişkene atamak için kullanılır. C dilinde en yaygın atama operatörü '=' dir. Örneğin, 'int a = 10;' ifadesi, a değişkenine 10 değerini atar. Ayrıca, '+=' gibi bileşik atama operatörleri de bulunmaktadır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930772"
  },
  {
    "question": "Bit düzeyinde operatörler nelerdir ve ne işe yarar?",
    "answer": "Bit düzeyinde operatörler, tam sayılar üzerinde bit düzeyinde işlemler yapmak için kullanılır. C dilinde '&' (ve), '|' (veya), '^' (xor), '~' (değil), '<<' (sol kaydırma) ve '>>' (sağ kaydırma) operatörleri bulunur. Örneğin, 'a & b' ifadesi, a ve b'nin bitlerini karşılaştırarak her iki bitin 1 olduğu durumlarda 1 döner.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930797"
  },
  {
    "question": "Koşul ifadeleri ile operatörlerin nasıl kullanıldığını açıklayın.",
    "answer": "C dilinde koşul ifadeleri 'if', 'else' ve 'switch' gibi yapılarla birlikte operatörler kullanılarak koşullu mantık oluşturulur. Örneğin, 'if (a > b) printf(\"a büyüktür\");' ifadesi, a değişkeninin b'den büyük olup olmadığını kontrol eder ve eğer doğruysa ekrana 'a büyüktür' yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930823"
  },
  {
    "question": "C dilinde modül operatörü '%' nasıl çalışır?",
    "answer": "Modül operatörü '%', iki sayının bölümünden kalanı bulmak için kullanılır. Örneğin, 'int kalan = 10 % 3;' ifadesi 10'un 3'e bölümünden kalan 1'i kalan değişkenine atar. Bu, genellikle çift sayıları kontrol etmek için kullanılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930852"
  },
  {
    "question": "Ternary operatör nasıl kullanılır?",
    "answer": "Ternary operatör, kısa bir if-else yapısı olarak kullanılabilir. 'koşul ? değer1 : değer2' şeklindedir. Örneğin, 'int sonuc = (a > b) ? a : b;' ifadesi, a'nın b'den büyük olup olmadığını kontrol eder ve büyük olan değeri sonuc değişkenine atar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930872"
  },
  {
    "question": "C dilinde öncelik sırası operatörlerin nasıl çalıştığını açıklayın.",
    "answer": "C dilinde operatörlerin öncelik sırası, hangi işlemlerin önce yapılacağını belirler. Örneğin, çarpma ve bölme işlemleri toplama ve çıkarmadan önce yapılır. 'int sonuc = 10 + 5 * 2;' ifadesinde, önce 5 * 2 işlemi yapılır ve sonra 10 ile toplanır, sonuç 20 olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:05.930911"
  },
  {
    "question": "Aritmetik operatörler nedir? Örnek kullanımı ile açıklayabilir misin?",
    "answer": "Aritmetik operatörler, sayısal değerler üzerinde matematiksel işlemler yapmamıza olanak sağlar. Temel aritmetik operatörler; toplama (+), çıkarma (-), çarpma (*), bölme (/) ve mod alma (%)'dır. Örneğin, iki sayının toplamını hesaplamak için şu kodu yazabiliriz:\n\n```c\nint a = 10;\nint b = 5;\nint toplam = a + b;\nprintf(\"Toplam: %d\\n\", toplam);\n```\nBu kod, 10 ve 5'in toplamını hesaplayarak 'Toplam: 15' çıktısını verir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156082"
  },
  {
    "question": "Karşılaştırma operatörleri nelerdir ve nasıl kullanılırlar?",
    "answer": "Karşılaştırma operatörleri, iki değeri karşılaştırmak için kullanılır ve genellikle bool (doğru/yanlış) sonuç döndürür. En yaygın karşılaştırma operatörleri: eşittir (==), eşit değildir (!=), büyüktür (>), küçüktür (<), büyük eşittir (>=) ve küçük eşittir (<=) şeklindedir. Örneğin:\n\n```c\nint x = 10;\nint y = 20;\nif (x < y) {\n    printf(\"x, y'den küçüktür.\\n\");\n}\n```\nBu kod, x'in y'den küçük olduğunu kontrol eder ve 'x, y'den küçüktür.' mesajını yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156121"
  },
  {
    "question": "Mantıksal operatörlerin rolü nedir? Örnek bir kullanım göster.",
    "answer": "Mantıksal operatörler, birden fazla koşulun bir arada değerlendirilmesini sağlar. En yaygın mantıksal operatörler; ve (&&), veya (||) ve değil (!) operatörleridir. Örneğin:\n\n```c\nint a = 5;\nint b = 10;\nif (a < b && b > 5) {\n    printf(\"Her iki koşul da doğrudur.\\n\");\n}\n```\nBu kod, a'nın b'den küçük ve b'nin 5'ten büyük olup olmadığını kontrol eder. Her iki koşul da doğruysa mesaj yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156145"
  },
  {
    "question": "Artırma ve azaltma operatörlerini açıkla ve bir örnek ver.",
    "answer": "Artırma (++) ve azaltma (--) operatörleri, bir değişkenin değerini 1 artırmak veya 1 azaltmak için kullanılır. Bu operatörler, ön (prefix) veya son (postfix) olarak kullanılabilir. Örneğin:\n\n```c\nint a = 5;\nint b = ++a; // Ön artırma\nprintf(\"a: %d, b: %d\\n\", a, b);\n```\nBu kodda, 'a' önce artırılır (6 olur) ve daha sonra 'b' bu değeri alır (b=6). Sonuç olarak, 'a: 6, b: 6' yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156168"
  },
  {
    "question": "Bit düzeyinde operatörler nelerdir? Bir örnekle göster.",
    "answer": "Bit düzeyinde operatörler, sayıların bitleri üzerinde işlem yapmamıza olanak tanır. Yaygın bit düzeyinde operatörler; ve (&), veya (|), değil (~), sol kaydırma (<<) ve sağ kaydırma (>>) operatörleridir. Örnek olarak, iki sayının bit düzeyinde 've' işlemini yapalım:\n\n```c\nint x = 12; // 1100\nint y = 5;  // 0101\nint sonuc = x & y; // 0100\nprintf(\"Sonuç: %d\\n\", sonuc);\n```\nBu kod, 12'nin (1100) ve 5'in (0101) bit düzeyinde 've' işlemini yapar ve sonuc 4 (0100) olarak yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156193"
  },
  {
    "question": "Koşul operatörü (ternary operator) nedir? Bir örnek ile açıklayabilir misin?",
    "answer": "Koşul operatörü, bir if-else yapısını tek satırda yazmamıza olanak tanır. Söz dizimi: `koşul ? değer1 : değer2`. Eğer 'koşul' true ise 'değer1', false ise 'değer2' döner. Örnek:\n\n```c\nint a = 10;\nint b = (a > 5) ? 1 : 0;\nprintf(\"b: %d\\n\", b);\n```\nBu kodda, 'a' 5'ten büyük olduğu için 'b' 1 değerini alır ve 'b: 1' yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156221"
  },
  {
    "question": "Atama operatörlerini açıkla ve bir örnek ver.",
    "answer": "Atama operatörleri, bir değişkene değer atamak için kullanılır. Temel atama operatörü '='dir. Ayrıca, kısmi atama işlemleri için kullanabileceğiniz bazı kısayollar vardır: '+=', '-=', '*=', '/=', '%='. Örneğin:\n\n```c\nint x = 10;\nx += 5; // x = x + 5\nprintf(\"x: %d\\n\", x);\n```\nBu kodda 'x' değeri önce 10, sonra 5 eklenerek 15 olur ve 'x: 15' yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156240"
  },
  {
    "question": "Öncelik sırası operatörleri nasıl çalışır? Bir örnekle açıkla.",
    "answer": "Operatörlerin öncelik sırası, hangi işlemlerin önce yapılacağını belirler. Örneğin, çarpma ve bölme, toplama ve çıkarmadan daha yüksek önceliğe sahiptir. Örnek:\n\n```c\nint a = 5;\nint b = 10;\nint sonuc = a + b * 2; // Öncelik sırası gereği önce çarpma, sonra toplama\nprintf(\"Sonuç: %d\\n\", sonuc);\n```\nBu kodda, önce 'b * 2' (20) yapılır, sonra 'a + 20' hesaplanır, sonuç 25 olur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156263"
  },
  {
    "question": "Null bir göstericinin (pointer) kontrolü için hangi operatörler kullanılır?",
    "answer": "Göstericilerle çalışırken null olup olmadığını kontrol etmek için karşılaştırma operatörleri kullanılır. Örneğin, bir göstericinin null olup olmadığını kontrol ederken '==' operatörü kullanılır. Örnek:\n\n```c\nint *ptr = NULL;\nif (ptr == NULL) {\n    printf(\"Gösterici null.\\n\");\n} else {\n    printf(\"Gösterici geçerli.\\n\");\n}\n```\nBu kod, 'ptr' null olduğu için 'Gösterici null.' mesajını yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156288"
  },
  {
    "question": "C dilinde azaltma operatörü (decrement operator) nasıl çalışır? Bir örnek ile açıkla.",
    "answer": "Azaltma operatörü (--) mevcut bir değişkenin değerini 1 azaltmak için kullanılır. Önceki veya sonraki pozisyonda kullanılabilir. Örneğin,:\n\n```c\nint a = 5;\nint b = a--;\nprintf(\"a: %d, b: %d\\n\", a, b);\n```\nBu kodda, 'b' değerini 'a' değerini alır (5) ve daha sonra 'a' 1 azaltılır (4). Sonuç olarak, 'a: 4, b: 5' yazdırılır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:13:36.156317"
  },
  {
    "question": "C dilinde bit düzeyinde operatörler nasıl çalışır ve hangi senaryolarda kullanılır?",
    "answer": "Bit düzeyinde operatörler, bit düzeyinde manipülasyon yapmak için kullanılır. Örneğin, '&' (AND), '|' (OR), '^' (XOR), '~' (NOT), '<<' (sola kaydırma), '>>' (sağa kaydırma) operatörleri. Bu operatörleri kullanarak, belli bitleri sıfırlayabilir ya da birleştirebiliriz. Örneğin, bir baytın belirli bitlerini sıfırlamak için AND operatörünü kullanabiliriz. Eğer bir değişkenin en düşük 3 bitini sıfırlamak istiyorsak: `değişken &= ~0x07;` ifadesini kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987363"
  },
  {
    "question": "C dilinde koşullu operatör (ternary operator) nasıl kullanılır ve ne zaman tercih edilmelidir?",
    "answer": "Koşullu operatör, `? :` şeklinde yazılır ve bir koşulun sağlanıp sağlanmadığına göre iki farklı değer döndürür. Örneğin: `int max = (a > b) ? a : b;` ifadesi `a` b'den büyükse `max` değişkenine `a` değerini atar, aksi takdirde `b` değerini atar. Genellikle tek satırlık koşullu atamalar için tercih edilir, böylece kod daha okunaklı hale gelir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987411"
  },
  {
    "question": "C dilinde artı ve artı (++) operatörünün önceliği ve etkileri nelerdir?",
    "answer": "Artı ve artı (++) operatörü, bir değişkenin değerini 1 artırmak için kullanılır. Ön ek (prefix) ve son ek (postfix) şeklinde iki farklı kullanımı vardır. Ön ek kullanıldığında, değişkenin değeri artırılır ve sonra kullanılır: `int x = 5; int y = ++x;` burada `y` 6 olur. Son ek kullanıldığında ise değişkenin mevcut değeri kullanılır ve sonra artırılır: `int y = x++;` burada `y` 5 olur. Bu nedenle, hangi türü kullanacağınız, değerin ne zaman kullanılacağına bağlıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987446"
  },
  {
    "question": "C dilinde atama operatörleri (+=, -=, *=, /=) nasıl çalışır?",
    "answer": "Atama operatörleri, bir değişkenin mevcut değerine belirli bir işlemi uygular. Örneğin, `x += 5;` ifadesi, `x = x + 5;` ile aynıdır. Bu operatörler, kodu daha kısa ve okunabilir hale getirir. Örneğin, bir döngü içinde bir sayının toplamını bulmak için `toplam += sayı;` şeklinde kullanılabilir. Bu, toplamı güncelleyerek hesaplama işlemlerini kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987482"
  },
  {
    "question": "C dilinde mantıksal operatörler (&&, ||, !) nasıl çalışır ve hangi durumlarda kullanılır?",
    "answer": "Mantıksal operatörler, boolean değerleri üzerinde çalışır. `&&` (ve) operatörü, iki koşulun ikisinin de doğru olması durumunda true döner. `||` (veya) operatörü, en az bir koşul true olduğunda true döner. `!` (değil) operatörü ise bir koşulun tersini alır. Örneğin, bir kullanıcının giriş bilgilerini kontrol ederken bu operatörleri kullanarak çeşitli durumları kontrol edebiliriz: `if (kullanici_girdi && sifre_dogru) { /* giriş başarılı */ }`.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987528"
  },
  {
    "question": "C dilinde kıyaslama operatörleri (==, !=, <, >, <=, >=) nasıl kullanılır ve dikkat edilmesi gereken noktalar nelerdir?",
    "answer": "Kıyaslama operatörleri, iki değeri karşılaştırmak için kullanılır. `==` eşittir, `!=` eşit değildir, `<` küçüktür, `>` büyüktür, `<=` küçük veya eşit, `>=` büyük veya eşittir. Bu operatörler, koşullu ifadelerde sıklıkla kullanılır. Ancak, değerin tipine dikkat etmek önemlidir; örneğin, `0` ve `NULL` birbirine eşit değildir. Ayrıca, `=` operatörü ile `==` operatörü sıklıkla karıştırılabilir, bu nedenle dikkatli olunmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987565"
  },
  {
    "question": "C dilinde bitwise NOT (~) operatörü ile mantıksal NOT (!) operatörü arasındaki fark nedir?",
    "answer": "Bitwise NOT (~) operatörü, bir sayının tüm bitlerini tersine çevirir. Örneğin, `~5` ifadesi, 5'in bitlerini tersine çevirir. Mantıksal NOT (!) operatörü ise boolean değerlerin tersini alır. Örneğin, `!true` ifadesi `false` döner. Kullanım yerleri farklıdır; bitwise NOT, sayılarla, mantıksal NOT ise boolean ifadelerle çalışır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987596"
  },
  {
    "question": "C dilinde aritmetik operatörlerin öncelik sırası nedir ve bu sıralama nasıl etkiler?",
    "answer": "Aritmetik operatörlerin öncelik sırası, işlem sırasını belirler. Öncelik sırası genellikle şu şekildedir: 1) çarpma ve bölme, 2) toplama ve çıkarma. Bu, örneğin `3 + 5 * 2` ifadesinin önce `5 * 2` işleminin gerçekleştirilip sonra 3 ile toplanacağı anlamına gelir. Sonuç olarak, ifade `3 + 10` olur ve `13` döner. Eğer önceliği değiştirmek istiyorsak, parantez kullanabiliriz: `3 + (5 * 2)`.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987638"
  },
  {
    "question": "C dilinde döngü kontrol operatörleri (break, continue) nasıl çalışır?",
    "answer": "Döngü kontrol operatörleri, döngü akışını kontrol etmek için kullanılır. `break` ifadesi, döngüyü hemen sonlandırır. Örneğin, belirli bir koşula ulaşıldığında döngüyü kırmak için kullanabilirsiniz. `continue` ifadesi ise döngünün mevcut iterasyonunu atlar ve bir sonraki iterasyona geçer. Örneğin, `for` döngüsü içinde belirli bir değeri atlamak için `continue;` kullanabilirsiniz. Bu operatörler, döngülerde daha esnek kontrol sağlar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987678"
  },
  {
    "question": "C dilinde NULL ve 0 arasındaki fark nedir ve hangi durumlarda kullanmalıyız?",
    "answer": "NULL, bir işaretçinin hiçbir yeri işaret etmediğini belirtir. Genellikle işaretçi değişkenlerine atanır. Örneğin, `int *ptr = NULL;` ifadesi, ptr'nin hiçbir adresi işaret etmediği anlamına gelir. 0 ise bir tam sayı değeridir ve sayısal işlemlerde kullanılabilir. İşaretçileri kontrol ederken NULL kullanmak daha açıklayıcıdır. Örneğin, `if (ptr != NULL)` ifadesi, ptr işaretçisinin geçerli bir adres işaret edip etmediğini kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:09.987706"
  },
  {
    "question": "C dilinde iki sayının toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki gibi bir fonksiyon tanımlayabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int x = 5;\n    int y = 10;\n    int sonuc = toplama(x, y);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu fonksiyon, iki tam sayıyı alır ve bunların toplamını döner.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.908949"
  },
  {
    "question": "C dilinde bir sayının karesini hesaplayan bir program yazın.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint kare(int n) {\n    return n * n;\n}\n\nint main() {\n    int sayi = 4;\n    int sonuc = kare(sayi);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu örnekte, verilen sayının karesini hesaplayan bir fonksiyon tanımladık.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909003"
  },
  {
    "question": "İki sayının maksimumunu bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki gibi bir maksimum bulma fonksiyonu tanımlayabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int x = 7;\n    int y = 12;\n    int sonuc = max(x, y);\n    printf(\"Maksimum: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu fonksiyonda, iki sayıdan hangisinin daha büyük olduğunu belirlemek için şart operatörünü kullandık.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909040"
  },
  {
    "question": "C dilinde bir sayının faktöriyelini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki gibi bir faktöriyel hesaplama fonksiyonu oluşturabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int sayi = 5;\n    int sonuc = faktoriyel(sayi);\n    printf(\"Faktöriyel: %d\\n\", sonuc);\n    return 0;\n}\n```\nBurada, rekürsif bir şekilde faktöriyel hesaplıyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909079"
  },
  {
    "question": "Bir sayının pozitif mi negatif mi olduğunu kontrol eden bir program yazın.",
    "answer": "Aşağıdaki gibi bir kontrol fonksiyonu yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid kontrol(int n) {\n    if (n > 0)\n        printf(\"Pozitif\\n\");\n    else if (n < 0)\n        printf(\"Negatif\\n\");\n    else\n        printf(\"Sıfır\\n\");\n}\n\nint main() {\n    int sayi = -3;\n    kontrol(sayi);\n    return 0;\n}\n```\nBu program, bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909122"
  },
  {
    "question": "C dilinde bir sayının çift veya tek olduğunu kontrol eden bir program yazın.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid cift_veya_tek(int n) {\n    if (n % 2 == 0)\n        printf(\"Çift\\n\");\n    else\n        printf(\"Tek\\n\");\n}\n\nint main() {\n    int sayi = 8;\n    cift_veya_tek(sayi);\n    return 0;\n}\n```\nBu program, bir sayının çift veya tek olduğunu kontrol etmek için modül operatörünü kullanır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909169"
  },
  {
    "question": "C dilinde bir sayının mutlak değerini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte mutlak değeri hesaplayan bir fonksiyon bulabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint mutlak_deger(int n) {\n    return (n < 0) ? -n : n;\n}\n\nint main() {\n    int sayi = -10;\n    int sonuc = mutlak_deger(sayi);\n    printf(\"Mutlak Değer: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu fonksiyonda, koşul operatörünü kullanarak sayının mutlak değerini hesaplıyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909211"
  },
  {
    "question": "C dilinde iki sayının toplamını ve farkını bulan bir program yazın.",
    "answer": "Aşağıdaki gibi bir fonksiyon tanımlayabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid toplama_ve_fark(int a, int b, int *toplam, int *fark) {\n    *toplam = a + b;\n    *fark = a - b;\n}\n\nint main() {\n    int x = 10, y = 5;\n    int toplam, fark;\n    toplama_ve_fark(x, y, &toplam, &fark);\n    printf(\"Toplam: %d, Fark: %d\\n\", toplam, fark);\n    return 0;\n}\n```\nBu program, iki sayının toplamını ve farkını hesaplar ve sonuçları işaretçi (pointer) kullanarak döner.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909248"
  },
  {
    "question": "C dilinde bir sayıyı 2 ile çarpan bir fonksiyon yazın.",
    "answer": "Aşağıdaki gibi bir çarpma fonksiyonu tanımlayabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint carpma(int n) {\n    return n * 2;\n}\n\nint main() {\n    int sayi = 6;\n    int sonuc = carpma(sayi);\n    printf(\"Çarpan Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu fonksiyonda, verilen bir sayıyı iki ile çarpan basit bir fonksiyon yazılmıştır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909282"
  },
  {
    "question": "Bir tam sayının pozitif olup olmadığını kontrol eden bir program yazın.",
    "answer": "Aşağıdaki gibi bir kontrol fonksiyonu yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid pozitif_mi(int n) {\n    if (n > 0)\n        printf(\"Pozitif\\n\");\n    else\n        printf(\"Pozitif Değil\\n\");\n}\n\nint main() {\n    int sayi = 3;\n    pozitif_mi(sayi);\n    return 0;\n}\n```\nBu program, bir sayının pozitif olup olmadığını kontrol eder ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:14:37.909325"
  },
  {
    "question": "İki sayının toplamını ve farkını döndüren bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon iki sayıyı alır ve toplamını ve farkını döndürür. Burada '+' ve '-' operatörleri kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nvoid toplamVeFark(int a, int b, int *toplam, int *fark) {\n    *toplam = a + b;  // '+' operatörü\n    *fark = a - b;   // '-' operatörü\n}\n\nint main() {\n    int a = 10, b = 5, toplam, fark;\n    toplamVeFark(a, b, &toplam, &fark);\n    printf(\"Toplam: %d, Fark: %d\\n\", toplam, fark);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053795"
  },
  {
    "question": "Bir sayının pozitif, negatif veya sıfır olduğunu belirleyen bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon, bir sayının pozitif, negatif veya sıfır olduğunu kontrol eder. '>' ve '<' operatörleri kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nvoid pozNegZir(int sayi) {\n    if (sayi > 0) {\n        printf(\"Pozitif\\n\"); // '>' operatörü\n    } else if (sayi < 0) {\n        printf(\"Negatif\\n\"); // '<' operatörü\n    } else {\n        printf(\"Sıfır\\n\");\n    }\n}\n\nint main() {\n    pozNegZir(10);\n    pozNegZir(-5);\n    pozNegZir(0);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053843"
  },
  {
    "question": "Bir sayının çift mi tek mi olduğunu kontrol eden bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon, bir sayının çift veya tek olduğunu kontrol eder. Burada '%' (mod) operatörü kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nvoid ciftMiTekMi(int sayi) {\n    if (sayi % 2 == 0) { // '%' ve '==' operatörleri\n        printf(\"Çift\\n\");\n    } else {\n        printf(\"Tek\\n\");\n    }\n}\n\nint main() {\n    ciftMiTekMi(10);\n    ciftMiTekMi(7);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053875"
  },
  {
    "question": "Üç sayının en büyüğünü bulan bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon üç sayıyı alır ve en büyük olanı bulur. Burada '>' operatörü kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int a, int b, int c) {\n    int max = a; // Başlangıçta en büyük a kabul ediliyor\n    if (b > max) { // '>' operatörü\n        max = b;\n    }\n    if (c > max) {\n        max = c;\n    }\n    return max;\n}\n\nint main() {\n    printf(\"En büyük: %d\\n\", enBuyuk(10, 20, 15));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053903"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplayan bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyonda, bir sayının faktöriyelini hesaplamak için '*' ve '--' operatörleri kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    int sonuc = 1;\n    for (int i = n; i > 0; i--) { // '--' operatörü\n        sonuc *= i; // '*' operatörü\n    }\n    return sonuc;\n}\n\nint main() {\n    printf(\"5! = %d\\n\", faktoriyel(5));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053930"
  },
  {
    "question": "Bir dizideki en küçük sayıyı bulan bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon, bir dizi içerisindeki en küçük sayıyı bulur. Burada '<' operatörü kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nint enKucuk(int dizi[], int boyut) {\n    int min = dizi[0]; // İlk eleman en küçük başlangıçta\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < min) { // '<' operatörü\n            min = dizi[i];\n        }\n    }\n    return min;\n}\n\nint main() {\n    int dizi[] = {3, 5, 1, 4, 2};\n    printf(\"En küçük: %d\\n\", enKucuk(dizi, 5));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053956"
  },
  {
    "question": "Bir sayının asal olup olmadığını kontrol eden bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon, bir sayının asal olup olmadığını kontrol eder. '%' ve '==' operatörleri kullanılmıştır.\n\n```c\n#include <stdio.h>\n\nint asalMi(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0; // '%' ve '==' operatörleri\n    }\n    return 1;\n}\n\nint main() {\n    printf(\"7 asal mı? %d\\n\", asalMi(7));\n    printf(\"8 asal mı? %d\\n\", asalMi(8));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.053989"
  },
  {
    "question": "Bir sayının karesini hesaplayan bir makro tanımlayın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki makro, bir sayının karesini hesaplar. Burada '*' operatörü kullanılmıştır.\n\n```c\n#include <stdio.h>\n\n#define KARE(x) ((x) * (x)) // '*' operatörü\n\nint main() {\n    printf(\"Kare: %d\\n\", KARE(5));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.054018"
  },
  {
    "question": "Bir sayının tersini hesaplayan bir fonksiyon yazın. Hangi operatörleri kullandınız?",
    "answer": "Aşağıdaki fonksiyon, bir sayının tersini (1/sayı) hesaplar. Burada '/' operatörü kullanılmıştır.\n\n```c\n#include <stdio.h>\n\ndouble tersiniHesapla(int n) {\n    if (n != 0) {\n        return 1.0 / n; // '/' operatörü\n    } else {\n        printf(\"Tanımsız\\n\");\n        return 0;\n    }\n}\n\nint main() {\n    printf(\"Tersi: %f\\n\", tersiniHesapla(4));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:11.054043"
  },
  {
    "question": "C dilinde bir değişkenin değerinin bit düzeyinde tersini almak için hangi operatörleri kullanabilirim?",
    "answer": "Bit düzeyinde ters almak için '~' operatörünü kullanabilirsiniz. Örneğin, `int a = 5; int b = ~a;` işlemi, 'a' değişkeninin değerinin bit düzeyinde tersini alır ve 'b' değişkenine atar. 'a' değişkeninin değeri 5 olduğu için, bit düzeyinde tersini aldığınızda 'b' değişkeninin değeri -6 olacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.033921"
  },
  {
    "question": "C dilinde bir değişkenin değeri üzerinde artış ve azalış yapmak için hangi operatörleri kullanmalıyım?",
    "answer": "C dilinde artış için '++' operatörünü, azalış için '--' operatörünü kullanabilirsiniz. Örneğin, `int a = 10; a++;` kodu, 'a' değişkeninin değerini 11 yapar. Benzer şekilde, `int b = 10; b--;` kodu 'b' değişkeninin değerini 9 yapar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.033969"
  },
  {
    "question": "C dilinde mantıksal operatörlerin (AND, OR, NOT) nasıl çalıştığını ve örneklerini açıklayın.",
    "answer": "Mantıksal operatörler, boolean değerler üzerinde işlem yapar. '&&' (AND) operatörü, her iki operand da true ise true döner. '||' (OR) operatörü, en az bir operand true ise true döner. '!' (NOT) operatörü ise operandın değerini tersine çevirir. Örnek: `int a = 1, b = 0; if (a && b) { /* çalışmaz */ } if (a || b) { /* çalışır */ } if (!b) { /* çalışır */ }",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034001"
  },
  {
    "question": "C dilinde koşul ifadelerinde ternary operatörünün nasıl kullanılacağını gösterin.",
    "answer": "Ternary operatör, kısa bir if-else ifadesi yazmanızı sağlar. Genel formu `koşul ? doğru : yanlış;` şeklindedir. Örneğin, `int a = 5; int b = (a > 3) ? 10 : 20;` ifadesinde, 'a' 3'ten büyük olduğu için 'b' değişkeninin değeri 10 olacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034034"
  },
  {
    "question": "C dilinde bir dizi elemanlarının toplamını hesaplamak için döngü ve operatörler kullanarak bir örnek yazın.",
    "answer": "Dizi elemanlarının toplamını hesaplamak için bir döngü ve '+' operatörünü kullanabilirsiniz. Örnek: `int dizi[] = {1, 2, 3, 4, 5}; int toplam = 0; for (int i = 0; i < 5; i++) { toplam += dizi[i]; }` Bu kod, 'toplam' değişkeninde dizinin elemanlarının toplamını saklar, yani 15 olacaktır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034066"
  },
  {
    "question": "Bit kaydırma operatörlerinin ne işe yaradığını açıklayın ve bir örnek verin.",
    "answer": "Bit kaydırma operatörleri, bir sayının bitlerini sağa veya sola kaydırmak için kullanılır. '<<' operatörü sola kaydırırken, '>>' operatörü sağa kaydırır. Örnek: `int a = 5; int b = a << 1;` 'b' değişkeninin değeri 10 olacaktır çünkü 5'in ikili gösterimini bir sola kaydırdığınızda 10 elde edersiniz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034092"
  },
  {
    "question": "C dilinde birden fazla değişkenin değerini aynı anda atamak için hangi operatörü kullanıyorsunuz?",
    "answer": "Birden fazla değişkeni aynı anda atamak için atama operatörü '=' kullanabilirsiniz. Örneğin, `int a, b, c; a = b = c = 5;` ifadesi, hem 'a', hem 'b', hem de 'c' değişkeninin değerini 5 olarak ayarlar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034120"
  },
  {
    "question": "C dilinde artı ve eksi operatörleri ile birlikte kullanılan öncelik sırasını açıklayın.",
    "answer": "C dilinde, '+' ve '-' operatörleri aynı önceliğe sahiptir ve soldan sağa doğru değerlendirilir. Örneğin, `int x = 5 - 3 + 2;` ifadesi, önce '5 - 3' işlemi yapılır ve 2 elde edilir, ardından '+ 2' eklenir ve sonucun 4 olduğu bulunur.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034146"
  },
  {
    "question": "C dilinde karşılaştırma operatörlerinin mantığını ve örneklerini açıklayın.",
    "answer": "Karşılaştırma operatörleri, iki değeri karşılaştırmak için kullanılır. '==' eşitlik için, '!=' eşitsizlik için, '<' küçük için, '>' büyük için, '<=' küçük veya eşit için, '>=' büyük veya eşit için kullanılır. Örneğin: `if (a == b) { /* eşit */ } if (a != b) { /* eşit değil */ }`",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034168"
  },
  {
    "question": "C dilinde bir değişkenin değerinin, başka bir değişkenin değerine eşit olup olmadığını kontrol etmek için hangi operatörü kullanmalıyım?",
    "answer": "Bir değişkenin değerinin başka bir değere eşit olup olmadığını kontrol etmek için '==' karşılaştırma operatörünü kullanabilirsiniz. Örnek kod: `int a = 5; int b = 5; if (a == b) { /* kod bloğu çalışır */ }` Bu durumda 'a' ve 'b' eşit olduğu için koşul sağlanır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:31.034204"
  },
  {
    "question": "Bir programda iki sayının toplamını hesaplamak için kullanılan kodda, + operatörü yerine başka operatör kullanılabilir mi? Önerileriniz nelerdir?",
    "answer": "Evet, + operatörünü kullanmak yerine fonksiyonlar aracılığıyla toplama işlemi gerçekleştirebilirsiniz. Örneğin, iki sayıyı toplayan bir fonksiyon yazabilirsiniz: \n\n```c\nint topla(int a, int b) {\n    return a + b;\n}\n```\nBu, kodun daha okunabilir olmasını ve gerektiğinde topla fonksiyonunu farklı yerlerde kullanabilmenizi sağlar.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981255"
  },
  {
    "question": "Boolean değişkenlerin mantıksal AND (&&) ve OR (||) operatörlerini kullanarak bir koşul kontrolü gerçekleştiren bir kod parçasında, bu operatörler yerine bit düzeyinde AND (&) ve OR (|) kullanmak ne gibi sorunlar yaratır?",
    "answer": "Mantıksal operatörler, boolean değerler üzerinde işlem yaparken sonuçları doğru bir şekilde verir. Bit düzeyindeki operatörler ise, tam sayılar üzerinde çalışır ve boolean değerlerin bit düzeyinde karşılaştırılmasını yapar. Bu nedenle, koşul ifadelerinde mantıksal operatörler tercih edilmelidir. Örneğin:\n\n```c\nif (x > 0 && y > 0) {\n    // Do something\n}\n```\nYerine bit düzeyinde AND kullanmak, beklenmedik sonuçlar doğurabilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981336"
  },
  {
    "question": "Bir döngü içerisinde sayıları toplamak için kullanılan bir kodda increment işlemi için 'i++' yerine 'i += 1' kullanmanın avantajları ve dezavantajları nelerdir?",
    "answer": "'i++' operatörü, 'i += 1' ile aynı işlevi görse de, 'i++' genellikle daha kısa ve daha okunabilir bir yazım sunar. Ancak, 'i += 1' ifadesi, daha karmaşık artış miktarları için (örneğin, i += 2) daha kolay değiştirilebilir. Genel olarak, sayının artış miktarını değiştirmeyecekseniz 'i++' kullanmak daha yaygındır. Örneğin:\n\n```c\nfor (int i = 0; i < 10; i++) {\n    toplam += i;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981400"
  },
  {
    "question": "C dilinde, bir değişkeni artırmak için 'x = x + 1' yerine 'x++' kullanmanın performansa etkisi var mı?",
    "answer": "'x++' ifadesi, derleyici tarafından genellikle daha optimize bir şekilde işlenir. Ancak, modern derleyiciler 'x = x + 1' ifadesini de optimize edebilir. Yine de, 'x++' kullanmak, kodun daha temiz ve okunabilir olmasını sağlar. Örneğin:\n\n```c\nint x = 0;\nfor (int i = 0; i < 10; i++) {\n    x++;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981440"
  },
  {
    "question": "Ternary operatör (?:) ile if-else yapısını karşılaştırın. Hangisi hangi senaryolarda daha uygundur?",
    "answer": "Ternary operatör, basit koşul ifadelerinde kodu daha kısa ve okunabilir hale getirebilir. Ancak, karmaşık koşullarda if-else yapısı daha anlaşılırdır. Örneğin:\n\n```c\n// Ternary operatör ile\nint max = (a > b) ? a : b;\n\n// If-else yapısı ile\nint max;\nif (a > b) {\n    max = a;\n} else {\n    max = b;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981472"
  },
  {
    "question": "Hangi durumlarda bit düzeyinde operatörler (&, |, ^) kullanmak mantıklıdır? Bir örnek verin.",
    "answer": "Bit düzeyinde operatörler, genellikle bit manipülasyonu gereken durumlarda kullanılır. Örneğin, bir bitin durumunu değiştirmek için:\n\n```c\nint x = 5; // 0101\nx |= 2; // 0010\n// x artık 7 (0111)\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981503"
  },
  {
    "question": "Kodunuzda döngü koşulunu kontrol etmek için 'while' yerine 'for' kullanmanın avantajı nedir?",
    "answer": "'for' döngüsü, genellikle sayma veya belirli bir koşula dayalı döngüler için daha uygundur ve daha düzenli bir yapı sunar. 'while' döngüsü ise genellikle koşula dayalı döngüler için tercih edilir. Örneğin:\n\n```c\n// For döngüsü\nfor (int i = 0; i < 10; i++) {\n    printf(\"%d\", i);\n}\n\n// While döngüsü\nint i = 0;\nwhile (i < 10) {\n    printf(\"%d\", i);\n    i++;\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981564"
  },
  {
    "question": "Bir değişken üzerinde matematiksel işlemler yaparken, işlem önceliği hakkında bilgi verin. Hangi operatörler önceliklidir?",
    "answer": "Matematiksel operatörlerin önceliği, işlem sırasını belirler. Örneğin, çarpma (*) ve bölme (/) toplama (+) ve çıkarma (-) işlemlerinden önce gelir. Örnek olarak:\n\n```c\nint sonuc = 5 + 2 * 3; // 5 + (2 * 3) = 11\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981598"
  },
  {
    "question": "C dilinde postfix ve prefix operatörleri arasındaki fark nedir? Bir örnek ile açıklayın.",
    "answer": "Postfix (i++) ve prefix (++i) operatörleri, değişkenin değerini artırma işlemi yapar fakat farklı zamanda etkisini gösterir. Prefix operatörü, değişkenin değeri artırıldıktan sonra kullanılırken, postfix operatörü önce mevcut değeri kullanır, sonra artırma işlemi yapılır. Örnek:\n\n```c\nint a = 5;\nint b = a++; // b = 5, a = 6\nint c = ++a; // c = 7, a = 7\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981627"
  },
  {
    "question": "C dilinde belirli bir sayının tek mi çift mi olduğunu kontrol etmek için hangi operatörleri kullanmalıyız? Bir örnek verin.",
    "answer": "Bir sayının tek mi çift mi olduğunu kontrol etmek için modülüs (%) operatörünü kullanabilirsiniz. Eğer sayı 2 ile bölündüğünde kalan 0 ise çift, 1 ise tektir. Örnek:\n\n```c\nint sayi = 7;\nif (sayi % 2 == 0) {\n    printf(\"Çift\");\n} else {\n    printf(\"Tek\");\n}\n```",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:15:49.981709"
  },
  {
    "question": "C dilinde iki tam sayı değişkeninin maksimumunu bulmak için hangi operatörleri kullanabiliriz? Optimize edilmiş bir çözüm önerin.",
    "answer": "İki tam sayı değişkeninin maksimumunu bulmak için ternary operatörünü kullanabiliriz. Ancak, daha okunabilir olması açısından, 'if' yapısı ile de yazabiliriz. İşte her iki yöntem: \n\nTernary operatör kullanımı:\n```c\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n```\n\n'if' yapısı:\n```c\nint max(int a, int b) {\n    if (a > b) return a;\n    else return b;\n}\n```\n\nTernary operatör daha kısa kod yazmamıza olanak tanırken, 'if' yapısı daha okunabilir olabilir. Genellikle, daha karmaşık koşullarda 'if' yapılarını tercih etmek daha iyi olabilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737147"
  },
  {
    "question": "Bir dizi içindeki en büyük elemanı bulmak için döngü ve karşılaştırma operatörlerini nasıl kullanırsın? Kodunu optimize et.",
    "answer": "Dizi içindeki en büyük elemanı bulmak için döngü ile kontrol yapabiliriz. İşte örnek bir kod: \n\n```c\nint find_max(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n```\n\nBu kodda, her bir elemanı kontrol ederek maksimum değeri güncelliyoruz. Ancak başlangıç değerini dizinin ilk elemanı olarak belirlemek, başlangıçta dizinin her elemanını kontrol etme ihtiyacını azaltıyor.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737202"
  },
  {
    "question": "Bitwise operatörler kullanarak iki sayının toplamını nasıl hesaplayabilirsin? Bir öneri ile göster.",
    "answer": "İki sayının toplamını bitwise operatörler ile hesaplamak için 'AND', 'XOR' ve 'LEFT SHIFT' operatörlerini kullanabiliriz. İşte bir örnek: \n\n```c\nint add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;   // Taşıma işlemlerini buluyoruz.\n        a = a ^ b;           // Gerçek toplamı buluyoruz.\n        b = carry << 1;      // Taşımayı bir sola kaydırıyoruz.\n    }\n    return a;\n}\n```\n\nBu yöntem, her iki sayının bitlerini kullanarak toplamı bulur ve daha verimli bir şekilde çalışır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737246"
  },
  {
    "question": "C dilinde 'sizeof' operatörü nasıl kullanılır? Bellek optimizasyonu için önerilerde bulun.",
    "answer": "'sizeof' operatörü, bir değişkenin veya veri türünün bellekte kapladığı alanı bayt cinsinden döndürür. Bu operatörü kullanarak bellek optimizasyonu yapabiliriz. Örneğin, bir dizi tanımlarken: \n\n```c\nint arr[10];\nprintf(\"Dizi eleman sayısı: %zu\\n\", sizeof(arr) / sizeof(arr[0]));\n```\n\nBu, dizinin eleman sayısını hesaplar. Bellek optimizasyonu için, mümkün olduğunca küçük veri türlerini (örneğin, 'int' yerine 'short') kullanmak, kullanılan bellek miktarını azaltır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737277"
  },
  {
    "question": "C dilinde mantıksal operatörlerin kullanımında dikkat edilmesi gereken noktalar nelerdir? Örnekle açıkla.",
    "answer": "Mantıksal operatörler (&&, ||) koşul ifadelerinde kullanılır. Bu operatörlerin kısa devre değerlendirmesi vardır. Örneğin: \n\n```c\nif (a != 0 && (b / a) > 2) {\n    // b, a'dan büyükse bu blok çalışır.\n}\n```\n\nEğer 'a' sıfırsa, 'b / a' ifadesi değerlendirilmeyecek ve program hatası vermeyecek. Bu, performans açısından önemli bir optimizasyondur, çünkü gereksiz işlemleri önler.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737306"
  },
  {
    "question": "C dilinde dizideki elemanları karşılaştırarak bazı koşullara göre sıralamak için hangi operatörleri kullanmalıyız? Örnek bir kod öner.",
    "answer": "Dizi elemanlarını karşılaştırarak sıralamak için '>' ve '<' karşılaştırma operatörlerini kullanabiliriz. Bubble sort algoritmasıyla bunu gerçekleştirebiliriz. Örnek: \n\n```c\nvoid bubble_sort(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\nBu yöntem, her iki elemanı karşılaştırarak sıralama yapar. Ancak, daha verimli sıralama algoritmaları (örneğin, quicksort) kullanılabilir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737344"
  },
  {
    "question": "C dilinde bir tam sayının negatif olup olmadığını kontrol etmek için hangi operatörleri kullanmalıyız? Optimize bir çözümle göster.",
    "answer": "Bir tam sayının negatif olup olmadığını kontrol etmek için '>' ve '<' operatörlerini kullanabiliriz. Ancak, 'if' yapısı içinde sadece '<' kullanmak yeterlidir. Örnek: \n\n```c\nbool is_negative(int num) {\n    return num < 0;\n}\n```\n\nBu şekilde, sadece bir karşılaştırma yaparak negatif olup olmadığını kontrol etmiş oluyoruz. Performansı artırmak için gereksiz 'if' yapılarından kaçınmak önemlidir.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737381"
  },
  {
    "question": "C dilinde bir karakter dizisinin uzunluğunu hesaplamak için hangi operatörleri kullanabiliriz? örnek bir kod ile göster.",
    "answer": "Karakter dizisinin uzunluğunu hesaplamak için 'strlen' fonksiyonu kullanabiliriz. Ancak, kendi 'for' döngümüzle de bunu yapabiliriz. İşte örnek: \n\n```c\nint string_length(char str[]) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n```\n\nBu kod, dizinin sonuna kadar giderek karakter sayısını bulur. Bu şekilde, 'strlen' fonksiyonuna alternatif bir çözüm sunmuş oluyoruz.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737413"
  },
  {
    "question": "C dilinde bir sayının tek mi çift mi olduğunu kontrol etmek için hangi operatörleri kullanmalıyız? Kısa bir örnekle göster.",
    "answer": "Bir sayının tek mi çift mi olduğunu kontrol etmek için '&' bitwise operatörünü kullanabiliriz. Ancak basit bir çözüm olarak '%' mod operatörünü de kullanabiliriz. Örnek: \n\n```c\nbool is_even(int num) {\n    return (num % 2) == 0;\n}\n```\n\nBu kod, sayının 2 ile bölümünden kalanının 0 olup olmadığını kontrol eder. Bitwise operatör ile kontrol etmek için: \n```c\nbool is_even(int num) {\n    return (num & 1) == 0;\n}\n```\n\nİkinci yöntem genellikle daha hızlıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737448"
  },
  {
    "question": "C dilinde üç sayının ortalamasını almak için hangi operatörleri kullanmalıyız? Optimize bir çözüm ile göster.",
    "answer": "Üç sayının ortalamasını almak için toplama ve bölme operatörlerini kullanabiliriz. İşte örnek bir kod: \n\n```c\nfloat average(int a, int b, int c) {\n    return (a + b + c) / 3.0;\n}\n```\n\nBurada, toplamı bulup 3'e bölerek ortalamayı hesaplıyoruz. '3.0' kullanarak sonucu float türünde döndürmek daha doğru olur. Kodun optimizasyonu açısından, yalnızca gerekli işlemler yapılmalı ve gereksiz dönüşümlerden kaçınılmalıdır.",
    "category": "basic_syntax",
    "topic": "operators",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Operatörler",
    "timestamp": "2025-06-01T14:16:24.737480"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir C programının eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Pozitif sayı.\");\n    } else if (sayi < 0) {\n        printf(\"Negatif sayı.\");\n    } else {\n        printf(\"Sıfır.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir sayı alır ve sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.404955"
  },
  {
    "question": "Kullanıcının girdiği bir not değerine göre 'Geçti' veya 'Kaldı' mesajı veren bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 50) {\n        printf(\"Geçti\");\n    } else {\n        printf(\"Kaldı\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir not alır ve notun 50 veya üstünde olup olmadığını kontrol ederek kullanıcıya 'Geçti' veya 'Kaldı' mesajı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405008"
  },
  {
    "question": "Kullanıcının girdiği bir yılın artık yıl olup olmadığını kontrol eden bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yil;\n    printf(\"Bir yıl girin: \");\n    scanf(\"%d\", &yil);\n\n    if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n        printf(\"Artık yıl.\");\n    } else {\n        printf(\"Artık yıl değil.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, belirli bir yılın artık yıl olup olmadığını kontrol eder. Artık yıl olma koşullarını yerine getirip getirmediğine bakar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405040"
  },
  {
    "question": "Kullanıcının girdiği bir sayının çift mi tek mi olduğunu kontrol eden bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 2 == 0) {\n        printf(\"Çift sayı.\");\n    } else {\n        printf(\"Tek sayı.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği sayının çift mi yoksa tek mi olduğunu kontrol eder ve uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405071"
  },
  {
    "question": "Kullanıcının girdiği bir sayının 10'dan büyük mü, 10'dan küçük mü yoksa 10'a eşit mi olduğunu kontrol eden bir program eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 10) {\n        printf(\"Sayı 10'dan büyük.\");\n    } else if (sayi < 10) {\n        printf(\"Sayı 10'dan küçük.\");\n    } else {\n        printf(\"Sayı 10'a eşit.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği sayının 10 ile olan ilişkisini kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405114"
  },
  {
    "question": "Kullanıcıdan alınan bir karakterin büyük harf mi küçük harf mi yoksa rakam mı olduğunu kontrol eden bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char karakter;\n    printf(\"Bir karakter girin: \");\n    scanf(\" %c\", &karakter);\n\n    if (isupper(karakter)) {\n        printf(\"Büyük harf.\");\n    } else if (islower(karakter)) {\n        printf(\"Küçük harf.\");\n    } else if (isdigit(karakter)) {\n        printf(\"Rakam.\");\n    } else {\n        printf(\"Geçersiz karakter.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir karakter alır ve bu karakterin büyük harf, küçük harf veya rakam olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405151"
  },
  {
    "question": "Kullanıcının girdiği iki sayıyı karşılaştırarak daha büyük olanı ekrana yazan bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &sayi1, &sayi2);\n\n    if (sayi1 > sayi2) {\n        printf(\"Büyük sayı: %d\", sayi1);\n    } else if (sayi2 > sayi1) {\n        printf(\"Büyük sayı: %d\", sayi2);\n    } else {\n        printf(\"Her iki sayı eşit.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, iki sayıyı karşılaştırır ve hangisinin daha büyük olduğunu belirleyip ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405182"
  },
  {
    "question": "Kullanıcının girdiği bir ay numarasına göre o ayın ismini yazan bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int ay;\n    printf(\"Bir ay numarası girin (1-12): \");\n    scanf(\"%d\", &ay);\n\n    if (ay == 1) {\n        printf(\"Ocak\");\n    } else if (ay == 2) {\n        printf(\"Şubat\");\n    } else if (ay == 3) {\n        printf(\"Mart\");\n    } else if (ay == 4) {\n        printf(\"Nisan\");\n    } else if (ay == 5) {\n        printf(\"Mayıs\");\n    } else if (ay == 6) {\n        printf(\"Haziran\");\n    } else if (ay == 7) {\n        printf(\"Temmuz\");\n    } else if (ay == 8) {\n        printf(\"Ağustos\");\n    } else if (ay == 9) {\n        printf(\"Eylül\");\n    } else if (ay == 10) {\n        printf(\"Ekim\");\n    } else if (ay == 11) {\n        printf(\"Kasım\");\n    } else if (ay == 12) {\n        printf(\"Aralık\");\n    } else {\n        printf(\"Geçersiz ay numarası.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir ay numarası alır ve bu numaraya karşılık gelen ay ismini ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405210"
  },
  {
    "question": "Kullanıcının girdiği bir sayının 100'e bölünme durumunu kontrol eden bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 100 == 0) {\n        printf(\"Sayı 100'e tam bölünür.\");\n    } else {\n        printf(\"Sayı 100'e tam bölünmez.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan alınan sayının 100'e tam bölünüp bölünmediğini kontrol eder ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405240"
  },
  {
    "question": "Kullanıcının girdiği bir sayının 1 ile 100 arasında olup olmadığını kontrol eden bir programın eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi >= 1 && sayi <= 100) {\n        printf(\"Sayı 1 ile 100 arasında.\");\n    } else {\n        printf(\"Sayı 1 ile 100 arasında değil.\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir sayı alır ve sayının 1 ile 100 arasında olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:17:16.405272"
  },
  {
    "question": "Kullanıcının girdiği sayının pozitif, negatif veya sıfır olduğunu belirleyen bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Sayı pozitiftir.\");\n    } else if (sayi < 0) {\n        printf(\"Sayı negatiftir.\");\n    } else {\n        printf(\"Sayı sıfırdır.\");\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği sayıyı kontrol ederek, sayının pozitif, negatif veya sıfır olduğunu belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064068"
  },
  {
    "question": "Bir öğrencinin notuna göre harf notunu belirleyen bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin (0-100): \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf Notu: A\");\n    } else if (not >= 80) {\n        printf(\"Harf Notu: B\");\n    } else if (not >= 70) {\n        printf(\"Harf Notu: C\");\n    } else if (not >= 60) {\n        printf(\"Harf Notu: D\");\n    } else {\n        printf(\"Harf Notu: F\");\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği notu alarak uygun harf notunu belirler.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064130"
  },
  {
    "question": "Bir kullanıcıdan bir ay numarası alıp, o ayın kaç gün olduğunu belirleyen bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int ay;\n    printf(\"Bir ay numarası girin (1-12): \");\n    scanf(\"%d\", &ay);\n\n    switch (ay) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 8:\n        case 10:\n        case 12:\n            printf(\"31 gün\");\n            break;\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n            printf(\"30 gün\");\n            break;\n        case 2:\n            printf(\"28 veya 29 gün\");\n            break;\n        default:\n            printf(\"Geçersiz ay numarası\");\n    }\n\n    return 0;\n}\n// Bu program, girilen ay numarasına göre o ayın kaç gün olduğunu belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064187"
  },
  {
    "question": "Bir kullanıcıdan yaşını alarak, hangi yaş grubuna ait olduğunu belirten bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas < 0) {\n        printf(\"Geçersiz yaş\");\n    } else if (yas <= 12) {\n        printf(\"Çocuk\");\n    } else if (yas <= 19) {\n        printf(\"Genç\");\n    } else if (yas <= 65) {\n        printf(\"Yetişkin\");\n    } else {\n        printf(\"Yaşlı\");\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının yaşına göre hangi yaş grubuna ait olduğunu belirler.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064237"
  },
  {
    "question": "Bir kişinin cinsiyetini (K veya E) alarak, ona uygun selamı veren bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char cinsiyet;\n    printf(\"Cinsiyetinizi girin (K/E): \");\n    scanf(\" %c\", &cinsiyet);\n\n    if (cinsiyet == 'K' || cinsiyet == 'k') {\n        printf(\"Merhaba Hanım!\");\n    } else if (cinsiyet == 'E' || cinsiyet == 'e') {\n        printf(\"Merhaba Bey!\");\n    } else {\n        printf(\"Geçersiz cinsiyet\");\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının cinsiyetini alarak uygun selamı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064291"
  },
  {
    "question": "Kullanıcıdan alınan bir sayının asal olup olmadığını kontrol eden bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi, i, asal = 1;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi < 2) {\n        asal = 0;\n    }\n\n    for (i = 2; i <= sayi / 2; i++) {\n        if (sayi % i == 0) {\n            asal = 0;\n            break;\n        }\n    }\n\n    if (asal) {\n        printf(\"%d asal bir sayıdır.\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\", sayi);\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği sayının asal olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064338"
  },
  {
    "question": "Kullanıcının girdiği üç sayının en büyüğünü bulan bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    printf(\"Üç sayı girin: \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    int enBuyuk = a; // Varsayılan olarak a en büyük olsun\n\n    if (b > enBuyuk) {\n        enBuyuk = b;\n    }\n    if (c > enBuyuk) {\n        enBuyuk = c;\n    }\n\n    printf(\"En büyük sayı: %d\", enBuyuk);\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği üç sayıdan en büyüğünü bulur.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064387"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının, 5'e veya 7'ye tam bölünüp bölünmediğini kontrol eden bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 5 == 0 && sayi % 7 == 0) {\n        printf(\"Sayı hem 5'e hem de 7'ye tam bölünmektedir.\");\n    } else if (sayi % 5 == 0) {\n        printf(\"Sayı 5'e tam bölünmektedir.\");\n    } else if (sayi % 7 == 0) {\n        printf(\"Sayı 7'ye tam bölünmektedir.\");\n    } else {\n        printf(\"Sayı ne 5'e ne de 7'ye tam bölünmektedir.\");\n    }\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği sayının 5'e veya 7'ye tam bölünüp bölünmediğini kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064477"
  },
  {
    "question": "Bir kullanıcıdan bir sıcaklık değeri alarak, Celsius'tan Fahrenheit'a dönüştüren bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    printf(\"Celsius cinsinden bir sıcaklık girin: \");\n    scanf(\"%f\", &celsius);\n\n    fahrenheit = (celsius * 9 / 5) + 32;\n    printf(\"Fahrenheit cinsinden sıcaklık: %.2f\", fahrenheit);\n\n    return 0;\n}\n// Bu program, kullanıcının girdiği Celsius sıcaklık değerini Fahrenheit'a dönüştürür.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:01.064542"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Pozitif bir sayı girdiniz.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Negatif bir sayı girdiniz.\\n\");\n    } else {\n        printf(\"Sıfır girdiniz.\\n\");\n    }\n    return 0;\n}\n// Bu kod parçası, kullanıcının girdiği sayının pozitif, negatif veya sıfır olduğunu kontrol eder ve duruma göre uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.769891"
  },
  {
    "question": "Kullanıcının girdiği bir notun harf karşılığını belirleyen bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Bir not girin (0-100 arası): \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"A\\n\");\n    } else if (not >= 80) {\n        printf(\"B\\n\");\n    } else if (not >= 70) {\n        printf(\"C\\n\");\n    } else if (not >= 60) {\n        printf(\"D\\n\");\n    } else {\n        printf(\"F\\n\");\n    }\n    return 0;\n}\n// Bu kod, kullanıcının girdiği notu alır ve belirtilen aralıklara göre harf notunu hesaplayıp ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.769935"
  },
  {
    "question": "Bir sayının asal olup olmadığını kontrol eden bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi, i, asal = 1;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi <= 1) {\n        asal = 0;\n    }\n    for (i = 2; i <= sayi / 2; i++) {\n        if (sayi % i == 0) {\n            asal = 0;\n            break;\n        }\n    }\n\n    if (asal) {\n        printf(\"%d bir asal sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d bir asal değildir.\\n\", sayi);\n    }\n    return 0;\n}\n// Bu program, kullanıcının girdiği sayının asal olup olmadığını kontrol eder ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.769963"
  },
  {
    "question": "Kullanıcının girdiği bir yılın artık yıl olup olmadığını kontrol eden bir kod parçasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yil;\n    printf(\"Bir yıl girin: \");\n    scanf(\"%d\", &yil);\n\n    if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n        printf(\"%d bir artık yıldır.\\n\", yil);\n    } else {\n        printf(\"%d bir artık yıl değildir.\\n\", yil);\n    }\n    return 0;\n}\n// Bu kod, kullanıcının girdiği yılın artık yıl olup olmadığını kontrol eder ve duruma göre uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.769991"
  },
  {
    "question": "Üç kenar uzunluğu verilen bir üçgenin türünü belirleyen bir programın eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float a, b, c;\n    printf(\"Üçgenin kenar uzunluklarını girin: \");\n    scanf(\"%f %f %f\", &a, &b, &c);\n\n    if (a + b > c && a + c > b && b + c > a) {\n        if (a == b && b == c) {\n            printf(\"Eşkenar üçgen.\\n\");\n        } else if (a == b || a == c || b == c) {\n            printf(\"İkizkenar üçgen.\\n\");\n        } else {\n            printf(\"Çeşitkenar üçgen.\\n\");\n        }\n    } else {\n        printf(\"Bu uzunluklarla bir üçgen oluşturulamaz.\\n\");\n    }\n    return 0;\n}\n// Bu program, kullanıcının girdiği üç kenar uzunluğuna göre üçgenin türünü belirler ve duruma göre mesaj verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.770020"
  },
  {
    "question": "Bir kullanıcının girdiği sayının 1 ile 100 arasında olup olmadığını kontrol eden bir programın eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi >= 1 && sayi <= 100) {\n        printf(\"Sayı 1 ile 100 arasında.\\n\");\n    } else {\n        printf(\"Sayı 1 ile 100 arasında değil.\\n\");\n    }\n    return 0;\n}\n// Bu kod, kullanıcının girdiği sayının 1 ile 100 arasında olup olmadığını kontrol eder ve duruma göre bir mesaj ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.770054"
  },
  {
    "question": "Bir dizi içinde en büyük sayıyı bulan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10], i, enBuyuk;\n    printf(\"10 adet sayı girin: \");\n    for (i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    enBuyuk = dizi[0];\n    for (i = 1; i < 10; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n    return 0;\n}\n// Bu program, kullanıcıdan 10 sayı alır ve bu sayılar arasından en büyük olanı bulup ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.770080"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının çift mi tek mi olduğunu kontrol eden bir programın eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 2 == 0) {\n        printf(\"Sayı çifttir.\\n\");\n    } else {\n        printf(\"Sayı tektir.\\n\");\n    }\n    return 0;\n}\n// Bu kod, kullanıcının girdiği sayının çift mi yoksa tek mi olduğunu kontrol eder ve duruma göre bir mesaj yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.770111"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin palindrom olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n\n    int uzunluk = strlen(kelime);\n    int palindrom = 1;\n    for (int i = 0; i < uzunluk / 2; i++) {\n        if (kelime[i] != kelime[uzunluk - 1 - i]) {\n            palindrom = 0;\n            break;\n        }\n    }\n\n    if (palindrom) {\n        printf(\"%s bir palindromdur.\\n\", kelime);\n    } else {\n        printf(\"%s bir palindrom değildir.\\n\", kelime);\n    }\n    return 0;\n}\n// Bu program, kullanıcının girdiği kelimenin palindrom olup olmadığını kontrol eder ve duruma göre uygun mesajı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:34.770137"
  },
  {
    "question": "Bir kullanıcıdan yaşını alan ve 18 yaşından büyükse 'Reşit' yazan bir programda neden 'Reşit' yazmadı?",
    "answer": "Programda yaş kontrolü yapılırken, kullanıcının girdiği değer bir tamsayı olarak değil de bir string olarak alındı. Bu durumda, kontrol ifadesi doğru çalışmadı. Yaşı tamsayıya dönüştürmek için 'atoi()' fonksiyonunu kullanmalıyız. Örnek düzeltme: 'int yas = atoi(input); if (yas >= 18) { printf(\"Reşit\"); }'",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730147"
  },
  {
    "question": "Bir sayının pozitif, negatif veya sıfır olduğunu belirleyen bir programda 'Sayı pozitif' ifadesi her zaman yazdırılıyor. Neden?",
    "answer": "Kontrol yapısında şart ifadesi yanlış yazılmış. 'if (sayi > 0)' yerine 'if (sayi >= 0)' yazılmış. Bu durumda sıfır pozitif olarak kabul edildi. Düzeltmek için 'if (sayi > 0)' ve 'else if (sayi == 0)' şeklinde ayırmalıyız.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730199"
  },
  {
    "question": "Bir öğrencinin notunu kontrol eden ve 'Geçti' veya 'Kaldı' yazan programda, not 50 ve üzeri geçerli olarak kabul edilmedi. Hatalı olan nedir?",
    "answer": "Programda 'if (not > 50)' şeklinde bir kontrol yapılmış. Bu durumda 50 notu geçmiyor. Doğru kontrol 'if (not >= 50)' olmalı. Bu şekilde 50 puan da 'Geçti' olarak sayılacaktır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730244"
  },
  {
    "question": "Kullanıcının girdiği bir sayının tek mi çift mi olduğunu kontrol eden program her zaman 'Tek' yazıyor. Sorun ne?",
    "answer": "Kontrol ifadesinde 'if (sayi % 2 == 1)' kullanılmış. Ancak bu, yalnızca tek sayılar için geçerli. Çift sayılar için 'if (sayi % 2 == 0)' şartını eklemek gerekiyor. Örnek düzeltme: 'if (sayi % 2 == 0) { printf(\"Çift\"); } else { printf(\"Tek\"); }'",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730280"
  },
  {
    "question": "Bir kullanıcıdan alınan sayının 0 ile 100 arasında olup olmadığını kontrol eden program her durumda 'Geçerli' yazıyor. Sorun nedir?",
    "answer": "Kontrol yapısında sınırlar yanlış ayarlanmış. 'if (sayi >= 0 && sayi <= 100)' ifadeleri doğru. Ancak kullanıcıdan alınan değer kontrol edilmeden önce bu değer 'int' türüne dönüştürülmemişse, koşul çalışmayacaktır. 'scanf' fonksiyonu ile alınan değeri direkt int türüne atamak gerek.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730318"
  },
  {
    "question": "Bir ürün fiyatı 100 TL'den fazla ise indirim uygulanacak yazan programda indirim uygulanmıyor. Sorun ne?",
    "answer": "Kontrol ifadesinde fiyatı kontrol etmek için sadece 'if (fiyat > 100)' yazılmış. Ancak indirim uygulaması için else koşulu eklenmemiş. Doğru kontrol: 'if (fiyat > 100) { fiyat *= 0.9; } else { printf(\"İndirim uygulanmadı\"); }'",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730349"
  },
  {
    "question": "Bir kullanıcıdan alınan iki sayının büyük olanını yazdırmak için yazılan programda, her iki sayının da eşit olması halinde 'Birinci sayi büyük' yazıyor. Sorun ne?",
    "answer": "Programda kontrol ifadesi sadece 'if (a > b)' şeklinde yazılmış. Eşitlik kontrolü yapılmadığı için bu sorun ortaya çıkıyor. Düzeltmek için 'if (a > b)' ve 'else if (a < b)' koşulunu kullanmalıyız. Eşitlik durumunda ayrıca 'a ve b eşit' şeklinde bir mesaj vermeliyiz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730393"
  },
  {
    "question": "Bir kullanıcının girdiği notu harf notuna dönüştüren programda, 85 ve 90 arasındaki notlar için 'B' yerine 'C' yazıyor. Bunun nedeni nedir?",
    "answer": "Not kontrolü 'if (not >= 85 && not < 90)' şeklinde yazılmış. Bu durumda 90 notu da 'C' olarak sayılıyor. Düzeltmek için aralığı 'if (not >= 85 && not <= 90)' olarak değiştirmeliyiz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730444"
  },
  {
    "question": "Bir programda gün numarasına göre haftanın gününü yazdırırken tüm günler için 'Pazartesi' yazılıyor. Sorun ne?",
    "answer": "Gün kontrolü için 'if (gun == 1)' şeklinde ifadeler kullanılmış, ancak diğer günler için 'else' yapısı yok. Her gün için ayrı 'if' koşulları eklenmeli. Örnek: 'if (gun == 1) { printf(\"Pazartesi\"); } else if (gun == 2) { printf(\"Salı\"); }' şeklinde devam ettirilmelidir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730477"
  },
  {
    "question": "Bir kullanıcıdan alınan bir karakterin sesli harf olup olmadığını kontrol eden programda her zaman 'Sesli harf' yazıyor. Hatanın nedeni nedir?",
    "answer": "Karakter karşılaştırmasında 'if (karakter == 'a' || karakter == 'e' || karakter == 'i' || karakter == 'o' || karakter == 'u')' yerine küçük ve büyük harf arasındaki durum kontrol edilmemiş. Düzeltmek için hem küçük hem büyük harfleri kontrol etmek gerekli; örneğin: 'if (karakter == 'a' || karakter == 'A' || karakter == 'e' ... )'.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:18:58.730530"
  },
  {
    "question": "Bir kullanıcıdan yaşını girmesini istiyorum. Eğer yaş 18'den büyükse 'Yetişkin' yazdırmalıyım. Ancak kodda yaş kontrolü yapılırken yanlış bir değişken kullanılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Kodda yaş kontrolü yapılırken 'userAge' yerine 'ageInput' değişkeni kullanılmış. Bu hatayı düzeltmek için 'userAge' değişkeni kontrol edilmelidir. Kod şu şekilde olmalı: if (userAge > 18) { printf('Yetişkin'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214152"
  },
  {
    "question": "Bir öğrencinin notunu kontrol etmem gerekiyor. Eğer not 50'den küçükse 'Başarısız', 50-70 arası ise 'Geçti', 70-85 arası ise 'İyi', 85'ten büyükse 'Harika' yazdırmalıyım. Ancak, bir koşul yanlış tanımlanmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Koşul tanımlamalarında sınır değerleri yanlış kullanılmış. Örneğin, 50-70 arası için 'if (not >= 50 && not < 70)' yerine 'if (not > 50 && not < 70)' yazılmış. Doğru tanım şu şekilde olmalıdır: if (not < 50) { printf('Başarısız'); } else if (not >= 50 && not <= 70) { printf('Geçti'); } else if (not > 70 && not <= 85) { printf('İyi'); } else { printf('Harika'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214294"
  },
  {
    "question": "Bir kullanıcıdan bir sayı girmesini istiyorum. Girilen sayı negatifse 'Negatif', pozitifse 'Pozitif' ve sıfırsa 'Sıfır' yazdırmalıyım. Ancak sıfır durumu göz ardı ediliyor. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Sıfır durumu kontrol yapılırken göz ardı edilmiş. Kodda sıfır durumu için bir koşul eklenmemiş. Doğru koşul şu şekilde olmalı: if (sayi < 0) { printf('Negatif'); } else if (sayi > 0) { printf('Pozitif'); } else { printf('Sıfır'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214392"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayıyı karşılaştırarak büyük olanı bulmalıyım. Ancak kodda karşılaştırma operatörleri yanlış kullanılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Karşılaştırma operatörlerinde '>' yerine '<' kullanılmış. Bu durum doğru sonucu vermez. Doğru kod şu şekilde olmalıdır: if (sayi1 > sayi2) { printf('Büyük sayı: %d', sayi1); } else { printf('Büyük sayı: %d', sayi2); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214467"
  },
  {
    "question": "Bir kullanıcıdan bir karakter girmesini istiyorum. Eğer girilen karakter bir harfse 'Harf', değilse 'Harf değil' yazdırmalıyım. Ancak karakter kontrolü yaparken yanlış bir fonksiyon kullanılıyor. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Kodda karakter kontrolü için 'isdigit()' fonksiyonu kullanılmış. Bu nedenle harf kontrolü yapılamaz. Doğru kontrol için 'isalpha()' fonksiyonu kullanılmalıdır. Doğru kod şu şekilde olmalıdır: if (isalpha(inputChar)) { printf('Harf'); } else { printf('Harf değil'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214601"
  },
  {
    "question": "Bir bankanın kredi onay sistemi için kullanıcının gelirini girmesini istiyorum. Gelir 5000'den fazlaysa onay vermeliyim. Ancak koşul yanlışlıkla 'gelir <= 5000' olarak yazılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Koşulda gelir 5000'den fazla olması beklenirken, 'gelir <= 5000' kullanılmış. Bu nedenle onay verilmez. Doğru koşul 'if (gelir > 5000)' olmalıdır. Kod: if (gelir > 5000) { printf('Kredi onaylandı'); } else { printf('Kredi reddedildi'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214696"
  },
  {
    "question": "Bir kullanıcının girdiği üç sayının en büyüğünü bulmalıyım. Ancak iç içe if blokları yerine tek bir if bloğu kullanılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "En büyük sayıyı bulmak için iç içe if blokları gereklidir. Tek bir if bloğu kullanıldığında sadece bir koşul değerlendirilir. Doğru yapı şu şekilde olmalıdır: if (sayi1 >= sayi2 && sayi1 >= sayi3) { printf('En büyük: %d', sayi1); } else if (sayi2 >= sayi1 && sayi2 >= sayi3) { printf('En büyük: %d', sayi2); } else { printf('En büyük: %d', sayi3); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214769"
  },
  {
    "question": "Kullanıcıdan bir ay numarası girmesini istemek istiyorum. Eğer ay 1-12 arasında değilse 'Geçersiz ay' yazdırmalıyım. Ancak bu kontrol için '&&' operatörü yanlış kullanılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Koşulda 'ay < 1 && ay > 12' kullanılmış. Bu durumda hiçbir ay geçerli olmaz. Doğru kontrol için '||' operatörü kullanılmalıdır. Doğru koşul: if (ay < 1 || ay > 12) { printf('Geçersiz ay'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214863"
  },
  {
    "question": "Bir kullanıcıdan bir şifre girmesini istiyorum. Eğer şifre 8 karakterden uzunsa 'Şifre güçlü', 8 karakterden kısaysa 'Şifre zayıf' yazdırmalıyım. Ancak bir hata sonucu karakter sayısını kontrol etmiyor. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Karakter sayısını kontrol etmek için strlen() fonksiyonu kullanılmamış. Doğru kontrol için strlen() fonksiyonu ile şifre uzunluğu kontrol edilmelidir. Kod: if (strlen(sifre) > 8) { printf('Şifre güçlü'); } else { printf('Şifre zayıf'); }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.214971"
  },
  {
    "question": "Bir kullanıcıdan bir ücret girmesini istiyorum. Eğer ücret 1000 TL'den fazla ise %10 indirim uygulamalıyım. Ancak indirim uygulama koşulunda 'ücret < 1000' yazılmış. Hatanın kaynağını ve çözümünü açıkla.",
    "answer": "Koşulda 'ücret < 1000' ifadesi kullanılmış, bu yüzden indirim uygulanmıyor. Doğru koşul 'ücret > 1000' olmalıdır. Kod: if (ücret > 1000) { indirim = ücret * 0.10; toplam = ücret - indirim; }.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:19:28.215058"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcıdan yaşını alıp, eğer yaş 18 veya daha büyükse 'Yetişkin' yazan, aksi halde 'Çocuk' yazan programda hata var. Nedenini ve çözümünü açıkla.",
    "answer": "Kodda yaşın tam sayı olarak alınıp alınmadığı kontrol edilmemiş. Eğer kullanıcı geçersiz bir değer girerse program çöker. Bunu çözmek için yaşın bir tam sayı olup olmadığını kontrol eden bir if yapısı eklenmeli. Örneğin: \n\nint yas;\nprintf(\"Yaşınızı girin: \");\nif(scanf(\"%d\", &yas) != 1) {\n    printf(\"Geçersiz giriş.\");\n} else if (yas >= 18) {\n    printf(\"Yetişkin\");\n} else {\n    printf(\"Çocuk\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152537"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcının notunu alıp, not aralığına göre 'Başarılı', 'Orta', 'Başarısız' yazan programda bir hata var. Hatanın sebebi nedir ve nasıl düzeltilir?",
    "answer": "Kodda notun 0-100 aralığında olup olmadığı kontrol edilmeden sınıflandırma yapılıyor. Eğer kullanıcı 105 gibi bir değer girerse program yanlış sonuç verir. Düzeltmek için if-else yapısına not aralığı kontrolü eklenmeli. Örnek: \n\nint not;\nprintf(\"Notunuzu girin: \");\nscanf(\"%d\", &not);\nif (not < 0 || not > 100) {\n    printf(\"Geçersiz not.\");\n} else if (not >= 85) {\n    printf(\"Başarılı\");\n} else if (not >= 50) {\n    printf(\"Orta\");\n} else {\n    printf(\"Başarısız\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152616"
  },
  {
    "question": "Aşağıdaki kod parçasında, bir kullanıcıdan iki sayı alıp, bunların toplamını yazdıran bir program var. Ancak, program her durumda 0 yazdırıyor. Bunun sebebini ve çözümünü açıkla.",
    "answer": "Kodda toplam hesaplama işlemi doğru yapılmamış. Kullanıcıdan iki sayı alındıktan sonra toplam değişkenine bu sayıların toplamı atanmalı. Çözüm şu şekilde olmalı: \n\nint a, b, toplam;\nprintf(\"İki sayı girin: \");\nscanf(\"%d %d\", &a, &b);\ntoplam = a + b;\nprintf(\"Toplam: %d\", toplam);",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152676"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcıdan bir karakter alınıp, bu karakterin büyük harf olup olmadığını kontrol eden bir program var. Ancak program her durumda 'Büyük harf değil.' yazıyor. Hatanın nedeni nedir?",
    "answer": "Kodda karakterin kontrolü 'A' ile 'Z' arasında olup olmadığına göre yapılıyor ama ASCII değerleri kullanılmamış. Bunun yerine karakterin doğrudan karşılaştırılması gerek. Çözüm şu şekilde olmalı: \n\nchar ch;\nprintf(\"Bir karakter girin: \");\nscanf(\"%c\", &ch);\nif (ch >= 'A' && ch <= 'Z') {\n    printf(\"Büyük harf\");\n} else {\n    printf(\"Büyük harf değil.\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152734"
  },
  {
    "question": "Aşağıdaki kodda bir dizi tanımlanmış ve bu dizinin elemanlarının toplamı hesaplanmaya çalışılıyor. Ancak toplam değeri yanlış hesaplanıyor. Hatanın sebebi nedir?",
    "answer": "Kodda dizinin eleman sayısı ile toplam hesaplanırken bir hata yapılmış. Toplamı hesaplamak için döngü kullanırken dizinin boyutunu doğru kullanmak gerek. Örnek düzeltme: \n\nint dizi[5], toplam = 0;\nfor(int i = 0; i < 5; i++) {\n    toplam += dizi[i];\n}\nprintf(\"Toplam: %d\", toplam);",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152776"
  },
  {
    "question": "Aşağıdaki kodda, pozitif bir sayı için 'Pozitif', negatif bir sayı için 'Negatif' yazdıran bir program mevcut. Ancak kullanıcı 0 girdiğinde de 'Negatif' yazıyor. Hatanın sebebi nedir?",
    "answer": "Kodda 0 durumu kontrol edilmemiş. 0, pozitif veya negatif değildir. Bu nedenle 0'ı kontrol eden bir ek if yapısı eklenmesi gerekir. Düzeltme şu şekilde olmalı: \n\nint sayi;\nscanf(\"%d\", &sayi);\nif (sayi > 0) {\n    printf(\"Pozitif\");\n} else if (sayi < 0) {\n    printf(\"Negatif\");\n} else {\n    printf(\"Sıfır\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152829"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcının girdiği rakamın tek mi çift mi olduğunu kontrol eden bir program var. Ancak program her durumda 'Tek' yazıyor. Hatanın sebebi nedir?",
    "answer": "Kodda sayının çift olup olmadığı kontrol edilmeden her durumda tek olduğu varsayılmış. Doğru kontrol için sayının 2 ile bölümünden kalan kontrol edilmeli. Örnek düzeltme: \n\nint sayi;\nscanf(\"%d\", &sayi);\nif (sayi % 2 == 0) {\n    printf(\"Çift\");\n} else {\n    printf(\"Tek\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152874"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcıdan alınan 3 sayının en büyüğünü bulmaya çalışan bir program var. Ancak her durumda ilk sayıyı en büyük olarak gösteriyor. Hatanın sebebi nedir ve nasıl düzeltilir?",
    "answer": "Kodda en büyük sayıyı bulma mantığı yanlış. Tüm sayılar karşılaştırılmalı. Düzeltme için if yapısı şöyle olmalıdır: \n\nint a, b, c;\nscanf(\"%d %d %d\", &a, &b, &c);\nint enBuyuk = a;\nif (b > enBuyuk) enBuyuk = b;\nif (c > enBuyuk) enBuyuk = c;\nprintf(\"En büyük sayı: %d\", enBuyuk);",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.152935"
  },
  {
    "question": "Aşağıdaki kodda bir kullanıcıdan alınan bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden program var. Ancak kullanıcı negatif bir sayı girdiğinde 'Pozitif' yazıyor. Hatanın sebebi nedir?",
    "answer": "Kodda karşılaştırmaların mantığı yanlış. Negatif sayılar için pozitif olduğu varsayılmış. Düzeltmek için if yapısındaki koşullar doğru değiştirilmeli. Örnek düzeltme: \n\nint sayi;\nscanf(\"%d\", &sayi);\nif (sayi > 0) {\n    printf(\"Pozitif\");\n} else if (sayi < 0) {\n    printf(\"Negatif\");\n} else {\n    printf(\"Sıfır\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.153025"
  },
  {
    "question": "Aşağıdaki kodda kullanıcıdan alınan bir notun harf karşılığını yazdırmaya çalışan bir program var. Ancak not 90-100 arası için 'C', 80-89 arası için 'B' yazıyor. Hatanın sebebi nedir?",
    "answer": "Kodda not aralıkları yanlış tanımlanmış. 90-100 için 'A', 80-89 için 'B' yazılmalıdır. Düzeltmek için aralıkları şu şekilde ayarlayın: \n\nint not;\nscanf(\"%d\", &not);\nif (not >= 90 && not <= 100) {\n    printf(\"A\");\n} else if (not >= 80 && not < 90) {\n    printf(\"B\");\n} else if (not >= 70 && not < 80) {\n    printf(\"C\");\n} else {\n    printf(\"Başarısız\");\n}",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:00.153079"
  },
  {
    "question": "Bir kullanıcının yaşını kontrol etmek için if-else yapısını nasıl kullanabilirim?",
    "answer": "Kullanıcının yaşını kontrol etmek için öncelikle kullanıcının yaşını bir değişkene atarız. Ardından, if-else yapısını kullanarak yaşın 18'den büyük mü yoksa eşit veya küçük mü olduğunu kontrol edebiliriz. Eğer 18'den büyükse, 'Yetişkinsiniz.' mesajı gösterilebilir, aksi takdirde 'Henüz yetişkin değilsiniz.' mesajı gösterilir. Örnek kod:\n\n```c\nint yas;\nprintf(\"Yaşınızı girin: \");\nscanf(\"%d\", &yas);\n\nif (yas >= 18) {\n    printf(\"Yetişkinsiniz.\");\n} else {\n    printf(\"Henüz yetişkin değilsiniz.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252461"
  },
  {
    "question": "Bir sayının pozitif, negatif veya sıfır olduğunu kontrol etmek için nasıl bir kod yazabilirim?",
    "answer": "Bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol etmek için bir if-else if yapısı kullanabiliriz. Kullanıcıdan bir sayı alırız ve ardından bu sayının değerine göre uygun mesajı yazdırırız. Örnek kod:\n\n```c\nint sayi;\nprintf(\"Bir sayı girin: \");\nscanf(\"%d\", &sayi);\n\nif (sayi > 0) {\n    printf(\"Pozitif bir sayı.\");\n} else if (sayi < 0) {\n    printf(\"Negatif bir sayı.\");\n} else {\n    printf(\"Sayı sıfır.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252538"
  },
  {
    "question": "Bir öğrencinin notuna göre 'Başarılı' veya 'Başarısız' olduğunu belirtmek için nasıl bir kontrol yapısı kullanmalıyım?",
    "answer": "Öğrencinin notunu kontrol etmek için if yapısını kullanabiliriz. Kullanıcıdan notunu alır ve bu not 50 veya daha yüksekse 'Başarılı' mesajı gösterilir, aksi takdirde 'Başarısız' mesajı gösterilir. Örnek kod:\n\n```c\nint not;\nprintf(\"Notunuzu girin: \");\nscanf(\"%d\", &not);\n\nif (not >= 50) {\n    printf(\"Başarılı.\");\n} else {\n    printf(\"Başarısız.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252586"
  },
  {
    "question": "Bir kullanıcının girdiği sayının çift mi tek mi olduğunu kontrol etmek için hangi yapıyı kullanmalıyım?",
    "answer": "Bir sayının çift veya tek olup olmadığını kontrol etmek için mod (%) operatörünü kullanarak if yapısını uygulayabiliriz. Kullanıcıdan bir sayı alırız ve bu sayının 2 ile bölümünden kalanına bakarız. Kalan 0 ise çift, aksi takdirde tektir. Örnek kod:\n\n```c\nint sayi;\nprintf(\"Bir sayı girin: \");\nscanf(\"%d\", &sayi);\n\nif (sayi % 2 == 0) {\n    printf(\"Çift bir sayı.\");\n} else {\n    printf(\"Tek bir sayı.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252617"
  },
  {
    "question": "Bir kullanıcının girdiği ay numarasına göre o ayın adını nasıl yazdırabilirim?",
    "answer": "Kullanıcının girdiği ay numarasına göre ay adını yazdırmak için switch-case yapısını kullanabiliriz. Kullanıcıdan ay numarasını alır ve bu numaraya göre uygun ay adını yazdırırız. Örnek kod:\n\n```c\nint ay;\nprintf(\"Ay numarasını girin (1-12): \");\nscanf(\"%d\", &ay);\n\nswitch (ay) {\n    case 1: printf(\"Ocak\"); break;\n    case 2: printf(\"Şubat\"); break;\n    case 3: printf(\"Mart\"); break;\n    case 4: printf(\"Nisan\"); break;\n    case 5: printf(\"Mayıs\"); break;\n    case 6: printf(\"Haziran\"); break;\n    case 7: printf(\"Temmuz\"); break;\n    case 8: printf(\"Ağustos\"); break;\n    case 9: printf(\"Eylül\"); break;\n    case 10: printf(\"Ekim\"); break;\n    case 11: printf(\"Kasım\"); break;\n    case 12: printf(\"Aralık\"); break;\n    default: printf(\"Geçersiz ay numarası.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252643"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayıyı karşılaştırarak hangisinin büyük olduğunu nasıl bulabilirim?",
    "answer": "İki sayıyı karşılaştırmak için if-else yapısını kullanabiliriz. Kullanıcıdan iki sayı alır ve bu sayılardan hangisinin büyük olduğunu kontrol ederiz. Örnek kod:\n\n```c\nint sayi1, sayi2;\nprintf(\"İki sayı girin: \");\nscanf(\"%d %d\", &sayi1, &sayi2);\n\nif (sayi1 > sayi2) {\n    printf(\"Büyük sayı: %d\", sayi1);\n} else if (sayi2 > sayi1) {\n    printf(\"Büyük sayı: %d\", sayi2);\n} else {\n    printf(\"İki sayı eşit.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252673"
  },
  {
    "question": "Bir kullanıcının girdiği notla 'AA', 'BB', 'CC' veya 'DD' harf notlarını nasıl belirleyebilirim?",
    "answer": "Bir notun harf notunu belirlemek için if-else if yapısını kullanabiliriz. Kullanıcıdan not alır ve bu notun aralığına göre uygun harf notunu belirleriz. Örnek kod:\n\n```c\nint not;\nprintf(\"Notunuzu girin: \");\nscanf(\"%d\", &not);\n\nif (not >= 85) {\n    printf(\"AA\");\n} else if (not >= 70) {\n    printf(\"BB\");\n} else if (not >= 55) {\n    printf(\"CC\");\n} else {\n    printf(\"DD\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252707"
  },
  {
    "question": "Bir sayının 100'den büyük, 50 ile 100 arasında ya da 50'den küçük olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir sayının belirli aralıklarda olup olmadığını kontrol etmek için if-else if yapısını kullanabiliriz. Kullanıcıdan bir sayı alarak, bu sayı 100'den büyük mü, 50 ile 100 arasında mı yoksa 50'den küçük mü olduğunu kontrol ederiz. Örnek kod:\n\n```c\nint sayi;\nprintf(\"Bir sayı girin: \");\nscanf(\"%d\", &sayi);\n\nif (sayi > 100) {\n    printf(\"Sayı 100'den büyük.\");\n} else if (sayi >= 50) {\n    printf(\"Sayı 50 ile 100 arasında.\");\n} else {\n    printf(\"Sayı 50'den küçük.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252754"
  },
  {
    "question": "Bir kullanıcının girdiği sayının asal olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir sayının asal olup olmadığını kontrol etmek için bir döngü ve if yapısını kullanabiliriz. Kullanıcıdan bir sayı alır ve 2'den başlayarak bu sayının kareköküne kadar olan sayılarla bölümünü kontrol ederiz. Eğer hiçbir bölüm kalanı 0 çıkmazsa, sayı asal kabul edilir. Örnek kod:\n\n```c\nint sayi, i, asal = 1;\nprintf(\"Bir sayı girin: \");\nscanf(\"%d\", &sayi);\n\nif (sayi <= 1) {\n    asal = 0;\n} else {\n    for (i = 2; i <= sqrt(sayi); i++) {\n        if (sayi % i == 0) {\n            asal = 0;\n            break;\n        }\n    }\n}\n\nif (asal) {\n    printf(\"Sayı asaldır.\");\n} else {\n    printf(\"Sayı asal değildir.\");\n}\n```",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:20:33.252778"
  },
  {
    "question": "Bir aracın hızına göre hız limitini kontrol eden bir C programı nasıl yazılır?",
    "answer": "Hız limitini kontrol etmek için bir 'if' ifadesi kullanılabilir. Örneğin, hız 60 km/saatin üzerindeyse, aracın hızının aşılması durumunda bir uyarı mesajı yazdırabiliriz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int hiz;\n    printf(\"Hızı girin (km/saat): \");\n    scanf(\"%d\", &hiz);\n\n    if (hiz > 60) {\n        printf(\"Hız limiti aşıldı!\\n\");\n    } else {\n        printf(\"Hız limiti içinde.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, kullanıcıdan hız bilgisi alır ve hızın 60'dan büyük olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.593909"
  },
  {
    "question": "Bir sınav notunu değerlendirip harf notunu belirleyen bir program yazınız.",
    "answer": "Sınav notunu değerlendirirken, 'if-else if' yapısı kullanılabilir. Notu alıp, aralıklara göre harf notunu belirleyebiliriz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Sınav notunu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf notu: A\\n\");\n    } else if (not >= 80) {\n        printf(\"Harf notu: B\\n\");\n    } else if (not >= 70) {\n        printf(\"Harf notu: C\\n\");\n    } else if (not >= 60) {\n        printf(\"Harf notu: D\\n\");\n    } else {\n        printf(\"Harf notu: F\\n\");\n    }\n    return 0;\n}\n```\nBu kod, girilen not aralığına göre harf notunu belirler.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.593960"
  },
  {
    "question": "Bir kullanıcıdan yaşını alıp, oy kullanma yeterliliğini kontrol eden bir program nasıl yazılır?",
    "answer": "Oy kullanma hakkı için yaşın en az 18 olması gerekir. Bu durumda basit bir 'if' yapısı kullanılabilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas >= 18) {\n        printf(\"Oy kullanma hakkına sahipsiniz.\\n\");\n    } else {\n        printf(\"Oy kullanma hakkına sahip değilsiniz.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, kullanıcının yaşını kontrol eder ve oy kullanma yeterliliğini belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.593990"
  },
  {
    "question": "Bir öğrenci notlarının ortalamasını hesaplayıp geçme durumunu kontrol eden bir program yazın.",
    "answer": "Öğrencinin başarı durumunu belirlemek için not ortalaması hesaplanabilir. 'if' yapısı ile ortalama 60 ve üzerindeyse geçer olarak değerlendirilebilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    float not1, not2, not3, ortalama;\n    printf(\"3 notu girin: \");\n    scanf(\"%f %f %f\", &not1, &not2, &not3);\n\n    ortalama = (not1 + not2 + not3) / 3;\n\n    if (ortalama >= 60) {\n        printf(\"Geçtiniz. Ortalamanız: %.2f\\n\", ortalama);\n    } else {\n        printf(\"Kaldınız. Ortalamanız: %.2f\\n\", ortalama);\n    }\n    return 0;\n}\n```\nBu kod, üç notun ortalamasını hesaplayarak geçme durumunu kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594017"
  },
  {
    "question": "Bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir C programı yazın.",
    "answer": "Sayıyı kontrol etmek için 'if-else' yapısı kullanılabilir. Pozitif, negatif veya sıfır durumlarını belirlemek mümkündür.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Pozitif bir sayı.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Negatif bir sayı.\\n\");\n    } else {\n        printf(\"Sayı sıfır.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, girilen sayının durumunu kontrol eder ve uygun mesajı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594045"
  },
  {
    "question": "Bir kullanıcıdan 1 ile 7 arasında bir sayı alıp, haftanın hangi günü olduğunu tahmin eden bir program yazınız.",
    "answer": "Kullanıcıdan alınan sayıya göre, haftanın günlerini belirlemek için 'switch' ifadesi kullanılabilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int gun;\n    printf(\"1 ile 7 arasında bir sayı girin: \");\n    scanf(\"%d\", &gun);\n\n    switch (gun) {\n        case 1:\n            printf(\"Pazartesi\\n\");\n            break;\n        case 2:\n            printf(\"Salı\\n\");\n            break;\n        case 3:\n            printf(\"Çarşamba\\n\");\n            break;\n        case 4:\n            printf(\"Perşembe\\n\");\n            break;\n        case 5:\n            printf(\"Cuma\\n\");\n            break;\n        case 6:\n            printf(\"Cumartesi\\n\");\n            break;\n        case 7:\n            printf(\"Pazar\\n\");\n            break;\n        default:\n            printf(\"Geçersiz sayı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, kullanıcının girdiği sayıya göre haftanın gününü yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594078"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayıyı karşılaştırıp, hangisinin daha büyük olduğunu belirleyen bir program yazınız.",
    "answer": "İki sayıyı karşılaştırmak için 'if' yapısı kullanılabilir. Kullanıcının girdiği sayılara göre uygun mesaj verilebilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &sayi1, &sayi2);\n\n    if (sayi1 > sayi2) {\n        printf(\"Büyük sayı: %d\\n\", sayi1);\n    } else if (sayi2 > sayi1) {\n        printf(\"Büyük sayı: %d\\n\", sayi2);\n    } else {\n        printf(\"İki sayı eşit.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, iki sayıyı karşılaştırarak hangisinin büyük olduğunu belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594109"
  },
  {
    "question": "Bir çalışan için maaş zammı hesaplayıp, hangi oranda zam yapılacağını belirten bir program yazınız.",
    "answer": "Maaş zammı oranı, mevcut maaşa bağlı olarak belirlenebilir. 'if-else if' yapısı ile zam yüzdesi hesaplanabilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    float maas, zam;\n    printf(\"Mevcut maaşı girin: \");\n    scanf(\"%f\", &maas);\n\n    if (maas < 3000) {\n        zam = maas * 0.10;\n    } else if (maas <= 5000) {\n        zam = maas * 0.05;\n    } else {\n        zam = maas * 0.03;\n    }\n\n    printf(\"Zam miktarı: %.2f\\n\", zam);\n    return 0;\n}\n```\nBu kod, çalışanın maaşına göre ne kadar zam yapılacağını hesaplar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594137"
  },
  {
    "question": "Bir kullanıcıdan cinsiyet bilgisini alıp, uygun mesajı veren bir program yazınız.",
    "answer": "Kullanıcıdan alınan cinsiyete göre uygun mesaj vermek için 'if' yapısı kullanılabilir.\n\n```c\n#include <stdio.h>\n\nint main() {\n    char cinsiyet;\n    printf(\"Cinsiyetinizi girin (E/K): \");\n    scanf(\" %c\", &cinsiyet);\n\n    if (cinsiyet == 'E' || cinsiyet == 'e') {\n        printf(\"Erkek\\n\");\n    } else if (cinsiyet == 'K' || cinsiyet == 'k') {\n        printf(\"Kadın\\n\");\n    } else {\n        printf(\"Geçersiz cinsiyet.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, girilen cinsiyet bilgisine göre uygun mesajı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:07.594162"
  },
  {
    "question": "Bir kullanıcıdan alınan yaş değerine göre bir mesaj döndüren bir program yazın. 18 yaşından küçüklere 'Reşit değilsiniz', 18-65 arası için 'Yetişkinsiniz' ve 65 yaş üstü için 'Yaşlısınız' mesajı verin.",
    "answer": "Bu senaryoda, kullanıcıdan yaş bilgisi almak için 'scanf' fonksiyonu kullanılır. Ardından 'if-else if-else' yapısıyla yaş aralıklarına göre uygun mesajları döndüreceğiz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas < 18) {\n        printf(\"Reşit değilsiniz\\n\");\n    } else if (yas <= 65) {\n        printf(\"Yetişkinsiniz\\n\");\n    } else {\n        printf(\"Yaşlısınız\\n\");\n    }\n    return 0;\n}\n```\nBurada, kullanıcıdan alınan yaş değerine göre koşullar kontrol edilmekte ve uygun mesaj yazdırılmaktadır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971000"
  },
  {
    "question": "Bir öğrenci not sistemi oluşturun. Kullanıcının girdiği not değerine göre 'Başarılı', 'Orta', 'Başarısız' mesajlarını döndüren bir program yazın. 0-49 için 'Başarısız', 50-74 için 'Orta', 75-100 için 'Başarılı' mesajı verin.",
    "answer": "Not değerini alıp, bu değere göre bir değerlendirme yapabilmek için tekrar 'if-else if-else' yapısını kullanıyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not < 50) {\n        printf(\"Başarısız\\n\");\n    } else if (not < 75) {\n        printf(\"Orta\\n\");\n    } else if (not <= 100) {\n        printf(\"Başarılı\\n\");\n    } else {\n        printf(\"Geçersiz not!\\n\");\n    }\n    return 0;\n}\n```\nProgram, girilen not değerine göre uygun mesajı verir. Ayrıca, geçerli bir not aralığı dışında bir değer girildiğinde 'Geçersiz not!' mesajını gösterir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971083"
  },
  {
    "question": "Bir kullanıcının girdiği sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir program yazın.",
    "answer": "Bu durumda, kullanıcının girdiği sayıyı alıp kontrol edebiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Pozitif\\n\");\n    } else if (sayi < 0) {\n        printf(\"Negatif\\n\");\n    } else {\n        printf(\"Sıfır\\n\");\n    }\n    return 0;\n}\n```\nBurada, kullanıcıdan alınan sayı pozitif, negatif veya sıfır olarak sınıflandırılmakta ve uygun mesajı vermektedir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971115"
  },
  {
    "question": "Kullanıcının girdiği iki sayının hangisinin büyük olduğunu kontrol edin ve sonucu yazdırın.",
    "answer": "Kullanıcının girdiği iki sayıyı karşılaştırmak için:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İlk sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n\n    if (sayi1 > sayi2) {\n        printf(\"Büyük sayı: %d\\n\", sayi1);\n    } else if (sayi2 > sayi1) {\n        printf(\"Büyük sayı: %d\\n\", sayi2);\n    } else {\n        printf(\"Her iki sayı eşit.\\n\");\n    }\n    return 0;\n}\n```\nBu program, iki sayıyı karşılaştırır ve hangisinin daha büyük olduğunu veya eşit olduğunu belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971143"
  },
  {
    "question": "Kullanıcının girdiği sıcaklık değerine göre 'Soğuk', 'Ilımlı', 'Sıcak' gibi bir değerlendirme yapan bir program yazın. 0-15 arası 'Soğuk', 16-25 arası 'Ilımlı', 26 ve üzeri 'Sıcak' olarak sınıflandırın.",
    "answer": "Sıcaklığın değerlendirilmesi için:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sicaklik;\n    printf(\"Sıcaklık değerini girin: \");\n    scanf(\"%d\", &sicaklik);\n\n    if (sicaklik <= 15) {\n        printf(\"Soğuk\\n\");\n    } else if (sicaklik <= 25) {\n        printf(\"Ilımlı\\n\");\n    } else {\n        printf(\"Sıcak\\n\");\n    }\n    return 0;\n}\n```\nProgram, girilen sıcaklık değerine göre uygun mesajı verir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971206"
  },
  {
    "question": "Bir kullanıcıdan alınan bir karakterin sesli, sessiz harf olup olmadığını kontrol eden bir program yazın.",
    "answer": "Harf kontrolü için karakterleri incelememiz gerekiyor:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char karakter;\n    printf(\"Bir karakter girin: \");\n    scanf(\" %c\", &karakter);\n\n    if (karakter == 'a' || karakter == 'e' || karakter == 'i' || karakter == 'o' || karakter == 'u' || karakter == 'A' || karakter == 'E' || karakter == 'I' || karakter == 'O' || karakter == 'U') {\n        printf(\"Sesli harf\\n\");\n    } else {\n        printf(\"Sessiz harf\\n\");\n    }\n    return 0;\n}\n```\nBurada, sesli harfleri kontrol etmek için 'if' yapısında bir dizi 'or' koşulu kullanıyoruz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971236"
  },
  {
    "question": "Bir kullanıcıdan 1 ile 7 arasında bir sayı alarak haftanın gününü belirten bir program yazın. 1 için 'Pazartesi', 2 için 'Salı'... 7 için 'Pazar' yazısının döndüğünden emin olun.",
    "answer": "Bu durumda bir 'switch' yapısı kullanışlı olacaktır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int gun;\n    printf(\"1-7 arası bir sayı girin: \");\n    scanf(\"%d\", &gun);\n\n    switch (gun) {\n        case 1:\n            printf(\"Pazartesi\\n\");\n            break;\n        case 2:\n            printf(\"Salı\\n\");\n            break;\n        case 3:\n            printf(\"Çarşamba\\n\");\n            break;\n        case 4:\n            printf(\"Perşembe\\n\");\n            break;\n        case 5:\n            printf(\"Cuma\\n\");\n            break;\n        case 6:\n            printf(\"Cumartesi\\n\");\n            break;\n        case 7:\n            printf(\"Pazar\\n\");\n            break;\n        default:\n            printf(\"Geçersiz sayı!\\n\");\n            break;\n    }\n    return 0;\n}\n```\nKullanıcıdan alınan sayıya göre uygun gün adını yazdırıyoruz, geçersiz bir girişte hata mesajı veriyoruz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971306"
  },
  {
    "question": "Bir kullanıcının girdiği bir üçgenin kenar uzunluklarına göre üçgenin çeşitlerini belirten bir program yazın. Eşkenar, İkizkenar veya Çeşitkenar olarak sınıflandırın.",
    "answer": "Üçgenin kenar uzunluklarına göre sınıflandırma yapmak için:\n\n```c\n#include <stdio.h>\n\nint main() {\n    float a, b, c;\n    printf(\"Üçgenin kenar uzunluklarını girin: \");\n    scanf(\"%f %f %f\", &a, &b, &c);\n\n    if (a == b && b == c) {\n        printf(\"Eşkenar üçgen\\n\");\n    } else if (a == b || b == c || a == c) {\n        printf(\"İkizkenar üçgen\\n\");\n    } else {\n        printf(\"Çeşitkenar üçgen\\n\");\n    }\n    return 0;\n}\n```\nBu program, üçgenin kenar uzunluklarını alarak uygun üçgen çeşidini belirler.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971350"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının asal olup olmadığını kontrol eden bir program yazın.",
    "answer": "Bir sayının asal olup olmadığını kontrol etmek için 2'den başlayarak sayının kareköküne kadar olan sayılarla bölünüp bölünmediğini kontrol etmeliyiz:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int sayi, asal = 1;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi <= 1) {\n        asal = 0;\n    } else {\n        for (int i = 2; i <= sqrt(sayi); i++) {\n            if (sayi % i == 0) {\n                asal = 0;\n                break;\n            }\n        }\n    }\n\n    if (asal) {\n        printf(\"%d bir asal sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d bir asal sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n```\nBu program, kullanıcının girdiği sayının asal olup olmadığını kontrol eder ve sonucu belirtir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:21:50.971376"
  },
  {
    "question": "Kullanıcının girdiği bir sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Sayi pozitiftir.\\n\");\n    } else if (sayi < 0) {\n        printf(\"Sayi negatiftir.\\n\");\n    } else {\n        printf(\"Sayi sıfırdır.\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir sayı alır ve bu sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887612"
  },
  {
    "question": "Bir öğrencinin notuna göre geçti veya kaldı bilgisini veren bir program yazın. Geçme notu 50'dir.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu girin: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 50) {\n        printf(\"Geçtiniz!\\n\");\n    } else {\n        printf(\"Kaldınız!\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir not alarak, notun 50 veya daha yüksek olup olmadığını kontrol eder ve duruma göre geçme veya kalma durumunu bildirir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887687"
  },
  {
    "question": "Bir yılın artık yıl olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yil;\n    printf(\"Yili girin: \");\n    scanf(\"%d\", &yil);\n\n    if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n        printf(\"%d bir artık yıldır.\\n\", yil);\n    } else {\n        printf(\"%d bir artık yıl değildir.\\n\", yil);\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir yıl alır ve bu yılın artık yıl olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887733"
  },
  {
    "question": "Bir kullanıcının girdiği sayının tek mi çift mi olduğunu belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 2 == 0) {\n        printf(\"Sayi çifttir.\\n\");\n    } else {\n        printf(\"Sayi tektir.\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği sayının çift mi yoksa tek mi olduğunu kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887781"
  },
  {
    "question": "Kullanıcının girdiği bir sayının 100'den büyük olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 100) {\n        printf(\"Sayi 100'den büyüktür.\\n\");\n    } else {\n        printf(\"Sayi 100'den büyük değildir.\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği sayının 100'den büyük olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887833"
  },
  {
    "question": "Bir kullanıcının girdiği sıcaklık değerine göre hava durumu tahmini yapan bir program yazın. 0'dan düşükse 'soğuk', 0-20 arası 'ılıman', 20 ve üstü 'sıcak' olsun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    float sicaklik;\n    printf(\"Sicaklik değerini girin: \");\n    scanf(\"%f\", &sicaklik);\n\n    if (sicaklik < 0) {\n        printf(\"Hava durumu: Soğuk.\\n\");\n    } else if (sicaklik >= 0 && sicaklik < 20) {\n        printf(\"Hava durumu: Ilıman.\\n\");\n    } else {\n        printf(\"Hava durumu: Sıcak.\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği sıcaklık değerine göre hava durumu tahmini yapar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887932"
  },
  {
    "question": "Kullanıcının girdiği 3 sayının en büyüğünü bulan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    printf(\"Üç sayı girin: \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    if (a >= b && a >= c) {\n        printf(\"En büyük sayı: %d\\n\", a);\n    } else if (b >= a && b >= c) {\n        printf(\"En büyük sayı: %d\\n\", b);\n    } else {\n        printf(\"En büyük sayı: %d\\n\", c);\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği üç sayı arasından en büyük olanı bulur.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.887973"
  },
  {
    "question": "Bir kullanıcıdan bir karakter girmesini isteyin ve bu karakterin bir sesli harf mi yoksa sessiz harf mi olduğunu belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char ch;\n    printf(\"Bir karakter girin: \");\n    scanf(\"%c\", &ch);\n\n    if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\n        ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n        printf(\"'%c' bir sesli harftir.\\n\", ch);\n    } else {\n        printf(\"'%c' bir sessiz harftir.\\n\", ch);\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcıdan alınan bir karakterin sesli mi yoksa sessiz mi olduğunu kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.888040"
  },
  {
    "question": "Bir kullanıcının girdiği yaşa göre 'çocuk', 'genç' veya 'yetişkin' tanımlayan bir program yazın. 0-12 çocuk, 13-19 genç, 20 ve üstü yetişkin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas >= 0 && yas <= 12) {\n        printf(\"Çocuk.\\n\");\n    } else if (yas >= 13 && yas <= 19) {\n        printf(\"Genç.\\n\");\n    } else {\n        printf(\"Yetişkin.\\n\");\n    }\n\n    return 0;\n}\n\n// Bu program, kullanıcının yaşını alır ve bu yaşa göre kategori belirler.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:20.888122"
  },
  {
    "question": "Bir kullanıcının girdiği sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi giriniz: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Girdiğiniz sayı pozitif.\");\n    } else if (sayi < 0) {\n        printf(\"Girdiğiniz sayı negatif.\");\n    } else {\n        printf(\"Girdiğiniz sayı sıfır.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir sayı alır ve bu sayının pozitif, negatif veya sıfır olup olmadığını kontrol ederek çıktıyı ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736093"
  },
  {
    "question": "Bir kullanıcının girdiği notun harf karşılığını veren bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Notunuzu giriniz: \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf notu: A\");\n    } else if (not >= 80) {\n        printf(\"Harf notu: B\");\n    } else if (not >= 70) {\n        printf(\"Harf notu: C\");\n    } else if (not >= 60) {\n        printf(\"Harf notu: D\");\n    } else {\n        printf(\"Harf notu: F\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcının notunu alarak harf notunu belirler ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736144"
  },
  {
    "question": "Bir yıldızın asal olup olmadığını kontrol eden bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi, asal = 1;\n    printf(\"Bir sayi giriniz: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi <= 1) {\n        asal = 0;\n    } else {\n        for (int i = 2; i <= sayi / 2; i++) {\n            if (sayi % i == 0) {\n                asal = 0;\n                break;\n            }\n        }\n    }\n\n    if (asal) {\n        printf(\"Girdiğiniz sayı asal.\");\n    } else {\n        printf(\"Girdiğiniz sayı asal değil.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir sayı alarak asal olup olmadığını kontrol eder ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736174"
  },
  {
    "question": "Kullanıcının girdiği sayının tek mi çift mi olduğunu kontrol eden bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi giriniz: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 2 == 0) {\n        printf(\"Girdiğiniz sayı çifttir.\");\n    } else {\n        printf(\"Girdiğiniz sayı tektir.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği sayının tek veya çift olduğunu kontrol eder ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736204"
  },
  {
    "question": "Bir kullanıcının yaşına göre hangi yaş grubuna ait olduğunu belirleyen bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı giriniz: \");\n    scanf(\"%d\", &yas);\n\n    if (yas < 0) {\n        printf(\"Geçersiz yaş.\");\n    } else if (yas <= 12) {\n        printf(\"Çocuk\");\n    } else if (yas <= 19) {\n        printf(\"Genç\");\n    } else if (yas <= 64) {\n        printf(\"Yetişkin\");\n    } else {\n        printf(\"Yaşlı\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcının yaşını alır ve yaş grubunu belirleyerek ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736232"
  },
  {
    "question": "Kullanıcının girdiği üç kenar uzunluğunun bir üçgen oluşturup oluşturmadığını kontrol eden bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    printf(\"Üçgenin üç kenar uzunluğunu giriniz (a, b, c): \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    if (a + b > c && a + c > b && b + c > a) {\n        printf(\"Bu kenar uzunlukları bir üçgen oluşturur.\");\n    } else {\n        printf(\"Bu kenar uzunlukları bir üçgen oluşturmaz.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan üç kenar uzunluğunu alır ve bu kenarların bir üçgen oluşturup oluşturmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736265"
  },
  {
    "question": "Bir kullanıcının girdiği ay numarasına göre ayın gün sayısını veren bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int ay;\n    printf(\"Ay numarasını giriniz (1-12): \");\n    scanf(\"%d\", &ay);\n\n    switch (ay) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            printf(\"Bu ay 31 gündür.\");\n            break;\n        case 4: case 6: case 9: case 11:\n            printf(\"Bu ay 30 gündür.\");\n            break;\n        case 2:\n            printf(\"Bu ay 28 gündür (artık yılda 29).\\n\");\n            break;\n        default:\n            printf(\"Geçersiz ay numarası.\");\n            break;\n    }\n    return 0;\n}\n\n// Bu program, kullanıcının girdiği ay numarasına göre ayın gün sayısını belirler ve ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736292"
  },
  {
    "question": "Bir kullanıcının girdiği iki sayının hangisinin daha büyük olduğunu belirleyen bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    printf(\"İki sayı giriniz (a b): \");\n    scanf(\"%d %d\", &a, &b);\n\n    if (a > b) {\n        printf(\"Daha büyük sayı: %d\\n\", a);\n    } else if (b > a) {\n        printf(\"Daha büyük sayı: %d\\n\", b);\n    } else {\n        printf(\"Her iki sayı eşittir.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan iki sayı alarak hangi sayının daha büyük olduğunu belirler ve sonucu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736320"
  },
  {
    "question": "Bir kullanıcının girdiği sayının 100'den büyük mü yoksa küçük mü olduğunu kontrol eden bir C programı yazınız.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayi giriniz: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 100) {\n        printf(\"Girdiğiniz sayı 100'den büyüktür.\");\n    } else if (sayi < 100) {\n        printf(\"Girdiğiniz sayı 100'den küçüktür.\");\n    } else {\n        printf(\"Girdiğiniz sayı 100'e eşittir.\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir sayı alarak 100 ile karşılaştırır ve sonucunu ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:22:47.736353"
  },
  {
    "question": "C dilinde bir kullanıcıdan alınan sayının pozitif, negatif veya sıfır olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi > 0) {\n        printf(\"Pozitif\\n\");\n    } else if (sayi < 0) {\n        printf(\"Negatif\\n\");\n    } else {\n        printf(\"Sıfır\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan bir sayı alır ve bu sayının pozitif, negatif veya sıfır olup olmadığını kontrol eder. Kontrol yapıları (if-else) kullanılarak sonuç ekrana yazdırılır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270732"
  },
  {
    "question": "Kullanıcının girdiği bir sayının asal olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint asalMi(int sayi) {\n    if (sayi <= 1) return 0;\n    for (int i = 2; i * i <= sayi; i++) {\n        if (sayi % i == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (asalMi(sayi)) {\n        printf(\"%d asal bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği bir sayının asal olup olmadığını kontrol eder. Asal kontrol fonksiyonu, sayının 1'den büyük olup olmadığını ve diğer sayılarla bölünüp bölünmediğini kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270775"
  },
  {
    "question": "Kullanıcının girdiği bir öğrencinin notunu alıp, not aralığına göre harf notunu belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int not;\n    printf(\"Öğrencinin notunu girin (0-100): \");\n    scanf(\"%d\", &not);\n\n    if (not >= 90) {\n        printf(\"Harf notu: A\\n\");\n    } else if (not >= 80) {\n        printf(\"Harf notu: B\\n\");\n    } else if (not >= 70) {\n        printf(\"Harf notu: C\\n\");\n    } else if (not >= 60) {\n        printf(\"Harf notu: D\\n\");\n    } else {\n        printf(\"Harf notu: F\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan not alır ve belirli aralıklara göre harf notunu belirler. Kontrol yapıları ile not aralıkları kontrol edilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270808"
  },
  {
    "question": "Kullanıcının girdiği bir yılın artık yıl olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yil;\n    printf(\"Bir yıl girin: \");\n    scanf(\"%d\", &yil);\n\n    if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n        printf(\"%d artık bir yıldır.\\n\", yil);\n    } else {\n        printf(\"%d artık bir yıl değildir.\\n\", yil);\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği bir yılın artık yıl olup olmadığını kontrol eder. Artık yıl kontrolü için gerekli olan matematiksel koşullar if-else yapısı ile kontrol edilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270836"
  },
  {
    "question": "Kullanıcının girdiği bir sayının 1 ile 100 arasında olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi >= 1 && sayi <= 100) {\n        printf(\"Sayı 1 ile 100 arasındadır.\\n\");\n    } else {\n        printf(\"Sayı 1 ile 100 arasında değildir.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği bir sayının 1 ile 100 arasında olup olmadığını kontrol eder. && operatörü ile iki koşul birden kontrol edilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270875"
  },
  {
    "question": "Bir dizideki elemanların pozitif veya negatif olduğunu kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[5];\n    printf(\"5 adet sayı girin: \");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 0; i < 5; i++) {\n        if (dizi[i] > 0) {\n            printf(\"%d pozitif.\\n\", dizi[i]);\n        } else if (dizi[i] < 0) {\n            printf(\"%d negatif.\\n\", dizi[i]);\n        } else {\n            printf(\"%d sıfır.\\n\", dizi[i]);\n        }\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan 5 adet sayı alır ve bu sayıların her birinin pozitif, negatif veya sıfır olup olmadığını kontrol eder. Her bir eleman için ayrı ayrı if-else yapısı kullanılır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270901"
  },
  {
    "question": "Bir kullanıcıdan alınan yaş değeriyle, kullanıcının hangi yaş grubuna girdiğini belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int yas;\n    printf(\"Yaşınızı girin: \");\n    scanf(\"%d\", &yas);\n\n    if (yas < 0) {\n        printf(\"Geçersiz yaş.\\n\");\n    } else if (yas <= 12) {\n        printf(\"Çocuk.\\n\");\n    } else if (yas <= 19) {\n        printf(\"Genç.\\n\");\n    } else if (yas <= 65) {\n        printf(\"Yetişkin.\\n\");\n    } else {\n        printf(\"Yaşlı.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının yaşını alarak yaş grubunu belirler. Negatif yaş kontrolü de yapılır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270938"
  },
  {
    "question": "Kullanıcının girdiği üç kenar uzunluğuna göre bir üçgenin çeşitlerini (eşkenar, ikizkenar, çeşitkenar) belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    printf(\"Üçgenin kenar uzunluklarını girin: \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    if (a <= 0 || b <= 0 || c <= 0) {\n        printf(\"Geçersiz kenar uzunlukları.\\n\");\n    } else if (a == b && b == c) {\n        printf(\"Eşkenar üçgen.\\n\");\n    } else if (a == b || b == c || a == c) {\n        printf(\"İkizkenar üçgen.\\n\");\n    } else {\n        printf(\"Çeşitkenar üçgen.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan üç kenar uzunluğu alır ve bu kenar uzunluklarına göre üçgenin çeşidini belirler. Negatif değer kontrolü yapılır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.270977"
  },
  {
    "question": "Bir kullanıcının girdiği bir sayının tek mi çift mi olduğunu belirleyen bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    if (sayi % 2 == 0) {\n        printf(\"Sayı çifttir.\\n\");\n    } else {\n        printf(\"Sayı tektir.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcının girdiği bir sayının tek mi çift mi olduğunu kontrol eder. Modül alma işlemi ile kontrol sağlanır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:31.271005"
  },
  {
    "question": "Birden fazla koşul kontrolü yaparken if-else yerine switch-case kullanmanın avantajları nelerdir?",
    "answer": "Switch-case yapısı, tek bir değişkenin birden fazla duruma göre kontrol edilmesi gerektiğinde daha okunabilir ve derli toplu bir yapı sunar. Eğer kontrol edilen koşul sayısı fazlaysa, if-else yapısı karmaşıklaşabilir. Ayrıca, switch-case içinde 'fall-through' özelliği, bir durumdan diğerine geçmeyi kolaylaştırır. Ancak, switch-case sadece tam eşitlik kontrolü yapabildiğinden, aralık kontrolü gibi durumlarda if-else yapısı tercih edilmelidir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.917841"
  },
  {
    "question": "Bir fonksiyonda çok sayıda if-else if yapısı kullanıldığında performansı nasıl etkiler ve bunu nasıl optimize edebiliriz?",
    "answer": "Çok sayıda if-else if yapısı, kodun okunabilirliğini zorlaştırabilir ve performans kaybına neden olabilir. Bunun yerine, koşulları bir dizi içinde saklayıp her koşulu kontrol eden bir fonksiyon yazabiliriz. Ayrıca, koşul kontrolünü bir harita yapısı (dictionary) ile gerçekleştirmek, belirli bir durumda doğrudan erişim sağlayarak hız kazanımı sunabilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.917900"
  },
  {
    "question": "İç içe if-else yapılarının okunabilirliğini artırmak için neler yapabiliriz?",
    "answer": "İç içe if-else yapılarında kodun okunabilirliğini artırmak için, her bir koşulu ayrı bir fonksiyona dönüştürmek faydalı olabilir. Ayrıca, her bir koşulun ne yaptığını açıklayan yorum satırları eklemek ve mantıksal operatörleri kullanarak koşulları birleştirmek de okunabilirliği artırır. Örneğin, 'if (x > 0 && y > 0)' şeklinde bir yapı, iç içe if kullanımına göre daha anlaşılırdır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.917929"
  },
  {
    "question": "Bir koşul kontrolü yapılan kod parçasının karmaşıklığını azaltmak için hangi teknikleri kullanabiliriz?",
    "answer": "Karmaşıklığı azaltmak için 'early return' tekniğini kullanabiliriz. Bu, fonksiyonun başında geçerli olmayan durumlar için hemen çıkmamızı sağlar. Ayrıca, koşulları fonksiyonlar halinde ayırmak, kodun okunabilirliğini ve bakımını kolaylaştırır. 'Ternary operator' kullanımı da, basit koşul kontrollerini daha kısa bir şekilde ifade etmemize yardımcı olabilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.917959"
  },
  {
    "question": "Karmaşık bir kontrol yapısı içeren bir algoritmanın test edilebilirliğini artırmak için nasıl bir yaklaşım benimsemeliyiz?",
    "answer": "Karmaşık kontrol yapıları, birim testleri ile daha iyi bir şekilde test edilebilir. Her bir koşulun ayrı bir fonksiyon haline getirilmesi, bu koşulların ayrı ayrı test edilmesine olanak tanır. Ayrıca, koşul sonuçlarını belirlemek için farklı veri setleri ile test senaryoları oluşturmak, hataların tespitini kolaylaştırır. Mock nesneleri kullanarak dış bağımlılıkları izole etmek de faydalı olacaktır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.917991"
  },
  {
    "question": "Bir programda belirli bir durumu kontrol ederken hem hata durumunu hem de normal akışı yönetmek için ne tür bir yapı kullanabiliriz?",
    "answer": "Hata yönetimi için 'try-catch' yapısını kullanabiliriz. Bu yapı, hata meydana geldiğinde normal akışın kesintiye uğramadan devam etmesine olanak tanır. Örneğin, bir dosya okuma işlemi sırasında bir hata oluşursa, catch bloğu ile bu durumu ele alabiliriz. Ayrıca, durumları kontrol etmek için if-else yapısını kullanarak, hem normal akışı hem de hata durumunu yönetebiliriz.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.918027"
  },
  {
    "question": "Koşul ifadelerini optimize etmenin en etkili yollarından biri nedir?",
    "answer": "Koşul ifadelerini optimize etmenin en etkili yollarından biri, 'short-circuit evaluation' yani kısa devre değerlendirmesidir. Bu, ilk koşul sağlandığında diğer koşulları kontrol etmemeyi sağlar. Örneğin, 'if (a && b)' ifadesinde, a yanlışsa b'yi kontrol etmez. Bu yaklaşım, gereksiz hesaplamalardan kaçınarak performansı artırabilir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.918049"
  },
  {
    "question": "Birden fazla koşulu kontrol etmek için boolean değişkenlerini kullanmanın avantajları ve dezavantajları nelerdir?",
    "answer": "Boolean değişkenleri, koşul kontrolünü daha okunabilir hale getirir ve karmaşıklığı azaltır. Ancak, bu değişkenlerin yanlış kullanımı, kodun mantığını zorlaştırabilir. Örneğin, bir boolean değişkeni 'isReady' olarak adlandırıldığında, bu değişkenin hangi durumları temsil ettiğini anlamak zor olabilir. Bu nedenle, değişken adlarının dikkatli seçilmesi önemlidir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.918080"
  },
  {
    "question": "Aynı koşulu birden fazla if ifadesinde kullanmak yerine nasıl daha etkili bir yapı oluşturabiliriz?",
    "answer": "Aynı koşulu birden fazla if ifadesinde kullanmak yerine, koşulu bir değişkene atayarak tekrar kullanabiliriz. Bu, kodun hem okunabilirliğini artırır hem de performansı iyileştirir. Örneğin: 'bool condition = (x > y); if (condition) { ... } else if (condition) { ... }' şeklinde bir yapı, koşulu sadece bir kez kontrol eder.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.918112"
  },
  {
    "question": "Switch-case yapısının hangi durumlarda kullanılmaması gerektiğini düşünüyorsunuz?",
    "answer": "Switch-case yapısı, sadece belirli türdeki verilerle çalıştığında etkili bir çözümdür. Ancak, aralık kontrolü gibi durumlarda ya da karmaşık mantık gerektiren koşullarda kullanılmamalıdır. Örneğin, bir değişkenin belirli bir aralıkta olup olmadığını kontrol ederken if-else yapısını tercih etmek daha uygun olacaktır. Ayrıca, switch-case yapısı, sadece int veya enum gibi belirli veri türleri ile sınırlıdır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:23:54.918136"
  },
  {
    "question": "Bir programda kullanıcıdan alınan bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden bir fonksiyonu inceleyin. Kod, gereksiz tekrarlara sahip ve performans açısından optimize edilmeli.",
    "answer": "Aşağıdaki gibi bir kontrol yapısı kullanılarak daha optimize bir hale getirilebilir:\n\n```c\nvoid kontrol(int sayi) {\n    if (sayi > 0) {\n        printf(\"Pozitif\");\n    } else if (sayi < 0) {\n        printf(\"Negatif\");\n    } else {\n        printf(\"Sıfır\");\n    }\n}\n```\n\nBu yapı, gereksiz tekrarları önler ve okunabilirliği artırır. Ayrıca, fonksiyonu çağırmadan önce sayının geçerli olup olmadığını kontrol etmeyi unutmamak da önemlidir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716173"
  },
  {
    "question": "Bir kullanıcı giriş sisteminde, kullanıcı adının ve şifresinin doğrulanması için kullanılan bir kontrol yapısını inceleyin. Kod, kullanıcı adının boş olup olmadığını kontrol etmeden doğrudan işlem yapıyor. Nasıl iyileştirilebilir?",
    "answer": "Aşağıdaki şekilde, kullanıcı adı ve şifrenin doğruluğunu kontrol eden bir yapı oluşturulabilir:\n\n```c\nvoid girisYap(char *kullaniciAdi, char *sifre) {\n    if (strlen(kullaniciAdi) == 0) {\n        printf(\"Kullanıcı adı boş olamaz.\");\n        return;\n    }\n    if (strlen(sifre) == 0) {\n        printf(\"Şifre boş olamaz.\");\n        return;\n    }\n    // Kullanıcı adı ve şifre kontrolü\n}\n```\n\nBu kontrol, kullanıcı giriş işlemlerinin güvenliğini artırır ve kullanıcı deneyimini iyileştirir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716247"
  },
  {
    "question": "Hava durumu uygulamanızda, sıcaklık aralıklarına göre kıyafet önerileri sunan bir kontrol yapısını inceleyin. Kodda çok fazla if-else yapısı var. Bunun yerine nasıl daha verimli hale getirilebilir?",
    "answer": "Switch-case yapısı kullanarak kontrol yapısını optimize edebiliriz:\n\n```c\nvoid kiyafetOner(int sicaklik) {\n    switch (sicaklik) {\n        case -10 ... 0:\n            printf(\"Kalın kaban giyin.\");\n            break;\n        case 1 ... 15:\n            printf(\"Hafif mont giyin.\");\n            break;\n        case 16 ... 25:\n            printf(\"Tişört giyin.\");\n            break;\n        default:\n            printf(\"Sıcak havalar için şort öneririm.\");\n    }\n}\n```\n\nBu yapı, okunabilirliği artırır ve mantıksal akışı daha net hale getirir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716299"
  },
  {
    "question": "Bir e-ticaret sistemindeki ürün fiyatlarının indirimli fiyatlarını hesaplayan bir kontrol yapısını inceleyin. Kodda çok fazla tekrarlayan hesaplama var. Nasıl iyileştirilebilir?",
    "answer": "Tekrarlayan hesaplamalar için ayrı bir fonksiyon tanımlamak daha verimli olacaktır:\n\n```c\nfloat indirimHesapla(float fiyat, float indirimOrani) {\n    return fiyat - (fiyat * (indirimOrani / 100));\n}\n\nvoid urunFiyatHesapla(float fiyat, float indirimOrani) {\n    float indirimliFiyat = indirimHesapla(fiyat, indirimOrani);\n    printf(\"İndirimli fiyat: %.2f\", indirimliFiyat);\n}\n```\n\nBu yapı, hesaplamaların merkezi bir yerde yapılmasını sağlar ve kodun bakımını kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716343"
  },
  {
    "question": "Bir oyun programında düşmanın hareketlerini kontrol eden bir yapıyı inceleyin. Kodda çok fazla if-else yapısı var ve okunabilirliği azaltıyor. Bunu nasıl iyileştirebilirsiniz?",
    "answer": "Durum makineleri kullanarak kodun yapısını iyileştirebiliriz:\n\n```c\ntypedef enum { SOL, SAG, YUKARI, ASAGI } Hareket;\n\nvoid dusmanHareket(Hareket hareket) {\n    switch (hareket) {\n        case SOL:\n            // sola hareket et\n            break;\n        case SAG:\n            // sağa hareket et\n            break;\n        case YUKARI:\n            // yukarı hareket et\n            break;\n        case ASAGI:\n            // aşağı hareket et\n            break;\n    }\n}\n```\n\nBu yapı, kodu daha modüler hale getirir ve yeni hareket türleri eklemeyi kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716387"
  },
  {
    "question": "Bir not hesaplama sisteminde, öğrencinin notunu harf notuna çeviren bir kontrol yapısını inceleyin. Kodda tekrar eden ifadeler var. Bunu nasıl iyileştirebilirsiniz?",
    "answer": "Harf notlarını belirlemek için bir fonksiyon kullanarak kodu daha temiz hale getirebiliriz:\n\n```c\nchar harfNotu(int not) {\n    if (not >= 90)\n        return 'A';\n    else if (not >= 80)\n        return 'B';\n    else if (not >= 70)\n        return 'C';\n    else if (not >= 60)\n        return 'D';\n    else\n        return 'F';\n}\n\nvoid notHesapla(int not) {\n    printf(\"Harf notu: %c\", harfNotu(not));\n}\n```\n\nBu, kodun okunabilirliğini artırır ve harf notu hesaplamasını tek bir yerde yapar.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716429"
  },
  {
    "question": "Bir iletişim uygulamasında kullanıcının online veya offline durumunu kontrol eden bir yapı var. Ancak, bu yapı çok karmaşık ve belirsiz. Nasıl iyileştirebilirsiniz?",
    "answer": "Durum makineleri ile durumu tanımlamak ve kontrol etmek daha iyi bir yöntemdir:\n\n```c\ntypedef enum { ONLINE, OFFLINE } Durum;\n\nvoid durumKontrol(Durum durum) {\n    switch (durum) {\n        case ONLINE:\n            printf(\"Kullanıcı çevrimiçi.\");\n            break;\n        case OFFLINE:\n            printf(\"Kullanıcı çevrimdışı.\");\n            break;\n    }\n}\n```\n\nBu yapı, durum kontrolünü daha net ve anlaşılır hale getirir.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716470"
  },
  {
    "question": "Bir banka sisteminde hesap türlerini kontrol eden bir yapı bulunuyor. Farklı hesap türlerine göre farklı işlemler yapmak gerekiyor. Bu yapıyı nasıl iyileştirebilirsiniz?",
    "answer": "Hesap türlerini bir enum ile tanımlayarak ve her hesap türü için ayrı bir fonksiyon oluşturarak daha düzenli bir yapı elde edebiliriz:\n\n```c\ntypedef enum { TASARRUF, VADESIZ, VADALI } HesapTuru;\n\nvoid hesapIslem(HesapTuru hesap) {\n    switch (hesap) {\n        case TASARRUF:\n            // Tasarruf hesabı işlemleri\n            break;\n        case VADESIZ:\n            // Vadesiz hesap işlemleri\n            break;\n        case VADALI:\n            // Vadeli hesap işlemleri\n            break;\n    }\n}\n```\n\nBu yapı, yeni hesap türleri eklemeyi ve mevcut yapıyı yönetmeyi kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716548"
  },
  {
    "question": "Bir chat uygulamasında mesajların tipine göre farklı işlemler yapılması gerekiyor. Ancak mevcut kontrol yapısı çok karmaşık ve hatalara açık. Bunu nasıl iyileştirebilirsiniz?",
    "answer": "Mesaj türlerini enum ile tanımlayıp her bir tür için ayrı bir fonksiyon yazarak kodu daha düzenli hale getirebiliriz:\n\n```c\ntypedef enum { METIN, GORUNTU, DOSYA } MesajTuru;\n\nvoid mesajIslem(MesajTuru tur) {\n    switch (tur) {\n        case METIN:\n            // Metin mesajı işleme\n            break;\n        case GORUNTU:\n            // Görüntü mesajı işleme\n            break;\n        case DOSYA:\n            // Dosya mesajı işleme\n            break;\n    }\n}\n```\n\nBu yapı, kodun modülerliğini artırır ve mesaj türlerine yeni özellikler eklemeyi kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "control_structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Kontrol yapıları",
    "timestamp": "2025-06-01T14:24:39.716593"
  },
  {
    "question": "Kullanıcının girdiği iki sayının toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "İşte iki sayının toplamını hesaplayan bir fonksiyonun örneği: \n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n    int toplam = toplama(sayi1, sayi2);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n``` \nBu kod, kullanıcıdan iki sayı alır ve bunların toplamını hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547010"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıda bir sayının faktöriyelini hesaplayan bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d! = %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n``` \nBu kod, girilen sayının faktöriyelini hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547047"
  },
  {
    "question": "Bir dizinin elemanlarının ortalamasını hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıda bir dizinin elemanlarının ortalamasını hesaplayan fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nfloat ortalama(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int dizi[5];\n    printf(\"5 adet sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Ortalama: %.2f\\n\", ortalama(dizi, 5));\n    return 0;\n}\n``` \nBu kod, kullanıcıdan 5 sayı alır ve bunların ortalamasını hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547069"
  },
  {
    "question": "Bir sayının asal olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "Aşağıda bir sayının asal olup olmadığını kontrol eden bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint asalMi(int n) {\n    if (n < 2) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (asalMi(sayi)) {\n        printf(\"%d asal bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n``` \nBu kod, kullanıcıdan bir sayı alır ve asal olup olmadığını kontrol eder.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547092"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıda bir stringin uzunluğunu hesaplayan fonksiyon örneği vardır:\n\n```c\n#include <stdio.h>\n\nint stringUzunlugu(char str[]) {\n    int uzunluk = 0;\n    while (str[uzunluk] != '\\0') {\n        uzunluk++;\n    }\n    return uzunluk;\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"String uzunluğu: %d\\n\", stringUzunlugu(str));\n    return 0;\n}\n``` \nBu kod, kullanıcıdan bir string alır ve uzunluğunu hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547111"
  },
  {
    "question": "Kullanıcının girdiği bir sayının karesini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıda bir sayının karesini hesaplayan bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint kare(int n) {\n    return n * n;\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d sayısının karesi: %d\\n\", sayi, kare(sayi));\n    return 0;\n}\n``` \nBu kod, kullanıcıdan bir sayı alır ve karesini hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547133"
  },
  {
    "question": "Bir dizideki en büyük sayıyı bulan bir fonksiyon yazın.",
    "answer": "Aşağıda bir dizideki en büyük sayıyı bulan fonksiyonun örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int dizi[5];\n    printf(\"5 adet sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"En büyük sayı: %d\\n\", enBuyuk(dizi, 5));\n    return 0;\n}\n``` \nBu kod, kullanıcıdan 5 sayı alır ve en büyük olanını bulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547154"
  },
  {
    "question": "Dört işlem yapan bir fonksiyon yazın (toplama, çıkarma, çarpma, bölme).",
    "answer": "Aşağıda dört işlem yapan bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid dörtIslem(int a, int b) {\n    printf(\"Toplama: %d\\n\", a + b);\n    printf(\"Çıkarma: %d\\n\", a - b);\n    printf(\"Çarpma: %d\\n\", a * b);\n    if (b != 0) {\n        printf(\"Bölme: %.2f\\n\", (float)a / b);\n    } else {\n        printf(\"Bölme: Tanımsız (sayı sıfır)\\n\");\n    }\n}\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &sayi1, &sayi2);\n    dörtIslem(sayi1, sayi2);\n    return 0;\n}\n``` \nBu kod, kullanıcıdan iki sayı alır ve dört işlemi gerçekleştirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547182"
  },
  {
    "question": "Bir karakterin ASCII değerini dönen bir fonksiyon yazın.",
    "answer": "Aşağıda bir karakterin ASCII değerini dönen fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint asciiDeğeri(char c) {\n    return (int)c;\n}\n\nint main() {\n    char karakter;\n    printf(\"Bir karakter girin: \");\n    scanf(\" %c\", &karakter);\n    printf(\"'%c' karakterinin ASCII değeri: %d\\n\", karakter, asciiDeğeri(karakter));\n    return 0;\n}\n``` \nBu kod, kullanıcıdan bir karakter alır ve o karakterin ASCII değerini döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:10.547202"
  },
  {
    "question": "Aşağıdaki kod parçasını tamamlayın. Kullanıcıdan iki sayı alarak bunların toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sayi1, sayi2;\n    printf(\"Birinci sayıyı girin: \");\n    scanf(\"%d\", &sayi1);\n    printf(\"İkinci sayıyı girin: \");\n    scanf(\"%d\", &sayi2);\n    printf(\"Toplam: %d\\n\", toplama(sayi1, sayi2));\n    return 0;\n}\n\n// Bu kod, kullanıcıdan iki tam sayı alır ve toplamını hesaplamak için 'toplama' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910194"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamlayın. Bir dizinin elemanlarının ortalamasını hesaplayan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nfloat ortalama(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int sayilar[5] = {10, 20, 30, 40, 50};\n    printf(\"Ortalama: %.2f\\n\", ortalama(sayilar, 5));\n    return 0;\n}\n\n// Bu kod, bir dizinin elemanlarının ortalamasını hesaplamak için 'ortalama' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910269"
  },
  {
    "question": "Aşağıdaki kodda eksik olan fonksiyonu tamamlayın. Verilen bir sayının faktöriyelini hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    printf(\"%d sayısının faktöriyeli: %d\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir sayı alır ve bu sayının faktöriyelini hesaplamak için 'faktoriyel' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910325"
  },
  {
    "question": "Aşağıdaki kodda eksik olan fonksiyonu tamamlayın. Bir dizinin en büyük elemanını bulan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int sayilar[5] = {3, 7, 2, 9, 5};\n    printf(\"En büyük sayı: %d\\n\", enBuyuk(sayilar, 5));\n    return 0;\n}\n\n// Bu kod, bir dizinin en büyük elemanını bulmak için 'enBuyuk' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910378"
  },
  {
    "question": "Aşağıdaki kodu tamamlayın. Kullanıcıdan alınan bir kelimenin tersini yazdıran bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersYazdir(char kelime[]) {\n    int uzunluk = strlen(kelime);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        printf(\"%c\", kelime[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n    tersYazdir(kelime);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir kelime alır ve o kelimenin tersini yazdırmak için 'tersYazdir' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910439"
  },
  {
    "question": "Aşağıdaki kodda eksik olan fonksiyonu tamamlayın. Bir dizi içerisindeki negatif sayıları sayan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nint negatifSayilariSay(int dizi[], int boyut) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] < 0) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int sayilar[5] = {-1, 2, -3, 4, -5};\n    printf(\"Negatif sayıların adedi: %d\\n\", negatifSayilariSay(sayilar, 5));\n    return 0;\n}\n\n// Bu kod, bir dizideki negatif sayıların sayısını bulmak için 'negatifSayilariSay' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910497"
  },
  {
    "question": "Aşağıdaki kod parçasındaki fonksiyonu tamamlayın. Verilen bir sayının asal olup olmadığını kontrol eden bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nint asalMi(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n    if (asalMi(sayi)) {\n        printf(\"%d asal bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir sayı alır ve asal olup olmadığını kontrol etmek için 'asalMi' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910575"
  },
  {
    "question": "Aşağıdaki kodda eksik olan fonksiyonu tamamlayın. Bir dizinin elemanlarını sıralayan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[i] > dizi[j]) {\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int sayilar[5] = {5, 3, 8, 1, 2};\n    sirala(sayilar, 5);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, bir dizinin elemanlarını sıralamak için 'sirala' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910625"
  },
  {
    "question": "Aşağıdaki kodda eksik olan fonksiyonu tamamlayın. İki dizinin kesişim kümesini bulan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nvoid kesisim(int dizi1[], int boyut1, int dizi2[], int boyut2) {\n    printf(\"Kesişim kümesi: \");\n    for (int i = 0; i < boyut1; i++) {\n        for (int j = 0; j < boyut2; j++) {\n            if (dizi1[i] == dizi2[j]) {\n                printf(\"%d \", dizi1[i]);\n                break;\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int dizi1[5] = {1, 2, 3, 4, 5};\n    int dizi2[5] = {4, 5, 6, 7, 8};\n    kesisim(dizi1, 5, dizi2, 5);\n    return 0;\n}\n\n// Bu kod, iki dizinin kesişim kümesini bulmak için 'kesisim' fonksiyonunu kullanır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:25:49.910680"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, iki sayıyı toplamalı ve sonucu döndürmeli. int add(int a, int b);",
    "answer": "int add(int a, int b) {\n    return a + b;\n}\n\n// Bu fonksiyon, iki tam sayıyı alır ve bunların toplamını döndürür. Örneğin, add(3, 5) çağrıldığında 8 döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283393"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir dizinin elemanlarının ortalamasını hesaplamalı. float average(int arr[], int size);",
    "answer": "float average(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return (float)sum / size;\n}\n\n// Bu fonksiyon, bir tam sayı dizisi ve dizinin boyutunu alır. Dizi elemanlarının toplamını hesapladıktan sonra, ortalamayı döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283448"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir string'in uzunluğunu döndürmeli. int string_length(char str[]);",
    "answer": "int string_length(char str[]) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n\n// Bu fonksiyon, bir karakter dizisi (string) alır ve dizinin sonuna kadar giderek uzunluğunu hesaplar. Örneğin, string_length(\"Merhaba\") 7 döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283481"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, iki string'i birleştirmeli. void concatenate(char str1[], char str2[], char result[]);",
    "answer": "void concatenate(char str1[], char str2[], char result[]) {\n    int i, j;\n    for (i = 0; str1[i] != '\\0'; i++) {\n        result[i] = str1[i];\n    }\n    for (j = 0; str2[j] != '\\0'; j++) {\n        result[i + j] = str2[j];\n    }\n    result[i + j] = '\\0';\n}\n\n// Bu fonksiyon, iki string alır ve bunları 'result' dizisine birleştirir. Sonuç dizisinin sonuna null karakter eklenir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283536"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, verilen bir sayının faktöriyelini hesaplamalı. int factorial(int n);",
    "answer": "int factorial(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * factorial(n - 1);\n}\n\n// Bu fonksiyon, bir tam sayı alır ve faktöriyelini hesaplar. Örneğin, factorial(5) 120 döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283578"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, iki tarih arasındaki gün sayısını hesaplamalı. int days_between(int day1, int month1, int year1, int day2, int month2, int year2);",
    "answer": "int days_between(int day1, int month1, int year1, int day2, int month2, int year2) {\n    struct tm date1 = {0}, date2 = {0};\n    date1.tm_year = year1 - 1900;\n    date1.tm_mon = month1 - 1;\n    date1.tm_mday = day1;\n    date2.tm_year = year2 - 1900;\n    date2.tm_mon = month2 - 1;\n    date2.tm_mday = day2;\n\n    double seconds = difftime(mktime(&date2), mktime(&date1));\n    return seconds / (60 * 60 * 24);\n}\n\n// Bu fonksiyon, iki tarih alır ve aralarındaki gün sayısını hesaplar. `difftime` ile iki tarih arasındaki farkı saniye cinsinden bulup, 24 saate bölerek gün sayısını döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283632"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir dizi içerisindeki en büyük sayıyı bulmalı. int max_in_array(int arr[], int size);",
    "answer": "int max_in_array(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// Bu fonksiyon, bir tam sayı dizisi alır ve dizideki en büyük elemanı bulur. En büyük elemanı döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283669"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir string içerisinde belirli bir karakterin sayısını döndürmeli. int count_char(char str[], char c);",
    "answer": "int count_char(char str[], char c) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == c) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Bu fonksiyon, bir string ve bir karakter alır. String içerisinde belirtilen karakterin kaç kez tekrarlandığını sayar ve döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283709"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir sayının asal olup olmadığını kontrol etmeli. int is_prime(int n);",
    "answer": "int is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Bu fonksiyon, bir tam sayı alır ve sayının asal olup olmadığını kontrol eder. Asal ise 1, değilse 0 döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283741"
  },
  {
    "question": "Aşağıdaki eksik fonksiyonu tamamla. Fonksiyon, bir dizinin tersini almalı. void reverse_array(int arr[], int size);",
    "answer": "void reverse_array(int arr[], int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - 1 - i];\n        arr[size - 1 - i] = temp;\n    }\n}\n\n// Bu fonksiyon, bir tam sayı dizisini alır ve dizinin elemanlarını tersine çevirir. İlk yarı ile son yarı elemanları arasında yer değişimi yaparak ters çevirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:26:29.283774"
  },
  {
    "question": "Bir fonksiyon, iki sayıyı toplamak için tasarlandı ancak her zaman sıfır dönüyor. Nedenini bul ve düzelt.",
    "answer": "Bu hatanın nedeni, toplama işlemi yerine değerlerin yanlışlıkla çarpılıyor olması olabilir. Fonksiyonun içinde toplam işlemi şöyle olmalıdır: 'return a + b;' şeklinde düzeltilmelidir. Örnek kod: \n\n```c\nint toplama(int a, int b) {\n    return a + b;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108444"
  },
  {
    "question": "Bir dizi içerisindeki maksimum sayıyı bulmak için yazılan fonksiyon, her seferinde dizinin ilk elemanını döndürüyor. Nedenini analiz et.",
    "answer": "Fonksiyonun içinde döngü ile dizinin elemanlarını kontrol etmek yerine yalnızca ilk elemana referans verilmiş olabilir. Düzeltmek için tüm elemanları kontrol eden bir döngü eklemek gereklidir. Örnek düzeltme: \n\n```c\nint maksimumBul(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108498"
  },
  {
    "question": "Bir fonksiyon, bir karakter dizisini tersine çevirmek için yazıldı ama çıktıda boş bir dizi döndürüyor. Hatanın kaynağını bul.",
    "answer": "Fonksiyon içinde yeni bir dizi oluşturulmadan yalnızca mevcut dizinin referansı kullanılmaya çalışılıyor olabilir. Yeni bir dizi tanımlanmalı ve ters çevrilen veriler oraya aktarılmalıdır. Örnek düzeltme: \n\n```c\nvoid tersCevir(char *dizi) {\n    int uzunluk = strlen(dizi);\n    char ters[uzunluk + 1];\n    for (int i = 0; i < uzunluk; i++) {\n        ters[i] = dizi[uzunluk - 1 - i];\n    }\n    ters[uzunluk] = '\\0';\n    printf(\"Ters: %s\\n\", ters);\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108563"
  },
  {
    "question": "Bir fonksiyon, faktöriyel hesaplamak için yazıldı ancak negatif bir sayı verildiğinde sonsuz döngüye giriyor. Sorunu çöz.",
    "answer": "Fonksiyon negatif sayılar için bir kontrol yapmıyor olabilir. Negatif sayılar için hemen bir hata mesajı döndürülmeli. Düzeltme: \n\n```c\nint faktoriyel(int n) {\n    if (n < 0) {\n        printf(\"Negatif sayı giremezsiniz!\\n\");\n        return -1;\n    }\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108598"
  },
  {
    "question": "Bir fonksiyon, iki sayıyı karşılaştırmak için yazıldı ama her zaman 'eşit' sonuç döndürüyor. Analiz et ve düzelt.",
    "answer": "Fonksiyon içinde karşılaştırma işlemi doğru yapılmıyor olabilir; muhtemelen yanlışlıkla atama işlemi kullanılmış. Düzeltmek için '==' yerine '=' kullanıldığı kontrol edilmeli ve düzeltme yapılmalıdır. Örnek düzeltme: \n\n```c\nconst char* kucuktenBuyuge(int a, int b) {\n    if (a < b) return \"a küçüktür\";\n    else if (a > b) return \"b küçüktür\";\n    return \"eşit\";\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108635"
  },
  {
    "question": "Bir fonksiyon, bir sayının asal olup olmadığını kontrol ederken her zaman 'asal değil' döndürüyor. Hatanın kaynağını bul.",
    "answer": "Fonksiyonun içindeki döngü yapısı hatalı olabilir, çünkü başlangıç ve son koşulları yanlış ayarlanmış. Kontroller düzgün şekilde yapılmalı. Düzeltme: \n\n```c\nint asalMi(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108679"
  },
  {
    "question": "Bir dizinin elemanlarını toplamak için yazılan fonksiyon, her seferinde dizinin son elemanını döndürüyor. Bunu düzelt.",
    "answer": "Fonksiyon içerisinde toplam işlemi yerine son eleman değerini tutan bir değişken kullanılıyor olabilir. Tüm elemanları toplamak için toplam değişkeni tanımlanmalı ve döngü ile toplanmalıdır. Örnek düzeltme: \n\n```c\nint diziTopla(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108711"
  },
  {
    "question": "Bir fonksiyon, bir diziyi sıralamak için yazıldı ama her seferinde yalnızca dizinin ilk iki elemanını değiştiriyor. Nedenini araştır.",
    "answer": "Sıralama algoritması eksik veya hatalı olabilir, muhtemelen sadece bir kez karşılaştırma yapılıyor. Doğru bir sıralama algoritması uygulanmalı. Bubblesort gibi basit bir yöntemle düzeltilebilir. Örnek düzeltme: \n\n```c\nvoid sirala(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108747"
  },
  {
    "question": "Bir fonksiyon, dizinin elemanlarını birleştirip bir dize döndürmesi gerekirken boş bir dize döndürüyor. Sorunu düzelt.",
    "answer": "Fonksiyon içinde birleştirme işlemi yapılmıyor olabilir, dizinin elemanları birleştirilip yeni bir dize oluşturulmaya çalışılmalı. Örnek düzeltme: \n\n```c\nvoid birlestir(char *sonuc, char dizi[][20], int boyut) {\n    sonuc[0] = '\\0'; // Boş bir dize başlat\n    for (int i = 0; i < boyut; i++) {\n        strcat(sonuc, dizi[i]);\n    }\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108779"
  },
  {
    "question": "Bir fonksiyon, bir tam sayının pozitif olup olmadığını kontrol ediyor ama her durumda 'pozitif' döndürüyor. Nedenini bul ve düzelt.",
    "answer": "Fonksiyonun kontrol şartları hatalı olabilir; muhtemelen '>' operatörü yerine '!=' kullanılmış. Düzeltmek için koşullar netleştirilmeli. Örnek düzeltme: \n\n```c\nconst char* pozitifMi(int n) {\n    if (n > 0) return \"Pozitif\";\n    else if (n < 0) return \"Negatif\";\n    return \"Sıfır\";\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:21.108816"
  },
  {
    "question": "Fonksiyonda yanlışlıkla geçersiz bir işaretçi kullanıldığında ne olur?",
    "answer": "Geçersiz bir işaretçi kullanıldığında program çökebilir veya beklenmeyen sonuçlar verebilir. Örneğin:\n\n```c\nvoid fonksiyon(int *ptr) {\n    printf(\"Değer: %d\", *ptr);\n}\n\nint main() {\n    int *p = NULL;\n    fonksiyon(p);\n    return 0;\n}\n```\nBu kodda 'p' işaretçisi NULL olduğu için 'fonksiyon' çağrısı sırasında bellek hatası alacağız. Bunu önlemek için işaretçi kontrol edilmelidir:\n\n```c\nvoid fonksiyon(int *ptr) {\n    if (ptr != NULL) {\n        printf(\"Değer: %d\", *ptr);\n    } else {\n        printf(\"Geçersiz işaretçi!\");\n    }\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.969839"
  },
  {
    "question": "Fonksiyon içinde statik bir değişkenin kullanımı sonucunda ne gibi sorunlar yaşanabilir?",
    "answer": "Statik bir değişken, değeri fonksiyonun her çağrısında korunur. Ancak bu bazen beklenmeyen sonuçlar doğurabilir. Örneğin:\n\n```c\nvoid sayacFonksiyonu() {\n    static int sayac = 0;\n    sayac++;\n    printf(\"Sayac: %d\\n\", sayac);\n}\n\nint main() {\n    for (int i = 0; i < 5; i++) {\n        sayacFonksiyonu();\n    }\n    return 0;\n}\n```\nBu kodda 'sayac' her çağrıda artar. Eğer sayac sıfırlanmak istenirse, statik değişken kullanılmamalıdır. Alternative olarak, sayacı her çağrıda sıfırlamak için global bir değişken ya da dinamik olarak allocate edilmiş bir bellek kullanılabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.969903"
  },
  {
    "question": "Bir fonksiyonun döndürdüğü değerin kullanılmadan önce kontrol edilmemesi ne gibi hatalara yol açar?",
    "answer": "Fonksiyonlardan dönen değerlerin kontrol edilmemesi, programın beklenmedik şekilde davranmasına neden olabilir. Örneğin:\n\n```c\nint böl(int a, int b) {\n    return a / b;\n}\n\nint main() {\n    int sonuc = böl(10, 0);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kodda 'böl' fonksiyonu 0 ile bölünmeye çalışıyor. Bu bir bellek hatasına veya tanımsız davranışa yol açar. Bu tür durumları önlemek için:\n\n```c\nint böl(int a, int b) {\n    if (b == 0) {\n        printf(\"Hata: Sıfır ile bölme!\\n\");\n        return -1; // Hatalı değer döndür\n    }\n    return a / b;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.969964"
  },
  {
    "question": "Fonksiyonun argümanlarının yanlış türde verilmesiyle ilgili bir örnek veriniz.",
    "answer": "Yanlış türde argümanlar verilmesi, tip uyuşmazlığına ve hatalara neden olabilir. Örneğin:\n\n```c\nvoid selamVer(int sayi) {\n    printf(\"Merhaba, sayı: %d\\n\", sayi);\n}\n\nint main() {\n    selamVer(3.14); // Hatalı argüman\n    return 0;\n}\n```\nBurada 'selamVer' fonksiyonu bir tam sayı beklerken ondalıklı bir değer veriliyor. Bu, truncation'a yol açabilir. Doğru türde argüman vermek önemlidir:\n\n```c\nint main() {\n    selamVer((int)3.14); // Cast ile dönüşüm\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970007"
  },
  {
    "question": "Fonksiyonun geçersiz bir dizi indeksine erişimi sonucu ne olur?",
    "answer": "Geçersiz bir dizi indeksi kullanıldığında bellek hatalarına yol açabilir. Örneğin:\n\n```c\nvoid diziYaz(int dizi[], int boyut) {\n    for (int i = 0; i <= boyut; i++) { // Hatalı döngü koşulu\n        printf(\"Dizi[%d]: %d\\n\", i, dizi[i]);\n    }\n}\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    diziYaz(dizi, 5);\n    return 0;\n}\n```\nBu kodda dizi boyutu aşılmıştır ve bu bellek hatasına yol açar. Doğru kullanım:\n\n```c\nvoid diziYaz(int dizi[], int boyut) {\n    for (int i = 0; i < boyut; i++) { // Doğru döngü koşulu\n        printf(\"Dizi[%d]: %d\\n\", i, dizi[i]);\n    }\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970046"
  },
  {
    "question": "Fonksiyon parametrelerinin değiştirilmesi sonucu meydana gelebilecek sorunları açıklayınız.",
    "answer": "Fonksiyon parametreleri varsayılan olarak değeri kopyalar. Ancak işaretçi kullanıldığında orijinal veriler değiştirilebilir. Örneğin:\n\n```c\nvoid degerArtir(int x) {\n    x++;\n}\n\nint main() {\n    int a = 5;\n    degerArtir(a);\n    printf(\"A: %d\\n\", a); // A hala 5\n    return 0;\n}\n```\nBurada 'a' değişkeni değişmez. Ancak işaretçi ile:\n\n```c\nvoid degerArtir(int *x) {\n    (*x)++;\n}\n\nint main() {\n    int a = 5;\n    degerArtir(&a);\n    printf(\"A: %d\\n\", a); // A artık 6\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970087"
  },
  {
    "question": "Fonksiyon içinde tanımlanan bir değişkenin ömrü ve kapsamı hakkında bilgi veriniz.",
    "answer": "Fonksiyon içinde tanımlanan değişkenler, sadece o fonksiyon çağrıldığında var olurlar. Bu değişkenler, fonksiyon tamamlandığında bellekten silinir. Örneğin:\n\n```c\nvoid fonksiyon() {\n    int yerelDegisken = 10;\n    printf(\"Yerel Değişken: %d\\n\", yerelDegisken);\n}\n\nint main() {\n    fonksiyon();\n    // printf(\"Yerel Değişken: %d\\n\", yerelDegisken); // Hata: Erişim dışı\n    return 0;\n}\n```\nYerel değişken 'yerelDegisken' yalnızca 'fonksiyon' içinde geçerlidir. Eğer bu değeri 'main' içinde kullanmak isterseniz, global bir değişken tanımlamalısınız.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970131"
  },
  {
    "question": "Fonksiyon çağrılarında yığın taşması (stack overflow) durumunu açıklayınız.",
    "answer": "Yığın taşması, çok derin veya sonsuz rekürsif fonksiyon çağrıları sonucu meydana gelir. Örneğin:\n\n```c\nvoid sonsuzFonksiyon() {\n    sonsuzFonksiyon(); // Sonsuz döngü\n}\n\nint main() {\n    sonsuzFonksiyon();\n    return 0;\n}\n```\nBu kod, yığın taşması hatasına neden olacaktır. Rekürsif fonksiyonlar kullanıyorsanız, bir çıkış koşulu belirlemek önemlidir:\n\n```c\nvoid rekursifFonksiyon(int n) {\n    if (n == 0) return;\n    rekursifFonksiyon(n - 1);\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970172"
  },
  {
    "question": "C dilinde fonksiyon adresinin yanlış kullanımı sonucunda ne olabilir?",
    "answer": "Fonksiyon adreslerinin yanlış kullanımı, programda beklenmedik davranışlara yol açabilir. Örneğin:\n\n```c\nvoid selam() {\n    printf(\"Merhaba!\\n\");\n}\n\nint main() {\n    void (*fonksiyonPtr)() = NULL;\n    fonksiyonPtr(); // Hata: NULL işaretçi üzerinden çağrı\n    return 0;\n}\n```\nBurada 'fonksiyonPtr' NULL olduğu için çağrı yapılamaz. Doğru bir fonksiyon adresi atanmalıdır:\n\n```c\nint main() {\n    fonksiyonPtr = selam;\n    fonksiyonPtr(); // Artık doğru çalışır\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:27:52.970210"
  },
  {
    "question": "Fonksiyon nedir ve neden kullanılır?",
    "answer": "Fonksiyon, belirli bir görevi yerine getiren, adlandırılmış bir kod bloğudur. Fonksiyonlar, kodun yeniden kullanılabilirliğini artırır, programı modüler hale getirir ve daha okunabilir olmasını sağlar. Örneğin, bir matematiksel işlem yapan bir fonksiyon tanımlayarak bu işlemi birden fazla yerde kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182263"
  },
  {
    "question": "C dilinde bir fonksiyon nasıl tanımlanır?",
    "answer": "C dilinde bir fonksiyon tanımlamak için önce dönüş türü, ardından fonksiyon adı ve parantez içinde parametreler belirtilir. Örneğin: `int toplama(int a, int b) { return a + b; }` bu, iki tam sayıyı toplayarak sonucu döndüren bir fonksiyondur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182299"
  },
  {
    "question": "Fonksiyona parametre nasıl geçilir?",
    "answer": "Fonksiyona parametre geçmek, fonksiyon tanımında parantez içinde değişken isimleri belirleyerek yapılır. Örneğin, `toplama(int a, int b)` fonksiyonunda 'a' ve 'b', fonksiyona geçirilen parametrelerdir. Fonksiyon çağrıldığında, bu parametreler belirtilen değerlerle doldurulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182315"
  },
  {
    "question": "Dönüş türü olmayan bir fonksiyon nasıl yazılır?",
    "answer": "Dönüş türü olmayan bir fonksiyon yazmak için `void` anahtar kelimesi kullanılır. Örneğin: `void selamla() { printf(\"Merhaba!\"); }` fonksiyonu, çağrıldığında 'Merhaba!' mesajını ekrana yazdırır, ancak değer döndürmez.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182337"
  },
  {
    "question": "Fonksiyon nasıl çağrılır?",
    "answer": "Fonksiyonu çağırmak için fonksiyon adını ve parantez içinde gerekli parametreleri yazmamız yeterlidir. Örneğin, `int sonuc = toplama(5, 10);` ifadesi, 'toplama' fonksiyonunu çağırarak 5 ve 10 değerlerini geçirir ve sonucu 'sonuc' değişkenine atar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182352"
  },
  {
    "question": "Fonksiyonlar arasında nasıl veri paylaşımı yapılır?",
    "answer": "Fonksiyonlar arasında veri paylaşımı, global değişkenler kullanılarak veya fonksiyon çağrısı sırasında parametre geçilerek yapılabilir. Ancak global değişkenlerin kullanımı kodun karmaşıklaşmasına yol açabilir, bu yüzden mümkün olduğunca kaçınılmalıdır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182371"
  },
  {
    "question": "Bir fonksiyonda default parametre değeri nasıl tanımlanır?",
    "answer": "C dilinde doğrudan default parametre değeri tanımlama imkanı yoktur, fakat bir işlevi çağırırken parametre verilmediğinde, bunu kontrol eden bir fonksiyon yazılabilir. Örneğin, iki parametre alan bir fonksiyonu, ikincisi için varsayılan bir değer kullanarak çağırabilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182391"
  },
  {
    "question": "Fonksiyonların aşırı yüklenmesi nedir?",
    "answer": "Fonksiyon aşırı yüklenmesi, aynı isimde fakat farklı parametre listelerine sahip birden fazla fonksiyon yazma işlemidir. C dilinde bu durum desteklenmezken, C++ gibi dillerde mümkündür. Bu, farklı türde veya sayıda parametre ile aynı işlemi gerçekleştirmek için kullanılır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182408"
  },
  {
    "question": "Rekürsif fonksiyon nedir?",
    "answer": "Rekürsif fonksiyon, kendisini çağıran bir fonksiyondur. Örneğin, faktöriyel hesaplamak için kullanılan bir fonksiyon: `int faktoriyel(int n) { return (n == 0) ? 1 : n * faktoriyel(n - 1); }` burada fonksiyon, 'n' değeri 0’a ulaşana kadar kendisini çağırır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182426"
  },
  {
    "question": "Fonksiyonları ve değişkenleri yerel ve global olarak tanımlamak ne anlama geliyor?",
    "answer": "Yerel değişkenler, yalnızca tanımlandıkları fonksiyonda geçerlidir ve fonksiyon sona erdiğinde yok olurlar. Global değişkenler ise programın herhangi bir yerinden erişilebilir ve programın sona erdiği ana kadar var olur. Fonksiyonlar yerel değişkenler kullanarak belirli işlemleri sınırlı bir alanda tutabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182451"
  },
  {
    "question": "Fonksiyonların geri dönüş değerini nasıl kullanıyoruz?",
    "answer": "Fonksiyonlar, belirli bir değer döndürmek için 'return' anahtar kelimesi kullanır. Bu değer, fonksiyon çağrıldığı yerde kullanılabilir. Örneğin, `int sonuc = toplama(3, 4);` ifadesinde 'toplama' fonksiyonu, iki sayıyı toplar ve sonucu 'sonuc' değişkenine atar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:15.182470"
  },
  {
    "question": "Fonksiyonlarda parametre geçiş yöntemleri nelerdir?",
    "answer": "İki ana parametre geçiş yöntemi vardır: değer ile geçiş ve referans ile geçiş. Değer ile geçişte, fonksiyona gönderilen değişkenin bir kopyası oluşturulur. Referans ile geçişte ise değişkenin adresi gönderilir, bu sayede fonksiyon içindeki değişiklikler orijinal değişkeni etkiler.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522684"
  },
  {
    "question": "Fonksiyonun dönüş değerinin nasıl kullanıldığı hakkında bir örnek ver.",
    "answer": "Bir fonksiyon, belirli bir değeri döndürebilir. Örneğin: 'float hesaplaAlan(float yaricap) { return 3.14 * yaricap * yaricap; }' fonksiyonu bir çemberin alanını döndürür. Bu değeri kullanmak için: 'float alan = hesaplaAlan(5);' şeklinde çağırabiliriz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522730"
  },
  {
    "question": "Recursive (özyinelemeli) fonksiyon nedir ve ne zaman kullanılmalıdır?",
    "answer": "Recursive fonksiyon, kendisini çağıran bir fonksiyondur. Genellikle karmaşık problemleri basit alt problemlere ayırmak için kullanılır. Örneğin, faktöriyel hesaplamak için bir recursive fonksiyon yazılabilir. Ancak, dikkatli olunmalı; sonsuz döngüye girmemek için bir çıkış koşulu olmalıdır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522755"
  },
  {
    "question": "C dilinde fonksiyonları nasıl çağırırız?",
    "answer": "Fonksiyonları çağırmak için fonksiyon ismini ve gerekli parametreleri kullanırız. Örneğin, 'int sonuc = toplama(5, 10);' ifadesi, 'toplama' fonksiyonunu çağırarak sonucu 'sonuc' değişkenine atar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522772"
  },
  {
    "question": "Fonksiyon içinde global ve yerel değişkenlerin kullanımı hakkında bilgi ver.",
    "answer": "Global değişkenler, programın her yerinden erişilebilirken, yerel değişkenler yalnızca tanımlandıkları fonksiyon içinde geçerlidir. Fonksiyon içinde global bir değişken üzerinde işlem yapıldığında, bu değişkenin değeri değiştirilebilir. Ancak yerel değişkenin değeri sadece fonksiyonun çalıştığı süre boyunca geçerlidir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522797"
  },
  {
    "question": "Fonksiyonlar ile hata yönetimi nasıl yapılır?",
    "answer": "Fonksiyonlar içinde hata yönetimi, döndürülen değerlerin kontrol edilmesi ile yapılır. Örneğin, bir dosya açma fonksiyonu başarısız olursa '-1' dönebilir. Bu durumda, fonksiyonu çağıran kod, dönen değeri kontrol ederek durumu ele alabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522815"
  },
  {
    "question": "Fonksiyonlar ile veri kümesi üzerinde nasıl işlem yapılır?",
    "answer": "Fonksiyonlar, veri kümeleri üzerinde çeşitli işlemler yapmak için kullanılabilir. Örneğin, bir dizi elemanlarının toplamını hesaplamak için 'float toplamDizi(int dizi[], int boyut) { ... }' şeklinde bir fonksiyon yazılabilir. Bu fonksiyon, dizinin elemanlarını toplar ve sonucu döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522837"
  },
  {
    "question": "C dilinde fonksiyonlar ile bellek yönetimini nasıl kontrol edebilirim?",
    "answer": "C dilinde dinamik bellek yönetimi için 'malloc', 'calloc' gibi fonksiyonlar kullanılır. Bir fonksiyon içinde dinamik bellek ayırdığınızda, bu belleği serbest bırakmak için 'free' fonksiyonunu kullanmalısınız. Örneğin, 'int* dizi = (int*)malloc(boyut * sizeof(int));' ile bellek ayırıp, işlem sonrası 'free(dizi);' ile serbest bırakmalısınız.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522859"
  },
  {
    "question": "Fonksiyonların parametre listesi nasıl esnek hale getirilebilir?",
    "answer": "C dilinde, esnek bir fonksiyon parametre listesi oluşturmak için 'variadic' fonksiyonlar kullanılabilir. Örneğin, 'printf' fonksiyonu, farklı sayıda ve türde parametre alabilir. Kendi değişken sayıda parametre alan bir fonksiyon yazmak için 'stdarg.h' kütüphanesini kullanarak 'va_list', 'va_start' ve 'va_end' makrolarını uygulayabilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:28:32.522879"
  },
  {
    "question": "C dilinde bir fonksiyonun geri dönüş değerini nasıl kullanabiliriz? Örnek ile açıkla.",
    "answer": "C dilinde bir fonksiyon, belirli bir türde değer döndürebilir. Örneğin, iki sayının toplamını döndüren bir fonksiyon tanımlayalım:\n\n```c\nint topla(int a, int b) {\n    return a + b;\n}\n```\nBu fonksiyonu kullanarak hesaplama yapabiliriz:\n\n```c\nint main() {\n    int sonuc = topla(5, 10);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}\n```\nBurada, 'topla' fonksiyonu iki tam sayı alır ve bunların toplamını döndürür. 'sonuc' değişkeni bu dönen değeri saklar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748785"
  },
  {
    "question": "Fonksiyonlar arası parametre geçişi nasıl yapılır? Bir örnekle göster.",
    "answer": "C dilinde, bir fonksiyona parametre geçişi yapılırken, değer geçişi veya referans geçişi yöntemi kullanılabilir. Aşağıda, iki değişkenin değerlerini değiştiren bir örnek:\n\n```c\nvoid degistir(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n```\n'degistir' fonksiyonu işaretçi (pointer) kullanarak iki değişkenin değerlerini değiştirir. Bu fonksiyonu kullanırken:\n\n```c\nint main() {\n    int a = 5, b = 10;\n    degistir(&a, &b);\n    printf(\"a: %d, b: %d\\n\", a, b);\n    return 0;\n}\n```\nBurada '&' operatörü ile değişkenlerin adresleri fonksiyona gönderilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748828"
  },
  {
    "question": "Recursive fonksiyon nedir? Bir örnek ile açıkla.",
    "answer": "Recursive (özyinelemeli) fonksiyon, kendisini çağıran bir fonksiyondur. Örnek olarak, bir sayının faktöriyelini hesaplayan bir fonksiyon:\n\n```c\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n```\nBu fonksiyon, n değeri 0 olduğunda 1 döndürür, aksi halde n değeri ile bir önceki sayının faktöriyelini çarpar. Kullanımı:\n\n```c\nint main() {\n    int sonuc = faktoriyel(5);\n    printf(\"5! = %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kod parçası, 5! (120) sonucunu verir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748859"
  },
  {
    "question": "C dilinde fonksiyonların aşırı yüklenmesi (overloading) mümkün müdür? Neden?",
    "answer": "C dilinde fonksiyon aşırı yüklemesi mümkün değildir. Aynı isimde iki farklı fonksiyon tanımlamak hata verir. Ancak, farklı isimler veya farklı parametre listeleri ile işlevsellik sağlanabilir. Örneğin:\n\n```c\nint topla_int(int a, int b) {\n    return a + b;\n}\nfloat topla_float(float a, float b) {\n    return a + b;\n}\n```\nBurada 'topla_int' ve 'topla_float' fonksiyonları farklı parametre türlerine sahip olduğu için kullanılabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748887"
  },
  {
    "question": "Fonksiyon pointer'ları nedir ve nasıl kullanılır? Bir örnek ile açıkla.",
    "answer": "Fonksiyon pointer'ları, bir fonksiyonu işaret eden bir işaretçi türüdür. Aşağıdaki örnekte, iki sayı arasındaki işlemi dinamik olarak seçen bir uygulama:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) {\n    return a + b;\n}\nint carpma(int a, int b) {\n    return a * b;\n}\n\nint hesapla(int (*islem)(int, int), int x, int y) {\n    return islem(x, y);\n}\n```\nBu örnekte 'hesapla' fonksiyonu, bir fonksiyon pointer'ı alır ve bu pointer ile belirtilen işlemi yapar. Kullanımı:\n\n```c\nint main() {\n    printf(\"Toplama: %d\\n\", hesapla(toplama, 5, 10));\n    printf(\"Çarpma: %d\\n\", hesapla(carpma, 5, 10));\n    return 0;\n}\n```\nBu kod, önce toplama ardından çarpma işleminin sonucunu verecektir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748912"
  },
  {
    "question": "C dilinde bir fonksiyonun değişken sayıda argüman alması nasıl sağlanır?",
    "answer": "C dilinde değişken sayıda argüman almak için 'stdarg.h' kütüphanesini kullanabiliriz. Aşağıdaki örnek, birden fazla tam sayının toplamını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdarg.h>\n\nint toplam(int sayi, ...) {\n    va_list ap;\n    int toplam = 0;\n    va_start(ap, sayi);\n    for (int i = 0; i < sayi; i++) {\n        toplam += va_arg(ap, int);\n    }\n    va_end(ap);\n    return toplam;\n}\n```\nKullanımı:\n\n```c\nint main() {\n    printf(\"Toplam: %d\\n\", toplam(3, 1, 2, 3));\n    return 0;\n}\n```\nBu kod, 1, 2 ve 3 sayılarını toplar ve sonucu verir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748936"
  },
  {
    "question": "Fonksiyonların global ve yerel değişkenlerle etkileşimi nasıldır?",
    "answer": "C dilinde, yerel değişkenler sadece tanımlandıkları blok içinde geçerlidir. Global değişkenler ise tüm programda erişilebilir. Aşağıdaki örnekte global ve yerel değişkenlerin etkileşimi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint global_degisken = 10;\n\nvoid fonksiyon() {\n    int local_degisken = 5;\n    printf(\"Global: %d, Local: %d\\n\", global_degisken, local_degisken);\n}\n```\nKullanımı:\n\n```c\nint main() {\n    fonksiyon();\n    // printf ile local_degisken erişilemez.\n    return 0;\n}\n```\nGlobal değişken her yerden erişilebilirken, local_degisken sadece 'fonksiyon' içinde kullanılabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748966"
  },
  {
    "question": "C dilinde fonksiyon tanımında default parametre değeri nasıl verilir?",
    "answer": "C dilinde fonksiyon tanımları için default (varsayılan) parametre değeri verme imkanı yoktur; ancak bu durumu aşmak için fonksiyon aşırı yüklemesi veya başka bir fonksiyon kullanarak simüle edebiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n\nvoid yazdir(int sayi, int tekrar) {\n    for(int i = 0; i < tekrar; i++) {\n        printf(\"%d\\n\", sayi);\n    }\n}\n\nvoid yazdir_default(int sayi) {\n    yazdir(sayi, 1);\n}\n```\nBurada 'yazdir_default' fonksiyonu, default olarak 'tekrar' parametresini 1 alacak şekilde çağırır. Kullanımı:\n\n```c\nint main() {\n    yazdir(5, 3); // 5'i 3 kez yazar.\n    yazdir_default(10); // 10'u 1 kez yazar.\n    return 0;\n}\n```\nBu yaklaşım, belirli bir işlevselliği elde etmemizi sağlar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.748987"
  },
  {
    "question": "C dilinde callback fonksiyonu nedir? Bir örnek ile açıkla.",
    "answer": "Callback fonksiyonu, başka bir fonksiyonun argümanı olarak geçilen ve çağrıldığında çalıştırılan bir fonksiyondur. Örneğin, bir dizinin elemanlarını sıralamak için bir callback fonksiyonu tanımlayalım:\n\n```c\n#include <stdio.h>\n\nint kucuktenBuyuge(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid sirala(int *dizi, int boyut, int (*karsilastir)(const void*, const void*)) {\n    qsort(dizi, boyut, sizeof(int), karsilastir);\n}\n```\nBurada 'sirala' fonksiyonu, 'qsort' fonksiyonuna karsilastir fonksiyonunu gönderir. Kullanımı:\n\n```c\nint main() {\n    int dizi[] = {30, 10, 20};\n    sirala(dizi, 3, kucuktenBuyuge);\n    for(int i = 0; i < 3; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu kod, diziyi küçükten büyüğe sıralar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:04.749010"
  },
  {
    "question": "İki sayının toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int x = 5, y = 7;\n    int toplam = topla(x, y);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n} // topla fonksiyonu iki sayıyı alır ve toplamlarını döner.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820293"
  },
  {
    "question": "Bir dizideki en büyük elemanı bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int dizi[] = {3, 5, 2, 9, 1};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk(dizi, boyut));\n    return 0;\n} // enBuyuk fonksiyonu, verilen dizideki en büyük elemanı bulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820399"
  },
  {
    "question": "Bir kelimenin tersini döndüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char* kelime) {\n    int n = strlen(kelime);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = kelime[i];\n        kelime[i] = kelime[n - i - 1];\n        kelime[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char kelime[] = \"Merhaba\";\n    tersCevir(kelime);\n    printf(\"Ters kelime: %s\\n\", kelime);\n    return 0;\n} // tersCevir fonksiyonu, verilen kelimenin tersini döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820432"
  },
  {
    "question": "Bir stringin karakter sayısını hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint karakterSayisi(const char* str) {\n    int sayi = 0;\n    while (*str != '\\0') {\n        sayi++;\n        str++;\n    }\n    return sayi;\n}\n\nint main() {\n    const char* metin = \"Merhaba Dünya\";\n    printf(\"Karakter sayısı: %d\\n\", karakterSayisi(metin));\n    return 0;\n} // karakterSayisi fonksiyonu, verilen stringin karakter sayısını hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820464"
  },
  {
    "question": "Bir dizinin elemanlarını sıralayan bir fonksiyon yazın (Bubble Sort kullanarak).",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 6, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    bubbleSort(dizi, boyut);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n} // bubbleSort fonksiyonu, verilen diziyi sıralar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820522"
  },
  {
    "question": "Bir dizideki çift sayıları bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid ciftSayilariBul(int dizi[], int boyut) {\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 == 0) {\n            printf(\"%d \", dizi[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    ciftSayilariBul(dizi, boyut);\n    return 0;\n} // ciftSayilariBul fonksiyonu, verilen dizideki çift sayıları bulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820555"
  },
  {
    "question": "İki sayıyı değiştiren bir fonksiyon yazın (referans ile).",
    "answer": "#include <stdio.h>\n\nvoid degistir(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Önce: x = %d, y = %d\\n\", x, y);\n    degistir(&x, &y);\n    printf(\"Sonra: x = %d, y = %d\\n\", x, y);\n    return 0;\n} // degistir fonksiyonu, iki sayının değerlerini değiştirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:29:44.820593"
  },
  {
    "question": "Bir dizideki en küçük sayıyı bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki kod, verilen bir dizideki en küçük sayıyı bulan bir fonksiyon içerir. 'find_min' fonksiyonu, dizinin elemanlarını karşılaştırarak en küçük değeri bulur.\n\n```c\n#include <stdio.h>\n\nint find_min(int arr[], int size) {\n    int min = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    return min;\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 1, 4};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"En küçük sayı: %d\\n\", find_min(arr, size));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010033"
  },
  {
    "question": "Bir dizideki tüm elemanların toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte, 'sum_array' fonksiyonu bir dizinin elemanlarının toplamını hesaplar. Fonksiyon, dizinin her elemanını toplamak için bir döngü kullanır.\n\n```c\n#include <stdio.h>\n\nint sum_array(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Toplam: %d\\n\", sum_array(arr, size));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010097"
  },
  {
    "question": "Bir kelimeyi tersine çeviren bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte 'reverse_string' fonksiyonu, verilen bir karakter dizisini tersine çevirir. Fonksiyon, iki uçtan başlayarak karakterleri karşılaştırır ve yer değiştirir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"merhaba\";\n    reverse_string(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010137"
  },
  {
    "question": "Bir sayının faktoriyelini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte 'factorial' fonksiyonu, bir sayının faktoriyelini hesaplar. Fonksiyon, rekürsif olarak kendini çağırarak hesaplama yapar.\n\n```c\n#include <stdio.h>\n\nint factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int num = 5;\n    printf(\"%d! = %d\\n\", num, factorial(num));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010176"
  },
  {
    "question": "İki sayının en büyük ortak bölenini (EBOB) bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki kodda 'gcd' fonksiyonu, iki sayının EBOB'unu bulmak için Öklid algoritmasını kullanır. Fonksiyon, daha küçük olan sayıyı diğerine böler ve kalan ile işlemi tekrarlar.\n\n```c\n#include <stdio.h>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    int a = 48, b = 18;\n    printf(\"EBOB: %d\\n\", gcd(a, b));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010229"
  },
  {
    "question": "Bir dizideki elemanları sıralayan bir fonksiyon yazın (Bubble Sort).",
    "answer": "Aşağıdaki örnekte 'bubble_sort' fonksiyonu, verilen bir dizinin elemanlarını sıralamak için Bubble Sort algoritmasını kullanır. Fonksiyon, diziyi karşılaştırarak sıralar.\n\n```c\n#include <stdio.h>\n\nvoid bubble_sort(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    bubble_sort(arr, size);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010275"
  },
  {
    "question": "Bir dizideki belirli bir sayının kaç kez tekrarlandığını bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki 'count_occurrences' fonksiyonu, verilen bir dizide belirli bir sayının kaç kez tekrarlandığını bulur. Fonksiyon, döngü kullanarak her elemanı kontrol eder.\n\n```c\n#include <stdio.h>\n\nint count_occurrences(int arr[], int size, int num) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == num) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 4, 2, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int num = 2;\n    printf(\"%d sayısı %d kez tekrarlandı.\\n\", num, count_occurrences(arr, size, num));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010325"
  },
  {
    "question": "Bir cümledeki kelime sayısını bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki 'count_words' fonksiyonu, bir karakter dizisindeki kelime sayısını bulur. Fonksiyon, boşluk karakterlerini kullanarak kelimeleri sayar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint count_words(const char *str) {\n    int count = 0;\n    int in_word = 0;\n    while (*str) {\n        if (*str == ' ' || *str == '\\n' || *str == '\\t') {\n            in_word = 0;\n        } else if (in_word == 0) {\n            in_word = 1;\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *sentence = \"Merhaba dünya, nasılsınız?\";\n    printf(\"Kelime sayısı: %d\\n\", count_words(sentence));\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010366"
  },
  {
    "question": "Dizideki çift sayıları bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte 'find_even_numbers' fonksiyonu, bir dizideki çift sayıları bulur ve bir başka diziye kaydeder. Fonksiyon, çift sayıları kontrol edip saklar.\n\n```c\n#include <stdio.h>\n\nvoid find_even_numbers(int arr[], int size, int even[], int *even_size) {\n    *even_size = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            even[*even_size] = arr[i];\n            (*even_size)++;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int even[6];\n    int even_size;\n    find_even_numbers(arr, size, even, &even_size);\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < even_size; i++) {\n        printf(\"%d \", even[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:30:20.010403"
  },
  {
    "question": "Verilen bir dizi içinde en küçük ve en büyük elemanı bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir dizi içinde en küçük ve en büyük elemanları bulan bir fonksiyon içerir:\n\n```c\n#include <stdio.h>\n\nvoid findMinMax(int arr[], int size, int *min, int *max) {\n    *min = arr[0];\n    *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        }\n        if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}\n\nint main() {\n    int arr[] = {3, 1, 5, 7, 2};\n    int min, max;\n    int size = sizeof(arr)/sizeof(arr[0]);\n    findMinMax(arr, size, &min, &max);\n    printf(\"En Küçük: %d, En Büyük: %d\\n\", min, max);\n    return 0;\n}\n```\nBu fonksiyon, iki işaretçi alarak en küçük ve en büyük elemanı bulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452217"
  },
  {
    "question": "Bir stringin palindrom olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir stringin palindrom olup olmadığını kontrol eder:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(const char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    const char *str = \"level\";\n    if (isPalindrome(str)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}\n```\nFonksiyon, stringin başından sonuna kadar kontrol ederek palindrom olup olmadığını belirler.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452259"
  },
  {
    "question": "N sayısının faktoriyelini hesaplayan bir rekürsif fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, bir sayının faktoriyelini hesaplamak için rekürsif bir fonksiyon kullanır:\n\n```c\n#include <stdio.h>\n\nunsigned long long factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int n = 5;\n    printf(\"%d! = %llu\\n\", n, factorial(n));\n    return 0;\n}\n```\nBu fonksiyon, 0 için 1 döndürür ve diğer sayılar için kendisini tekrar çağırarak faktöriyeli hesaplar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452282"
  },
  {
    "question": "Bir dizideki elemanların toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir dizideki elemanların toplamını hesaplar:\n\n```c\n#include <stdio.h>\n\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int total = sumArray(arr, size);\n    printf(\"Dizi toplamı: %d\\n\", total);\n    return 0;\n}\n```\nBu fonksiyon, dizi elemanlarını toplar ve sonucu döndürür.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452302"
  },
  {
    "question": "Bir integer dizisinin sıralanmasını sağlayan bir fonksiyon yazın (Bubble Sort).",
    "answer": "Aşağıdaki C kodu, bir integer dizisini sıralamak için Bubble Sort algoritmasını kullanır:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Elemanları değiştir\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, size);\n    printf(\"Sıralı Dizi: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, iki iç içe döngü kullanarak diziyi sıralar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452333"
  },
  {
    "question": "Bir dizideki çif sayıları döndüren bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir dizideki çift sayıları döndürür:\n\n```c\n#include <stdio.h>\n\nvoid printEvenNumbers(int arr[], int size) {\n    printf(\"Çift Sayılar: \");\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            printf(\"%d \", arr[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printEvenNumbers(arr, size);\n    return 0;\n}\n```\nBu fonksiyon, her elemanı kontrol ederek çift sayıları ekrana yazdırır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452354"
  },
  {
    "question": "Verilen iki sayıyı takas eden bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, iki sayıyı takas etmek için bir fonksiyon kullanır:\n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Önce: x = %d, y = %d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"Sonra: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```\nBu fonksiyon, iki değişkenin adreslerini alarak takas işlemi gerçekleştirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452374"
  },
  {
    "question": "Bir diziyi ters çeviren bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, bir diziyi ters çeviren bir fonksiyon içerir:\n\n```c\n#include <stdio.h>\n\nvoid reverseArray(int arr[], int size) {\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, size);\n    printf(\"Ters Dizi: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, dizinin başından ve sonundan elemanları değiştirerek ters çevirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452392"
  },
  {
    "question": "Bir dizideki en sık tekrar eden elemanı bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, verilen bir dizideki en sık tekrar eden elemanı bulur:\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\nint findMostFrequent(int arr[], int size) {\n    int maxCount = 0, mostFrequent;\n    for (int i = 0; i < size; i++) {\n        int count = 0;\n        for (int j = 0; j < size; j++) {\n            if (arr[j] == arr[i]) {\n                count++;\n            }\n        }\n        if (count > maxCount) {\n            maxCount = count;\n            mostFrequent = arr[i];\n        }\n    }\n    return mostFrequent;\n}\n\nint main() {\n    int arr[] = {1, 3, 3, 2, 2, 2, 4};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"En Sık Tekrar Eden Eleman: %d\\n\", findMostFrequent(arr, size));\n    return 0;\n}\n```\nBu fonksiyon, her elemanı kontrol ederek en sık tekrar eden elemanı bulur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:14.452415"
  },
  {
    "question": "Fonksiyonumda gereksiz global değişkenler kullanıyorsam nasıl bir çözüm bulabilirim?",
    "answer": "Global değişken kullanımı, kodun okunabilirliğini ve bakımını zorlaştırabilir. Bunun yerine, fonksiyonunuza parametre olarak gerekli verileri geçin. Örneğin, bir toplam hesaplayan fonksiyonunuzu düşünün: \n\n```c\nint toplam(int a, int b) {\n    return a + b;\n}\n```\nBurada `a` ve `b` fonksiyon parametreleri olarak geçirilmekte. Eğer global değişkenler yerine bu yöntemi kullanırsanız, kodunuz daha modüler ve test edilebilir hale gelir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813147"
  },
  {
    "question": "Fonksiyonumun çok uzun olduğunu düşünüyorum. Bunu nasıl iyileştirebilirim?",
    "answer": "Uzun fonksiyonlar genellikle birden fazla işlemi tek bir yerde yapar. Kodunuzu fonksiyonel parçalara ayırarak daha küçük, belirli görevler üstlenen fonksiyonlar oluşturabilirsiniz. Örneğin:\n\n```c\nvoid islemYap(int x) {\n    // uzun kod bloğu\n}\n```\nBunu şu şekilde yeniden yapılandırabilirsiniz:\n\n```c\nvoid veriTemizle(int *veri);\nvoid veriAnalizEt(int *veri);\nvoid islemYap(int x) {\n    veriTemizle(&x);\n    veriAnalizEt(&x);\n}\n```\nBu yöntem, kodun okunabilirliğini artırır ve her fonksiyonu ayrı ayrı test etmenizi sağlar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813199"
  },
  {
    "question": "Fonksiyonlarımda hata ayıklama zorluğu yaşıyorum. Bunun için ne yapmalıyım?",
    "answer": "Hata ayıklamayı kolaylaştırmak için, fonksiyonlarınıza hata kodları veya istisnalar ekleyebilirsiniz. Örneğin:\n\n```c\nint bol(int a, int b) {\n    if (b == 0) {\n        return -1; // Hata: bölme hatası\n    }\n    return a / b;\n}\n```\nBu şekilde, bölme hatasıyla karşılaşıldığında fonksiyon bir hata kodu döndürür ve bu kodu kontrol ederek program akışınızı yönetebilirsiniz. Ayrıca, fonksiyon başında ve sonunda logging yaparak, hangi değerlerin kullanıldığını görebilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813230"
  },
  {
    "question": "Fonksiyonlarımda döngü kullanıyorum, performansı nasıl artırabilirim?",
    "answer": "Döngü içindeki işlemleri optimize etmek için, gereksiz hesaplamaları döngü dışında yapmalısınız. Örneğin, şu şekilde bir döngü düşünelim:\n\n```c\nfor (int i = 0; i < n; i++) {\n    toplam += i * 2;\n}\n```\nBunu şu şekilde optimize edebilirsiniz:\n\n```c\nint sabit = 2;\nfor (int i = 0; i < n; i++) {\n    toplam += i * sabit;\n}\n```\nBu, her döngü adımında `2` sabitini tekrar hesaplamaktan kaçınarak performansı artırır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813257"
  },
  {
    "question": "Fonksiyonlarımda belleği yönetmekte zorlanıyorum. Ne yapmalıyım?",
    "answer": "Bellek yönetimi için, fonksiyonlarınızda dinamik bellek tahsisi (malloc) kullanıyorsanız, her zaman tahsis edilen bellek için serbest bırakma (free) işlemi yapmalısınız. Örneğin:\n\n```c\nint* diziOlustur(int boyut) {\n    int* dizi = malloc(boyut * sizeof(int));\n    return dizi;\n}\n```\nBu fonksiyonu kullandıktan sonra, ilgili bellek alanını serbest bırakmayı unutmayın:\n\n```c\nint* dizi = diziOlustur(10);\n// işlemler...\nfree(dizi);\n```\nBu, bellekte sızıntıları önleyecektir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813293"
  },
  {
    "question": "Fonksiyonlarımın daha esnek olmasını istiyorum. Bunun için hangi tasarım prensiplerini kullanmalıyım?",
    "answer": "Fonksiyonlarınızı daha esnek hale getirmek için, belirli bir işlem yapacak şekilde tasarlamak yerine, bir arayüz üzerinden çalışacak şekilde yazabilirsiniz. Örneğin, bir hesaplama fonksiyonu:\n\n```c\nint hesapla(int x, int y, int (*islem)(int, int)) {\n    return islem(x, y);\n}\n```\nBu fonksiyon, istediğiniz herhangi bir işlem fonksiyonunu parametre olarak alır. Örneğin, toplama veya çarpma işlemleri için farklı fonksiyonlar tanımlayabilirsiniz ve `hesapla` fonksiyonuyla kullanabilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813327"
  },
  {
    "question": "Fonksiyonlarımın performansını artırmak için hangi teknikleri kullanabilirim?",
    "answer": "Performansı artırmak için, sık kullanılan fonksiyonlarınızı inline fonksiyonlarına dönüştürebilirsiniz. C dilinde, inline fonksiyonlar derleyiciye bu fonksiyonun çağrıldığı her yerde gömülmesini sağlar:\n\n```c\ninline int kare(int x) {\n    return x * x;\n}\n```\nBu, fonksiyon çağrısı maliyetini ortadan kaldırarak performansı artırabilir. Ancak, inline kullanımı dikkatli olmalı, çünkü çok büyük fonksiyonlar için kod boyutunu artırabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813353"
  },
  {
    "question": "Fonksiyonlarımda çok sayıda parametre kullanıyorum. Bunu nasıl daha yönetilebilir hale getirebilirim?",
    "answer": "Çok sayıda parametre kullanmak yerine, yapıları (struct) kullanarak fonksiyonlarınıza birden fazla değişkeni tek bir parametre olarak geçirebilirsiniz. Örneğin:\n\n```c\ntypedef struct {\n    int a;\n    int b;\n    int c;\n} Parametreler;\n\nvoid islemYap(Parametreler p) {\n    // İşlemler\n}\n```\nBu yapı, fonksiyon çağrılarınızı daha temiz ve daha kolay yönetilebilir hale getirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813384"
  },
  {
    "question": "Fonksiyona geçirdiğim parametrelerin doğruluğunu nasıl kontrol edebilirim?",
    "answer": "Fonksiyonlarınızda parametre doğrulaması yaparak, beklenmeyen durumları önleyebilirsiniz. Örneğin, bir fonksiyonda negatif sayılar almamanız gerekiyorsa:\n\n```c\nvoid pozitifSayiyiIsle(int sayi) {\n    if (sayi < 0) {\n        printf(\"Hata: Negatif sayı geçilemez!\");\n        return;\n    }\n    // İşlemler\n}\n```\nBu yöntem, hata ayıklamayı kolaylaştırır ve güvenli bir kod yazmanıza yardımcı olur.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813408"
  },
  {
    "question": "Fonksiyonlarımda aynı kodu tekrar etmekten kaçınmak için ne yapmalıyım?",
    "answer": "Kod tekrarını önlemek için, ortak işlevselliği ayrı bir fonksiyona taşıyabilirsiniz. Örneğin:\n\n```c\nvoid ortakIslem(int x) {\n    // Ortak işlemler\n}\n\nvoid birinciFonksiyon(int a) {\n    ortakIslem(a);\n}\n\nvoid ikinciFonksiyon(int b) {\n    ortakIslem(b);\n}\n```\nBu şekilde, ortak kodu tek bir yerde yöneterek bakım ve güncellemeleri kolaylaştırabilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:31:50.813435"
  },
  {
    "question": "Bir dizi içerisindeki elemanları tersine döndüren bir fonksiyonu optimize etmek için ne gibi değişiklikler yapabilirim?",
    "answer": "Diziyi tersine döndürmek için genellikle O(n) karmaşıklığında bir algoritma gereklidir. Ancak mevcut kodunuzda iki geçiş yapılıyorsa, bunu tek bir geçişe indirgemek için iki gösterici kullanarak baştan ve sondan başladığınız bir döngü oluşturabilirsiniz. Ayrıca, gereksiz kopyalamalardan kaçınmak için tercihen yerinde değişim yapmalısınız. Örneğin:\n\n```c\nvoid reverseArray(int *arr, int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - i - 1];\n        arr[size - i - 1] = temp;\n    }\n}\n```\nBu yöntem, hem zaman hem de alan karmaşıklığını optimize eder.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445613"
  },
  {
    "question": "Bir fonksiyonun gereksiz yere tekrar eden hesaplamalar yapmasını önlemek için ne tür bir optimizasyon yapabilirim?",
    "answer": "Eğer bir fonksiyon belirli bir hesaplamayı her çağrıldığında tekrarlıyorsa, bu tür tekrar eden işlemleri önlemek için memoizasyon tekniğini kullanabilirsiniz. Memoizasyon, hesaplanan sonuçları saklayarak aynı girdi ile tekrar çağrıldığında önceden hesaplanmış sonucun kullanılmasını sağlar. Örneğin:\n\n```c\n#include <stdio.h>\n#define MAX 100\n\nint memo[MAX];\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n];\n    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);\n    return memo[n];\n}\n\nvoid initMemo() {\n    for (int i = 0; i < MAX; i++) memo[i] = -1;\n}\n```\nBu örnekte, Fibonacci hesaplamalarında gereksiz tekrarlar önlenmiştir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445663"
  },
  {
    "question": "Bir diziyi sıralayan fonksiyonu daha verimli hale getirmek için hangi algoritmayı tercih etmeliyim?",
    "answer": "Dizi sıralama algoritmaları arasında, hızlı sıralama (Quicksort) genellikle en verimli olanlardan biridir. Ancak, dizi boyutu küçükse veya dizi büyük oranda sıralıysa, daha basit bir algoritma olan seçim sıralaması (Selection Sort) veya balon sıralaması (Bubble Sort) kullanılabilir. Örneğin, Quicksort ile sıralama:\n\n```c\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int *arr, int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int *arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n```\nBu algoritma, ortalama O(n log n) zaman karmaşıklığı sunar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445699"
  },
  {
    "question": "Fonksiyonumda kullanılan global değişkenlerin etkisini azaltmak için ne yapabilirim?",
    "answer": "Global değişkenlerin kullanımı, kodun okunabilirliğini ve bakımını zorlaştırabilir. Bunun yerine, fonksiyonlar arasındaki veri aktarımını parametreler aracılığıyla yapmalısınız. Ayrıca, yapı (struct) kullanarak bir grup veriyi tek bir parametre olarak gönderebilirsiniz. Örneğin:\n\n```c\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nvoid processPoint(Point p) {\n    // İşlemleri burada yap\n}\n\nint main() {\n    Point p = {1, 2};\n    processPoint(p);\n}\n```\nBu, global değişken kullanımını azaltır ve fonksiyonlar arası bağımlılığı minimize eder.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445730"
  },
  {
    "question": "Bir fonksiyonun performansını analiz etmek için hangi teknikleri kullanabilirim?",
    "answer": "Performans analizi için profilleme araçlarını kullanabilirsiniz. Örneğin, Gprof veya Valgrind gibi araçlar, hangi fonksiyonların ne kadar süre çalıştığını izler. Ayrıca, algoritmanın karmaşıklığını analiz ederek büyük O notasyonunu kullanarak en kötü durum senaryolarını inceleyebilirsiniz. Kodunuzu optimize ederken, hangi fonksiyonların en çok zamana harcadığını tespit etmek için bu analizleri yapmanız faydalıdır.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445754"
  },
  {
    "question": "Bir fonksiyonun içindeki döngüyü nasıl daha verimli hale getirebilirim?",
    "answer": "Döngülerin içindeki hesaplamaları dışarı alarak veya döngü koşullarını optimize ederek verimliliği artırabilirsiniz. Ayrıca, döngü içinde sabit kalan hesaplamaları dışarı alıp, döngü içinde sadece değişkenleri kullanarak hesaplamaları gerçekleştirebilirsiniz. Örneğin:\n\n```c\n// Orijinal döngü\nfor (int i = 0; i < n; i++) {\n    result += i * constant;\n}\n\n// Optimize edilmiş döngü\nint temp = constant;\nfor (int i = 0; i < n; i++) {\n    result += i * temp;\n}\n```\nBu tür basit optimizasyonlar, özellikle büyük veri setlerinde performansı artırabilir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445781"
  },
  {
    "question": "Fonksiyonlarımda hata yönetimini daha etkili hale getirmek için ne yapabilirim?",
    "answer": "Hata yönetimi için, her fonksiyondan dönen sonuçları kontrol etmelisiniz. Bunun yanı sıra, hata kodları kullanmak yerine exception handling (istisna yönetimi) yöntemlerini kullanmak, kodun daha okunabilir ve bakımı kolay hale getirebilir. C dilinde bu yapı bulunmamakla birlikte, fonksiyonlarınızdan hata durumlarını belirten özel kodlar dönebilir:\n\n```c\nint myFunction() {\n    // ...\n    if (error) return -1; // Hata durumu\n    return 0; // Başarı durumu\n}\n```\nAyrıca, özel hata yönetim fonksiyonları yazarak, hata durumlarının daha merkezi bir şekilde ele alınmasını sağlayabilirsiniz.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445805"
  },
  {
    "question": "Büyük veri setleri ile çalışırken fonksiyonlarımın bellek kullanımını nasıl optimize edebilirim?",
    "answer": "Bellek yönetimi için dinamik bellek ayırma (malloc, calloc) kullanırken, her zaman belleği serbest bırakmayı (free) unutmayın. Ayrıca, gereksiz büyük veri yapılarından kaçınmak için sadece gerekli olan verileri saklamaya çalışın. Bellek havuzları (memory pools) kullanarak bellek tahsislerini optimize edebilir ve fragmentasyonu azaltabilirsiniz. Örneğin:\n\n```c\nvoid *createPool(size_t size) {\n    return malloc(size);\n}\n\nvoid destroyPool(void *pool) {\n    free(pool);\n}\n```\nBu yöntem, bellek yönetimini daha etkin hale getirir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445833"
  },
  {
    "question": "Fonksiyonlarımda kullanılan algoritmaların doğru çalıştığını nasıl garanti edebilirim?",
    "answer": "Unit test (birim testi) yazarak her fonksiyonun beklenen şekilde çalıştığını garanti altına alabilirsiniz. Her fonksiyonu farklı senaryolar ile test eden test fonksiyonları hazırlayın. C dilinde bu testleri manuel olarak yapabileceğiniz gibi, CUnit veya Check gibi kütüphaneleri de kullanarak otomatik testler yazabilirsiniz. Örneğin:\n\n```c\nvoid test_myFunction() {\n    assert(myFunction() == expected_value);\n}\n```\nBu, fonksiyonlarınızın doğru çalıştığını doğrulamak için etkili bir yöntemdir.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445858"
  },
  {
    "question": "Birden fazla parametre alan fonksiyonlarımı nasıl daha okunabilir hale getirebilirim?",
    "answer": "Çok sayıda parametre alan fonksiyonlar, okunabilirliği azaltabilir. Bunun yerine, bir yapı (struct) kullanarak bir grup parametreyi tek bir nesne olarak geçirebilirsiniz. Örneğin:\n\n```c\ntypedef struct {\n    int width;\n    int height;\n    int depth;\n} Dimensions;\n\nvoid processDimensions(Dimensions dims) {\n    // İşlemleri burada yap\n}\n\nint main() {\n    Dimensions box = {10, 20, 30};\n    processDimensions(box);\n}\n```\nBu yaklaşım, fonksiyon parametrelerinizi daha düzenli hale getirir ve daha okunabilir bir kod sağlar.",
    "category": "basic_syntax",
    "topic": "functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Fonksiyonlar",
    "timestamp": "2025-06-01T14:32:38.445882"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define PI ____  int main() {  printf(\"Pi'nin değeri: %f\", PI);  return 0; }",
    "answer": "Eksik kısmı '3.14' olarak tamamlayabilirsiniz. Bu şekilde PI'nin değeri 3.14 olarak tanımlanmış olur. Kodun tamamı şöyle görünür: \n#include <stdio.h>  \n#define PI 3.14  \nint main() {  \n   printf(\"Pi'nin değeri: %f\", PI);  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195163"
  },
  {
    "question": "Aşağıdaki kodda eksik #ifdef direktifini tamamlayın. #include <stdio.h>  #define DEBUG  int main() {  ____  printf(\"Debug modunda çalışıyor.\");  return 0; }",
    "answer": "Eksik kısmı '#ifdef DEBUG' ile tamamlayabilirsiniz. Bu, DEBUG tanımı varsa 'Debug modunda çalışıyor.' mesajını yazdırır. Kod şöyle görünür: \n#include <stdio.h>  \n#define DEBUG  \nint main() {  \n#ifdef DEBUG  \n   printf(\"Debug modunda çalışıyor.\");  \n#endif  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195267"
  },
  {
    "question": "Aşağıdaki kod parçasının eksik kısmını tamamlayın. #include <stdio.h>  #define SQUARE(x) ____  int main() {  int n = 5;  printf(\"Karesi: %d\", SQUARE(n));  return 0; }",
    "answer": "Eksik kısmı '((x) * (x))' olarak tamamlayabilirsiniz. Bu şekilde SQUARE makrosu verilen sayının karesini alır. Tam kod: \n#include <stdio.h>  \n#define SQUARE(x) ((x) * (x))  \nint main() {  \n   int n = 5;  \n   printf(\"Karesi: %d\", SQUARE(n));  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195361"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define MAX(a,b) ____  int main() {  printf(\"En büyük: %d\", MAX(10, 20));  return 0; }",
    "answer": "Eksik kısım '((a) > (b) ? (a) : (b))' olmalıdır. Bu, iki sayıdan en büyüğünü döndürür. Tam kod şöyle görünür: \n#include <stdio.h>  \n#define MAX(a,b) ((a) > (b) ? (a) : (b))  \nint main() {  \n   printf(\"En büyük: %d\", MAX(10, 20));  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195450"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define CUBE(x) ____  int main() {  int n = 3;  printf(\"Küpü: %d\", CUBE(n));  return 0; }",
    "answer": "Eksik bölüm '((x) * (x) * (x))' olmalıdır. Bu, verilen sayının küpünü alır. Tam kod: \n#include <stdio.h>  \n#define CUBE(x) ((x) * (x) * (x))  \nint main() {  \n   int n = 3;  \n   printf(\"Küpü: %d\", CUBE(n));  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195559"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını doldurun. #include <stdio.h>  #define GREETING(name) printf(\"Merhaba, ____!\");  int main() {  GREETING(Ali);  return 0; }",
    "answer": "Eksik kısmı 'name' olmalıdır. Bu makro, verilen isme göre selam verir. Tam kod: \n#include <stdio.h>  \n#define GREETING(name) printf(\"Merhaba, %s!\", name)  \nint main() {  \n   GREETING(\"Ali\");  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195653"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define VERSION 1.0  int main() {  printf(\"Versiyon: ____\", VERSION);  return 0; }",
    "answer": "Eksik kısmı '%f' olmalıdır. Bu, VERSION değişkeninin doğru bir şekilde yazdırılmasını sağlar. Tam kod: \n#include <stdio.h>  \n#define VERSION 1.0  \nint main() {  \n   printf(\"Versiyon: %f\", VERSION);  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195726"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define MULTIPLY(a,b) ____  int main() {  printf(\"Çarpım: %d\", MULTIPLY(3, 4));  return 0; }",
    "answer": "Eksik kısım '((a) * (b))' olmalıdır. Bu, iki sayıyı çarpar. Tam kod böyle görünür: \n#include <stdio.h>  \n#define MULTIPLY(a,b) ((a) * (b))  \nint main() {  \n   printf(\"Çarpım: %d\", MULTIPLY(3, 4));  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195807"
  },
  {
    "question": "Aşağıdaki kod dizisinde eksik #ifndef direktifini tamamlayın. #include <stdio.h>  #define MY_HEADER  ____  int main() {  printf(\"Header tanımlı.\");  return 0; }",
    "answer": "Eksik kısımlar '#ifndef MY_HEADER' ile '#define MY_HEADER' arasındaki kısımdır. Bu, MY_HEADER tanımlı değilse içeriyi yazdırır. Tam kod: \n#include <stdio.h>  \n#ifndef MY_HEADER  \n#define MY_HEADER  \n   int main() {  \n      printf(\"Header tanımlı.\");  \n      return 0;  \n   }  \n#endif",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195878"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. #include <stdio.h>  #define STRINGIFY(x) #x  int main() {  printf(\"String: %s\", STRINGIFY(Hello, World));  return 0; }",
    "answer": "Eksik kısmı 'x' olmalıdır. Bu, verilen ifadeyi stringe çevirir. Tam kod: \n#include <stdio.h>  \n#define STRINGIFY(x) #x  \nint main() {  \n   printf(\"String: %s\", STRINGIFY(Hello, World));  \n   return 0;  \n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:09.195963"
  },
  {
    "question": "Aşağıdaki kod parçasını tamamlayarak bir dosyanın içeriğini okuyun. Dosya yolu 'data.txt' olsun ve dosya açma işleminde hata kontrolü yapın.",
    "answer": "#include <stdio.h>\n\n#define FILE_PATH \"data.txt\"\n\nint main() {\n    FILE *file = fopen(FILE_PATH, \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya okuma işlemleri burada yapılacak\n    fclose(file);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018764"
  },
  {
    "question": "Aşağıdaki kodda, tanımlı olan makro 'MAX' değerini 100 olarak ayarlayın ve bu makro ile bir döngü oluşturun.",
    "answer": "#include <stdio.h>\n\n#define MAX 100\n\nint main() {\n    for (int i = 0; i < MAX; i++) {\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018839"
  },
  {
    "question": "Aşağıdaki kodda, koşullu derleme kullanarak 'DEBUG' makrosu tanımlandığında ekstra hata mesajı basılmasını sağlayın.",
    "answer": "#include <stdio.h>\n\n#define DEBUG\n\nint main() {\n    int x = 5;\n    #ifdef DEBUG\n        printf(\"Debug modunda: x = %d\\n\", x);\n    #endif\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018878"
  },
  {
    "question": "Aşağıdaki kodda, 'SQUARE' makrosunu tanımlayarak bir sayının karesini hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\n#define SQUARE(x) ((x) * (x))\n\nint main() {\n    int number = 4;\n    printf(\"%d'nin karesi: %d\\n\", number, SQUARE(number));\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018916"
  },
  {
    "question": "Aşağıdaki kodda, 'PI' sabitini tanımlayarak bir dairenin alanını hesaplayın ve sonucu yazdırın.",
    "answer": "#include <stdio.h>\n\n#define PI 3.14159\n\nint main() {\n    double radius = 5.0;\n    double area = PI * SQUARE(radius);\n    printf(\"Dairenin alanı: %f\\n\", area);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018946"
  },
  {
    "question": "Aşağıdaki kodda, 'ARRAY_SIZE' makrosunu kullanarak bir dizinin boyutunu tanımlayın ve bu boyutta bir dizi oluşturun.",
    "answer": "#include <stdio.h>\n\n#define ARRAY_SIZE 10\n\nint main() {\n    int array[ARRAY_SIZE];\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        array[i] = i * 2;\n        printf(\"array[%d] = %d\\n\", i, array[i]);\n    }\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.018980"
  },
  {
    "question": "Aşağıdaki kodda, 'MIN' ve 'MAX' makrolarını tanımlayarak iki sayı arasındaki en küçük ve en büyük değeri döndüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"En küçük: %d, En büyük: %d\\n\", MIN(x, y), MAX(x, y));\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.019024"
  },
  {
    "question": "Aşağıdaki kodda, çoklu dosya içeriğini derlemek için '#include' direktifini kullanarak bir kütüphane tanımlayın.",
    "answer": "#include <stdio.h>\n#include \"my_library.h\"\n\nint main() {\n    my_function(); // my_library.h içinde tanımlı bir fonksiyon\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.019058"
  },
  {
    "question": "Aşağıdaki kodda, derleyiciye dosya derleme zamanı bilgilerini göstermek için '__DATE__' ve '__TIME__' makrolarını kullanın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    printf(\"Bu dosya %s tarihinde, %s saatinde derlenmiştir.\\n\", __DATE__, __TIME__);\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.019106"
  },
  {
    "question": "Aşağıdaki kodda, '#if' direktifini kullanarak bir koşul altında farklı değerler yazdırın.",
    "answer": "#include <stdio.h>\n\n#define CONDITION 1\n\nint main() {\n    #if CONDITION\n        printf(\"Koşul sağlandı!\\n\");\n    #else\n        printf(\"Koşul sağlanmadı.\\n\");\n    #endif\n    return 0;\n}",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:31.019155"
  },
  {
    "question": "Kodun başında bir dizi boyutunu tanımlamak için hangi preprocessor direktifesi kullanılabilir? Eksik kodu tamamlayın: #define ARRAY_SIZE ______",
    "answer": "#define ARRAY_SIZE 100 // Bu direktif, dizinin boyutunu 100 olarak tanımlıyor. Preprocessor, bu satırı derleme zamanında her 'ARRAY_SIZE' ifadesinin yerine 100 koyacak.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755667"
  },
  {
    "question": "Bir hata mesajını derleme zamanında kontrol etmek için hangi preprocessor ifadesi kullanılmalıdır? Eksik kodu tamamlayın: #if ______",
    "answer": "#if !defined(MY_HEADER_H) // Burada MY_HEADER_H tanımlı değilse derleyici bu bloğu geçer, aksi takdirde hata mesajı görüntülenir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755751"
  },
  {
    "question": "Çoklu platform desteği için hangi preprocessor direktifesi ile koşullu derleme yapılır? Eksik kodu tamamlayın: #ifdef ______",
    "answer": "#ifdef _WIN32 // Bu ifade, Windows platformunda çalışan kodun derlenmesini sağlayacak. Eğer _WIN32 tanımlı ise, Windows'a özel kodlar burada yer alacak.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755815"
  },
  {
    "question": "Bir hata ayıklama modu için bir debug direktifinin tanımlanması gerekiyor. Eksik kodu tamamlayın: #define ______",
    "answer": "#define DEBUG_MODE 1 // Bu direktif, DEBUG_MODE değişkenini tanımlar. Eğer bu mod aktifse, hata ayıklama ile ilgili ifadeler derlenecek.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755873"
  },
  {
    "question": "Bir dosyanın yalnızca bir kez eklenmesini sağlamak için hangi preprocessor direktifi kullanılır? Eksik kodu tamamlayın: #ifndef ______",
    "answer": "#ifndef MY_HEADER_H // Bu ifade, eğer MY_HEADER_H tanımlı değilse dosyanın içeriğinin eklenmesini sağlar. Bu, header dosyalarının çoklu eklenmesini önler.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755935"
  },
  {
    "question": "Farklı bir dosya içeriğini dahil etmek için hangi preprocessor direktifi kullanılmalıdır? Eksik kodu tamamlayın: #include ______",
    "answer": "#include <stdio.h> // Bu direktif, standart giriş/çıkış kütüphanesini projeye dahil etmek için kullanılır. Artık printf gibi fonksiyonları kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.755996"
  },
  {
    "question": "Özel bir makro tanımlamak için hangi preprocessor direktivesi kullanılır? Eksik kodu tamamlayın: #define ______",
    "answer": "#define SQUARE(x) ((x) * (x)) // Bu makro, verilen bir sayının karesini hesaplar. Makrolar, kod tekrarını azaltmak için kullanışlıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.756051"
  },
  {
    "question": "Bir koşul altında işlemi durdurmak için kullanılan preprocessor ifadesini tamamlayın: #error ______",
    "answer": "#error \"Hatalı yapılandırma! Lütfen ayarları kontrol edin.\" // Bu direktif, belirli bir koşul sağlanmadığında derleme sürecini durdurmak için kullanılır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.756101"
  },
  {
    "question": "Proje için belirli bir versiyon numarasını tanımlamak üzere hangi direktifi kullanmalıyız? Eksik kodu tamamlayın: #define ______",
    "answer": "#define VERSION \"1.0.0\" // Bu tanım, proje versiyonunu belirtmek için kullanılır. Kodun başka yerlerinde bu versiyon bilgisi kullanılabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.756161"
  },
  {
    "question": "Kodun belirli bölümlerini yalnızca DEBUG_MODE tanımlandığında derlemek için hangi preprocessor direktifleri kullanılmalıdır? Eksik kodu tamamlayın: #ifdef ______",
    "answer": "#ifdef DEBUG_MODE // Bu ifade, eğer DEBUG_MODE tanımlı ise bu bölümün derlenmesini sağlar. Bu sayede hata ayıklama sırasında ekstra bilgiler eklenebilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.756229"
  },
  {
    "question": "Birden fazla platform için farklı kütüphaneler eklemek üzere hangi preprocessor direktifi kullanmalıyız? Eksik kodu tamamlayın: #if ______",
    "answer": "#if defined(_WIN32) // Bu ifade, eğer Windows ortamında isek Windows'a özgü kütüphanelerin dahil edilmesini sağlar. Diğer platformlar için farklı şartlar eklenebilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:33:51.756293"
  },
  {
    "question": "Kodumda #define ve #include direktiflerini kullanıyorum ama hata alıyorum. Neden?",
    "answer": "#define direktifi, bir sabit veya makro tanımlamak için kullanılır. #include ise başka bir dosyayı ekler. Eğer #include direktifinizde dosya adı yanlış yazılmışsa ya da dosya mevcut değilse hata alırsınız. Örneğin, `#include <stdio.h>` yerine `#include <std_io.h>` yazarsanız dosya bulunamaz ve hata alırsınız. Doğru dosya adını kullanmak önemlidir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.752928"
  },
  {
    "question": "Kodumda #ifdef direktifi kullanarak bir koşul oluşturuyorum, ancak beklediğim gibi çalışmıyor. Neden?",
    "answer": "#ifdef direktifi, bir makronun tanımlı olup olmadığını kontrol eder. Eğer tanımlı değilse, bu bloğun içindeki kod çalışmaz. Örneğin, `#define MY_MACRO` ifadesini kullanmadıysanız ve `#ifdef MY_MACRO` bloğunun içindeki kod çalışmıyorsa, bu makronun tanımlı olmadığını gösterir. #define ile makroyu tanımladığınızdan emin olun.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.752980"
  },
  {
    "question": "Kodumda #ifndef kullanıyorum ama hata alıyorum. Neden?",
    "answer": "#ifndef direktifi, bir makronun tanımlı olup olmadığını kontrol eder. Eğer makro tanımlıysa, kod bloğu atlanır. Eğer istediğiniz kodun çalışmasını istiyorsanız, makronun tanımlı olmadığından emin olun ya da doğru bir makro adı kullanın. Örneğin, `#ifndef MY_MACRO` kullanıyorsanız ve `#define MY_MACRO` daha önce tanımlanmışsa, bu bloğun içindeki kod çalışmaz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753002"
  },
  {
    "question": "Kodumda #elif direktifi kullanıyorum ama beklenen sonucu alamıyorum. Neden?",
    "answer": "#elif, bir önceki #if veya #else if kontrolüne ek olarak yeni bir koşul ekler. Eğer #if koşulu doğruysa, #elif koşulu kontrol edilmez. Örneğin, `#if A > B` ve `#elif A < B` yazıyorsanız, A > B koşulu doğruysa, A < B koşulu asla kontrol edilmez. İstediğiniz koşulun önceliğini kontrol edin.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753027"
  },
  {
    "question": "Kodumda #undef direktifi kullanarak bir makroyu kaldırdım, ama hala kullanılıyor. Neden?",
    "answer": "#undef direktifi, belirli bir makroyu kaldırmak için kullanılır. Ancak bu direktifi kullandıktan sonra, makro adıyla ilgili tüm kodu gözden geçirmelisiniz. Eğer #undef'den önce kodunuzda bu makroyu kullanıyorsanız, derleyici bu makroyu hala tanıyabilir. #undef'den sonra bu makroyu kullanmadığınızdan emin olun.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753055"
  },
  {
    "question": "Kodumda #pragma direktifi kullanıyorum ama etkisiz görünüyor. Neden?",
    "answer": "#pragma, derleyiciye özel talimatlar vermek için kullanılır ve her derleyici bu talimatları farklı şekilde yorumlayabilir. Eğer kullandığınız #pragma ifadesi, derleyiciniz tarafından desteklenmiyorsa etkisiz kalır. Örneğin, `#pragma omp parallel` ifadesi GCC derleyicisinde çalışabilir ama başka bir derleyicide çalışmayabilir. Kullanılan derleyicinin dökümantasyonunu kontrol edin.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753078"
  },
  {
    "question": "Kodumda birden fazla #define ifadesi var ama bazıları çalışmıyor. Neden?",
    "answer": "Bir makro tanımladıktan sonra, daha sonra aynı isimle başka bir makro tanımlarsanız, son tanım geçerli olur. Örneğin, `#define PI 3.14` ve daha sonra `#define PI 3.14159` yazdığınızda son tanım geçerli olur. Eski tanım kaybolur. Dolayısıyla, farklı değerlere sahip makrolar için farklı isimler kullanmalısınız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753101"
  },
  {
    "question": "Kodumda #define ile fonksiyon oluşturuyorum ama hata alıyorum. Neden?",
    "answer": "#define ile fonksiyon tanımlarken, parantez kullanımına dikkat etmelisiniz. Örneğin, `#define SQUARE(x) x*x` yazdığınızda, `SQUARE(2+1)` ifadesi `2+1*2+1` olarak değerlendirilir. Bu da beklenmedik sonuca yol açar. Doğru kullanım için `#define SQUARE(x) ((x)*(x))` şeklinde olmalıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753124"
  },
  {
    "question": "Kodumda birden fazla #include ifadesi var ama dosyalar çakışıyor. Neden?",
    "answer": "#include direktifi ile dosyaları eklerken, aynı dosyayı birden fazla kez ekliyorsanız çakışma yaşanabilir. Bunun önüne geçmek için include korumaları kullanmalısınız. Örneğin, her dosyanın başına `#ifndef FILENAME_H` ve `#define FILENAME_H` ekleyin ve dosyanın sonuna `#endif` ekleyin. Bu şekilde dosya sadece bir kez eklenir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753148"
  },
  {
    "question": "Kodumda #line direktifi kullanıyorum ama beklenmedik bir hata alıyorum. Neden?",
    "answer": "#line direktifi, derleyiciye kaynak dosyasındaki satır numarasını ve dosya adını değiştirmesi için bilgi verir. Eğer bu direktifi yanlış bir yerde kullanıyorsanız, derleyici dosyanızı yanlış gösterebilir. Örneğin, #line direktifini bir fonksiyonun ortasında kullanmak, hata mesajlarındaki satır numaralarının karışmasına neden olabilir. Bu direktifi dikkatli kullanmalısınız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:34:11.753172"
  },
  {
    "question": "Kodumda #define ile tanımladığım bir makroyu #ifdef ile kontrol ediyorum, ama beklediğim gibi çalışmıyor. Neden?",
    "answer": "Muhtemelen makro tanımınız, kodun derlenmeden önceki aşamasında tanımlanmamış. #ifdef direktifi, yalnızca tanımlı olan makroları kontrol eder. Örneğin:\n\n```c\n#define MY_MACRO\n\n#ifdef MY_MACRO\n// Bu kısım derlenecek\n#else\n// Bu kısım derlenmeyecek\n#endif\n```\nEğer `#define MY_MACRO` satırını kaldırırsanız, `#ifdef MY_MACRO` içerisindeki kod derlenmeyecektir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918345"
  },
  {
    "question": "Kodumda #include direktifi kullanarak bir dosyayı dahil ettim, ama içeriği göremiyorum. Sorun ne olabilir?",
    "answer": "Muhtemelen dosya yolu ya da dosya adı yanlış. #include direktifi, belirtilen dosyayı bulamazsa hata verir ama bazen sadece önceden tanımlı dosyaların içeriği gözükmez. Şu şekilde kontrol edin:\n\n```c\n#include \"header.h\" // Eğer header.h'yı aynı dizinde bulamıyorsanız doğru yolu kullanmalısınız.\n```\nAyrıca, dosyanın uygun şekilde tanımlandığından emin olun.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918426"
  },
  {
    "question": "Koşullu derleme kullanarak bazı kod parçalarını dışlamak istiyorum ama derleyici her iki durumu da derliyor. Neden?",
    "answer": "Bu durum genellikle yanlışlıkla alt koşullu direktif kullanımı nedeniyle meydana gelir. Örneğin, `#if` direktifini kullandıysanız, `#else` ile birlikte her iki durum da korunursa, her iki durum da derlenecektir. Örneğin:\n\n```c\n#if 0\n// Bu kısım derlenmez\n#else\n// Bu kısım derlenir\n#endif\n```\nKoşulun doğru yazıldığından emin olun.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918483"
  },
  {
    "question": "Birden fazla dosyadaki #define tanımlarının çakıştığını düşünüyorum. Nasıl çözebilirim?",
    "answer": "Çakışmaları önlemek için makrolarınıza daha özgün isimler vermek iyi bir çözümdür. Ayrıca, `#undef` direktifi ile önceden tanımlanmış bir makroyu kaldırabilirsiniz. Örneğin:\n\n```c\n#define MY_MACRO\n// Kod\n#undef MY_MACRO\n#define MY_MACRO2\n// Kod\n```\nBu şekilde, mevcut tanımı kaldırarak yeni bir tanım yapabilirsiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918546"
  },
  {
    "question": "Makro tanımlarken parametre geçmem gerekti, ama beklediğim gibi çalışmıyor. Neden?",
    "answer": "Makro tanımında parantezleri doğru kullanmamış olabilirsiniz. Makrolarda parametre geçerken dikkat etmeniz gereken bir durum, parametrelerin doğru bir şekilde parantez içine alınmasıdır. Örneğin:\n\n```c\n#define SQUARE(x) ((x) * (x))\n```\nEğer bu parantezleri kullanmazsanız, `SQUARE(1 + 2)` ifadesi `1 + 2 * 1 + 2` olarak derlenir ki bu yanlıştır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918593"
  },
  {
    "question": "Kodda #pragma direktifi kullanıyorum ama derleyici bunu görmezden geliyor. Neden?",
    "answer": "Bu durum, #pragma direktifinin derleyiciye özgü olmasından kaynaklanıyor olabilir. Her derleyici, #pragma'nın farklı anlamlar taşıyabilir. Örneğin, GCC ve MSVC gibi derleyicilerin #pragma kullanımı farklılık gösterebilir. Bu nedenle, kullandığınız derleyicinin belgelerini kontrol etmeli ve desteklenen #pragma direktiflerini incelemelisiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918636"
  },
  {
    "question": "Farklı platformlar için aynı kodu derlemek istiyorum ama #ifdef kullanırken sorun yaşıyorum. Çözüm nedir?",
    "answer": "Platforma özgü makrolar tanımlamak için, belirli derleyici veya platform için #define kullanmalısınız. Örneğin:\n\n```c\n#ifdef _WIN32\n// Windows için kod\n#elif defined(__linux__)\n// Linux için kod\n#endif\n```\nBu şekilde, her platform için ayrı ayrı kod yazabilirsiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918691"
  },
  {
    "question": "Benim kodumda #ifndef kullanarak bir şey tanımladım ama her zaman tanımlı görünmüyor. Hata ne?",
    "answer": "Bu durum, #ifndef direktifinin kontrol ettiği makronun daha önce tanımlanmış olması anlamına gelir. Örneğin:\n\n```c\n#ifndef MY_MACRO\n#define MY_MACRO\n// Kod\n#endif\n```\nEğer `MY_MACRO` zaten tanımlıysa, bu koşul hiçbir zaman sağlanmaz ve içerik derlenmez.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918742"
  },
  {
    "question": "Kodumda tanımlı olan makroları değiştirmek istiyorum ama derleyici hata veriyor. Neden?",
    "answer": "Makrolar bir kez tanımlandıktan sonra, yeniden tanımlanmaya çalışıldığında hata alırsınız. Bunun önüne geçmek için `#undef` ile önce makroyu kaldırmalısınız. Örneğin:\n\n```c\n#define MY_MACRO 10\n#undef MY_MACRO\n#define MY_MACRO 20\n```\nBu şekilde, ilk tanımı kaldırıp yeni bir tanım yapabilirsiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918788"
  },
  {
    "question": "Makro tanımlarken yanlış bir işlemi gerçekleştirdiğimi düşünüyorum. Bu durumu nasıl kontrol edebilirim?",
    "answer": "Makro genişletmelerini görmek için derleyiciye `-E` seçeneği ile ön işleme aşamasını kullanabilirsiniz. Örneğin:\n\n```bash\ngcc -E myfile.c\n```\nBu, makroların nerelerde nasıl genişletildiğini görebilmenizi sağlar. Böylece hataları daha kolay tespit edebilirsiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:35:04.918839"
  },
  {
    "question": "C dilinde #define direktifi ile makro tanımlamanın avantajları nelerdir?",
    "answer": "#define direktifi, sabit değerler veya fonksiyon benzeri makrolar tanımlamak için kullanılır. Bu, kodun okunabilirliğini artırır ve sabit değerlerin merkezi bir yerden yönetilmesine olanak tanır. Örneğin, #define PI 3.14 ile PI değerini her yerde kullanabiliriz. Bu, kodun bakımını ve değişikliklerini kolaylaştırır çünkü PI değerini değiştirdiğimizde, tüm kodda otomatik olarak güncellenir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234594"
  },
  {
    "question": "#include direktifi neden önemlidir ve nasıl kullanılır?",
    "answer": "#include direktifi, başka bir dosyadaki tanımları mevcut dosyaya dahil etmek için kullanılır. Bu, kodun modüler olmasını sağlar. Örneğin, bir kütüphane dosyasını (örneğin, <stdio.h>) dahil ederek o kütüphanenin işlevlerini kullanabiliriz. Kullanım şekli: #include <stdio.h> veya #include \"myheader.h\". Birincisi sistem kütüphanelerini, ikincisi ise kullanıcı tanımlı başlık dosyalarını dahil eder.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234634"
  },
  {
    "question": "Conditional compilation (koşullu derleme) nedir ve nasıl kullanılır?",
    "answer": "Koşullu derleme, belirli koşullar altında kodun yalnızca belirli bölümlerinin derlenmesini sağlamak için kullanılır. Bu, #ifdef, #ifndef, #else, #elif ve #endif direktifleri ile gerçekleştirilir. Örneğin, #ifdef DEBUG ile kodun yalnızca DEBUG tanımlı olduğunda derlenmesini sağlayabiliriz. Bu, geliştirme ve üretim ortamlarında farklı davranışlar elde etmemizi sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234661"
  },
  {
    "question": "Makro ile fonksiyon arasındaki farklar nelerdir?",
    "answer": "Makrolar, derleme zamanında metin değiştirme işlemidir; bu nedenle performans avantajı sağlar. Fonksiyonlar ise çalışma zamanında çağrılır ve tipi kontrolü yapılır. Örneğin, #define MAX(a, b) ((a) > (b) ? (a) : (b)) şeklinde bir makro tanımlarsak, bu her yerde metin olarak yer değiştirecek, ancak fonksiyon kullanırsak derleyici tarafından tip kontrolü yapılacaktır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234679"
  },
  {
    "question": "Preprocessor direktifleri ile global değişkenleri nasıl yönetiriz?",
    "answer": "Global değişkenleri yönetmek için genellikle #define ve extern anahtar kelimesi kullanılır. Örneğin, bir dosyada global bir değişken tanımlayıp, diğer dosyalarda erişmek için extern kullanabiliriz. Bu, değişkenin sadece bir kez tanımlanmasını ve başka dosyalarda kullanılabilmesini sağlar. Örnek: int globalVar; // main.c dosyası. extern int globalVar; // another.c dosyası.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234700"
  },
  {
    "question": "#pragma direktifi ne işe yarar, örnek verebilir misin?",
    "answer": "#pragma direktifi, derleyiciye özel talimatlar vermek için kullanılır ve her derleyici için farklılık gösterebilir. Örneğin, #pragma once direktifi, bir başlık dosyasının yalnızca bir kez dahil edilmesini sağlamak için kullanılır. Bu, çoğaltma hatalarını önler ve derleme süresini kısaltır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234723"
  },
  {
    "question": "C dilinde #undef direktifi ne amaçla kullanılır?",
    "answer": "#undef direktifi, daha önce tanımlanmış bir makronun tanımını kaldırmak için kullanılır. Örneğin, bir makro tanımlandıktan sonra artık kullanılmaması gerekiyorsa, #undef MY_MACRO ile o makroyu iptal edebiliriz. Bu, özellikle koşullu derlemede değişiklik gerektiğinde faydalıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234743"
  },
  {
    "question": "#if, #else ve #endif direktiflerinin kullanımına bir örnek verebilir misin?",
    "answer": "Bu direktifler, koşullu derleme için kullanılır. Örneğin, #if !defined(NDEBUG) ile DEBUG modunda kod yazmak için kullanılabiliriz. Eğer NDEBUG tanımlı değilse, #else ile alternatif bir kod parçası ekleyebiliriz. Bu, geliştiricinin hangi kodun derleneceğini kontrol etmesine olanak tanır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234770"
  },
  {
    "question": "Başlık dosyalarının (#include) neden iyi bir uygulama olduğunu açıkla.",
    "answer": "Başlık dosyaları, kodun modüler ve yeniden kullanılabilir olmasını sağlar. Fonksiyon prototipleri, makrolar ve veri yapıları gibi tanımları merkezi bir yerden yöneterek kodun daha düzenli olmasına yardımcı olur. Ayrıca, aynı başlık dosyası birden fazla dosyada kullanılabilir, bu da kod tekrarı ve bakımını azaltır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234796"
  },
  {
    "question": "C dilinde çoklu başlık dosyası korumalarının sağlanması için ne yapılmalıdır?",
    "answer": "Çoklu başlık dosyası koruması sağlamak için genellikle include guards (dahil korumaları) kullanılır. Bunun için başlık dosyasının en üstüne #ifndef ve #define eklenir ve dosyanın sonunda #endif ile kapatılır. Örnek: \n#ifndef MYHEADER_H\n#define MYHEADER_H\n... // başlık içeriği\n#endif",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:09.234822"
  },
  {
    "question": "C programında bir değişken için birden fazla değer tanımlamak için nasıl bir preprocessor directive kullanabiliriz?",
    "answer": "Preprocessor directive olarak '#define' kullanabiliriz. Örneğin, bir sabit tanımlamak için: \n\n#define PI 3.14\n\nBu sayede kodumuzda 'PI' ifadesini kullandığımızda otomatik olarak 3.14 değeri ile değiştirilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562107"
  },
  {
    "question": "C programında platforma özgü kod parçalarını nasıl ayırabiliriz?",
    "answer": "Bunu yapmanın yolu '#ifdef', '#ifndef', '#endif' direktiflerini kullanmaktır. Örneğin:\n\n#ifdef _WIN32\n    printf(\"Windows'tasınız.\");\n#else\n    printf(\"Windows dışında bir platformdasınız.\");\n#endif\n\nBu şekilde, programımız hangi platformda derleniyorsa ona uygun kodu çalıştırır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562145"
  },
  {
    "question": "C programlarında hata ayıklama sırasında hangi preprocessor direktifleri kullanılabilir?",
    "answer": "Hata ayıklama için '#ifdef DEBUG' veya '#ifndef NDEBUG' direktiflerini kullanabiliriz. Örneğin:\n\n#ifdef DEBUG\n    printf(\"Hata ayıklama modu açıktır.\");\n#endif\n\nBu şekilde, 'DEBUG' tanımlandığında hata ayıklama mesajları yazdırılır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562172"
  },
  {
    "question": "C dilinde birden fazla dosya için ortak bir başlık dosyası oluştururken hangi direktifleri kullanmalıyız?",
    "answer": "Bu durumda '#ifndef', '#define' ve '#endif' direktiflerini kullanarak bir include guard oluşturmalıyız. Örneğin:\n\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n// Başlık dosyası içeriği buraya\n\n#endif  // MY_HEADER_H\n\nBu, başlık dosyasının birden fazla kez dahil edilmesini önler.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562203"
  },
  {
    "question": "C programında bir fonksiyonun parametrelerinin sayısını değiştirmek için hangi preprocessor direktifini kullanabiliriz?",
    "answer": "Parametre sayısını değiştirmek için '#define' ile makro tanımlayabiliriz. Örneğin:\n\n#define SQUARE(x) ((x) * (x))\n\nBu makro ile SQUARE(5) ifadesi 25 sonucunu döndürecektir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562234"
  },
  {
    "question": "C programında birden fazla dosya içindeki değişkenleri tanımlamak için nasıl bir yapı kullanmalıyız?",
    "answer": "Bu durumda '#include' direktifini kullanarak ortak bir başlık dosyası oluşturabiliriz. Örneğin, 'config.h' dosyasında ortak değişkenler tanımlanabilir ve diğer dosyalarda şu şekilde dahil edilebilir:\n\n#include \"config.h\"\n\nBu sayede ortak değişkenlere erişim sağlanır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562262"
  },
  {
    "question": "C dilinde belirli bir kod parçasının sadece bir kez derlenmesini sağlamak için hangi direktifi kullanmalıyız?",
    "answer": "Bunu sağlamak için '#pragma once' direktifini kullanabiliriz. Örneğin:\n\n#pragma once\n\nBu direktif, dosyanın her derleme aşamasında sadece bir kez dahil edilmesini garanti eder.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562292"
  },
  {
    "question": "C programında bir hata mesajı göndermek için hangi preprocessor direktifini kullanabiliriz?",
    "answer": "Hata mesajı göndermek için '#error' direktifini kullanabiliriz. Örneğin:\n\n#error \"Bu bir hata mesajıdır!\"\n\nBu direktif, derleyiciye bir hata mesajı gönderir ve derlemeyi durdurur.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562328"
  },
  {
    "question": "C dilinde platform bağımsız bir uygulama geliştirmek için hangi preprocessor direktiflerinden yararlanmalıyız?",
    "answer": "Platform bağımsız kod yazmak için '#ifdef' ve '#else' direktiflerini kullanarak platforma özgü kodları ayırabiliriz. Örneğin:\n\n#ifdef __linux__\n    printf(\"Linux platformunda çalışıyor.\");\n#else\n    printf(\"Diğer bir platformda çalışıyor.\");\n#endif\n\nBu, kodumuzun hangi platformda çalıştığını kontrol etmemizi sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562357"
  },
  {
    "question": "C dilinde bir makroyu tanımlarken nasıl parametre kullanabiliriz?",
    "answer": "Makro tanımlarken parametre kullanmak için parantez içinde değişken isimlerini belirtebiliriz. Örneğin:\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nBu makro, iki sayı arasında en büyük olanı döndürür.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:26.562382"
  },
  {
    "question": "C dilinde bir dosyayı include etmek için nasıl bir preprocessor direktifi kullanılır?",
    "answer": "C dilinde bir dosyayı include etmek için ' #include ' preprocessor direktifini kullanırız. Örneğin, ' #include <stdio.h> ' ifadesi, standart girdi/çıktı işlemleri için gerekli olan kütüphaneyi programımıza dahil eder. Eğer kendi oluşturduğumuz bir başlık dosyasını dahil etmek istiyorsak, ' #include \"my_header.h\" ' şeklinde kullanırız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204813"
  },
  {
    "question": "C dilinde bir makro tanımlamak için hangi direktifi kullanırız ve nasıl tanımlanır?",
    "answer": "C dilinde makro tanımlamak için ' #define ' direktifini kullanırız. Örneğin, ' #define PI 3.14 ' ifadesi, 'PI' adında bir makro oluşturur. Program içerisinde 'PI' kullanıldığında, derleyici bunu 3.14 ile değiştirecektir. Bu, kodun okunabilirliğini artırır ve değerleri tek bir yerden yönetmemizi sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204856"
  },
  {
    "question": "Koşullu derleme nedir ve nasıl uygulanır?",
    "answer": "Koşullu derleme, belirli koşullara bağlı olarak kodun belirli kısımlarını derleyip derlememek için kullanılır. ' #ifdef ' ve ' #ifndef ' direktifleri bu amaçla kullanılır. Örneğin, ' #ifdef DEBUG ' ifadesi, DEBUG tanımlıysa belirli kodun derlenmesini sağlar. Bu, hata ayıklama sürecinde faydalıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204877"
  },
  {
    "question": "Birden fazla dosyada aynı makro tanımlandığında ne olur ve bunu önlemek için ne yapabiliriz?",
    "answer": "Birden fazla dosyada aynı makro tanımlandığında derleyici hata verebilir. Bunu önlemek için ' #ifndef ' ve ' #define ' kombinasyonunu kullanarak koşullu olarak tanım yapabiliriz. Örneğin:\n\n```c\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n// Kodlar buraya\n\n#endif\n```\nBu, 'MY_HEADER_H' makrosu tanımlı değilse kodun sadece bir kez derlenmesini sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204908"
  },
  {
    "question": "C dilinde bir hata mesajı veya uyarı için preprocessor direktifi nasıl kullanılır?",
    "answer": "C dilinde ' #error ' direktifi kullanarak bir hata mesajı oluşturabiliriz. Bu direktif, derleme sırasında belirli bir koşul oluştuğunda hata vermek için kullanılabilir. Örneğin:\n\n```c\n#if !defined(MY_MACRO)\n#error \"MY_MACRO tanımlı değil!\"\n#endif\n```\nBu, MY_MACRO tanımlı değilse hata mesajı verecektir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204934"
  },
  {
    "question": "C dilinde birden fazla dosya için ortak ayarları nasıl tanımlarsınız?",
    "answer": "Ortak ayarları tanımlamak için bir konfigürasyon başlık dosyası oluşturabiliriz. Örneğin, 'config.h' adlı bir dosya oluşturarak burada sabitler ve makrolar tanımlayabiliriz. Diğer dosyalar bu başlık dosyasını ' #include \"config.h\" ' ile dahil edebilir. Böylece tüm dosyalar aynı ayarları kullanır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204967"
  },
  {
    "question": "Preprocessor'un ' #pragma ' direktifi nedir ve nasıl kullanılır?",
    "answer": "' #pragma ' direktifi, derleyiciye özel talimatlar vermek için kullanılır. Örneğin, ' #pragma once ' direktifi, bir dosyanın birden fazla kez dahil edilmesini önler. Örnek bir kullanım:\n\n```c\n#pragma once\n\n// Kodlar buraya\n```\nBu, dosyanın sadece bir kez derlenmesini sağlar ve derleyici için performans artışı sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.204991"
  },
  {
    "question": "Preprocessor direktifleri ile platform bağımlı kod nasıl yazılır?",
    "answer": "Platform bağımlı kod yazmak için ' #ifdef ', ' #ifndef ' gibi direktifleri kullanarak belirli platformlara özel kod parçalarını tanımlayabiliriz. Örneğin:\n\n```c\n#ifdef _WIN32\n// Windows'a özgü kod\n#else\n// Diğer platformlara özgü kod\n#endif\n```\nBu şekilde kod, derlendiği platforma göre değişiklik gösterir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.205013"
  },
  {
    "question": "C dilinde bir preprocessor makrosunun parametre alması nasıl sağlanır?",
    "answer": "Parametre alan bir makro tanımlamak için ' #define ' direktifi kullanılır. Örneğin, iki sayının toplamını hesaplamak için:\n\n```c\n#define SUM(x, y) ((x) + (y))\n```\nBu, 'SUM(3, 5)' ifadesi kullanıldığında 8 olarak değerlendirilecektir. Parantez kullanımı, yanlış değerlendirmeleri önlemek için önemlidir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.205034"
  },
  {
    "question": "C dilinde, preprocessor direktifleri ile fonksiyonları nasıl inline hale getiririz?",
    "answer": "Preprocessor direktifleri ile inline fonksiyonlar oluşturmak için ' #define ' kullanabiliriz. Örneğin:\n\n```c\n#define INLINE_FUNC(x) (x * x)\n```\nBu fonksiyonu çağırdığımızda derleyici, bu ifadeyi direkt kod içerisine yerleştirir, böylece çağrı overhead'ini ortadan kaldırır. Ancak, bu kullanım dikkatli yapılmalıdır, çünkü büyük fonksiyonlar inline hale getirilirse kod boyutu artabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:36:52.205059"
  },
  {
    "question": "Preprocessor direktifleri kullanarak birden fazla dosyadan alınan veri ile toplam hesaplayan bir program nasıl yazılır?",
    "answer": "C dilinde, birden fazla dosyadan veri almak için \"#include\" direktifini kullanabiliriz. Örneğin, 'data.h' dosyasında veriler bulunuyorsa, 'main.c' dosyasında bu dosyayı içe aktararak verileri kullanabiliriz. Aşağıda bir örnek verilmektedir:\n\n```c\n// data.h\nint data1 = 10;\nint data2 = 20;\n\n// main.c\n#include <stdio.h>\n#include \"data.h\"\n\nint main() {\n    int sum = data1 + data2;\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n```\nBu program, data1 ve data2 değişkenlerini data.h dosyasından alarak toplamını hesaplar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927381"
  },
  {
    "question": "Debug modunu aktif hale getirmek için nasıl bir preprocessor direktifi kullanılır?",
    "answer": "C dilinde, debug modunu yönetmek için genellikle \"#define\" direktifi kullanılır. Aşağıda bir örnek verilmiştir:\n\n```c\n// my_debug.h\n#ifdef DEBUG\n#define DEBUG_PRINT(x) printf(\"DEBUG: %s\\n\", x)\n#else\n#define DEBUG_PRINT(x)\n#endif\n\n// main.c\n#include <stdio.h>\n#include \"my_debug.h\"\n\nint main() {\n    DEBUG_PRINT(\"Program başladı.\");\n    // Diğer kodlar\n    return 0;\n}\n```\nBu kod, DEBUG tanımlıysa mesajı yazdırır, aksi takdirde hiçbir şey yapmaz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927424"
  },
  {
    "question": "Koşullu derleme kullanarak bir fonksiyonu farklı platformlarda nasıl tanımlarsınız?",
    "answer": "Farklı platformlarda aynı isimde farklı fonksiyonlar tanımlamak için \"#ifdef\" ve \"#elif\" direktiflerini kullanabiliriz. Aşağıda bir örnek:\n\n```c\n// platform.h\n#ifdef WINDOWS\nvoid myFunction() {\n    printf(\"Windows versiyonu\\n\");\n}\n#elif defined(LINUX)\nvoid myFunction() {\n    printf(\"Linux versiyonu\\n\");\n}\n#else\nvoid myFunction() {\n    printf(\"Bilinmeyen platform\\n\");\n}\n#endif\n```\nBu kod, derleme sırasında hangi platformda çalışıldığını kontrol eder ve uygun fonksiyonu tanımlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927451"
  },
  {
    "question": "Birden fazla dosyada ortak kullanılan sabitleri tanımlamak için en iyi yaklaşım nedir?",
    "answer": "Ortak sabitleri tanımlamak için \"#define\" ile bir header dosyası oluşturmak en iyi yaklaşımdır. Aşağıda bir örnek verilmiştir:\n\n```c\n// constants.h\n#define PI 3.14\n#define E 2.71\n\n// main.c\n#include <stdio.h>\n#include \"constants.h\"\n\nint main() {\n    printf(\"PI: %f\\n\", PI);\n    printf(\"E: %f\\n\", E);\n    return 0;\n}\n```\nBu şekilde, sabitler birden fazla dosyada kullanılabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927479"
  },
  {
    "question": "Preprocessor direktifleri ile çoklu dosya koruması nasıl sağlanır?",
    "answer": "Çoklu dosya koruması için \"#ifndef\", \"#define\" ve \"#endif\" direktifleri kullanılır. Aşağıda bir örnek verilmiştir:\n\n```c\n// my_header.h\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\nvoid myFunction();\n\n#endif\n```\nBu kod, my_header.h dosyasının birden fazla kez dahil edilmesini engeller.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927503"
  },
  {
    "question": "Makrolar kullanarak bir fonksiyonun nasıl daha kısa yazılabileceğini gösterin.",
    "answer": "Makrolar ile fonksiyonları daha kısa yazmak mümkündür. Örneğin, aşağıdaki gibi bir makro tanımı yapabiliriz:\n\n```c\n#define SQUARE(x) ((x) * (x))\n\n// main.c\n#include <stdio.h>\n#include \"my_header.h\"\n\nint main() {\n    int num = 5;\n    printf(\"Karesi: %d\\n\", SQUARE(num));\n    return 0;\n}\n```\nBu kodda, SQUARE makrosu kullanılarak num değişkeninin karesi hesaplanmıştır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927545"
  },
  {
    "question": "Preprocessor ile birden fazla derleme seçeneği nasıl yönetilir?",
    "answer": "Birden fazla derleme seçeneği için \"#if\", \"#elif\" ve \"#else\" direktiflerini kullanabiliriz. Örneğin:\n\n```c\n#define VERSION 2\n\n#if VERSION == 1\n#define FEATURE \"Özellik 1\"\n#elif VERSION == 2\n#define FEATURE \"Özellik 2\"\n#else\n#define FEATURE \"Varsayılan Özellik\"\n#endif\n\n// main.c\n#include <stdio.h>\n#include \"feature.h\"\n\nint main() {\n    printf(\"Seçilen: %s\\n\", FEATURE);\n    return 0;\n}\n```\nBu örnekte, derleme sırasında hangi özelliklerin kullanılacağını belirliyoruz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927567"
  },
  {
    "question": "Preprocessor direktifleri ile global değişkenlerin tanımlanmasını nasıl yönetirsiniz?",
    "answer": "Global değişkenlerin tanımlanması için bir header dosyası kullanarak değişkenleri tanımlamak ve \"extern\" anahtar kelimesini kullanmak gereklidir. Örnek:\n\n```c\n// globals.h\n#ifndef GLOBALS_H\n#define GLOBALS_H\n\nextern int globalVar;\n\n#endif\n\n// globals.c\n#include \"globals.h\"\nint globalVar = 100;\n\n// main.c\n#include <stdio.h>\n#include \"globals.h\"\n\nint main() {\n    printf(\"Global Değişken: %d\\n\", globalVar);\n    return 0;\n}\n```\nBu yöntem, global değişkenlerinizi yönetmek için etkilidir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927590"
  },
  {
    "question": "C dilinde derleme zamanında değişkenlerin değerini nasıl değiştirebilirsiniz?",
    "answer": "Derleme zamanında değişken değerlerini değiştirmek için \"#define\" ile sabitler oluşturabiliriz. Örneğin:\n\n```c\n#define VALUE 10\n\n// main.c\n#include <stdio.h>\n\nint main() {\n    int variable = VALUE * 2;\n    printf(\"Değer: %d\\n\", variable);\n    return 0;\n}\n```\nBu kodda, derleme zamanında VALUE sabitinin değeri kullanılarak değişkenin değeri hesaplanmıştır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927615"
  },
  {
    "question": "Preprocessor ile birden fazla proje yapılandırmasını nasıl oluşturursunuz?",
    "answer": "Birden fazla proje yapılandırması için farklı tanımlar yaparak ve bu tanımlara göre koşullu derleme yaparak çözümler üretebiliriz. Örneğin:\n\n```c\n// config.h\n#define DEBUG_MODE\n\n// main.c\n#include <stdio.h>\n#include \"config.h\"\n\nint main() {\n#ifdef DEBUG_MODE\n    printf(\"Debug modu aktif\\n\");\n#else\n    printf(\"Debug modu kapalı\\n\");\n#endif\n    return 0;\n}\n```\nBu örnekte, DEBUG_MODE tanımlıysa debug mesajı gösterilecektir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:26.927638"
  },
  {
    "question": "Kodda yer alan #define direktifinin kullanımı nasıl optimize edilir?",
    "answer": "#define direktifi ile sabit değerler tanımlamak yaygındır. Ancak, tür güvenliği sağlamaz. Bunun yerine 'const' anahtar kelimesi ile sabitleri tanımlamak daha iyidir. Örneğin:\n\n// Eski yöntem\n#define PI 3.14\n\n// Yeni yöntem\nconst double PI = 3.14;\n\nBu şekilde, PI değişkenini bir türle birlikte kullanarak kodunuzun daha okunabilir ve güvenli olmasını sağlarsınız.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044833"
  },
  {
    "question": "#ifdef ve #ifndef direktiflerinin kullanımındaki fark nedir?",
    "answer": "#ifdef, belirtilen bir makronun tanımlı olup olmadığını kontrol ederken, #ifndef ise tanımlı değilse kodu derler. Örneğin:\n\n#ifdef MY_MACRO\n// MY_MACRO tanımlıysa burası çalışır\n#else\n// MY_MACRO tanımlı değilse burası çalışır\n#endif\n\nBu direktifleri, başlık dosyalarını korumak için kullanabiliriz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044871"
  },
  {
    "question": "Preprocessor direktifleri kodun okunabilirliğini nasıl etkiler?",
    "answer": "Preprocessor direktiflerinin aşırı kullanımı kodun okunabilirliğini düşürebilir. Örneğin, çok fazla #ifdef veya #define kullanmak, kodun akışını zorlaştırabilir. Bunun yerine, yapılandırma dosyaları veya yapılandırma sınıfları kullanarak doğrudan kodda sabitler tanımlamak daha iyidir. Örneğin, yapılandırma dosyası ile daha iyi bir ayrım sağlanabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044922"
  },
  {
    "question": "#pragma direktifinin amacı nedir ve nasıl kullanılır?",
    "answer": "#pragma, derleyiciye özel yönergeler verebilmek için kullanılır. Örneğin, derleyiciye belirli bir optimizasyon düzeyini ayarlamak için kullanılabilir:\n\n#pragma GCC optimize(\"O2\")\n\nBu tür direktifler, daha iyi performans sağlamak için kritik bölümlerde kullanılabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044943"
  },
  {
    "question": "Conditional compilation nedir ve nasıl kullanılır?",
    "answer": "Conditional compilation, belirli koşullar altında kod bloklarının derlenmesini sağlamak için kullanılır. Örneğin, farklı platformlar için özel kod yazmanız gerektiğinde:\n\n#ifdef WINDOWS\n// Windows'a özel kod\n#else\n// Diğer platformlar için kod\n#endif\n\nBu yöntem, platform bağımsız yazılım geliştirmede büyük kolaylık sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044962"
  },
  {
    "question": "Bir başlık dosyasında #include direktifini nasıl verimli kullanabiliriz?",
    "answer": "#include direktifi ile başlık dosyalarını ekleriz ancak karmaşık projelerde döngüsel bağımlılıkları önlemek için include guard kullanmak şarttır. Örneğin:\n\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n// Başlık dosyası içeriği buraya\n#endif\n\nBu yöntem, başlık dosyalarının birden fazla kez dahil edilmesini engelleyerek derleme süresini kısaltır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.044986"
  },
  {
    "question": "Preprocessor ile hata ayıklamada hangi direktifler kullanılır?",
    "answer": "Hata ayıklamada #error direktifi, belirli bir koşul sağlanmadığında hata mesajı oluşturmak için kullanılabilir. Örneğin:\n\n#ifdef DEBUG\n#error Debug modda çalışamaz\n#endif\n\nBu, geliştirme sırasında belirli hataları kolayca yakalamamızı sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.045008"
  },
  {
    "question": "#elif direktifi ne zaman kullanılır?",
    "answer": "#elif, bir #ifdef veya #ifndef direktifinden sonra gelen bir koşullu direktiftir. Birden fazla koşulu kontrol etmek için faydalıdır:\n\n#ifdef CONDITION1\n// Kod bloğu 1\n#elif defined(CONDITION2)\n// Kod bloğu 2\n#else\n// Diğer kod bloğu\n#endif\n\nBu yapıyla, kodunuzu daha düzenli bir şekilde kontrol edebilirsiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.045026"
  },
  {
    "question": "Preprocessor ile makroların sınırları nelerdir?",
    "answer": "Makrolar, fonksiyon benzeri ifadeler yazmak için kullanılabilir, ancak tür güvenliği sağlamaz ve hata ayıklama sırasında zor olabilir. Daha karmaşık işlemler için inline fonksiyonlar kullanmak daha iyidir:\n\n#define SQUARE(x) ((x) * (x))\n\nYukarıdaki makro, x'in türüne göre beklenmedik sonuçlara yol açabilir. Bunun yerine:\n\ninline int square(int x) { return x * x; }\n\nkullanmak, hataların daha kolay bulunmasını sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.045044"
  },
  {
    "question": "#undef direktifi ne amaçla kullanılır?",
    "answer": "#undef, daha önce tanımlanan bir makronun tanımını kaldırmak için kullanılır. Örneğin:\n\n#define TEMP_VALUE 100\n#undef TEMP_VALUE\n\nBu, belirli bir kod bloğunda kullanmak istemediğiniz makroları kaldırmak için yararlıdır. Ancak, dikkatli kullanılmalıdır, çünkü yanlışlıkla ihtiyaç duyulan bir makroyu kaldırmak hatalara yol açabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:37:52.045062"
  },
  {
    "question": "Kodda #define ile tanımlanan bir sabitin değerini değiştirmek istiyorum, ancak bu sabit birçok yerde kullanılıyor. Bu durumu nasıl yönetebilirim?",
    "answer": "Sabitlerin değerini değiştirmek için #define yerine const ya da enum kullanmayı düşünebilirsiniz. Örneğin:\n\n```c\nconst int MAX_USERS = 100;\n```\nBu sayede MAX_USERS sabitini sadece bir yerde tanımlayıp, gerektiğinde farklı değerlerle değiştirebilirsiniz. Ayrıca, sabitin kullanıldığı tüm yerlerde güncellenmesini sağlayabilirsiniz. #define kullanımı derleme zamanında sabitleri statik olarak tanımlar ve değiştirilmesi zor olabilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498209"
  },
  {
    "question": "Projemde yalnızca debug modda geçerli olacak kod parçalarını nasıl tanımlayabilirim?",
    "answer": "Debug modda geçerli olacak kod parçaları için #ifdef ve #endif direktiflerini kullanarak koşullu derleme yapabilirsiniz. Örnek:\n\n```c\n#ifdef DEBUG\n    printf(\"Debug mode is active\");\n#endif\n```\nBurada DEBUG isimli tanımlayıcı tanımlandığında, ilgili kod parçaları derlenecektir. DEBUG tanımlayıcısını derleme komutunuza eklemeyi unutmayın.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498252"
  },
  {
    "question": "Projemde sıkça kullanılan bir fonksiyonu makro olarak tanımlamak istiyorum. Ancak, bu makro çok karmaşık ve yan etkileri olabilecek bir ifade içeriyor. Ne yapmalıyım?",
    "answer": "Makro kullanımı yerine inline fonksiyonları tercih etmelisiniz. Makrolar, derleme zamanında işlem yapar ve yan etkiler oluşturabilir. Inline fonksiyonlar ise derleme zamanında daha güvenli bir şekilde çağrılır. Örneğin:\n\n```c\ninline int square(int x) { return x * x; }\n```\nBu sayede hem performans kazanımı sağlarsınız hem de tür güvenliği elde edersiniz.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498299"
  },
  {
    "question": "Birden fazla dosyada aynı preprocessor direktiflerini tanımlamak zorundayım. Bu durumdan nasıl kaçınabilirim?",
    "answer": "Preprocessor direktiflerini merkezi bir dosyada tanımlayıp, bu dosyayı diğer tüm kaynak dosyalarda #include ile ekleyebilirsiniz. Örneğin, 'config.h' gibi bir dosya oluşturun:\n\n```c\n#ifndef CONFIG_H\n#define CONFIG_H\n#define MAX_CONNECTIONS 10\n#endif\n```\nSonrasında bu dosyayı diğer kaynak dosyalarınızda şu şekilde ekleyin:\n\n```c\n#include \"config.h\"\n```\nBu yöntem, kodunuzu daha düzenli hale getirir ve tekrar eden tanımlamalardan kaçınmanızı sağlar.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498329"
  },
  {
    "question": "Preprocessor direktiflerinin sırasının önemli olduğu durumlarla karşılaştım. Bu durumu nasıl yönetebilirim?",
    "answer": "Preprocessor direktiflerinin sırası gerçekten önemlidir. Öncelikle, bağımlı olan tanımlamaları ilk başta yapmak gereklidir. Örneğin, bir typedef kullanan bir makro tanımlıyorsanız, typedef'in makrodan önce tanımlandığından emin olmalısınız. Bu sebeple, dosyalarınızı düzenlerken bağımlılıkları göz önünde bulundurmalısınız. Genellikle, başlık dosyasında tüm tanımlamalar ve typedef’ler üstte, fonksiyon prototipleri aşağıda yer almalıdır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498357"
  },
  {
    "question": "Karmaşık bir kod yapım mevcut ve bu yapının belirli bölümlerini koşullu olarak dışlamak istiyorum. #ifdef yerine ne kullanmalıyım?",
    "answer": "Koşullu dışlama için #if ve #elif kullanabilirsiniz. Bu sayede daha fazla esneklik kazanır ve birden fazla durumu kontrol edebilirsiniz. Örneğin:\n\n```c\n#if defined(VERSION_A)\n    // Kod bloğu A\n#elif defined(VERSION_B)\n    // Kod bloğu B\n#else\n    // Varsayılan kod bloğu\n#endif\n```\nBu yöntem, projenizde farklı versiyonları yönetmenize olanak tanır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498395"
  },
  {
    "question": "Projede belirli bir platforma özgü kodları nasıl yönetebilirim?",
    "answer": "Platforma özgü kodlara yönetmek için platforma özgü makrolar tanımlayarak koşullu derleme yapabilirsiniz. Örneğin:\n\n```c\n#ifdef _WIN32\n    // Windows'a özgü kod\n#elif defined(__linux__)\n    // Linux'a özgü kod\n#endif\n```\nBu sayede kodunuz, derlendiği platforma göre farklılık gösterebilir.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498417"
  },
  {
    "question": "Birçok farklı projede benzer preprocessor direktifleri kullanıyorum. Tekrar kullanmayı kolaylaştırmanın yolu nedir?",
    "answer": "Bu durumu yönetmek için bir başlık dosyası oluşturup, sık kullanılan direktifleri bu dosya içinde tanımlayabilirsiniz. Örneğin:\n\n```c\n// common_defs.h\n#ifndef COMMON_DEFS_H\n#define COMMON_DEFS_H\n#define BUFFER_SIZE 1024\n#define TIMEOUT 30\n#endif\n```\nHer projede bu dosyayı include ederek tüm sabitlere erişebilirsiniz. Bu yöntem, bakım ve güncellemeleri kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498448"
  },
  {
    "question": "Makro kullanırken değişken isimlerimde çakışma yaşanıyor. Bu durumu nasıl önlerim?",
    "answer": "Makrolar için daha özgün isimler kullanmalısınız veya #undef direktifi ile kullanım sonrası makroyu tanımsız hale getirmelisiniz. Örnek:\n\n```c\n#define MY_MACRO(x) (x * x)\n...\n#undef MY_MACRO\n```\nAlternatif olarak, fonksiyon kullanarak çakışmaların önüne geçebilirsiniz. Fonksiyonlar, kapsam içinde daha iyi çalışır ve çakışma riskini azaltır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498480"
  },
  {
    "question": "Preprocessor direktiflerini kullanarak hata ayıklama için daha fazla bilgi sağlamanın bir yolu var mı?",
    "answer": "Hata ayıklama için `#pragma message` direktifini kullanabilirsiniz. Bu direktif, derleme sürecinde belirli bir mesajı yazdırmanıza olanak tanır. Örnek:\n\n```c\n#pragma message \"Compiling version 1.0\"\n```\nBu sayede derleme sürecinizde hangi versiyonun derlendiğini takip edebilirsiniz. Bu gibi mesajlar hata ayıklama sürecini kolaylaştırır.",
    "category": "basic_syntax",
    "topic": "preprocessor",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Preprocessor directiveleri",
    "timestamp": "2025-06-01T14:38:19.498528"
  },
  {
    "question": "Kullanıcıdan 5 tam sayı girmesini isteyin ve bu sayıların toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n    int toplam = 0;\n\n    printf(\"5 adet tam sayı giriniz:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        toplam += sayilar[i];\n    }\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan 5 tam sayı alır ve bu sayıların toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402301"
  },
  {
    "question": "Kullanıcıdan alınan 10 öğrencinin notunu saklayın ve en yüksek notu bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int notlar[10];\n    int enYuksek = 0;\n\n    for(int i = 0; i < 10; i++) {\n        printf(\"Öğrenci %d notunu giriniz: \", i + 1);\n        scanf(\"%d\", &notlar[i]);\n        if(notlar[i] > enYuksek) {\n            enYuksek = notlar[i];\n        }\n    }\n\n    printf(\"En yüksek not: %d\\n\", enYuksek);\n    return 0;\n}\n\n// Açıklama: Bu program, 10 öğrencinin notlarını alır ve bu notlar arasındaki en yüksek değeri bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402346"
  },
  {
    "question": "Kullanıcıdan alınan 5 kelimenin uzunluklarını hesaplayarak ekrana yazdırın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelimeler[5][20];\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"Kelime %d: \", i + 1);\n        scanf(\"%s\", kelimeler[i]);\n    }\n\n    printf(\"Kelime uzunlukları:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"%s: %lu\\n\", kelimeler[i], strlen(kelimeler[i]));\n    }\n\n    return 0;\n}\n\n// Açıklama: Bu program, 5 kelime alır ve her bir kelimenin uzunluğunu hesaplayıp ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402373"
  },
  {
    "question": "Kullanıcıdan bir tam sayı dizisi alın ve dizinin elemanlarını tersine çevirin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n\n    printf(\"5 adet tam sayı giriniz:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    printf(\"Ters sıra: \");\n    for(int i = 4; i >= 0; i--) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan 5 tam sayı alır ve bu sayıların ters sırasını ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402401"
  },
  {
    "question": "Kullanıcıdan 6 adet sayı alın ve bu sayılardan yalnızca pozitif olanları bir diziye kaydedin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[6], pozitifSayilar[6], pozitifSayac = 0;\n\n    for(int i = 0; i < 6; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        if(sayilar[i] > 0) {\n            pozitifSayilar[pozitifSayac] = sayilar[i];\n            pozitifSayac++;\n        }\n    }\n\n    printf(\"Pozitif sayılar: \");\n    for(int i = 0; i < pozitifSayac; i++) {\n        printf(\"%d \", pozitifSayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan alınan sayıların içinden yalnızca pozitif olanları bir diziye kaydeder ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402434"
  },
  {
    "question": "Kullanıcıdan alınan 8 tam sayının aritmetik ortalamasını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[8];\n    int toplam = 0;\n\n    for(int i = 0; i < 8; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        toplam += sayilar[i];\n    }\n\n    double ortalama = toplam / 8.0;\n    printf(\"Aritmetik Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n\n// Açıklama: Bu program, 8 tam sayı alır ve bu sayıların aritmetik ortalamasını hesaplayarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402459"
  },
  {
    "question": "Kullanıcıdan alınan 10 sayının en küçüğünü ve en büyüğünü bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[10];\n    int enKucuk, enBuyuk;\n\n    printf(\"10 adet sayı giriniz:\\n\");\n    for(int i = 0; i < 10; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    enKucuk = enBuyuk = sayilar[0];\n    for(int i = 1; i < 10; i++) {\n        if(sayilar[i] < enKucuk) {\n            enKucuk = sayilar[i];\n        }\n        if(sayilar[i] > enBuyuk) {\n            enBuyuk = sayilar[i];\n        }\n    }\n\n    printf(\"En küçük: %d, En büyük: %d\\n\", enKucuk, enBuyuk);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan alınan 10 sayının en küçük ve en büyük değerlerini bulur ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402485"
  },
  {
    "question": "Kullanıcıdan alınan 5 adet sayının çift olanlarını sayısını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n    int ciftSayisi = 0;\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        if(sayilar[i] % 2 == 0) {\n            ciftSayisi++;\n        }\n    }\n\n    printf(\"Çift sayıların sayısı: %d\\n\", ciftSayisi);\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan alınan 5 sayının kaç tanesinin çift olduğunu sayar ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402531"
  },
  {
    "question": "Kullanıcıdan alınan bir dizinin elemanlarını sıralayın (basit bir sıralama algoritması ile).",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n    int temp;\n\n    printf(\"5 adet sayı giriniz:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"Sayı %d: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    // Sıralama (Bubble Sort)\n    for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 4 - i; j++) {\n            if(sayilar[j] > sayilar[j + 1]) {\n                temp = sayilar[j];\n                sayilar[j] = sayilar[j + 1];\n                sayilar[j + 1] = temp;\n            }\n        }\n    }\n\n    printf(\"Sıralı dizi: \");\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Bu program, kullanıcıdan alınan 5 sayıyı basit bir sıralama algoritması (Bubble Sort) ile sıralar ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:38:51.402574"
  },
  {
    "question": "Kullanıcıdan 5 tam sayı al ve bu sayıların toplamını ve ortalamasını hesaplayan bir C programını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n    int toplam = 0;\n    float ortalama;\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        toplam += sayilar[i];\n    }\n\n    ortalama = toplam / 5.0;\n    printf(\"Toplam: %d, Ortalama: %.2f\\n\", toplam, ortalama);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan 5 adet tamsayı girişi alır, bu sayıların toplamını ve ortalamasını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299178"
  },
  {
    "question": "Kullanıcının girdiği 10 sayıyı içeren bir dizi tanımlayın ve bu dizideki en büyük sayıyı bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[10];\n    int enBuyuk;\n\n    for(int i = 0; i < 10; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    enBuyuk = sayilar[0];\n    for(int i = 1; i < 10; i++) {\n        if(sayilar[i] > enBuyuk) {\n            enBuyuk = sayilar[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan 10 adet tamsayı alır ve bu sayıların en büyüğünü bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299231"
  },
  {
    "question": "Kullanıcıdan alınan 8 sayıyı tersten yazdıran bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[8];\n\n    for(int i = 0; i < 8; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    printf(\"Ters sırayla sayılar: \\\n\");\n    for(int i = 7; i >= 0; i--) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan 8 adet tamsayı alır ve bu sayıları tersten ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299255"
  },
  {
    "question": "Bir dizi oluşturarak 5 öğrencinin notlarını alın ve en yüksek notu alan öğrencinin numarasını bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int notlar[5];\n    int enYuksekNotIndex = 0;\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d. öğrencinin notunu girin: \", i + 1);\n        scanf(\"%d\", &notlar[i]);\n        if(notlar[i] > notlar[enYuksekNotIndex]) {\n            enYuksekNotIndex = i;\n        }\n    }\n\n    printf(\"En yüksek notu alan öğrenci: %d. öğrenci, Notu: %d\\n\", enYuksekNotIndex + 1, notlar[enYuksekNotIndex]);\n    return 0;\n}\n\n// Açıklama: Kullanıcının girdiği 5 öğrencinin notları arasında en yüksek olanının hangi öğrenciye ait olduğunu belirler.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299285"
  },
  {
    "question": "Kullanıcının girdiği 6 farklı ismi bir diziye kaydedin ve bunları alfabetik sıraya göre sıralayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isimler[6][30];\n\n    for(int i = 0; i < 6; i++) {\n        printf(\"%d. ismi girin: \", i + 1);\n        scanf(\"%s\", isimler[i]);\n    }\n\n    // Sıralama işlemi\n    for(int i = 0; i < 6 - 1; i++) {\n        for(int j = i + 1; j < 6; j++) {\n            if(strcmp(isimler[i], isimler[j]) > 0) {\n                char temp[30];\n                strcpy(temp, isimler[i]);\n                strcpy(isimler[i], isimler[j]);\n                strcpy(isimler[j], temp);\n            }\n        }\n    }\n\n    printf(\"Alfabetik sıradaki isimler: \\\n\");\n    for(int i = 0; i < 6; i++) {\n        printf(\"%s\\n\", isimler[i]);\n    }\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan 6 farklı isim alır ve bunları alfabetik sıraya göre sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299313"
  },
  {
    "question": "Kullanıcıdan alınan 10 tam sayının pozitif ve negatif sayılarının toplamını ayrı ayrı hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[10];\n    int pozitifToplam = 0, negatifToplam = 0;\n\n    for(int i = 0; i < 10; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        if(sayilar[i] > 0) {\n            pozitifToplam += sayilar[i];\n        } else if(sayilar[i] < 0) {\n            negatifToplam += sayilar[i];\n        }\n    }\n\n    printf(\"Pozitif toplam: %d, Negatif toplam: %d\\n\", pozitifToplam, negatifToplam);\n    return 0;\n}\n\n// Açıklama: Kullanıcının girdiği 10 sayının pozitif ve negatif kısımlarının toplamını ayrı ayrı hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299355"
  },
  {
    "question": "Kullanıcıdan alınan 5 sayının en küçük ve en büyük değerlerini bulan bir C programı yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[5];\n    int enKucuk, enBuyuk;\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    enKucuk = enBuyuk = sayilar[0];\n    for(int i = 1; i < 5; i++) {\n        if(sayilar[i] < enKucuk) {\n            enKucuk = sayilar[i];\n        }\n        if(sayilar[i] > enBuyuk) {\n            enBuyuk = sayilar[i];\n        }\n    }\n\n    printf(\"En küçük sayı: %d, En büyük sayı: %d\\n\", enKucuk, enBuyuk);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan alınan 5 sayının en küçüğünü ve en büyüğünü bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299383"
  },
  {
    "question": "Kullanıcının girdiği 10 sayının çift ve tek sayılarının sayısını hesaplayan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int sayilar[10];\n    int ciftSayisi = 0, tekSayisi = 0;\n\n    for(int i = 0; i < 10; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n        if(sayilar[i] % 2 == 0) {\n            ciftSayisi++;\n        } else {\n            tekSayisi++;\n        }\n    }\n\n    printf(\"Çift sayı adedi: %d, Tek sayı adedi: %d\\n\", ciftSayisi, tekSayisi);\n    return 0;\n}\n\n// Açıklama: Kullanıcının girdiği 10 sayının kaç tanesinin çift, kaç tanesinin tek olduğunu sayar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299410"
  },
  {
    "question": "Kullanıcıdan alınan 5 sayının medyanını hesaplayan bir program yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int sayilar[5];\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayilar[i]);\n    }\n\n    // Diziyi sıralama\n    qsort(sayilar, 5, sizeof(int), compare);\n    float medyan = sayilar[2]; // Orta elemanı al\n    printf(\"Medyan: %.2f\\n\", medyan);\n    return 0;\n}\n\n// Açıklama: Kullanıcıdan alınan 5 sayıyı sıralar ve medyan değerini hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:39:33.299432"
  },
  {
    "question": "Kullanıcıdan alınan 10 tam sayıyı bir diziye kaydedin ve bu dizinin ortalamasını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10], toplam = 0;\n    float ortalama;\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n        toplam += dizi[i];\n    }\n\n    ortalama = toplam / 10.0;\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan 10 tam sayı alır ve bunların ortalamasını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622200"
  },
  {
    "question": "Kullanıcının girdiği 5 isimden en uzun olanını bulun.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isimler[5][50];\n    char enUzun[50];\n\n    printf(\"5 isim girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%s\", isimler[i]);\n    }\n\n    strcpy(enUzun, isimler[0]);\n    for (int i = 1; i < 5; i++) {\n        if (strlen(isimler[i]) > strlen(enUzun)) {\n            strcpy(enUzun, isimler[i]);\n        }\n    }\n\n    printf(\"En uzun isim: %s\\n\", enUzun);\n    return 0;\n}\n\n// Bu kod, 5 isim alır ve en uzun ismi bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622238"
  },
  {
    "question": "Bir dizi içinde en küçük ve en büyük elemanları bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10], max, min;\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    max = min = dizi[0];\n    for (int i = 1; i < 10; i++) {\n        if (dizi[i] > max) max = dizi[i];\n        if (dizi[i] < min) min = dizi[i];\n    }\n\n    printf(\"En büyük: %d\\nEn küçük: %d\\n\", max, min);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan sayılardan en büyük ve en küçük olanları bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622262"
  },
  {
    "question": "Bir dizi içindeki tüm elemanları ters sırayla yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10];\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    printf(\"Ters sıralama:\\n\");\n    for (int i = 9; i >= 0; i--) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan sayıları ters sırayla yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622284"
  },
  {
    "question": "Bir dizi içindeki elemanların toplamını ve çarpımını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[5], toplam = 0, carpim = 1;\n\n    printf(\"5 tam sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n        toplam += dizi[i];\n        carpim *= dizi[i];\n    }\n\n    printf(\"Toplam: %d\\nÇarpım: %d\\n\", toplam, carpim);\n    return 0;\n}\n\n// Bu kod, 5 sayının toplamını ve çarpımını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622306"
  },
  {
    "question": "Bir dizi içinde belirli bir sayının kaç kez tekrarlandığını bulun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10], sayi, sayac = 0;\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    printf(\"Aramak istediğiniz sayıyı girin: \");\n    scanf(\"%d\", &sayi);\n\n    for (int i = 0; i < 10; i++) {\n        if (dizi[i] == sayi) {\n            sayac++;\n        }\n    }\n\n    printf(\"Sayı %d, %d kez tekrar edildi.\\n\", sayi, sayac);\n    return 0;\n}\n\n// Bu kod, dizideki bir sayının kaç kez tekrarlandığını bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622329"
  },
  {
    "question": "Bir dizi içindeki elemanları sıralayın (Bubble Sort algoritması ile).",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10];\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 0; i < 10 - 1; i++) {\n        for (int j = 0; j < 10 - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n\n    printf(\"Sıralı dizi:\\n\");\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan sayıları Bubble Sort algoritması ile sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622353"
  },
  {
    "question": "Bir dizideki elemanları iki katına çıkarın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[5];\n\n    printf(\"5 tam sayı girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &dizi[i]);\n        dizi[i] *= 2;  // Elemanları iki katına çıkar\n    }\n\n    printf(\"İki katına çıkmış dizinin elemanları:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, dizideki elemanları iki katına çıkar ve yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622372"
  },
  {
    "question": "Bir dizi içinde ardışık elemanlar toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[10], toplam = 0;\n\n    printf(\"10 tam sayı girin:\\n\");\n    for (int i = 0; i < 10; i++) {\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    for (int i = 0; i < 9; i++) {\n        toplam += dizi[i] + dizi[i + 1];\n    }\n\n    printf(\"Ardışık elemanlar toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n// Bu kod, dizideki ardışık elemanların toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:08.622392"
  },
  {
    "question": "Bir dizi elemanlarını toplamak için yazdığım kodda toplam değişkeni daima 0 çıkıyor. Hata nerede olabilir?",
    "answer": "Muhtemelen diziyi döngü ile iterken toplam değişkenini güncellemiyorsunuz. Aşağıdaki kodu kontrol edin:\n\n```c\nint dizi[] = {1, 2, 3, 4, 5};\nint toplam = 0;\nfor (int i = 0; i < 5; i++) {\n    toplam += dizi[i];\n}\nprintf(\"Toplam: %d\", toplam);\n```\nBurada, toplam değişkenini her döngüde güncelliyoruz. Eğer `toplam += dizi[i];` satırını atlıyorsanız, toplam her zaman 0 kalacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211644"
  },
  {
    "question": "Dizi elemanları için bir arama fonksiyonu yazdım ama her zaman -1 döndürüyor. Neden?",
    "answer": "Arama fonksiyonunuzda dizinin boyutunu kontrol etmiyor olabilirsiniz. Ayrıca, aradığınız değeri bulduğunuzda döngüden çıkmayı unutmamalısınız. Aşağıdaki gibi bir düzenleme yapabilirsiniz:\n\n```c\nint arama(int dizi[], int boyut, int aranan) {\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranan) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\nBu kod, aranan değer bulunduğunda dizinin indexini döndürür. Eğer her zaman -1 dönüyorsa, dizinin boyutunu doğru ayarladığınızdan emin olun.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211696"
  },
  {
    "question": "Diziye eleman eklemek için yazdığım kodda bellekte hata alıyorum. Hata nereden kaynaklanıyor olabilir?",
    "answer": "Dizinin boyutunu aşmaya çalışıyor olabilirsiniz. C dilinde, diziler statik olarak boyutlandırıldığından, boyutu değiştirmek veya yeni eleman eklemek için dinamik bellek yönetimini kullanmalısınız. Aşağıdaki gibi bir örnek kullanabilirsiniz:\n\n```c\nint *dizi;\nint boyut = 5;\ndizi = (int*)malloc(boyut * sizeof(int));\n// Eleman ekleme işlemi\nfree(dizi); // Belleği serbest bırakmayı unutmayın.\n```\nBurada, malloc ile bellekte yer açıyoruz ve diziyi dinamik olarak oluşturuyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211728"
  },
  {
    "question": "Dizinin tüm elemanlarını yazdırdığımda bazı değerler eksik görünüyor. Hata ne olabilir?",
    "answer": "Muhtemelen dizinin boyutunu döngüde yanlış ayarlıyorsunuz. Dizinin boyutunu aşan bir döngü kullanıyorsanız, geçersiz bellek alanlarına erişiyor olabilirsiniz. Aşağıdaki örneği inceleyin:\n\n```c\nint dizi[] = {1, 2, 3, 4, 5};\nfor (int i = 0; i <= 5; i++) { // <= 5 yanlış\n    printf(\"%d \", dizi[i]);\n}\n```\nBurada `i < 5` olmalı. Aksi halde, `dizi[5]` geçersiz bir erişimdir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211756"
  },
  {
    "question": "Bir dizinin elemanlarını ters çevirmek için yazdığım kodda sonuç beklediğim gibi olmuyor. Hata nerede?",
    "answer": "Zaten ters çevirmek için iki dizini karşılaştırmadığınızdan veya başlangıç ve bitiş indekslerini doğru ayarlamadığınızdan kaynaklanıyor olabilir. Aşağıdaki örnek doğru bir şekilde ters çevirme işlemi yapar:\n\n```c\nvoid tersCevir(int dizi[], int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = dizi[i];\n        dizi[i] = dizi[boyut - i - 1];\n        dizi[boyut - i - 1] = temp;\n    }\n}\n```\nEğer `boyut / 2` kullanmazsanız, dizinin ortasına kadar değil, tamamına kadar döngü oluşturursunuz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211786"
  },
  {
    "question": "Bir dizi elemanını güncellerken beklenmedik sonuçlar alıyorum. Hata nerede olabilir?",
    "answer": "Güncelleme işleminde kullanılan indeksi yanlış belirliyor olabilirsiniz. Dizi indeksleri 0'dan başladığı için, 1 yerine 0 kullanmalısınız. Örneğin:\n\n```c\nint dizi[5] = {1, 2, 3, 4, 5};\ndizi[1] = 10; // Doğru\n// dizi[5] = 10; // Yanlış, geçersiz erişim\n```\nBurada 5. indeks geçersizdir, dolayısıyla sonuç beklenmedik olur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211812"
  },
  {
    "question": "Dizinin en küçük elemanını bulmak için yazdığım kodda bazen yanlış sonuç alıyorum, sebep ne olabilir?",
    "answer": "Diziyi kontrol ederken ilk elemanı başlangıç noktası olarak almıyorsanız veya dizinin boyutunu yanlış ayarlıyorsanız bu sorun oluşabilir. Aşağıdaki gibi bir kod kullanmalısınız:\n\n```c\nint enKucukBul(int dizi[], int boyut) {\n    int enKucuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < enKucuk) {\n            enKucuk = dizi[i];\n        }\n    }\n    return enKucuk;\n}\n```\nİlk elemanı başlangıç noktası olarak almak, doğru karşılaştırmalar yapmanızı sağlayacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211841"
  },
  {
    "question": "Bir diziyi sıralamak için yazdığım kodda sıralama işlemi doğru çalışmıyor. Hata nerede olabilir?",
    "answer": "Sıralama algoritmanızda karşılaştırmaları doğru yapmıyor olabilirsiniz veya döngüleri yanlış sıralıyorsunuzdur. Örneğin, seçim sıralama algoritmasını kullanıyorsanız aşağıdaki gibi olmalıdır:\n\n```c\nvoid selectionSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[j] < dizi[minIndex]) {\n                minIndex = j;\n            }\n        }\n        // Takas işlemi\n        int temp = dizi[i];\n        dizi[i] = dizi[minIndex];\n        dizi[minIndex] = temp;\n    }\n}\n```\nHatalı karşılaştırmalar veya eksik takas işlemleri sıralamanın doğru çalışmamasına neden olabilir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211896"
  },
  {
    "question": "Bir dizinin elemanlarını kopyalamaya çalışıyorum ama kopyalanan dizide her zaman aynı değerler var. Hata nerede?",
    "answer": "Kopyalama işlemi sırasında, tüm elemanların aynı adresten kopyalandığını düşünebilirsiniz. Aşağıdaki gibi bir kopyalama işlemi yapmalısınız:\n\n```c\nvoid kopyala(int kaynak[], int hedef[], int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        hedef[i] = kaynak[i];\n    }\n}\n```\nEğer sadece `hedef = kaynak;` yaparsanız, `hedef` ve `kaynak` aynı belleği paylaşır ve güncellemeler birbirine yansır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211928"
  },
  {
    "question": "Bir dizinin elemanlarını sıraladıktan sonra yazdırdığımda bazen sıralama hatalı çıkıyor. Hata nerede olabilir?",
    "answer": "Dizi elemanlarını sıralarken, döngüleri yanlış ayarlıyor olabilirsiniz. Özellikle döngülerin sınırlarını kontrol edin. Aşağıdaki gibi bir sıralama fonksiyonu kullanmalısınız:\n\n```c\nvoid bubbleSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                // Takas işlemi\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n```\nDış döngüyü `boyut - 1` olarak ayarlamak ve iç döngüyü `boyut - i - 1` ile sınırlandırmak önemlidir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:40:44.211967"
  },
  {
    "question": "Bir dizinin elemanlarını tersine çevirmek için yazılan kodda neden her seferinde 0. ve son elemanı değiştirdiğimde dizinin tamamının yanlış döndüğünü görüyorum?",
    "answer": "Bu hata, döngü sınırlarının yanlış ayarlanmasından kaynaklanıyor. Eğer dizinin ortasına geldiğinizde 0. ve son elemanı değiştirmeye devam ederseniz, bazı elemanları iki kez değiştirirsiniz. Düzgün bir ters çevirme için döngünüzü dizinin yarısına kadar çalıştırmalısınız. Örnek düzeltme: \n\n```c\nvoid tersCevir(int dizi[], int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = dizi[i];\n        dizi[i] = dizi[boyut - 1 - i];\n        dizi[boyut - 1 - i] = temp;\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154288"
  },
  {
    "question": "Dizinin elemanlarını toplamak için yazdığım fonksiyonda döngü içerisinde dizinin boyutunu aşan bir indeks kullanıyorum, bu ne gibi sorunlara yol açar?",
    "answer": "Dizinin boyutunu aşan bir indeks kullanmak, 'segmentation fault' hatasına neden olabilir. Bu, bellekte izin verilmeyen bir alana erişmeye çalıştığınızda oluşur. Doğru bir döngü şartı kullanarak dizinin boyutunu kontrol etmelisiniz. Düzeltme: \n\n```c\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154380"
  },
  {
    "question": "Dizi içerisindeki en büyük elemanı bulmak için yazdığım kodda her seferinde 0. indexteki değeri kontrol ettiğimde neden sonuç yanlış çıkıyor?",
    "answer": "Eğer dizinin ilk elemanını en büyük olarak atamıyorsanız, dizinin tüm elemanlarını kontrol ettiğinizde en büyük değeri bulamayabilirsiniz. En büyük elemanı kontrol etmek için ilk elemanı başlangıç olarak almalı ve diğerlerini karşılaştırmalısınız. Aşağıdaki örnekte düzeltme yapabilirsiniz: \n\n```c\nint enBuyukBul(int dizi[], int boyut) {\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    return enBuyuk;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154452"
  },
  {
    "question": "Dizinin elemanlarını sıralamak için kullandığım 'bubble sort' algoritmasında neden bazı elemanlar sıralanmıyor?",
    "answer": "Bu hata genellikle iç içe geçen döngülerin doğru bir şekilde ayarlanmamasından kaynaklanır. Dış döngü dizinin boyutu kadar dönmelidir, ancak iç döngü dizinin sonuna kadar gitmemelidir. Her geçişte en büyük eleman son sıraya yerleşeceği için iç döngünüzde son elemanı atlamalısınız. Düzeltme: \n\n```c\nvoid bubbleSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - 1 - i; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154522"
  },
  {
    "question": "Bir diziye eleman eklemeye çalışırken neden 'out of bounds' hatası alıyorum?",
    "answer": "Bu hata, dizinin boyutunu aşan bir indekse erişmeye çalıştığınızda meydana gelir. Dizi oluştururken belirtilen boyutun dışına çıkmamalısınız. Eleman eklerken dizinin mevcut boyutunu kontrol edin ve gerekirse dinamik bellek kullanın. Örnek düzeltme: \n\n```c\nint* diziyeElemanEkle(int* dizi, int* boyut, int yeniEleman) {\n    dizi = realloc(dizi, (*boyut + 1) * sizeof(int));\n    if (dizi == NULL) return NULL;\n    dizi[*boyut] = yeniEleman;\n    (*boyut)++;\n    return dizi;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154570"
  },
  {
    "question": "Dizinin her elemanına 1 ekleyen bir fonksiyonda neden dizinin tüm elemanları sıfır oluyor?",
    "answer": "Bu durum genellikle fonksiyona dizinin elemanlarını atıfta bulunmadığınızda meydana gelir. Dizinin elemanlarına erişmek için doğru şekilde indeks kullanmalısınız ve doğrudan diziyi değiştirmelisiniz. İşte doğru bir düzeltme: \n\n```c\nvoid herElemaninaBirEkle(int dizi[], int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] += 1;\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154618"
  },
  {
    "question": "Bir dizi içerisinde belirli bir elemanın kaç kere tekrar ettiğini bulmaya çalışırken neden sonuç yanlış çıkıyor?",
    "answer": "Bu hata, dizinin elemanlarını kontrol ederken her seferinde tüm elemanları saymadığınızda veya dizinin boyutunu yanlış ayarladığınızda ortaya çıkabilir. Tüm elemanları karşılaştırmalı ve sayım yapmalısınız. Aşağıda bu sorunu düzelten bir örnek verilmiştir: \n\n```c\nint elemanSay(int dizi[], int boyut, int aranacak) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranacak) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154674"
  },
  {
    "question": "Diziden belirli bir indeksteki elemanı silmeye çalışırken neden dizinin geri kalanını kaydırmadığımı düşünüyorum?",
    "answer": "Diziden bir eleman sildiğinizde, geri kalan elemanları kaydırmanız gerekir. Eğer kaydırmazsanız, dizinin sonu eksik kalır veya beklenmedik sonuçlar alırsınız. İşte doğru bir kaydırma işlemi: \n\n```c\nvoid elemanSil(int dizi[], int* boyut, int indeks) {\n    for (int i = indeks; i < *boyut - 1; i++) {\n        dizi[i] = dizi[i + 1];\n    }\n    (*boyut)--;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154727"
  },
  {
    "question": "Dizi içerisindeki elemanları büyükten küçüğe sıralamak için kullandığım kodda neden bazen yanlış değerler elde ediyorum?",
    "answer": "Bu sorun genellikle sıralama algoritmanızın hatalı olmasından kaynaklanıyor. Örneğin, 'selection sort' ya da 'insertion sort' gibi algoritmalarda karşılaştırmalarınızı ve değişimlerinizi dikkatlice uygulamanız gerekir. Aşağıda bir örnek sıralama kodu verilmektedir: \n\n```c\nvoid selectionSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int max_index = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[j] > dizi[max_index]) {\n                max_index = j;\n            }\n        }\n        int temp = dizi[max_index];\n        dizi[max_index] = dizi[i];\n        dizi[i] = temp;\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154782"
  },
  {
    "question": "Dizi içerisinde negatif sayılar bulunuyorsa bunları saymak için yazdığım kodda neden sonuç her zaman sıfır?",
    "answer": "Bu durum, negatif sayıları kontrol etme şartınızın yanlış olmasından kaynaklanıyor olabilir. Negatif sayıları kontrol ederken doğru bir karşılaştırma yapmadığınızda sonuç sıfır çıkabilir. İşte doğru bir kontrol örneği: \n\n```c\nint negatifSayilariSay(int dizi[], int boyut) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] < 0) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:41:27.154836"
  },
  {
    "question": "Bir dizi elemanlarını tersine döndürmek için yazdığım kodda dizinin son elemanı düzgün bir şekilde yer değiştirmiyor. Hatanın kaynağı nedir?",
    "answer": "Diziyi tersine döndürürken, iki elemanın yerini değiştirmek için kullandığınız döngüde sınır koşullarını doğru ayarlamamış olabilirsiniz. Örneğin, dizinin uzunluğuna göre döngü koşulunu `i < n / 2` olarak ayarlamalısınız. Aksi takdirde, dizinin ortasında yer alan elemanı iki kez değiştirmeye çalışabilirsiniz. Aşağıdaki kod örneği bunu göstermektedir:\n\n```c\nvoid reverseArray(int arr[], int n) {\n    for (int i = 0; i < n / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[n - i - 1];\n        arr[n - i - 1] = temp;\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808496"
  },
  {
    "question": "Bir dizideki en büyük elemanı bulmaya çalışırken, dizinin son elemanını atlıyorum. Neden böyle bir hata yapıyorum?",
    "answer": "Dizinin elemanlarını kontrol ederken döngü koşulunu doğru ayarlamamanız bu hatanın nedeni olabilir. Genellikle dizinin son elemanını kontrol etmek için `i < n` koşulunu kullanmalısınız. Aşağıda, dizinin en büyük elemanını bulmak için uygun bir kod örneği verilmiştir:\n\n```c\nint findMax(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808592"
  },
  {
    "question": "Diziye değer atarken bellek taşması hatası alıyorum. Bu nasıl oluşuyor?",
    "answer": "Dizi boyutunu aşan bir indekse erişmeye çalışıyorsanız bellek taşması hatası alırsınız. Örneğin, dizinizin boyutu 5 ise, 0'dan 4'e kadar olan indeksleri kullanmalısınız. Eğer 5 veya daha büyük bir indekse erişmeye çalışıyorsanız, bu bellek dışına erişim anlamına gelir. Aşağıdaki kodda bir hata gösterilmektedir:\n\n```c\nint arr[5];\nfor (int i = 0; i <= 5; i++) { // Hatalı: 'i < 5' olmalı\n    arr[i] = i;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808634"
  },
  {
    "question": "Dizi elemanlarını sıralarken yanlış sonuçlar alıyorum. Hatanın sebebi ne olabilir?",
    "answer": "Sıralama algoritmanızı kontrol etmelisiniz. Örneğin, bir 'Bubble Sort' uygularken, iç döngünün doğru koşulda çalışıp çalışmadığını kontrol edin. Eğer `j < n - i - 1` koşulunu kullanmazsanız, dizinin son elemanları üzerinde gereksiz karşılaştırmalar yaparak yanlış sonuçlar elde edebilirsiniz:\n\n```c\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808678"
  },
  {
    "question": "Dizide tüm elemanların toplamını bulmaya çalışırken sonuç doğru çıkmıyor. Neden?",
    "answer": "Diziye erişim sırasında kullandığınız indeksi yanlış yazmış olabilirsiniz. Genelde 0'dan başlayıp dizi boyutunun bir eksiğine kadar gitmelisiniz. Eğer dizinin boyutunu yanlış kullanıyorsanız, eksik veya fazla eleman topluyorsunuz demektir. İşte doğru bir toplam alma kodu:\n\n```c\nint sumArray(int arr[], int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808721"
  },
  {
    "question": "Dizinin elemanlarını kopyalamak için yazdığım fonksiyon, beklediğim şekilde çalışmıyor. Hata nerede?",
    "answer": "Kopyalama işlemi sırasında, kaynak dizinin boyutunu doğru kullanmadığınız için eksik veya fazla kopyalama yapıyor olabilirsiniz. Kopyalama yapmak için doğru boyut ve indeks aralığına dikkat etmelisiniz. Aşağıda, bir diziyi kopyalamak için doğru bir yöntem verilmiştir:\n\n```c\nvoid copyArray(int source[], int destination[], int n) {\n    for (int i = 0; i < n; i++) {\n        destination[i] = source[i];\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808771"
  },
  {
    "question": "Dizideki negatif sayıları saymak için yazdığım kodda bir hata var. Hatanın nedeni ne olabilir?",
    "answer": "Negatif sayıları sayarken döngü içerisinde karşılaştırmayı doğru yapmadığınız için sonuç hatalı çıkabilir. Ayrıca, dizideki elemanları kontrol etmek için doğru indeksi kullanmalısınız. Aşağıdaki kod, dizideki negatif sayıları saymak için uygun bir örnektir:\n\n```c\nint countNegative(int arr[], int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808826"
  },
  {
    "question": "Bir dizinin elemanlarını bir başka diziye atarken, bazı elemanların kaybolduğunu görüyorum. Hatanın sebebi nedir?",
    "answer": "Dizi boyutlarını karıştırmış olabilirsiniz. Hedef dizinin boyutunun, kaynak dizinin boyutuna eşit veya daha büyük olması gerektiğini unutmayın. Ayrıca, kopyalama işlemi sırasında doğru döngü koşulunu kullandığınızdan emin olun. Aşağıda doğru bir kopyalama işlemi örneği verilmiştir:\n\n```c\nvoid safeCopy(int source[], int destination[], int sourceSize, int destinationSize) {\n    if (destinationSize < sourceSize) return; // Hata: hedef dizi yetersiz\n    for (int i = 0; i < sourceSize; i++) {\n        destination[i] = source[i];\n    }\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808891"
  },
  {
    "question": "Dizi aritmetik ortalamasını bulurken yanlış sonuç alıyorum. Hatanın sebebi nedir?",
    "answer": "Aritmetik ortalamayı hesaplarken, toplamı doğru tutup dizinin boyutunu uygun şekilde kontrol etmelisiniz. Eğer dizinin boyutunu yanlış kullanıyorsanız, ortalama hesaplama yanlış olacaktır. Aşağıdaki kod, doğru bir ortalama hesaplama işlemi için örnektir:\n\n```c\ndouble calculateAverage(int arr[], int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    return (double)sum / n;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:03.808934"
  },
  {
    "question": "C dilinde tek boyutlu dizi nedir ve nasıl tanımlanır?",
    "answer": "Tek boyutlu dizi, aynı türdeki birden fazla veriyi ardışık hafıza alanlarında saklamak için kullanılır. Dizi tanımlarken, veri tipini, dizi adını ve boyutunu belirtmemiz gerekir. Örneğin, 'int sayilar[10];' ifadesi, 10 adet tamsayı saklayabileceğimiz bir dizi tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622752"
  },
  {
    "question": "Dizi elemanlarına nasıl erişebiliriz?",
    "answer": "Dizi elemanlarına erişmek için dizinin adını ve elemanın indeksini kullanırız. Örneğin, 'sayilar[0]' ifadesi dizinin ilk elemanına erişir. Dizi indeksleri 0'dan başladığı için, 10 elemanlı bir dizi için son eleman 'sayilar[9]' olur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622787"
  },
  {
    "question": "Bir diziye değer atamak için hangi yöntemleri kullanabiliriz?",
    "answer": "Diziye değer atamak için döngü kullanabiliriz. Örneğin, bir 'for' döngüsü ile tüm elemanlara değer atayabiliriz: 'for(int i=0; i<10; i++) { sayilar[i] = i+1; }' bu kod, dizinin her elemanına 1'den 10'a kadar değer atar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622810"
  },
  {
    "question": "Dizinin tüm elemanlarını nasıl yazdırabiliriz?",
    "answer": "Dizinin elemanlarını yazdırmak için bir döngü kullanabiliriz. Örnek kod: 'for(int i=0; i<10; i++) { printf(\"%d \", sayilar[i]); }' bu kod, 'sayilar' dizisinin tüm elemanlarını ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622829"
  },
  {
    "question": "C dilinde bir diziyi nasıl başlatabiliriz?",
    "answer": "Bir diziyi başlatırken, tanımlama sırasında değerleri belirtebiliriz. Örneğin: 'int sayilar[5] = {1, 2, 3, 4, 5};' bu kod, 'sayilar' dizisini 1, 2, 3, 4 ve 5 değerleriyle başlatır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622846"
  },
  {
    "question": "Dizi boyutunu nasıl öğrenebiliriz?",
    "answer": "Dizi boyutunu öğrenmek için toplam byte (bayt) cinsinden boyutu, eleman boyutuna bölerek hesaplayabiliriz. Örnek: 'sizeof(sayilar) / sizeof(sayilar[0]);' bu kod, sayilar dizisinin eleman sayısını verir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622864"
  },
  {
    "question": "Dizideki maksimum değeri nasıl bulabiliriz?",
    "answer": "Dizideki maksimum değeri bulmak için bir döngü ile tüm elemanları karşılaştırabiliriz. Örnek kod: 'int max = sayilar[0]; for(int i=1; i<10; i++) { if(sayilar[i] > max) { max = sayilar[i]; }}' bu kod 'sayilar' dizisindeki en büyük sayıyı bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622882"
  },
  {
    "question": "Bir diziyi başka bir diziye nasıl kopyalayabiliriz?",
    "answer": "Bir diziyi kopyalamak için döngü kullanabiliriz. Örnek: 'for(int i=0; i<10; i++) { kopyaDizi[i] = sayilar[i]; }' bu, 'sayilar' dizisinin tüm elemanlarını 'kopyaDizi'ye kopyalar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622901"
  },
  {
    "question": "Dizinin elemanlarını tersine çevirmek için hangi yöntemleri kullanabiliriz?",
    "answer": "Dizinin elemanlarını tersine çevirmek için iki uçtaki elemanları birbirleriyle takas yaparak döngü kullanabiliriz. Örnek kod: 'for(int i=0; i<5; i++) { int temp = sayilar[i]; sayilar[i] = sayilar[9-i]; sayilar[9-i] = temp; }' bu, 10 elemanlı bir diziyi ters çevirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622925"
  },
  {
    "question": "Dizi toplamını nasıl hesaplayabiliriz?",
    "answer": "Dizi toplamını hesaplamak için bir döngü ile her elemanı toplayabiliriz. Örnek kod: 'int toplam = 0; for(int i=0; i<10; i++) { toplam += sayilar[i]; }' bu kod, 'sayilar' dizisinin tüm elemanlarının toplamını bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622945"
  },
  {
    "question": "Dizi elemanlarını sıralamak için hangi algoritmayı kullanabiliriz?",
    "answer": "Dizi elemanlarını sıralamak için 'Bubble Sort' algoritmasını kullanabiliriz. Örnek: 'for(int i=0; i<10-1; i++) { for(int j=0; j<10-i-1; j++) { if(sayilar[j] > sayilar[j+1]) { int temp = sayilar[j]; sayilar[j] = sayilar[j+1]; sayilar[j+1] = temp; }}}' bu, 'sayilar' dizisini küçükten büyüğe sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:24.622966"
  },
  {
    "question": "Bir dizi elemanlarına nasıl erişebilirim?",
    "answer": "C dilinde dizilere erişmek için indisi kullanırız. Dizinin ilk elemanı 0. indeksle başlar. Örneğin, 'int dizi[5] = {1, 2, 3, 4, 5};' şeklinde bir dizi tanımladığımızda, 'dizi[0]' ifadesi 1 değerini döndürür, 'dizi[1]' ise 2 değerini döndürür. Dizi elemanlarına erişim, döngü yapıları içinde de sıklıkla kullanılır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909030"
  },
  {
    "question": "Dizinin boyutunu nasıl bulabilirim?",
    "answer": "Dizinin boyutunu bulmak için toplam bellek alanını eleman boyutuna böleriz. Örneğin, 'int dizi[10];' tanımlandığında, dizinin boyutunu 'sizeof(dizi) / sizeof(dizi[0])' ile hesaplayabiliriz. Bu ifade, dizinin toplam bayt cinsinden boyutunu alır ve her bir elemanın boyutuna böler.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909065"
  },
  {
    "question": "Dizideki tüm elemanları nasıl yazdırabilirim?",
    "answer": "Bir dizinin tüm elemanlarını yazdırmak için bir döngü kullanabiliriz. Örneğin: \n```\nfor (int i = 0; i < 5; i++) {\n    printf(\"%d \", dizi[i]);\n}\n```\nBu kod, 'dizi' adlı dizinin ilk 5 elemanını sırayla ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909084"
  },
  {
    "question": "Bir diziyi nasıl tersine çevirebilirim?",
    "answer": "Bir diziyi tersine çevirmek için iki tane döngü kullanabiliriz. İlk döngü ile dizinin ilk yarısını, ikinci döngü ile de ikinci yarısını alıp yer değiştiririz. Örnek: \n```\nfor (int i = 0; i < n / 2; i++) {\n    int temp = dizi[i];\n    dizi[i] = dizi[n - i - 1];\n    dizi[n - i - 1] = temp;\n}\n```\nBu kod, 'dizi' adlı diziyi tersine çevirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909102"
  },
  {
    "question": "Dizi elemanlarını toplamak için bir fonksiyon nasıl yazılır?",
    "answer": "Dizi elemanlarını toplamak için bir fonksiyon yazabiliriz. İşte bir örnek: \n```\nint topla(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n```\nBu fonksiyon, verilen dizinin elemanlarını toplar ve sonucu döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909124"
  },
  {
    "question": "Bir diziyi en büyük ve en küçük değerleri nasıl bulabilirim?",
    "answer": "Dizinin en büyük ve en küçük değerlerini bulmak için bir döngü kullanarak elemanları kontrol edebiliriz. Örnek: \n```\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n```\nBu fonksiyon, dizideki en büyük değeri bulmak için kullanılır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909147"
  },
  {
    "question": "Dizide belirli bir elemanı aramak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizide belirli bir elemanı aramak için basit bir döngü kullanabiliriz. İşte bir örnek: \n```\nbool ara(int dizi[], int boyut, int aranan) {\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranan) {\n            return true;\n        }\n    }\n    return false;\n}\n```\nBu fonksiyon, dizide aranan elemanın olup olmadığını kontrol eder ve sonucu döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909171"
  },
  {
    "question": "Dizinin elemanlarını sıralamak için bir algoritma nasıl yazabilirim?",
    "answer": "Dizi elemanlarını sıralamak için 'bubble sort' algoritmasını kullanabiliriz. Örnek: \n```\nvoid sirala(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n```\nBu fonksiyon, verilen diziyi küçükten büyüğe sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909192"
  },
  {
    "question": "Dizinin ortalamasını nasıl hesaplayabilirim?",
    "answer": "Dizinin ortalamasını hesaplamak için önce dizinin elemanlarının toplamını bulup, ardından toplamı eleman sayısına bölebiliriz. Örnek: \n```\ndouble ortalama(int dizi[], int boyut) {\n    int toplam = topla(dizi, boyut);\n    return (double)toplam / boyut;\n}\n```\nBu fonksiyon, dizinin ortalamasını hesaplar ve döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909208"
  },
  {
    "question": "Bir dizideki çift sayıları filtrelemek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizideki çift sayıları filtrelemek için yeni bir dizi oluşturarak, mevcut dizideki elemanları kontrol edebiliriz. Örnek: \n```\nint çiftSayılariFiltrele(int dizi[], int boyut, int* yeniBoyut) {\n    int* yeniDizi = (int*)malloc(boyut * sizeof(int));\n    *yeniBoyut = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 == 0) {\n            yeniDizi[(*yeniBoyut)++] = dizi[i];\n        }\n    }\n    return yeniDizi;\n}\n```\nBu fonksiyon, dizideki çift sayıları filtreler ve yeni diziyi döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:42:58.909233"
  },
  {
    "question": "Tek boyutlu bir dizi tanımlayıp, bu dizinin elemanlarını kullanıcıdan alarak toplamını nasıl bulabilirim?",
    "answer": "Öncelikle bir dizi tanımlayıp, kullanıcıdan dizi elemanlarını almak için bir döngü kullanmalıyız. Kullanıcının girdiği her elemanı toplamak için bir değişken kullanacağız. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10]; // 10 elemanlı bir dizi tanımlıyoruz\n    int toplam = 0;\n    \n    for(int i = 0; i < 10; i++) {\n        printf(\"Dizi elemanını girin: \");\n        scanf(\"%d\", &dizi[i]); // Kullanıcıdan eleman alıyoruz\n        toplam += dizi[i]; // Elemanları topluyoruz\n    }\n    printf(\"Dizinin toplamı: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kod, kullanıcıdan 10 adet tam sayı alarak bunların toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047063"
  },
  {
    "question": "Bir dizideki negatif sayıları saymak için nasıl bir algoritma yazabilirim?",
    "answer": "Negatif sayıları saymak için diziyi döngü ile gezeriz ve her elemanı kontrol ederiz. Eğer eleman negatifse, bir sayacı artırırız. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10] = {3, -1, 4, -5, 0, -2, 9, -8, 7, -3};\n    int negatif_sayisi = 0;\n    \n    for(int i = 0; i < 10; i++) {\n        if(dizi[i] < 0) {\n            negatif_sayisi++;\n        }\n    }\n    printf(\"Negatif sayıların sayısı: %d\\n\", negatif_sayisi);\n    return 0;\n}\n```\nBu kod, tanımlı bir dizideki negatif sayıların sayısını bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047123"
  },
  {
    "question": "Bir diziyi sıralamak için hangi algoritmaları kullanabilirim ve örnek bir uygulama gösterebilir misin?",
    "answer": "Diziyi sıralamak için çeşitli algoritmalar mevcuttur, bunlardan bazıları: Bubble Sort, Selection Sort ve Quick Sort. Örnek olarak, Bubble Sort algoritmasını kullanarak bir dizi sıralayabiliriz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {5, 3, 4, 1, 2};\n    int n = 5;\n    int temp;\n    \n    for(int i = 0; i < n-1; i++) {\n        for(int j = 0; j < n-i-1; j++) {\n            if(dizi[j] > dizi[j+1]) {\n                temp = dizi[j];\n                dizi[j] = dizi[j+1];\n                dizi[j+1] = temp;\n            }\n        }\n    }\n    printf(\"Sıralanmış dizi: \");\n    for(int i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu kod, verilen bir diziyi artan sırada sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047174"
  },
  {
    "question": "Bir dizinin elemanlarını ters çevirmek için nasıl bir yöntem izleyebilirim?",
    "answer": "Dizinin elemanlarını ters çevirmek için iki indeks kullanabiliriz: biri baştan diğeri sondan başlayarak birbirleriyle yer değiştirebilirler. Örnek bir uygulama:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    int n = 5;\n    int temp;\n    \n    for(int i = 0; i < n / 2; i++) {\n        temp = dizi[i];\n        dizi[i] = dizi[n - i - 1];\n        dizi[n - i - 1] = temp;\n    }\n    printf(\"Ters çevrilmiş dizi: \");\n    for(int i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu kod, verilen bir dizinin elemanlarını ters çevirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047216"
  },
  {
    "question": "Bir dizideki en küçük ve en büyük sayıyı nasıl bulabilirim?",
    "answer": "Dizinin her bir elemanını kontrol ederek, en küçük ve en büyük sayıyı bulmak için iki değişken tanımlayabiliriz. Başlangıçta, en küçük değeri dizi[0] ve en büyük değeri de dizi[0] olarak ayarlayıp tüm elemanları kontrol edebiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {3, 1, 4, 1, 5};\n    int n = 5;\n    int en_kucuk = dizi[0];\n    int en_buyuk = dizi[0];\n    \n    for(int i = 1; i < n; i++) {\n        if(dizi[i] < en_kucuk) {\n            en_kucuk = dizi[i];\n        }\n        if(dizi[i] > en_buyuk) {\n            en_buyuk = dizi[i];\n        }\n    }\n    printf(\"En küçük: %d, En büyük: %d\\n\", en_kucuk, en_buyuk);\n    return 0;\n}\n```\nBu kod, dizideki en küçük ve en büyük sayıları bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047254"
  },
  {
    "question": "Bir dizinin ortalamasını hesaplamak için ne yapmalıyım?",
    "answer": "Dizinin elemanlarını toplayıp, eleman sayısına bölerek ortalamayı hesaplayabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {10, 20, 30, 40, 50};\n    int toplam = 0;\n    int n = 5;\n    \n    for(int i = 0; i < n; i++) {\n        toplam += dizi[i];\n    }\n    double ortalama = (double)toplam / n;\n    printf(\"Dizinin ortalaması: %.2f\\n\", ortalama);\n    return 0;\n}\n```\nBu kod, dizinin ortalamasını hesaplar ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047288"
  },
  {
    "question": "Bir dizideki elemanların frekansını nasıl hesaplayabilirim?",
    "answer": "Frekansı hesaplamak için, dizideki her bir elemanı kontrol edip, yeni bir dizi kullanarak her elemanın kaç kez tekrar ettiğini sayabiliriz. Örnek bir kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[10] = {1, 2, 2, 3, 1, 4, 4, 4, 5, 1};\n    int frekans[6] = {0}; // 1-5 arası sayılar için frekans dizisi\n    \n    for(int i = 0; i < 10; i++) {\n        frekans[dizi[i]]++; // Sayının frekansını artırıyoruz\n    }\n    // Sonuçları yazdırıyoruz\n    for(int i = 1; i <= 5; i++) {\n        printf(\"%d sayısı %d kez geçti.\\n\", i, frekans[i]);\n    }\n    return 0;\n}\n```\nBu kod, dizideki her sayının kaç kez geçtiğini hesaplar ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047320"
  },
  {
    "question": "Bir dizinin elemanlarını kopyalamak için nasıl bir yöntem kullanabilirim?",
    "answer": "Dizinin elemanlarını kopyalamak için, yeni bir dizi tanımlayıp mevcut dizinin elemanlarını bu yeni diziye döngü ile aktarabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    int kopya[5];\n    \n    for(int i = 0; i < 5; i++) {\n        kopya[i] = dizi[i]; // Elemanları kopyalıyoruz\n    }\n    printf(\"Kopyalanan dizi: \");\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", kopya[i]);\n    }\n    return 0;\n}\n```\nBu kod, bir dizinin elemanlarını başka bir diziye kopyalar ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047358"
  },
  {
    "question": "Bir diziyi döngü kullanmadan nasıl ters çevirebilirim?",
    "answer": "Diziyi döngü kullanmadan ters çevirmek için, bir yardımcı dizi tanımlayarak orijinal dizinin elemanlarını bu yardımcı diziye ters sırayla atayabiliriz. Örnek bir uygulama:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    int ters[5] = {0};\n    \n    // Diziyi ters çeviriyoruz\n    ters[0] = dizi[4];\n    ters[1] = dizi[3];\n    ters[2] = dizi[2];\n    ters[3] = dizi[1];\n    ters[4] = dizi[0];\n    \n    printf(\"Ters çevrilmiş dizi: \");\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", ters[i]);\n    }\n    return 0;\n}\n```\nBu kod, döngü kullanmadan dizi elemanlarını ters çevirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:43:42.047391"
  },
  {
    "question": "Verilen bir tam sayılar dizisinin elemanlarını toplamak için bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint toplama(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int sonuc = toplama(sayilar, boyut);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}\n// Bu kod örneği, bir tamsayı dizisinin elemanlarını toplamak için yazılmıştır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.161999"
  },
  {
    "question": "Bir dizide en büyük elemanı bulan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    return enBuyuk;\n}\n\nint main() {\n    int sayilar[] = {3, 5, 1, 9, 7};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int sonuc = enBuyuk(sayilar, boyut);\n    printf(\"En büyük eleman: %d\\n\", sonuc);\n    return 0;\n}\n// Bu kod, bir dizi içindeki en büyük elemanı bulmak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162042"
  },
  {
    "question": "Bir dizideki tüm elemanları tersine çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid terstenYaz(int dizi[], int boyut) {\n    for (int i = boyut - 1; i >= 0; i--) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    printf(\"Ters dizi: \");\n    terstenYaz(sayilar, boyut);\n    return 0;\n}\n// Bu kod, bir dizinin elemanlarını tersine yazdırmak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162067"
  },
  {
    "question": "Bir dizide belirli bir sayının kaç kez geçtiğini bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint sayiSay(int dizi[], int boyut, int aranan) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranan) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 2, 3, 2, 4};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int aranan = 2;\n    int sonuc = sayiSay(sayilar, boyut, aranan);\n    printf(\"%d sayısı %d kez geçiyor.\\n\", aranan, sonuc);\n    return 0;\n}\n// Bu kod, bir dizide belirli bir sayının kaç kez geçtiğini bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162093"
  },
  {
    "question": "Bir dizideki elemanları sıralamak için bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int sayilar[] = {5, 3, 8, 1, 2};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    sirala(sayilar, boyut);\n    printf(\"Sıralı dizi: \");\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu kod, bir dizi içindeki elemanları sıralamak için basit bir sıralama algoritması (Bubble Sort) kullanır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162114"
  },
  {
    "question": "Dizinin ortalama değerini hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nfloat ortalama(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int sayilar[] = {5, 10, 15, 20, 25};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    float sonuc = ortalama(sayilar, boyut);\n    printf(\"Ortalama: %.2f\\n\", sonuc);\n    return 0;\n}\n// Bu kod, bir dizinin ortalama değerini hesaplamak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162133"
  },
  {
    "question": "Dizideki en küçük elemanı bulan bir fonksiyon oluşturun.",
    "answer": "#include <stdio.h>\n\nint enKucuk(int dizi[], int boyut) {\n    int enKucuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < enKucuk) {\n            enKucuk = dizi[i];\n        }\n    }\n    return enKucuk;\n}\n\nint main() {\n    int sayilar[] = {4, 2, 8, 6, 1};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int sonuc = enKucuk(sayilar, boyut);\n    printf(\"En küçük eleman: %d\\n\", sonuc);\n    return 0;\n}\n// Bu kod, bir dizi içindeki en küçük elemanı bulmak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162153"
  },
  {
    "question": "Bir dizinin elemanlarını iki katına çıkaran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid ikiKatinaCikar(int dizi[], int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] *= 2;\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    ikiKatinaCikar(sayilar, boyut);\n    printf(\"İki katına çıkarılmış dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu kod, bir dizideki her elemanı iki katına çıkarmak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162174"
  },
  {
    "question": "Bir dizideki elemanları tek ve çift olarak ayıran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid tekCiftAyir(int dizi[], int boyut) {\n    printf(\"Tek sayılar: \");\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 != 0) {\n            printf(\"%d \", dizi[i]);\n        }\n    }\n    printf(\"\\nÇift sayılar: \");\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 == 0) {\n            printf(\"%d \", dizi[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    tekCiftAyir(sayilar, boyut);\n    return 0;\n}\n// Bu kod, bir dizideki elemanları tek ve çift olarak ayırmak için bir fonksiyon tanımlar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:18.162197"
  },
  {
    "question": "Bir tamsayı dizisindeki tüm elemanların toplamını hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint dizininToplamı(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Toplam: %d\\n\", dizininToplamı(dizi, boyut));\n    return 0;\n}\n\n// Bu kod, dizinin toplamını hesaplamak için bir döngü kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.980888"
  },
  {
    "question": "Bir tamsayı dizisindeki en büyük elemanı bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint enBuyukEleman(int dizi[], int boyut) {\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    return enBuyuk;\n}\n\nint main() {\n    int dizi[] = {3, 5, 7, 2, 8};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\\n\", enBuyukEleman(dizi, boyut));\n    return 0;\n}\n\n// Bu kod, dizideki en büyük elemanı bulmak için bir karşılaştırma döngüsü kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.980936"
  },
  {
    "question": "Bir tamsayı dizisini tersine çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid diziTersineCevir(int dizi[], int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = dizi[i];\n        dizi[i] = dizi[boyut - 1 - i];\n        dizi[boyut - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    diziTersineCevir(dizi, boyut);\n    printf(\"Ters çevrilmiş dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, dizinin elemanlarını tersine çevirmek için bir geçici değişken kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.980959"
  },
  {
    "question": "Bir tamsayı dizisinde belirli bir elemanın kaç kere tekrarlandığını bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint elemanSayisi(int dizi[], int boyut, int aranan) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranan) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 2, 4, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int aranan = 2;\n    printf(\"%d sayısı %d kere tekrar ediyor.\\n\", aranan, elemanSayisi(dizi, boyut, aranan));\n    return 0;\n}\n\n// Bu kod, dizide belirli bir elemanın kaç kez bulunduğunu saymak için bir döngü kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.980987"
  },
  {
    "question": "Bir tamsayı dizisindeki çift sayıları bulan ve yeni bir diziye atan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint* ciftSayilariBul(int dizi[], int boyut, int* yeniBoyut) {\n    int* ciftDizi = malloc(boyut * sizeof(int));\n    *yeniBoyut = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 == 0) {\n            ciftDizi[(*yeniBoyut)++] = dizi[i];\n        }\n    }\n    return ciftDizi;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int yeniBoyut;\n    int* ciftDizi = ciftSayilariBul(dizi, boyut, &yeniBoyut);\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < yeniBoyut; i++) {\n        printf(\"%d \", ciftDizi[i]);\n    }\n    printf(\"\\n\");\n    free(ciftDizi);\n    return 0;\n}\n\n// Bu kod, dizideki çift sayıları bulmak için dinamik bellek kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.981014"
  },
  {
    "question": "İki tamsayı dizisinin birleştirilip yeni bir dizi haline getirilmesini sağlayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint* diziBirleştir(int dizi1[], int boyut1, int dizi2[], int boyut2) {\n    int* yeniDizi = malloc((boyut1 + boyut2) * sizeof(int));\n    for (int i = 0; i < boyut1; i++) {\n        yeniDizi[i] = dizi1[i];\n    }\n    for (int i = 0; i < boyut2; i++) {\n        yeniDizi[boyut1 + i] = dizi2[i];\n    }\n    return yeniDizi;\n}\n\nint main() {\n    int dizi1[] = {1, 2, 3};\n    int dizi2[] = {4, 5, 6};\n    int boyut1 = sizeof(dizi1) / sizeof(dizi1[0]);\n    int boyut2 = sizeof(dizi2) / sizeof(dizi2[0]);\n    int* yeniDizi = diziBirleştir(dizi1, boyut1, dizi2, boyut2);\n    printf(\"Birleşik dizi: \");\n    for (int i = 0; i < boyut1 + boyut2; i++) {\n        printf(\"%d \", yeniDizi[i]);\n    }\n    printf(\"\\n\");\n    free(yeniDizi);\n    return 0;\n}\n\n// Bu kod, iki diziyi birleştirmek için dinamik bellek kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.981044"
  },
  {
    "question": "Bir tamsayı dizisini sıralamak için basit bir sıralama algoritması (Bubble Sort) uygulayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - 1 - i; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 4, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    bubbleSort(dizi, boyut);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, diziyi sıralamak için Bubble Sort algoritmasını kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.981085"
  },
  {
    "question": "Bir tamsayı dizisinin ortalamasını hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\ndouble diziOrtalamasi(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (double)toplam / boyut;\n}\n\nint main() {\n    int dizi[] = {2, 4, 6, 8, 10};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin ortalaması: %.2f\\n\", diziOrtalamasi(dizi, boyut));\n    return 0;\n}\n\n// Bu kod, dizinin ortalamasını hesaplamak için toplamı eleman sayısına böler.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.981107"
  },
  {
    "question": "Dizinin elemanlarını küçükten büyüğe sıralayan bir fonksiyon yazın ve ardından sıralı diziyi ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid quickSort(int dizi[], int sol, int sag) {\n    if (sol < sag) {\n        int pivot = dizi[sag];\n        int i = sol - 1;\n        for (int j = sol; j < sag; j++) {\n            if (dizi[j] < pivot) {\n                i++;\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n        int temp = dizi[i + 1];\n        dizi[i + 1] = dizi[sag];\n        dizi[sag] = temp;\n        quickSort(dizi, sol, i);\n        quickSort(dizi, i + 2, sag);\n    }\n}\n\nint main() {\n    int dizi[] = {10, 7, 8, 9, 1, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    quickSort(dizi, 0, boyut - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, Quick Sort algoritmasını kullanarak diziyi sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:44:53.981137"
  },
  {
    "question": "Bir dizi içerisindeki elemanların toplamını hesaplayan bir C fonksiyonu nasıl yazılır?",
    "answer": "Aşağıdaki fonksiyon, bir dizi ve dizi boyutunu alarak dizinin elemanlarının toplamını döndürür:\n\n```c\n#include <stdio.h>\n\nint diziToplami(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    printf(\"Toplam: %d\\n\", diziToplami(sayilar, boyut));\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505168"
  },
  {
    "question": "Bir dizideki elemanların en büyük değerini bulmak için hangi algoritmayı kullanabiliriz?",
    "answer": "Aşağıdaki fonksiyon, bir dizi alarak içerisindeki en büyük değeri bulur:\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    return enBuyuk;\n}\n\nint main() {\n    int sayilar[] = {3, 5, 7, 2, 8};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    printf(\"En büyük değer: %d\\n\", enBuyuk(sayilar, boyut));\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505212"
  },
  {
    "question": "Bir dizinin tersine çevrilmesi için nasıl bir fonksiyon yazabiliriz?",
    "answer": "Aşağıdaki kod, bir dizinin elemanlarını tersine çeviren bir fonksiyon sunar:\n\n```c\n#include <stdio.h>\n\nvoid diziTersCevir(int dizi[], int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = dizi[i];\n        dizi[i] = dizi[boyut - 1 - i];\n        dizi[boyut - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    diziTersCevir(sayilar, boyut);\n\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505236"
  },
  {
    "question": "Bir diziyi sıralamak için hangi algoritmayı kullanarak bir fonksiyon yazabilirsiniz?",
    "answer": "Aşağıdaki kod, basit bir seçme sıralama (selection sort) algoritması ile bir diziyi sıralar:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int dizi[], int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[j] < dizi[minIndex]) {\n                minIndex = j;\n            }\n        }\n        int temp = dizi[i];\n        dizi[i] = dizi[minIndex];\n        dizi[minIndex] = temp;\n    }\n}\n\nint main() {\n    int sayilar[] = {64, 25, 12, 22, 11};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    selectionSort(sayilar, boyut);\n\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505261"
  },
  {
    "question": "Bir diziyi aramak için ikili arama algoritması nasıl uygulanır?",
    "answer": "Aşağıdaki kod, sıralı bir dizide ikili arama yapan bir fonksiyonu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint ikiliArama(int dizi[], int boyut, int aranan) {\n    int sol = 0, sag = boyut - 1;\n    while (sol <= sag) {\n        int mid = sol + (sag - sol) / 2;\n        if (dizi[mid] == aranan) {\n            return mid;\n        }\n        if (dizi[mid] < aranan) {\n            sol = mid + 1;\n        } else {\n            sag = mid - 1;\n        }\n    }\n    return -1; // Bulunamadı\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int aranan = 3;\n    int sonuc = ikiliArama(sayilar, boyut, aranan);\n    if (sonuc != -1) {\n        printf(\"Eleman %d, dizinin %d. indeksinde bulundu.\\n\", aranan, sonuc);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505283"
  },
  {
    "question": "Bir dizi içerisindeki elemanların frekansını hesaplayan bir algoritma nasıl yazılır?",
    "answer": "Aşağıdaki kod, bir dizideki elemanların frekansını hesaplar ve yazdırır:\n\n```c\n#include <stdio.h>\n\nvoid elemanFrekansi(int dizi[], int boyut) {\n    int frekans[100] = {0}; // 100, maksimum eleman değeri\n    for (int i = 0; i < boyut; i++) {\n        frekans[dizi[i]]++;\n    }\n    for (int i = 0; i < 100; i++) {\n        if (frekans[i] != 0) {\n            printf(\"Eleman %d: %d kez\\n\", i, frekans[i]);\n        }\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 2, 3, 1, 4, 2};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    elemanFrekansi(sayilar, boyut);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505308"
  },
  {
    "question": "Bir dizi içindeki en küçük ve en büyük değerleri aynı anda nasıl bulabiliriz?",
    "answer": "Aşağıdaki fonksiyon, bir dizideki hem en küçük hem de en büyük değerleri bulur:\n\n```c\n#include <stdio.h>\n\nvoid minMaxBul(int dizi[], int boyut, int *min, int *max) {\n    *min = dizi[0];\n    *max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < *min) {\n            *min = dizi[i];\n        }\n        if (dizi[i] > *max) {\n            *max = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int sayilar[] = {5, 1, 9, 3, 7};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int min, max;\n    minMaxBul(sayilar, boyut, &min, &max);\n    printf(\"En küçük: %d, En büyük: %d\\n\", min, max);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505334"
  },
  {
    "question": "Bir dizinin kopyasını oluşturacak bir fonksiyon yazınız.",
    "answer": "Aşağıdaki fonksiyon, verilen bir dizinin kopyasını oluşturur:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* diziKopyala(int dizi[], int boyut) {\n    int* kopya = (int*)malloc(boyut * sizeof(int));\n    for (int i = 0; i < boyut; i++) {\n        kopya[i] = dizi[i];\n    }\n    return kopya;\n}\n\nint main() {\n    int sayilar[] = {10, 20, 30, 40};\n    int boyut = sizeof(sayilar) / sizeof(sayilar[0]);\n    int* kopya = diziKopyala(sayilar, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", kopya[i]);\n    }\n    free(kopya);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505354"
  },
  {
    "question": "Bir dizideki çift sayıları ayıran bir fonksiyon yazınız.",
    "answer": "Aşağıdaki kod, verilen bir dizideki çift ve tek sayıların ayrı dizilerde saklanmasını sağlar:\n\n```c\n#include <stdio.h>\n\nvoid ciftTekAyir(int dizi[], int boyut, int* cift, int* tek, int* ciftBoyut, int* tekBoyut) {\n    *ciftBoyut = 0;\n    *tekBoyut = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] % 2 == 0) {\n            cift[(*ciftBoyut)++] = dizi[i];\n        } else {\n            tek[(*tekBoyut)++] = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int sayilar[] = {1, 2, 3, 4, 5, 6};\n    int cift[6], tek[6];\n    int ciftBoyut, tekBoyut;\n    ciftTekAyir(sayilar, 6, cift, tek, &ciftBoyut, &tekBoyut);\n\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < ciftBoyut; i++) {\n        printf(\"%d \", cift[i]);\n    }\n    printf(\"\\nTek sayılar: \");\n    for (int i = 0; i < tekBoyut; i++) {\n        printf(\"%d \", tek[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:45:36.505374"
  },
  {
    "question": "Bir dizi içindeki elemanları ters çevirmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Diziyi ters çevirmek için bir fonksiyon kullanabiliriz. Örneğin:\n\n```c\nvoid reverseArray(int arr[], int size) {\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```\nBu fonksiyon, dizinin başlangıç ve son indeksten başlayarak elemanları yer değiştirerek ters çevirir. Bu sayede ek bir dizi oluşturmadan ters çevrilebilir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038004"
  },
  {
    "question": "Bir dizinin ortalamasını hesaplamak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizinin ortalamasını hesaplamak için toplamı bulup, eleman sayısına böleriz. İşte örnek bir fonksiyon:\n\n```c\nfloat calculateAverage(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return (float)sum / size;\n}\n```\nBu fonksiyon, dizinin elemanlarını toplar ve toplamı eleman sayısına böler. Ortalamayı hesaplamak için veri tipi dönüşümü de önemlidir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038044"
  },
  {
    "question": "Bir dizideki en büyük değeri bulmak için hangi yöntemleri kullanabilirim?",
    "answer": "En büyük değeri bulmanın en temel yolu döngü kullanmaktır. Aşağıda bir örnek verilmiştir:\n\n```c\nint findMax(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n```\nBu fonksiyon, dizinin her elemanını kontrol ederek en büyük değeri bulur.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038070"
  },
  {
    "question": "Bir dizinin sıralanmış olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Dizinin sıralı olup olmadığını kontrol etmek için her iki ardışık elemanı karşılaştırabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\nint isSorted(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            return 0; // Sıralı değil\n        }\n    }\n    return 1; // Sıralı\n}\n```\nBu fonksiyon, dizinin sıralı olup olmadığını kontrol eder ve uygun bir değer döner.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038093"
  },
  {
    "question": "Bir dizideki elemanların toplamını bulmak için optimizasyon yapabilir miyim?",
    "answer": "Dizinin toplamını bulmak için tek bir döngü yeterlidir ama bunu yaparken dizinin eleman sayısını bir değişkende tutmak performansı artırabilir:\n\n```c\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; ++i) {\n        sum += arr[i];\n    }\n    return sum;\n}\n```\nDaha fazla optimizasyon için SIMD (Single Instruction, Multiple Data) gibi özel kütüphaneler kullanmayı da düşünebilirsiniz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038117"
  },
  {
    "question": "Tek boyutlu dizilerde bellek yönetimi ile ilgili nelere dikkat etmeliyim?",
    "answer": "Dizilerin bellek yönetimi, dinamik bellek kullanıldığında kritik bir öneme sahiptir. Örneğin,\n\n```c\nint* createArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    if (arr == NULL) {\n        // Bellek ayırma hatası\n    }\n    return arr;\n}\n```\nBellek ayırdığınızda, kullanmayı bitirdiğinizde mutlaka `free(arr);` ile bellek alanını serbest bırakmalısınız. Ancak, `malloc` sonrası `NULL` kontrolü yapmadan devam etmek bellek sızıntısına yol açabilir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038145"
  },
  {
    "question": "Bir dizideki çift sayıları bulmak ve yeni bir diziye koymak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Çift sayıları bulmak için mevcut diziyi kontrol edip, çift olanları yeni bir diziye ekleyebiliriz:\n\n```c\nint* getEvenNumbers(int arr[], int size, int* newSize) {\n    int* evenArr = (int*)malloc(size * sizeof(int));\n    *newSize = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            evenArr[(*newSize)++] = arr[i];\n        }\n    }\n    return evenArr;\n}\n```\nYeni dizinin boyutunu geri döndürmek için bir işaretçi kullanıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038176"
  },
  {
    "question": "Bir diziyi sıralamak için hangi algoritmayı seçmeliyim ve neden?",
    "answer": "Diziyi sıralamak için birçok algoritma var, ancak hızlı sıralama (Quick Sort) genellikle iyi bir denge sunar. Çok büyük diziler için etkili bir sıralama algoritmasıdır. Örnek:\n\n```c\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n```\nBu algoritmanın ortalama zaman karmaşıklığı O(n log n) olduğundan, büyük dizilerde iyi bir performans gösterir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038199"
  },
  {
    "question": "Bir dizideki tekrar eden elemanları nasıl bulabilirim?",
    "answer": "Tekrar eden elemanları bulmak için bir dizi içinde her elemanı kontrol edebiliriz. Ancak, bu algoritmanın verimliliğini artırmak için bir hash tablosu (veya benzeri bir veri yapısı) kullanmak daha etkili olacaktır. Örnek:\n\n```c\nvoid findDuplicates(int arr[], int size) {\n    int hashTable[100] = {0}; // Eleman aralığına göre ayarlayın\n    for (int i = 0; i < size; i++) {\n        if (hashTable[arr[i]] == 1) {\n            printf(\"%d tekrarı var!\\n\", arr[i]);\n        }\n        hashTable[arr[i]]++;\n    }\n}\n```\nBu yaklaşım, tekrar eden elemanları O(n) karmaşıklıkla bulmamıza olanak tanır.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:46:01.038218"
  },
  {
    "question": "Bir dizinin elemanlarını tersine çeviren bir fonksiyon yazınız. Ancak, dizinin boyutu bilinmemektedir. Fonksiyonu optimize edin.",
    "answer": "Dizinin boyutunu bilmediğimiz için, 'NULL' sonlu bir dizi kullanabiliriz. Aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n\nvoid reverseArray(int *arr) {\n    int *start = arr;\n    int *end = arr;\n    while (*end != 0) { // Dizinin sonuna kadar git\n        end++;\n    }\n    end--;\n    while (start < end) {\n        int temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 0}; // Son eleman 0 ile sonlanıyor\n    reverseArray(arr);\n    for (int i = 0; arr[i] != 0; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu yöntem, ek hafıza kullanımını en aza indirir ve dizinin elemanlarını yerinde tersine çevirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902072"
  },
  {
    "question": "Bir dizi içinde en büyük ve en küçük elemanı tespit eden bir fonksiyon yazınız. Performansını artırmak için optimize edin.",
    "answer": "Diziyi tek seferde dolaşarak en büyük ve en küçük elemanı aynı anda bulabiliriz:\n\n```c\n#include <stdio.h>\n\nvoid findMinMax(int *arr, int size, int *min, int *max) {\n    if (size <= 0) return;\n    *min = *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        }\n        if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}\n\nint main() {\n    int arr[] = {3, 5, 1, 8, 7};\n    int min, max;\n    findMinMax(arr, 5, &min, &max);\n    printf(\"Min: %d, Max: %d\\n\", min, max);\n    return 0;\n}\n```\nBu yöntem, diziyi yalnızca bir kez dolaşarak O(n) zaman karmaşıklığı ile sonuç verir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902165"
  },
  {
    "question": "Bir dizi içinde belirli bir elemanın kaç defa geçtiğini bulan bir fonksiyon yazınız. Performansını artırmak için optimize edin.",
    "answer": "Diziyi tek seferde dolaşarak bir elemanın sayısını tespit edebiliriz:\n\n```c\n#include <stdio.h>\n\nint countOccurrences(int *arr, int size, int target) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 1, 4, 1};\n    int target = 1;\n    int count = countOccurrences(arr, 6, target);\n    printf(\"%d sayısı dizide %d kez geçiyor.\\n\", target, count);\n    return 0;\n}\n```\nDiziyi yalnızca bir kez gezdiğimiz için bu yöntem O(n) zaman karmaşıklığına sahiptir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902211"
  },
  {
    "question": "Bir dizinin elemanlarını sıralamak için bir algoritma yazınız. Performansını optimize edin.",
    "answer": "Hızlı sıralama (Quick Sort) algoritması kullanarak diziyi verimli bir şekilde sıralayabiliriz:\n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int *arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\nvoid quickSort(int *arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu algoritma ortalama O(n log n) zaman karmaşıklığına sahiptir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902240"
  },
  {
    "question": "Bir dizideki tüm çift sayıların toplamını bulan bir fonksiyon yazınız. Performansı artırmak için optimize edin.",
    "answer": "Diziyi tek seferde dolaşarak çift sayıların toplamını hesaplayabiliriz:\n\n```c\n#include <stdio.h>\n\nint sumEvenNumbers(int *arr, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int sum = sumEvenNumbers(arr, 6);\n    printf(\"Çift sayıların toplamı: %d\\n\", sum);\n    return 0;\n}\n```\nBu yöntem, diziyi yalnızca bir kez gezdiği için O(n) zaman karmaşıklığına sahiptir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902273"
  },
  {
    "question": "Bir dizinin elemanlarını bir başka diziye kopyalayan bir fonksiyon yazınız. Fonksiyonu optimize edin.",
    "answer": "Diziyi tek seferde kopyalayarak işlemi gerçekleştirebiliriz:\n\n```c\n#include <stdio.h>\n\nvoid copyArray(int *src, int *dest, int size) {\n    for (int i = 0; i < size; i++) {\n        dest[i] = src[i];\n    }\n}\n\nint main() {\n    int src[] = {1, 2, 3, 4, 5};\n    int dest[5];\n    copyArray(src, dest, 5);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dest[i]);\n    }\n    return 0;\n}\n```\nBu yöntem, kopyalama işlemini O(n) zaman karmaşıklığında gerçekleştirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902304"
  },
  {
    "question": "Bir dizideki elemanları belirli bir değere göre filtreleyen bir fonksiyon yazınız. Performansını artırmak için optimize edin.",
    "answer": "Diziyi tek seferde dolaşarak belirli bir değere eşit olanları filtreleyebiliriz:\n\n```c\n#include <stdio.h>\n\nvoid filterArray(int *arr, int size, int target, int *result, int *resultSize) {\n    *resultSize = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            result[*resultSize] = arr[i];\n            (*resultSize)++;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 4};\n    int result[5];\n    int resultSize;\n    filterArray(arr, 5, 2, result, &resultSize);\n    for (int i = 0; i < resultSize; i++) {\n        printf(\"%d \", result[i]);\n    }\n    return 0;\n}\n```\nBu yöntem O(n) zaman karmaşıklığına sahiptir ve filtreleme işlemini tek seferde gerçekleştirir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902337"
  },
  {
    "question": "Bir dizinin elemanlarını birbirleriyle değiştiren bir fonksiyon yazınız. Ancak, dizinin boyutunu ve elemanlarını kontrol ediniz. Performansı artırmak için optimize edin.",
    "answer": "Değiştirme işlemini yalnızca dizinin boyutunu kontrol ederek gerçekleştirebiliriz:\n\n```c\n#include <stdio.h>\n\nvoid swapElements(int *arr, int size, int index1, int index2) {\n    if (index1 < 0 || index1 >= size || index2 < 0 || index2 >= size) {\n        printf(\"Geçersiz indeks.\\n\");\n        return;\n    }\n    int temp = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = temp;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4};\n    swapElements(arr, 4, 1, 3);\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu yöntem, kontrol yaparak gereksiz işlemleri önler ve yalnızca değiştirme işlemi için O(1) zaman karmaşıklığına sahiptir.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902378"
  },
  {
    "question": "Bir dizinin sıralı olup olmadığını kontrol eden bir fonksiyon yazınız. Performansı artırmak için optimize edin.",
    "answer": "Diziyi tek seferde kontrol ederek sıralı olup olmadığını tespit edebiliriz:\n\n```c\n#include <stdio.h>\n\nint isSorted(int *arr, int size) {\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return 0; // Sıralı değil\n        }\n    }\n    return 1; // Sıralı\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    if (isSorted(arr, 5)) {\n        printf(\"Dizi sıralıdır.\\n\");\n    } else {\n        printf(\"Dizi sıralı değildir.\\n\");\n    }\n    return 0;\n}\n```\nBu yöntem O(n) zaman karmaşıklığına sahiptir ve diziyi yalnızca bir kez dolaşarak kontrol eder.",
    "category": "arrays_strings",
    "topic": "arrays_1d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Tek boyutlu diziler",
    "timestamp": "2025-06-01T14:47:02.902409"
  },
  {
    "question": "2x3 boyutunda bir dizi tanımlayıp elemanlarını kullanıcıdan alarak ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[2][3];\n    // Kullanıcıdan dizi elemanlarını alıyoruz.\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n    // Dizi elemanlarını ekrana yazdırıyoruz.\n    printf(\"Dizi Elemanları:\\n\");\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Burada 2x3 boyutunda bir dizi tanımlıyoruz. Kullanıcıdan bu dizinin her bir elemanını alıyoruz ve ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117575"
  },
  {
    "question": "3x4 boyutunda bir matrisin transpozunu hesaplayın ve ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][4], transpoz[4][3];\n    // Kullanıcıdan matris elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 4; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    // Transpozu alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 4; j++) {\n            transpoz[j][i] = matris[i][j];\n        }\n    }\n    // Transpozu ekrana yazdırıyoruz.\n    printf(\"Matrisin Transpozu:\\n\");\n    for(int i = 0; i < 4; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"%d \", transpoz[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Burada kullanıcıdan 3x4 boyutunda bir matris alıyoruz ve bu matrisin transpozunu hesaplayıp ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117616"
  },
  {
    "question": "5x5 boyutunda bir matrisi sıfırlarla doldurun ve ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[5][5];\n    // Matrisi sıfırlarla dolduruyoruz.\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 5; j++) {\n            matris[i][j] = 0;\n        }\n    }\n    // Matrisi ekrana yazdırıyoruz.\n    printf(\"Matristeki Elemanlar:\\n\");\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 5; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu örnekte 5x5 boyutunda bir matris oluşturup tüm elemanlarını sıfırlarla dolduruyoruz ve sonrasında ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117640"
  },
  {
    "question": "2 boyutlu bir dizideki tüm elemanların toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[3][4], toplam = 0;\n    // Kullanıcıdan dizi elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 4; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n    // Elemanların toplamını hesaplıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 4; j++) {\n            toplam += dizi[i][j];\n        }\n    }\n    printf(\"Dizinin Elemanları Toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n// Bu kodda 3x4 boyutunda bir dizi tanımlanıyor ve kullanıcıdan elemanları alındıktan sonra toplamı hesaplanıyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117672"
  },
  {
    "question": "3x3 boyutunda bir matrisin tüm elemanlarını 1 ile 9 arasındaki rastgele sayılarla doldurun ve ekrana yazdırın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    int matris[3][3];\n    srand(time(NULL)); // Rastgele sayı üreticisini başlatıyoruz.\n    // Matrisi rastgele sayılarla dolduruyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            matris[i][j] = rand() % 9 + 1; // 1 ile 9 arasında rastgele sayı.\n        }\n    }\n    // Matrisi ekrana yazdırıyoruz.\n    printf(\"Matristeki Elemanlar:\\n\");\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Burada 3x3 boyutunda bir matris oluşturup, her bir elemanını 1 ile 9 arasında rastgele sayılarla dolduruyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117704"
  },
  {
    "question": "Bir 2 boyutlu dizideki en büyük elemanı bulup ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[3][3], max;\n    // Kullanıcıdan dizi elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n    max = dizi[0][0]; // İlk elemanı başlangıç olarak alıyoruz.\n    // En büyük elemanı buluyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if(dizi[i][j] > max) {\n                max = dizi[i][j];\n            }\n        }\n    }\n    printf(\"Dizinin En Büyük Elemanı: %d\\n\", max);\n    return 0;\n}\n\n// Bu kodda kullanıcıdan alınan 3x3 boyutundaki dizide en büyük eleman bulunuyor ve ekrana yazdırılıyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117727"
  },
  {
    "question": "3x3 boyutunda bir matrisin elemanlarını kullanıcıdan alarak, her satırın toplamını ayrı ayrı hesaplayın ve yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3], satir_toplam;\n    // Kullanıcıdan matris elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    // Her bir satırın toplamını hesaplıyoruz ve yazdırıyoruz.\n    for(int i = 0; i < 3; i++) {\n        satir_toplam = 0;\n        for(int j = 0; j < 3; j++) {\n            satir_toplam += matris[i][j];\n        }\n        printf(\"Satır %d Toplamı: %d\\n\", i, satir_toplam);\n    }\n    return 0;\n}\n\n// Bu örnekte 3x3 boyutunda bir matris oluşturuluyor, her satırın toplamı hesaplanıyor ve ekrana yazdırılıyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117759"
  },
  {
    "question": "3x3 boyutunda bir matrisin köşegen elemanlarının toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3], toplam = 0;\n    // Kullanıcıdan matris elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    // Köşegen elemanlarının toplamını hesaplıyoruz.\n    for(int i = 0; i < 3; i++) {\n        toplam += matris[i][i]; // Ana köşegen elemanları.\n    }\n    printf(\"Köşegen Elemanlarının Toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n// Bu kodda 3x3 boyutunda bir matrisin ana köşegen elemanlarının toplamını hesaplıyoruz ve ekrana yazdırıyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117781"
  },
  {
    "question": "2D dizideki elemanları sıralamak için bir fonksiyon oluşturun ve çağırın.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int dizi[3][3]) {\n    int temp;\n    // Basit bir sıralama algoritması ile diziyi sıralıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            for(int k = j + 1; k < 3; k++) {\n                if(dizi[i][j] > dizi[i][k]) {\n                    temp = dizi[i][j];\n                    dizi[i][j] = dizi[i][k];\n                    dizi[i][k] = temp;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[3][3];\n    // Kullanıcıdan dizi elemanlarını alıyoruz.\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n    // Diziyi sıralıyoruz.\n    sirala(dizi);\n    // Sıralanmış diziyi ekrana yazdırıyoruz.\n    printf(\"Sıralanmış Dizi:\\n\");\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu örnekte 3x3 boyutunda bir dizi tanımlıyoruz ve içindeki elemanları sıralamak için bir fonksiyon oluşturuyoruz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:47:46.117804"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 3x3'lük bir matrisin elemanlarını kullanıcıdan alıp, bu matrisin transpozesini hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3], transpoze[3][3];\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"3x3'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Transpoze hesaplama\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            transpoze[j][i] = matris[i][j];\n        }\n    }\n\n    // Transpoze matrisini yazdırma\n    printf(\"Matrisin transpozu:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", transpoze[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214465"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 2x3'lük bir matrisin elemanlarının toplamını hesaplayın ve sonucu yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[2][3];\n    int toplam = 0;\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"2x3'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n            toplam += matris[i][j]; // Toplama ekliyoruz\n        }\n    }\n\n    // Toplamı yazdırma\n    printf(\"Matris elemanlarının toplamı: %d\\n\", toplam);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214531"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 4x4'lük bir matrisin yalnızca ana köşegen (diagonal) elemanlarını yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[4][4];\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"4x4'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Ana köşegen elemanlarını yazdırma\n    printf(\"Ana köşegen elemanları:\\n\");\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", matris[i][i]); // Ana köşegen elemanları\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214564"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 3x4'lük bir matrisin satır toplamlarını hesaplayın ve her bir satırın toplamını yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][4];\n    int satirToplam[3] = {0};\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"3x4'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n            satirToplam[i] += matris[i][j]; // Satır toplamını hesaplama\n        }\n    }\n\n    // Satır toplamlarını yazdırma\n    for (int i = 0; i < 3; i++) {\n        printf(\"Satır %d toplamı: %d\\n\", i+1, satirToplam[i]);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214599"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 5x5'lik bir matrisin en büyük elemanını bulun ve bu elemanın indeksini yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[5][5];\n    int enBuyuk; // En büyük eleman\n    int satir, sutun;\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"5x5'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // En büyük elemanı bulma\n    enBuyuk = matris[0][0];\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (matris[i][j] > enBuyuk) {\n                enBuyuk = matris[i][j];\n                satir = i;\n                sutun = j;\n            }\n        }\n    }\n\n    // Sonucu yazdırma\n    printf(\"En büyük eleman: %d, İndeks: [%d][%d]\\n\", enBuyuk, satir, sutun);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214632"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 3x5'lik bir matrisin elemanlarının ortalamasını hesaplayın ve sonucu yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][5];\n    int toplam = 0;\n    float ortalama;\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"3x5'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 5; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n            toplam += matris[i][j]; // Toplama ekliyoruz\n        }\n    }\n\n    // Ortalama hesaplama\n    ortalama = toplam / (3.0 * 5.0);\n    printf(\"Matris elemanlarının ortalaması: %.2f\\n\", ortalama);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214662"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 2x4'lük bir matrisin satır ve sütunlarındaki en küçük elemanları ayrı dizilere kaydedin ve yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[2][4];\n    int minSatir[2], minSutun[4];\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"2x4'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Satır en küçük elemanlarını bulma\n    for (int i = 0; i < 2; i++) {\n        minSatir[i] = matris[i][0];\n        for (int j = 1; j < 4; j++) {\n            if (matris[i][j] < minSatir[i]) {\n                minSatir[i] = matris[i][j];\n            }\n        }\n    }\n\n    // Sütun en küçük elemanlarını bulma\n    for (int j = 0; j < 4; j++) {\n        minSutun[j] = matris[0][j];\n        for (int i = 1; i < 2; i++) {\n            if (matris[i][j] < minSutun[j]) {\n                minSutun[j] = matris[i][j];\n            }\n        }\n    }\n\n    // Sonuçları yazdırma\n    printf(\"Satır en küçük elemanları:\\n\");\n    for (int i = 0; i < 2; i++) {\n        printf(\"Satır %d: %d\\n\", i+1, minSatir[i]);\n    }\n    printf(\"Sütun en küçük elemanları:\\n\");\n    for (int j = 0; j < 4; j++) {\n        printf(\"Sütun %d: %d\\n\", j+1, minSutun[j]);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214699"
  },
  {
    "question": "Aşağıdaki C kodunu tamamlayarak, 3x3'lük bir matrisin elemanlarını okuyun ve ardından matrisin tüm elemanlarını 2 ile çarpın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n\n    // Kullanıcıdan matris elemanlarını alma\n    printf(\"3x3'lük bir matrisin elemanlarını girin:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Matris elemanlarını 2 ile çarpma ve yazdırma\n    printf(\"Matrisin 2 ile çarpılmış hali:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            matris[i][j] *= 2;\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:48:48.214740"
  },
  {
    "question": "Aşağıda tanımlı iki boyutlu bir diziyi kullanarak, dizinin elemanlarını ekrana yazdıracak bir fonksiyon tamamlayın: int matris[3][4];",
    "answer": "#include <stdio.h>\n\nvoid yazdir(int matris[3][4]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int matris[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n    yazdir(matris);\n    return 0;\n}\n// Fonksiyon, iki boyutlu dizinin elemanlarını satır satır ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181480"
  },
  {
    "question": "Bir 3x3x3 boyutunda dizi tanımlayın ve bu dizinin tüm elemanlarını sıfır ile dolduran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid sıfırla(int dizi[3][3][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                dizi[i][j][k] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[3][3][3];\n    sıfırla(dizi);\n    return 0;\n}\n// Bu kod, üç boyutlu dizinin tüm elemanlarını sıfıra ayarlar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181578"
  },
  {
    "question": "Bir 4x4 matrisin transpozunu (satır ve sütunları yer değiştiren hali) hesaplayacak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid transpoze(int matris[4][4], int transpozeMatris[4][4]) {\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            transpozeMatris[j][i] = matris[i][j];\n        }\n    }\n}\n\nint main() {\n    int matris[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int transpozeMatris[4][4];\n    transpoze(matris, transpozeMatris);\n    return 0;\n}\n// Fonksiyon, verilen matrisin transpozunu hesaplayarak yeni bir diziye atar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181636"
  },
  {
    "question": "Aşağıdaki tanımlı 2D dizinin en büyük elemanını bulan bir fonksiyon yazın: int dizi[5][3];",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[5][3]) {\n    int max = dizi[0][0];\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (dizi[i][j] > max) {\n                max = dizi[i][j];\n            }\n        }\n    }\n    return max;\n}\n\nint main() {\n    int dizi[5][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}, {13, 14, 15}};\n    printf(\"En büyük eleman: %d\\n\", enBuyuk(dizi));\n    return 0;\n}\n// Fonksiyon, dizinin en büyük elemanını bulup döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181698"
  },
  {
    "question": "Bir 2D dizideki elemanların toplamını hesaplayan bir fonksiyon yazın: int matris[2][5];",
    "answer": "#include <stdio.h>\n\nint toplam(int matris[2][5]) {\n    int toplam = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 5; j++) {\n            toplam += matris[i][j];\n        }\n    }\n    return toplam;\n}\n\nint main() {\n    int matris[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};\n    printf(\"Toplam: %d\\n\", toplam(matris));\n    return 0;\n}\n// Fonksiyon, dizideki tüm elemanların toplamını döndürür.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181747"
  },
  {
    "question": "Kullanıcının girişte verdiği sayılarla 3x3 bir matris oluşturun ve bu matrisin satır toplamlarını hesaplayın.",
    "answer": "#include <stdio.h>\n\nvoid satirToplamlari(int matris[3][3], int toplamlar[3]) {\n    for (int i = 0; i < 3; i++) {\n        toplamlar[i] = 0; // Başlangıç toplamı sıfır\n        for (int j = 0; j < 3; j++) {\n            toplamlar[i] += matris[i][j];\n        }\n    }\n}\n\nint main() {\n    int matris[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"Matris[%d][%d] için bir değer girin: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    int toplamlar[3];\n    satirToplamlari(matris, toplamlar);\n    printf(\"Satır toplamları: \");\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d \", toplamlar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu kod, kullanıcıdan matris elemanlarını alır ve her satırın toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181801"
  },
  {
    "question": "Bir 2D dizideki her sütunun ortalamasını hesaplayan bir fonksiyon oluşturun: int dizi[4][6];",
    "answer": "#include <stdio.h>\n\nvoid ortalamaBul(int dizi[4][6], float ortalamalar[6]) {\n    for (int j = 0; j < 6; j++) {\n        int toplam = 0;\n        for (int i = 0; i < 4; i++) {\n            toplam += dizi[i][j];\n        }\n        ortalamalar[j] = toplam / 4.0;\n    }\n}\n\nint main() {\n    int dizi[4][6] = {{1, 2, 3, 4, 5, 6}, {7, 8, 9, 10, 11, 12}, {13, 14, 15, 16, 17, 18}, {19, 20, 21, 22, 23, 24}};\n    float ortalamalar[6];\n    ortalamaBul(dizi, ortalamalar);\n    for (int j = 0; j < 6; j++) {\n        printf(\"Sütun %d ortalaması: %.2f\\n\", j, ortalamalar[j]);\n    }\n    return 0;\n}\n// Fonksiyon, her sütunun ortalamasını hesaplar ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181855"
  },
  {
    "question": "Bir 2D dizinin simetrik olup olmadığını kontrol eden bir fonksiyon yazın: int dizi[3][3];",
    "answer": "#include <stdio.h>\n\nint simetrikMi(int dizi[3][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (dizi[i][j] != dizi[j][i]) {\n                return 0; // Simetrik değil\n            }\n        }\n    }\n    return 1; // Simetrik\n}\n\nint main() {\n    int dizi[3][3] = {{1, 2, 3}, {2, 4, 5}, {3, 5, 6}};\n    if (simetrikMi(dizi)) {\n        printf(\"Dizi simetriktir.\\n\");\n    } else {\n        printf(\"Dizi simetrik değildir.\\n\");\n    }\n    return 0;\n}\n// Bu kod, 2D dizinin simetrik olup olmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181906"
  },
  {
    "question": "Kullanıcıdan alınan 2D dizideki elemanların en küçük değerini bulan bir fonksiyon yazın: int dizi[4][4];",
    "answer": "#include <stdio.h>\n\nint enKucuk(int dizi[4][4]) {\n    int min = dizi[0][0];\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (dizi[i][j] < min) {\n                min = dizi[i][j];\n            }\n        }\n    }\n    return min;\n}\n\nint main() {\n    int dizi[4][4];\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"Dizi[%d][%d] için bir değer girin: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n    printf(\"En küçük eleman: %d\\n\", enKucuk(dizi));\n    return 0;\n}\n// Fonksiyon, kullanıcıdan alınan 2D dizinin en küçük elemanını bulur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:49:30.181958"
  },
  {
    "question": "İki boyutlu bir dizi tanımlarken boyutları yanlış belirledim. Kodum: int dizi[3];. Bu hata neyi ifade ediyor?",
    "answer": "Bu kodda 'dizi' adında sadece bir boyutlu bir dizi tanımlanmıştır. İki boyutlu bir dizi oluşturmak için, boyutları belirtmek gerekir. Doğru kod: int dizi[3][3]; olmalıdır. Bu, 3x3 boyutunda bir matris oluşturur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.216927"
  },
  {
    "question": "Aşağıdaki kodda döngü ile dizinin elemanlarını yazdırırken bir hata alıyorum. Kodum: int dizi[2][3] = {{1,2,3},{4,5,6}}; for(int i=0; i<=2; i++) { for(int j=0; j<=3; j++) { printf(\"%d \", dizi[i][j]); }}. Hata neden kaynaklanıyor?",
    "answer": "Döngü koşulları yanlış ayarlanmış. 'i<=2' ve 'j<=3' kullanmak yerine 'i<2' ve 'j<3' olmalı. Çünkü dizinin boyutları 2x3 olduğundan, dizinin indexleri 0, 1 ve 0, 1, 2 şeklindedir. Doğru döngü: for(int i=0; i<2; i++) { for(int j=0; j<3; j++) { printf(\"%d \", dizi[i][j]); }}",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217089"
  },
  {
    "question": "Dizi elemanlarını toplamak için yazdığım kodda beklenmedik bir sonuç alıyorum. Kodum: int dizi[2][2] = {{1,2},{3,4}}; int toplam = 0; for(int i=0; i<2; i++) { for(int j=0; j<2; j++) { toplam += dizi[i][j]; } } printf(\"Toplam: %d\", toplam);. Sonuç neden yanlış?",
    "answer": "Kodda bir hata yok. Ancak toplamın yanlış olduğuna inanıyorsanız, kontrol etmelisiniz. Bu kod, 1 + 2 + 3 + 4 = 10 sonucunu verecektir. Eğer farklı bir sonuç bekliyorsanız, dizinin elemanlarına tekrar bakmanız gerekebilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217238"
  },
  {
    "question": "Aşağıdaki kodda dizinin elemanlarına erişirken 'segmentation fault' hatası alıyorum. Kodum: int dizi[2][3]; dizi[2][1] = 5; printf(\"%d\", dizi[2][1]);. Hata nereden kaynaklanıyor?",
    "answer": "Hata, dizinin sınırlarını aşmanızdan kaynaklanıyor. 'dizi' 2x3 boyutunda tanımlandı, yani geçerli indexler 0 ve 1'dir. 'dizi[2][1]' kullanmak, sınır dışı bir erişim yapmaktadır. Doğru kullanım: 'dizi[1][1] = 5;' şeklinde olmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217327"
  },
  {
    "question": "İki boyutlu dizi üzerinde bir elemanı atamak istiyorum ama sonuç beklediğim gibi olmuyor. Kodum: int dizi[2][2]; dizi[0][1] = 10; printf(\"%d\", dizi[1][0]);. Beklenmeyen değer geliyor, neden?",
    "answer": "Yazdığınız kodda bir hata yok. Ancak ilk satırda sadece dizi[0][1] elemanını atanmışken, ikinci satırda dizi[1][0] elemanı basılmakta. Bu nedenle, dizi[1][0] henüz atanmadı ve rastgele bir değer gösterir. Doğru olan, her elemanı atadıktan sonra basmaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217423"
  },
  {
    "question": "Bir dizi tanımlamak için kullandığım aşağıdaki kodda hata alıyorum. Kodum: int dizi[2][2][2];. Bu hata neden kaynaklanıyor?",
    "answer": "Bu kodda bir hata yok. 'dizi' 3 boyutlu bir dizi olarak tanımlanmıştır. Ancak, dizinin boyutlarını doğru bir şekilde kullanmalısınız. Eğer her boyut için atama yapmazsanız ve erişmeye çalışırsanız bellek hataları alabilirsiniz. Sonrasında bu diziyi kullanmadan önce tüm elemanları başlatmalısınız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217487"
  },
  {
    "question": "Dizi elemanlarını ters sırayla yazdırmak istiyorum ancak kodum çalışmıyor. Kodum: int dizi[3] = {1,2,3}; for(int i=3; i>=0; i--) { printf(\"%d \", dizi[i]); }. Hata nereden kaynaklanıyor?",
    "answer": "Dizinin sınırları aşılmıştır. 'i>=0' yerine 'i>0' olmalıdır. Çünkü dizinin geçerli indexleri 0, 1 ve 2'dir. Doğru döngü: for(int i=2; i>=0; i--) { printf(\"%d \", dizi[i]); } olmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217611"
  },
  {
    "question": "Dizime veri atarken bir değer yazamıyorum. Kodum: int dizi[3][3]; dizi[3][0] = 123; printf(\"%d\", dizi[3][0]);. Hatanın nedeni nedir?",
    "answer": "Hata, dizi indexinin sınırlarını aşmanızdan kaynaklanıyor. 'dizi[3][0]' kullanmak, geçerli bir index değildir. Geçerli indexler 0, 1 ve 2'dir. Doğru kullanım: 'dizi[2][0] = 123;' olmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217684"
  },
  {
    "question": "Çok boyutlu diziyi bir fonksiyona geçirirken bir hata alıyorum. Kodum: void fonksiyon(int dizi[3][3]) { dizi[0][0] = 10; } main() { int dizi[3][3]; fonksiyon(dizi); printf(\"%d\", dizi[0][0]); }. Hata neden kaynaklanıyor?",
    "answer": "Bu kodda bir hata yok, ancak dizi üzerinde herhangi bir işlem yapılmadığı için beklenmedik bir sonuç alabilirsiniz. 'fonksiyon' çağrıldığında, dizinin elemanları varsayılan değeri alır. Başlatmadan işlem yapmayın. Başlatma ekleyin: 'int dizi[3][3] = {{0}};' şeklinde başlangıç yapmalısınız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217802"
  },
  {
    "question": "Dizi elemanlarını başka bir diziye kopyalamaya çalışırken hata alıyorum. Kodum: int dizi1[2][2] = {{1,2},{3,4}}; int dizi2[2][2]; dizi2 = dizi1;. Hatanın nedeni nedir?",
    "answer": "C dilinde dizileri doğrudan atamak mümkün değildir. Bunun yerine, elemanları tek tek kopyalamalısınız. Örneğin: 'for(int i=0; i<2; i++) { for(int j=0; j<2; j++) { dizi2[i][j] = dizi1[i][j]; } }' şeklinde bir döngü kullanmalısınız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:50:00.217904"
  },
  {
    "question": "İki boyutlu bir diziyi tanımlarken bellek kullanımında sorun yaşıyorum. 'int matrix[10][10];' tanımından sonra diziyi nasıl doğru bir şekilde başlatabilirim?",
    "answer": "Diziyi başlatmak için iki döngü kullanarak tüm elemanları sıfırlayabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[10][10];\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            matrix[i][j] = 0;\n        }\n    }\n    return 0;\n}\n```\nBu kod, 'matrix' adlı iki boyutlu dizinin tüm elemanlarını 0 ile başlatır. Bellek kullanımı açısından sorun olmaması için her bir elemanın doğru bir şekilde başlatıldığından emin olun.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734055"
  },
  {
    "question": "Bir üç boyutlu dizi tanımladım ve değer atarken hatalı sonuç alıyorum. 'int array[3][3][3];' tanımından sonra nasıl doğru bir atama yapabilirim?",
    "answer": "Üç boyutlu dizide değer atarken, her bir boyut için döngüler kullanmalısınız. Örneğin:\n\n```c\nint array[3][3][3];\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n            array[i][j][k] = i + j + k; // Her bir elemana toplamını atıyoruz.\n        }\n    }\n}\n```\nDizi elemanlarına erişim sırasını kontrol etmek çok önemlidir. Yanlış döngü sıralaması, beklenmedik sonuçlara yol açabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734117"
  },
  {
    "question": "Bir iki boyutlu dizide elemanları toplamak istiyorum, ancak sonuca ulaşamıyorum. Hata nerede olabilir?",
    "answer": "Toplama işlemi yaparken dizinin boyutlarını doğru şekilde kullanmadığınızdan emin olmalısınız. Aşağıdaki kod örneği, tüm elemanları toplayarak sonucu verir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int sum = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            sum += matrix[i][j];\n        }\n    }\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n```\nEğer dizinin boyutlarıyla oynarsanız veya döngü sınırlarını yanlış belirlerseniz, toplama işlemi hatalı olur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734149"
  },
  {
    "question": "Bir iki boyutlu dizinin transpozunu almak istiyorum ama sonuçları beklediğim gibi alamıyorum. Hatanın kaynağı ne olabilir?",
    "answer": "Transpoz alma işlemi için dizinin elemanlarını doğru bir şekilde değiştirmeniz gerekiyor. Aşağıdaki kod doğru bir transpoz işlemine örnek oluşturur:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int transposed[3][2];\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n    // Transpoze diziyi yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"%d \", transposed[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nDizinin boyutlarına dikkat etmezseniz, indeks dışı hatalar alabilirsiniz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734182"
  },
  {
    "question": "Bir dizi elemanını güncelleyebilmek için fonksiyon yazdım ama güncelleme yapılmıyor. Hatanın sebebi ne olabilir?",
    "answer": "Fonksiyona diziyi geçirirken, dizinin bir kopyasını değil, bir referansını geçmeniz gerekir. Aşağıda doğru bir kullanım örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid updateValue(int matrix[3][3], int row, int col, int value) {\n    matrix[row][col] = value;\n}\n\nint main() {\n    int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    updateValue(matrix, 1, 1, 10); // 2. satır, 2. sütunu 10 ile güncelliyoruz\n    printf(\"Güncellenmiş değer: %d\\n\", matrix[1][1]);\n    return 0;\n}\n```\nDizinin referansını geçmediğinizde, fonksiyon dizinin kopyasıyla çalışacağı için güncelleme yapılmaz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734214"
  },
  {
    "question": "Bir iki boyutlu diziyi, kullanıcıdan aldığım verilerle doldurmak istiyorum, ancak kullandığım döngüler hatalı. Doğru bir şekilde nasıl gerçekleştirebilirim?",
    "answer": "Kullanıcıdan veri almak için çift döngü kullanmalısınız. Aşağıdaki örnek, kullanıcıdan alınan verilerle bir iki boyutlu diziyi doldurmayı göstermektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[2][3];\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"[%d][%d] için bir sayı girin: \", i, j);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nDöngülerin sınırlarını doğru ayarlamazsanız, 'scanf' fonksiyonu ile bellek hataları yaşayabilirsiniz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734254"
  },
  {
    "question": "Bir dizinin elemanlarını sıralamak için iki boyutlu diziyi kullanmaya çalışıyorum, ancak algoritmamda hata var. Nasıl düzeltebilirim?",
    "answer": "İki boyutlu diziyi sıralamak için öncelikle tüm öğeleri tek boyutlu bir diziye aktarıp ardından sıralamanız gerekebilir. Aşağıda basit bir sıralama örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int matrix[3][3] = {{9, 2, 3}, {4, 5, 6}, {7, 8, 1}};\n    int temp[9], index = 0;\n\n    // Dizi elemanlarını tek boyutlu diziye aktarma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            temp[index++] = matrix[i][j];\n        }\n    }\n\n    // Sıralama işlemi\n    qsort(temp, 9, sizeof(int), compare);\n\n    // Sıralı elemanları yazdırma\n    for (int i = 0; i < 9; i++) {\n        printf(\"%d \", temp[i]);\n    }\n    return 0;\n}\n```\nAlgoritmanızda dizinin boyutlarına dikkat etmezseniz, sıralama hataları alabilirsiniz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734299"
  },
  {
    "question": "Bir diziyi okuduktan sonra, elemanlarının toplamını bulmak istiyorum ama aldığım sonuç yanlış. Hatanın kaynağı nedir?",
    "answer": "Dizinin boyutlarını kontrol ettiğinizden emin olun. Aşağıdaki örnekte, dizinin toplamını bulmak için doğru bir yöntem kullanılmıştır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int sum = 0;\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            sum += matrix[i][j];\n        }\n    }\n    printf(\"Toplam: %d\\n\", sum);\n    return 0;\n}\n```\nEğer dizinin boyutunu değiştirirseniz veya döngü sınırlarını yanlış belirlerseniz, yanlış sonuçlar alırsınız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734333"
  },
  {
    "question": "Bir iki boyutlu diziden belirli bir satırı silmek istiyorum ama nasıl yapacağımı bilmiyorum. Ne önerirsiniz?",
    "answer": "İki boyutlu diziden bir satırı silmek için, silmek istediğiniz satırdan sonraki tüm satırları bir yukarı kaydırmalısınız. Aşağıdaki örnek, bu işlemi gerçekleştiren bir kodu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matrix[4][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};\n    int rowToDelete = 1; // 2. satırı silmek istiyoruz\n\n    for (int i = rowToDelete; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            matrix[i][j] = matrix[i + 1][j];\n        }\n    }\n\n    // Sonuç dizisini yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nEğer dizinin boyutunu doğru ayarlamazsanız, bellek hataları ile karşılaşabilirsiniz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:08.734363"
  },
  {
    "question": "Çok boyutlu dizi nedir ve ne zaman kullanılır?",
    "answer": "Çok boyutlu dizi, birden fazla boyutta veri saklamak için kullanılan bir veri yapısıdır. Örneğin, iki boyutlu bir dizi, satır ve sütunlardan oluşan bir tablo gibi düşünülebilir. Çok boyutlu dizileri genellikle matris hesaplamaları, grafik verileri veya oyun programlama gibi senaryolarda kullanırız.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589787"
  },
  {
    "question": "C dilinde iki boyutlu bir dizi nasıl tanımlanır?",
    "answer": "İki boyutlu bir dizi tanımlamak için aşağıdaki gibi bir sözdizimi kullanabiliriz: `int dizi[3][4];` Bu, 3 satır ve 4 sütundan oluşan bir tamsayı dizisi oluşturur. Her bir eleman `dizi[i][j]` şeklinde erişilebilir, burada `i` satır ve `j` sütun indeksidir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589823"
  },
  {
    "question": "İki boyutlu bir diziyi nasıl başlatırız?",
    "answer": "İki boyutlu bir diziyi başlatmak için aşağıdaki gibi bir yöntem kullanabiliriz: `int dizi[2][3] = {{1, 2, 3}, {4, 5, 6}};` Bu kod, iki satır ve üç sütundan oluşan bir dizi oluşturur ve her bir elemana başlangıç değerleri atar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589843"
  },
  {
    "question": "Bir iki boyutlu dizinin elemanlarına nasıl erişebilirim?",
    "answer": "Bir iki boyutlu dizinin elemanlarına erişmek için indeksleme kullanırız. Örneğin, `int dizi[2][3] = {{1, 2, 3}, {4, 5, 6}};` dizisinde `dizi[1][2]` ifadesi, ikinci satırın üçüncü sütunundaki elemanı (yani 6) verir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589865"
  },
  {
    "question": "Çok boyutlu bir dizi döngü ile nasıl işlenir?",
    "answer": "Döngü kullanarak çok boyutlu dizileri işlemek için iç içe döngüler kullanabiliriz. Örneğin: \n```\nfor (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 3; j++) {\n        printf(\"%d \", dizi[i][j]);\n    }\n}\n``` Bu kod, dizinin her bir elemanını sırayla ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589885"
  },
  {
    "question": "Üç boyutlu bir dizi nedir ve nasıl tanımlanır?",
    "answer": "Üç boyutlu dizi, üç boyutta veri saklamak için kullanılır. Örneğin, `int dizi[2][3][4];` ifadesi, 2 katman, 3 satır ve 4 sütundan oluşan bir dizi oluşturur. Her bir eleman `dizi[i][j][k]` şeklinde erişilebilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589905"
  },
  {
    "question": "Çok boyutlu dizilerle basit bir matematik işlemi nasıl yapılır?",
    "answer": "Aşağıdaki gibi bir örnekle iki boyutlu dizilerde toplama işlemi gerçekleştirebiliriz: \n```\nint a[2][2] = {{1, 2}, {3, 4}};\nint b[2][2] = {{5, 6}, {7, 8}};\nint toplam[2][2];\nfor (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 2; j++) {\n        toplam[i][j] = a[i][j] + b[i][j];\n    }\n}\n``` Bu kod, `a` ve `b` dizilerini toplayarak `toplam` dizisine atar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589928"
  },
  {
    "question": "Dinamik olarak çok boyutlu bir dizi nasıl oluşturulur?",
    "answer": "Dinamik olarak çok boyutlu dizi oluşturmak için `malloc` fonksiyonunu kullanabiliriz. Örneğin: \n```\nint **dizi;\ndizi = (int **)malloc(2 * sizeof(int *));\nfor (int i = 0; i < 2; i++) {\n    dizi[i] = (int *)malloc(3 * sizeof(int));\n}\n``` Bu kod, iki boyutlu bir dizi için bellek ayırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589949"
  },
  {
    "question": "Çok boyutlu diziyi fonksiyona nasıl geçiririm?",
    "answer": "Çok boyutlu dizileri fonksiyona geçirirken, dizinin boyutunu belirtmemiz gerekir. Örneğin: \n```\nvoid fonksiyon(int dizi[2][3]) {\n    // Dizi ile işlemler yapılır.\n}\n``` Bu şekilde, fonksiyon çağrısı sırasında dizinin boyutu sabit olmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589967"
  },
  {
    "question": "Çok boyutlu dizide elemanları nasıl sıralarım?",
    "answer": "Çok boyutlu dizilerde elemanları sıralamak için önce tüm elemanları tek boyutlu bir diziye kopyalayabiliriz. Sonrasında bu tek boyutlu diziyi sıralayıp, sıralı elemanları tekrar çok boyutlu dizimize aktarabiliriz. Örneğin: \n```\nint dizi[2][3] = {{3, 1, 2}, {6, 4, 5}};\nint temp[6];\n// Elemanları tek boyutlu diziye kopyala.\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:51:34.589984"
  },
  {
    "question": "Çok boyutlu diziler nedir ve ne amaçla kullanılır?",
    "answer": "Çok boyutlu diziler, birden fazla dizinin bir araya gelerek oluşturduğu dizilerdir. Genellikle verilerin tablo şeklinde organize edilmesi gerektiğinde kullanılır. Örneğin, bir oyun geliştirdiğinizde, oyun alanını temsil etmek için 2 boyutlu bir dizi kullanabilirsiniz. Bu dizi, her bir hücresinde oyundaki objelerin veya boş alanların durumunu tutabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.306960"
  },
  {
    "question": "C dilinde 2 boyutlu bir dizi nasıl tanımlanır ve başlatılır?",
    "answer": "C dilinde 2 boyutlu bir dizi tanımlamak için 'tip diziAdı[satırSayısı][sütunSayısı]' şeklinde bir tanım yaparız. Örneğin: 'int matris[3][4];' ifadesi 3 satır ve 4 sütundan oluşan bir tamsayı dizisi tanımlar. Başlatmak için: 'int matris[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};' şeklinde bir başlangıç değeri verebiliriz.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307005"
  },
  {
    "question": "Çok boyutlu dizilerde elemanlara nasıl erişilir?",
    "answer": "Çok boyutlu dizilerde elemanlara erişmek için dizinin boyutlarına göre indeks kullanırız. Örneğin, 'int matris[3][4];' dizisinin 2. satır 3. sütunundaki elemana erişmek için 'matris[1][2]' ifadesini kullanırız. Unutmayın ki, diziler 0'dan başladığı için 1. satır 2. eleman 1. indeksle ifade edilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307031"
  },
  {
    "question": "Bir 2 boyutlu diziyi döngü ile nasıl yazdırırız?",
    "answer": "Bir 2 boyutlu diziyi yazdırmak için iç içe döngüler kullanırız. Dış döngü satırları, iç döngü ise sütunları iter. Örneğin: \n```c\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 4; j++) {\n        printf(\"%d \", matris[i][j]);\n    }\n    printf(\"\\n\");\n}\n``` Bu kod, dizinin tüm elemanlarını satır satır yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307054"
  },
  {
    "question": "C dilinde dinamik olarak çok boyutlu bir dizi nasıl oluşturulur?",
    "answer": "Dinamik olarak çok boyutlu bir dizi oluşturmak için malloc ve pointer kullanırız. Öncelikle satır sayısı kadar pointer dizisi tanımlarız, ardından her bir pointer için sütun sayısı kadar bellek tahsis ederiz. Örneğin: \n```c\nint **matris;\nmatris = malloc(satirSayisi * sizeof(int *));\nfor (int i = 0; i < satirSayisi; i++) {\n    matris[i] = malloc(sutunSayisi * sizeof(int));\n}\n``` Bu kod, satır sayısı ve sütun sayısı kadar bellek ayırarak 2 boyutlu bir dizi oluşturur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307078"
  },
  {
    "question": "Bir 3 boyutlu diziyi nasıl tanımlar ve başlatırsınız?",
    "answer": "3 boyutlu bir dizi, 'tip diziAdı[boyut1][boyut2][boyut3]' şeklinde tanımlanır. Örneğin: 'int dizi[2][3][4];' ifadesi 2 katman, 3 satır ve 4 sütundan oluşan bir tamsayı dizisi tanımlar. Başlatmak için: \n```c\nint dizi[2][3][4] = {{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}, \n                     {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}};\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307101"
  },
  {
    "question": "Çok boyutlu dizilerde depolama alanı verimliliğini artırmak için hangi yöntemler kullanılabilir?",
    "answer": "Çok boyutlu dizilerde depolama alanı verimliliğini artırmak için yapısal diziler (struct) kullanabiliriz. Bu sayede benzer veri tiplerini daha az yer kaplayacak şekilde gruplandırabiliriz. Ayrıca, mümkünse dizinin boyutlarını esnek tutarak bellek tahsisini dinamik olarak yönetmek, kullanılmayan alanları azaltacaktır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307133"
  },
  {
    "question": "Çok boyutlu bir dizinin elemanlarının toplamını nasıl hesaplayabilirsiniz?",
    "answer": "Dizinin tüm elemanlarının toplamını hesaplamak için iç içe döngüler kullanarak her bir elemanı toplarız. Örneğin: \n```c\nint toplam = 0;\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 4; j++) {\n        toplam += matris[i][j];\n    }\n}\nprintf(\"Toplam: %d\\n\", toplam);\n``` Bu kod, tüm elemanları gezerek toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307156"
  },
  {
    "question": "Çok boyutlu dizilerde geçerli bir bellek erişimi hatasını nasıl önleyebilirsiniz?",
    "answer": "Geçerli bir bellek erişimi hatasını önlemek için dizinin boyutlarını ve indekslerini dikkatli bir şekilde kontrol etmek önemlidir. Dizinin boyutlarını sabit bir değişkende tutarak ve döngü sınırlarını bu değişkenler ile belirleyerek bu hatayı azaltabiliriz. Ayrıca, dinamik bellek tahsisi kullanıyorsanız, her tahsisten sonra belleği kontrol edin ve serbest bırakmayı unutmayın.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307181"
  },
  {
    "question": "Bir 2 boyutlu dizide belirli bir değeri nasıl bulur ve konumunu döndürürsünüz?",
    "answer": "Bir 2 boyutlu dizide belirli bir değeri bulmak için yine iç içe döngüler kullanarak tüm elemanları kontrol edebiliriz. Eğer elemanı bulursak, konumunu (satır ve sütun indeksi) kaydedebiliriz. Örneğin: \n```c\nint aranan = 7;\nbool bulundu = false;\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 4; j++) {\n        if (matris[i][j] == aranan) {\n            printf(\"Bulundu: [%d][%d]\\n\", i, j);\n            bulundu = true;\n            break;\n        }\n    }\n    if (bulundu) break;\n}\n``` Bu kod, dizide aranan değeri bulduğunda indekslerini yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:02.307208"
  },
  {
    "question": "Çok boyutlu bir dizi nedir ve ne amaçla kullanılır?",
    "answer": "Çok boyutlu diziler, birden fazla boyutta verileri saklamak için kullanılan dizilerdir. Örneğin, bir 2D dizi, satırlar ve sütunlar şeklinde düzenlenmiş verilere sahiptir. Çok boyutlu diziler, genellikle matrisler, grafikler veya oyun alanları gibi yapıların temsilinde kullanılır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668813"
  },
  {
    "question": "C dilinde 3 boyutlu bir dizi nasıl tanımlanır ve nasıl erişilir?",
    "answer": "C dilinde 3 boyutlu bir dizi tanımlamak için şu şekilde yazabilirsiniz: 'int dizi[3][4][5];'. Burada 3, 4 ve 5 sırasıyla boyutları temsil eder. Dizi elemanlarına erişmek için ise dizi[x][y][z] şeklinde indeksleri kullanarak erişim sağlanır. Örneğin, dizi[1][2][3] ifadesi 1. katman, 2. satır, 3. sütundaki elemanı temsil eder.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668877"
  },
  {
    "question": "Çok boyutlu dizilerde bellek yönetimi nasıl yapılır?",
    "answer": "Çok boyutlu diziler statik ya da dinamik olarak tanımlanabilir. Statik diziler, derleme zamanında boyutları belirlenmiş dizilerdir, dinamik diziler ise 'malloc' gibi fonksiyonlar kullanılarak çalışma zamanında oluşturulur. Dinamik dizilerde bellek yönetimi önemlidir; kullanılmadığında 'free' fonksiyonu ile bellek serbest bırakılmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668900"
  },
  {
    "question": "Bir 2D dizinin elemanlarını toplamak için nasıl bir fonksiyon yazılabilir?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nint toplam(int dizi[3][4], int satir, int sutun) {\n    int toplam = 0;\n    for(int i = 0; i < satir; i++) {\n        for(int j = 0; j < sutun; j++) {\n            toplam += dizi[i][j];\n        }\n    }\n    return toplam;\n}\n```\nBu fonksiyon, 3 satır ve 4 sütundan oluşan bir 2D dizi alır ve tüm elemanların toplamını döner.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668925"
  },
  {
    "question": "Çok boyutlu dizilerle nasıl matris çarpımı yapılır?",
    "answer": "Matris çarpımı için iki 2D diziyi çarparken, birinci matrisin sütun sayısının ikinci matrisin satır sayısına eşit olması gerekir. Aşağıdaki örnekte, iki matrisin çarpımını hesaplayan bir fonksiyon verilmiştir:\n\n```c\nvoid matrisCarp(int mat1[3][2], int mat2[2][3], int sonuc[3][3]) {\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            sonuc[i][j] = 0;\n            for(int k = 0; k < 2; k++) {\n                sonuc[i][j] += mat1[i][k] * mat2[k][j];\n            }\n        }\n    }\n}\n```\nBu fonksiyon, iki matrisin çarpımını 'sonuc' matrisine kaydeder.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668949"
  },
  {
    "question": "Çok boyutlu dizilerde dizinin boyutunu nasıl dinamik olarak belirleyebilirsiniz?",
    "answer": "Dinamik boyutlandırma için, 'malloc' veya 'calloc' gibi fonksiyonlar kullanarak diziyi oluşturabilirsiniz. Örneğin, 2D bir diziyi dinamik olarak oluşturmak için:\n\n```c\nint **dizi;\nint satir = 3, sutun = 4;\ndizi = (int**)malloc(satir * sizeof(int*));\nfor(int i = 0; i < satir; i++) {\n    dizi[i] = (int*)malloc(sutun * sizeof(int));\n}\n```\nBu kod, 3x4 boyutunda bir 2D dizi oluşturur. Kullanım sonrasında bellek serbest bırakılmalıdır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668974"
  },
  {
    "question": "Çok boyutlu dizilerde elemanları nasıl sıralayabilirim?",
    "answer": "Çok boyutlu dizilerde sıralama genellikle belirli bir boyutta elemanları içeren bir dizi için yapılır. Örneğin, bir 2D dizide her satırı ayrı ayrı sıralamak istiyorsanız:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid satirSiralama(int dizi[3][4], int sutun) {\n    for(int i = 0; i < 3; i++) {\n        qsort(dizi[i], sutun, sizeof(int), cmpfunc);\n    }\n}\n\nint cmpfunc(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n```\nBu kod, her satır için 'qsort' fonksiyonunu kullanarak elemanları sıralar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.668993"
  },
  {
    "question": "Çok boyutlu dizilerde döngü ile nasıl verileri değiştirebilirim?",
    "answer": "Bir 2D dizideki tüm elemanları değiştirmek için iç içe döngüler kullanarak her bir elemana erişebilirsiniz. Örneğin, tüm elemanları 5 ile değiştirmek için:\n\n```c\nfor(int i = 0; i < 3; i++) {\n    for(int j = 0; j < 4; j++) {\n        dizi[i][j] = 5;\n    }\n}\n```\nBu döngü, 3x4 boyutundaki dizinin tüm elemanlarını 5 ile günceller.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.669014"
  },
  {
    "question": "Çok boyutlu diziler kullanarak bir oyun tahtası nasıl oluşturulabilir?",
    "answer": "Bir oyun tahtası oluşturmak için 2D bir dizi kullanılabilir. Örneğin, 3x3 boyutunda bir oyun tahtası için:\n\n```c\nchar tahta[3][3];\n\nvoid tahtaOlustur() {\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            tahta[i][j] = '-'; // Başlangıçta tüm hücreler boş\n        }\n    }\n}\n```\nBu kod, 3x3 boyutunda bir oyun tahtası oluşturur ve tüm hücreleri '-' ile doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.669036"
  },
  {
    "question": "Çok boyutlu dizilerde arama işlemi nasıl yapılır?",
    "answer": "Bir 2D dizide belirli bir değeri aramak için iç içe döngüler kullanılabilir. Aşağıda bir örnek verilmiştir:\n\n```c\nint arama(int dizi[3][4], int aranan) {\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 4; j++) {\n            if(dizi[i][j] == aranan) {\n                return 1; // Bulundu\n            }\n        }\n    }\n    return 0; // Bulunamadı\n}\n```\nBu fonksiyon, verilen 'aranan' değeri 2D dizide arayarak sonucu döner.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:52:24.669055"
  },
  {
    "question": "2 boyutlu bir dizi oluşturup, içinde 3x3'lük bir matris tanımlayın ve elemanlarını 1'den 9'a kadar doldurun.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int sayi = 1;\n\n    // Diziye değer atama\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            matris[i][j] = sayi++;\n        }\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu kod parçası, 3x3'lük bir matris oluşturur ve elemanlarını 1 ile 9 arasında doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538186"
  },
  {
    "question": "5x5 boyutunda bir matris tanımlayıp, bu matrisin köşegen elemanlarını 1, diğer elemanlarını 0 olarak ayarlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[5][5] = {0};\n\n    // Köşegen elemanlarını 1 yapma\n    for (int i = 0; i < 5; i++) {\n        matris[i][i] = 1;\n    }\n\n    // Matris elemanlarını yazdırma\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 5x5 boyutunda bir matrisin köşegen elemanlarını 1, diğerlerini 0 yapmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538241"
  },
  {
    "question": "Bir 2D dizi kullanarak, kullanıcıdan 4x4'lük bir matris girmesini isteyin ve ardından matrisin transpozesini hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[4][4];\n    int transpoz[4][4];\n\n    // Kullanıcıdan matris girişi alma\n    printf(\"4x4'lük matris giriniz:\\n\");\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Transpoze hesaplama\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            transpoz[j][i] = matris[i][j];\n        }\n    }\n\n    // Transpoze matris yazdırma\n    printf(\"Transpoze matris:\\n\");\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", transpoz[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir 4x4'lük matris alır ve transpozesini hesaplayarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538275"
  },
  {
    "question": "3 boyutlu bir dizi oluşturup, bu diziyi 1 ile 27 arasındaki sayılarla doldurun ve elemanlarını yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int dizi[3][3][3];\n    int sayi = 1;\n\n    // Diziye değer atama\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                dizi[i][j][k] = sayi++;\n            }\n        }\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                printf(\"%d \", dizi[i][j][k]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 3 boyutlu bir dizi oluşturur ve 1 ile 27 arasındaki sayılarla doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538306"
  },
  {
    "question": "Bir 2D dizi kullanarak, kullanıcıdan 3x3'lük bir matris alıp, matrisin toplamını hesaplayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int toplam = 0;\n\n    // Kullanıcıdan matris girişi alma\n    printf(\"3x3'lük matris giriniz:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &matris[i][j]);\n            toplam += matris[i][j];  // Elemanı toplam değişkenine ekle\n        }\n    }\n\n    // Toplamı yazdırma\n    printf(\"Matrisin toplamı: %d\\n\", toplam);\n    return 0;\n}\n\n// Bu program, kullanıcıdan 3x3'lük bir matris alır ve tüm elemanlarının toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538338"
  },
  {
    "question": "Bir 2D dizideki en büyük sayıyı bulan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[4][4];\n    int enBuyuk;\n\n    // Kullanıcıdan matris girişi alma\n    printf(\"4x4'lük matris giriniz:\\n\");\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // En büyük sayıyı bulma\n    enBuyuk = matris[0][0];\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (matris[i][j] > enBuyuk) {\n                enBuyuk = matris[i][j];\n            }\n        }\n    }\n\n    // Sonucu yazdırma\n    printf(\"Matristeki en büyük sayı: %d\\n\", enBuyuk);\n    return 0;\n}\n\n// Bu program, kullanıcıdan alınan 4x4'lük bir matrisin en büyük elemanını bulur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538361"
  },
  {
    "question": "Bir 2D dizideki belirli bir satırı yazdıran bir program yazın. Kullanıcıdan hangi satırı yazdırmak istediğini isteyin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int satir;\n\n    // Kullanıcıdan matris girişi alma\n    printf(\"3x3'lük matris giriniz:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n\n    // Kullanıcıdan yazdırılacak satır\n    printf(\"Hangi satırı yazdırmak istersiniz (0-2): \");\n    scanf(\"%d\", &satir);\n\n    // Seçilen satırı yazdırma\n    printf(\"Seçilen satır: \");\n    for (int j = 0; j < 3; j++) {\n        printf(\"%d \", matris[satir][j]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu program, kullanıcının belirttiği bir satırı 3x3'lük matristen yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538392"
  },
  {
    "question": "Bir 2D dizideki tüm sütunların toplamını hesaplayan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    int toplam[3] = {0};\n\n    // Kullanıcıdan matris girişi alma\n    printf(\"3x3'lük matris giriniz:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &matris[i][j]);\n            toplam[j] += matris[i][j];  // Sütun toplamını güncelle\n        }\n    }\n\n    // Sütun toplamlarını yazdırma\n    for (int j = 0; j < 3; j++) {\n        printf(\"Sütun %d toplamı: %d\\n\", j, toplam[j]);\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan 3x3'lük bir matrisin her bir sütunun toplamını hesaplar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:53:12.538416"
  },
  {
    "question": "2 boyutlu bir dizideki tüm elemanları toplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, 2 boyutlu bir dizideki tüm elemanları toplayan bir fonksiyon içermektedir:\n\n```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 4\n\nint toplamElemanlar(int dizi[ROWS][COLS]) {\n    int toplam = 0;\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            toplam += dizi[i][j];\n        }\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n    int toplam = toplamElemanlar(dizi);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kodda, `toplamElemanlar` fonksiyonu iki boyutlu dizinin tüm elemanlarını toplayarak toplamı döndürüyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931171"
  },
  {
    "question": "NxM boyutunda bir matrisin transpozunu (satır ve sütunlarının yer değiştirmesi) hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, NxM boyutunda bir matrisin transpozunu hesaplayarak ekrana yazdırmaktadır:\n\n```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 2\n\nvoid transpozeMatris(int matris[ROWS][COLS], int transpoze[COLS][ROWS]) {\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            transpoze[j][i] = matris[i][j];\n        }\n    }\n}\n\nvoid yazdirMatris(int matris[COLS][ROWS]) {\n    for(int i = 0; i < COLS; i++) {\n        for(int j = 0; j < ROWS; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int matris[ROWS][COLS] = {{1, 2}, {3, 4}, {5, 6}};\n    int transpoze[COLS][ROWS];\n    transpozeMatris(matris, transpoze);\n    yazdirMatris(transpoze);\n    return 0;\n}\n```\nBu kodda, `transpozeMatris` fonksiyonu matrisin transpozunu hesaplayarak `transpoze` dizisine kaydediyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931220"
  },
  {
    "question": "3 boyutlu bir dizide belirli bir eleman değerinin kaç kez geçtiğini bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, 3 boyutlu bir dizide belirli bir eleman değerinin kaç kez geçtiğini bulmaktadır:\n\n```c\n#include <stdio.h>\n\n#define DEPTH 3\n#define ROWS 3\n#define COLS 3\n\nint elemanSay(int dizi[DEPTH][ROWS][COLS], int aranan) {\n    int sayac = 0;\n    for(int i = 0; i < DEPTH; i++) {\n        for(int j = 0; j < ROWS; j++) {\n            for(int k = 0; k < COLS; k++) {\n                if(dizi[i][j][k] == aranan) {\n                    sayac++;\n                }\n            }\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int dizi[DEPTH][ROWS][COLS] = {{{1, 2, 3}, {4, 5, 6}, {7, 1, 9}}, {{10, 1, 12}, {13, 14, 15}, {16, 17, 18}}, {{19, 20, 1}, {22, 23, 24}, {25, 26, 27}}};\n    int sayi = 1;\n    int sonuc = elemanSay(dizi, sayi);\n    printf(\"%d sayısı %d kez bulundu.\\n\", sayi, sonuc);\n    return 0;\n}\n```\nBu kodda, `elemanSay` fonksiyonu aranan elemanın dizinin içinde kaç kez geçtiğini döndürmektedir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931251"
  },
  {
    "question": "Bir sınıfın notlarını temsil eden 2 boyutlu bir dizi oluşturun ve en yüksek notu bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, bir sınıfın notlarını temsil eden 2 boyutlu bir dizideki en yüksek notu bulmaktadır:\n\n```c\n#include <stdio.h>\n\n#define STUDENTS 5\n#define SUBJECTS 3\n\nint enYuksekNot(int notlar[STUDENTS][SUBJECTS]) {\n    int enYuksek = notlar[0][0];\n    for(int i = 0; i < STUDENTS; i++) {\n        for(int j = 0; j < SUBJECTS; j++) {\n            if(notlar[i][j] > enYuksek) {\n                enYuksek = notlar[i][j];\n            }\n        }\n    }\n    return enYuksek;\n}\n\nint main() {\n    int notlar[STUDENTS][SUBJECTS] = {{85, 90, 78}, {92, 88, 95}, {75, 80, 83}, {88, 88, 90}, {100, 95, 99}};\n    int sonuc = enYuksekNot(notlar);\n    printf(\"En yüksek not: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kodda, `enYuksekNot` fonksiyonu notlar dizisindeki en yüksek notu buluyor ve döndürüyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931283"
  },
  {
    "question": "Kullanıcının girdiği değerlerden oluşan 2 boyutlu bir dizi oluşturun ve diziyi ekrana yazdırın.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan alınan değerlerden oluşan 2 boyutlu bir diziyi ekrana yazdırmaktadır:\n\n```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 3\n\nint main() {\n    int dizi[ROWS][COLS];\n    printf(\"Dizinin elemanlarını girin:\\n\");\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            printf(\"[%d][%d]: \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n\n    printf(\"Dizi:\\n\");\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nBu kodda kullanıcıdan alınan elemanlar ile 2 boyutlu dizi oluşturulmakta ve ardından dizinin elemanları ekrana yazdırılmaktadır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931310"
  },
  {
    "question": "Bir 2 boyutlu dizideki en küçük sayıyı bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki C kodu, bir 2 boyutlu dizideki en küçük sayıyı bulmaktadır:\n\n```c\n#include <stdio.h>\n\n#define ROWS 4\n#define COLS 4\n\nint enKucukSayi(int dizi[ROWS][COLS]) {\n    int enKucuk = dizi[0][0];\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            if(dizi[i][j] < enKucuk) {\n                enKucuk = dizi[i][j];\n            }\n        }\n    }\n    return enKucuk;\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{5, 2, 9, 1}, {3, 7, 8, 6}, {4, 10, 12, 11}, {15, 14, 13, 0}};\n    int sonuc = enKucukSayi(dizi);\n    printf(\"En küçük sayı: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kodda, `enKucukSayi` fonksiyonu dizideki en küçük sayıyı bulmakta ve bunu döndürmektedir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931335"
  },
  {
    "question": "Bir 2 boyutlu dizideki her bir elemanın karesini alan bir fonksiyon yazın ve sonucu ekrana yazdırın.",
    "answer": "Aşağıdaki C kodu, bir 2 boyutlu dizinin her bir elemanının karesini alarak yeni bir dizide saklamakta ve ekrana yazdırmaktadır:\n\n```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 3\n\nvoid kareleriAl(int dizi[ROWS][COLS], int kareler[ROWS][COLS]) {\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            kareler[i][j] = dizi[i][j] * dizi[i][j];\n        }\n    }\n}\n\nvoid yazdirDizi(int kareler[ROWS][COLS]) {\n    for(int i = 0; i < ROWS; i++) {\n        for(int j = 0; j < COLS; j++) {\n            printf(\"%d \", kareler[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int kareler[ROWS][COLS];\n    kareleriAl(dizi, kareler);\n    printf(\"Kareler:\\n\");\n    yazdirDizi(kareler);\n    return 0;\n}\n```\nBu kodda, `kareleriAl` fonksiyonu dizinin her elemanının karesini alarak yeni bir diziye kaydediyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931364"
  },
  {
    "question": "Bir 2 boyutlu dizinin her satırının toplamını bulan bir fonksiyon yazın ve sonuçları ekrana yazdırın.",
    "answer": "Aşağıdaki C kodu, 2 boyutlu dizinin her bir satırının toplamını bulmakta ve sonuçları ekrana yazdırmaktadır:\n\n```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 4\n\nvoid satirToplamlari(int dizi[ROWS][COLS], int toplamlar[ROWS]) {\n    for(int i = 0; i < ROWS; i++) {\n        toplamlar[i] = 0;\n        for(int j = 0; j < COLS; j++) {\n            toplamlar[i] += dizi[i][j];\n        }\n    }\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n    int toplamlar[ROWS];\n    satirToplamlari(dizi, toplamlar);\n    printf(\"Satır toplamları:\\n\");\n    for(int i = 0; i < ROWS; i++) {\n        printf(\"Satır %d: %d\\n\", i + 1, toplamlar[i]);\n    }\n    return 0;\n}\n```\nBu kodda, `satirToplamlari` fonksiyonu her satırın toplamını hesaplayarak `toplamlar` dizisine kaydediyor ve ardından bu sonuçları ekrana yazdırıyor.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:54:07.931393"
  },
  {
    "question": "İki boyutlu bir dizi oluşturun ve bu diziyi başlangıçta 0 değerleri ile doldurun. Ardından, bu dizinin her elemanına satır ve sütun indekslerini kullanarak değer atayın.",
    "answer": "Aşağıdaki kod, 3x3 boyutunda bir iki boyutlu dizi oluşturur ve her elemanı, satır ve sütun indekslerinin toplamı ile doldurur:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[3][3]; // İki boyutlu dizi tanımı\n    \n    // Dizi elemanlarını doldurma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            dizi[i][j] = i + j;\n        }\n    }\n    \n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138095"
  },
  {
    "question": "Dinamik bir iki boyutlu dizi oluşturun ve kullanıcıdan satır ve sütun sayısını alarak diziyi bu değerlere göre oluşturun.",
    "answer": "Aşağıdaki kod, kullanıcıdan satır ve sütun sayısını alarak dinamik bellek kullanarak iki boyutlu bir dizi oluşturur:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int satir, sutun;\n    printf(\"Satir sayisini giriniz: \");\n    scanf(\"%d\", &satir);\n    printf(\"Sutun sayisini giriniz: \");\n    scanf(\"%d\", &sutun);\n\n    int **dizi = (int **)malloc(satir * sizeof(int *));\n    for (int i = 0; i < satir; i++) {\n        dizi[i] = (int *)malloc(sutun * sizeof(int));\n    }\n\n    // Dizi elemanlarını doldurma\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            dizi[i][j] = i * sutun + j;\n        }\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < satir; i++) {\n        free(dizi[i]);\n    }\n    free(dizi);\n\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138146"
  },
  {
    "question": "3 boyutlu bir dizi oluşturun ve bu dizinin her elemanını, 3 boyutun çarpımı ile doldurun. Dizi elemanlarını yazdırın.",
    "answer": "Aşağıdaki kod, 2x2x2 boyutunda bir üç boyutlu dizi oluşturur ve her elemanı, üç boyutun çarpımı ile doldurur:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[2][2][2]; // Üç boyutlu dizi tanımı\n    \n    // Dizi elemanlarını doldurma\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                dizi[i][j][k] = i * j * k;\n            }\n        }\n    }\n    \n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                printf(\"%d \", dizi[i][j][k]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138188"
  },
  {
    "question": "Bir 4x4 matrisin transpozunu hesaplayacak bir program yazın ve sonucu yazdırın.",
    "answer": "Aşağıdaki kod, 4x4 boyutunda bir matrisin transpozunu alır ve yazdırır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matris[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int transpoze[4][4];\n    \n    // Transpozunu hesaplama\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            transpoze[j][i] = matris[i][j];\n        }\n    }\n    \n    // Transpoze matrisini yazdırma\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", transpoze[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138215"
  },
  {
    "question": "Bir okulun öğrencilerinin notlarını tutan 10x5 boyutunda bir iki boyutlu dizi oluşturun ve her öğrencinin notlarını random olarak atayın. Ardından öğrencilerin ortalama notlarını hesaplayın.",
    "answer": "Aşağıdaki kod, 10 öğrencinin 5 dersten aldığı notları tutan bir iki boyutlu dizi oluşturur ve her öğrencinin not ortalamasını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    int notlar[10][5];\n    double ortalama[10];\n    srand(time(NULL));\n    \n    // Notları random olarak doldurma\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 5; j++) {\n            notlar[i][j] = rand() % 101; // 0-100 arası notlar\n        }\n    }\n    \n    // Ortalama hesaplama\n    for (int i = 0; i < 10; i++) {\n        double toplam = 0;\n        for (int j = 0; j < 5; j++) {\n            toplam += notlar[i][j];\n        }\n        ortalama[i] = toplam / 5;\n    }\n    \n    // Notları ve ortalamaları yazdırma\n    for (int i = 0; i < 10; i++) {\n        printf(\"Ogrenci %d: \", i + 1);\n        for (int j = 0; j < 5; j++) {\n            printf(\"%d \", notlar[i][j]);\n        }\n        printf(\"- Ortalama: %.2f\\n\", ortalama[i]);\n    }\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138267"
  },
  {
    "question": "Kullanıcının girdiği bir 3x3 matrisin determinantını hesaplayacak bir program yazın.",
    "answer": "Aşağıdaki kod, 3x3 boyutunda bir matrisin determinantını hesaplar:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matris[3][3];\n    printf(\"3x3 matrisini giriniz:\\n\");\n    \n    // Matris elemanlarını alma\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    \n    // Determinant hesaplama\n    int determinant = matris[0][0] * (matris[1][1] * matris[2][2] - matris[1][2] * matris[2][1]) - \n                      matris[0][1] * (matris[1][0] * matris[2][2] - matris[1][2] * matris[2][0]) + \n                      matris[0][2] * (matris[1][0] * matris[2][1] - matris[1][1] * matris[2][0]);\n    \n    printf(\"Determinant: %d\\n\", determinant);\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138293"
  },
  {
    "question": "Bir çok boyutlu dizideki elemanları bir dosyadan okuyacak ve ardından bu elemanları büyükten küçüğe sıralayacak bir program yazın. Dizi boyutunu kullanıcı girmelidir.",
    "answer": "Aşağıdaki kod, kullanıcının belirttiği boyutta bir diziyi dosyadan okur ve büyükten küçüğe sıralar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Sıralama fonksiyonu\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[i] < dizi[j]) {\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu giriniz: \");\n    scanf(\"%d\", &boyut);\n    int *dizi = malloc(boyut * sizeof(int));\n\n    // Dosyadan okuma\n    FILE *file = fopen(\"dizi.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya acilamadi!\\n\");\n        return 1;\n    }\n    for (int i = 0; i < boyut; i++) {\n        fscanf(file, \"%d\", &dizi[i]);\n    }\n    fclose(file);\n\n    // Sıralama\n    sirala(dizi, boyut);\n\n    // Büyükten küçüğe yazdırma\n    printf(\"Sıralı dizi:\\n\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n\n    free(dizi);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138334"
  },
  {
    "question": "Bir 4x4 matrisin köşegenindeki elemanların toplamını hesaplayacak bir program yazın.",
    "answer": "Aşağıdaki kod, 4x4 boyutundaki bir matrisin ana köşegenindeki elemanların toplamını hesaplar ve yazdırır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int matris[4][4];\n    int toplam = 0;\n    printf(\"4x4 matrisini giriniz:\\n\");\n    \n    // Matris elemanlarını alma\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    \n    // Ana köşegen elemanlarını toplama\n    for (int i = 0; i < 4; i++) {\n        toplam += matris[i][i];\n    }\n    \n    printf(\"Ana köşegen toplamı: %d\\n\", toplam);\n    \n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:55:08.138358"
  },
  {
    "question": "Çok boyutlu dizilerle basit bir matris çarpımı nasıl yapılır? Kod örneğiyle gösterin.",
    "answer": "Aşağıda iki matrisin çarpımını gerçekleştiren bir C kodu bulunmaktadır:\n\n```c\n#include <stdio.h>\n#define MAX 10\n\nvoid matrisCarp(int a[MAX][MAX], int b[MAX][MAX], int c[MAX][MAX], int satir1, int sutun1, int sutun2) {\n    for (int i = 0; i < satir1; i++) {\n        for (int j = 0; j < sutun2; j++) {\n            c[i][j] = 0;\n            for (int k = 0; k < sutun1; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int a[MAX][MAX] = {{1, 2}, {3, 4}};\n    int b[MAX][MAX] = {{5, 6}, {7, 8}};\n    int c[MAX][MAX];\n    matrisCarp(a, b, c, 2, 2, 2);\n    // Sonuç matrisini yazdırma\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"%d \", c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, iki matrisin çarpımı yapılıyor. Ancak, sabit değerler kullanmak yerine dinamik bellek yönetimi kullanarak daha büyük matrisler için genel bir çözüm sağlanabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119258"
  },
  {
    "question": "Çok boyutlu dizilerde bellekte yer tutma optimizasyonu nasıl yapılır?",
    "answer": "Çok boyutlu diziler genellikle bellekte bitişik alanlar kaplamak için kullanılır. Ancak, büyük matrislerde yer kullanımını optimize etmek için dinamik bellek tahsisi yapılabilir. Örneğin:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint** matrisOlustur(int satir, int sutun) {\n    int** matris = (int**)malloc(satir * sizeof(int*));\n    for (int i = 0; i < satir; i++) {\n        matris[i] = (int*)malloc(sutun * sizeof(int));\n    }\n    return matris;\n}\n\nvoid matrisSerbestBırak(int** matris, int satir) {\n    for (int i = 0; i < satir; i++) {\n        free(matris[i]);\n    }\n    free(matris);\n}\n\nint main() {\n    int satir = 5, sutun = 5;\n    int** matris = matrisOlustur(satir, sutun);\n    // Matris işlemleri\n    matrisSerbestBırak(matris, satir);\n    return 0;\n}\n```\nBu yöntemle, bellekte gereksiz yer kullanımı önlenir ve esneklik sağlanır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119311"
  },
  {
    "question": "Çok boyutlu dizilerde elemanlara erişim nasıl optimize edilir?",
    "answer": "Çok boyutlu dizilerde elemanlara erişim sıklıkla döngülerle yapılır. Performansı artırmak için, veri erişim sıklığını ve bellek erişim düzenini optimize etmek önemlidir. Bir örnek:\n\n```c\n#include <stdio.h>\n#define SIZE 1000\n\nvoid elemanErisimi(int dizi[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            dizi[i][j] = i + j; // 'dizi[i][j]' erişimi\n        }\n    }\n}\n\nint main() {\n    int dizi[SIZE][SIZE];\n    elemanErisimi(dizi);\n    return 0;\n}\n```\nBurada, elemanlara erişim sırayla yapılır. Ancak, 'dizi[j][i]' biçiminde erişim yapıldığında, bellek yerleşimi nedeniyle performans düşebilir. Bu yüzden, daima satır bazlı erişim tercih edilmelidir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119335"
  },
  {
    "question": "Çok boyutlu dizilerle veri saklama ve sıralama nasıl yapılır?",
    "answer": "Aşağıda, bir çok boyutlu dizide veri saklama ve içindeki verileri sıralama işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#define ROWS 3\n#define COLS 3\n\nvoid sirala(int dizi[ROWS][COLS]) {\n    int temp;\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS - 1; j++) {\n            for (int k = j + 1; k < COLS; k++) {\n                if (dizi[i][j] > dizi[i][k]) {\n                    temp = dizi[i][j];\n                    dizi[i][j] = dizi[i][k];\n                    dizi[i][k] = temp;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{3, 1, 2}, {9, 8, 7}, {6, 5, 4}};\n    sirala(dizi);\n    // Sıralı diziyi yazdırma\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nBu basit sıralama algoritması, her satırda verileri sıralar. Ancak, daha büyük dizilerde daha etkili sıralama algoritmaları kullanmak (örneğin, quicksort) daha uygun olabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119356"
  },
  {
    "question": "Çok boyutlu dizilerde veri girişi nasıl daha etkili hale getirilir?",
    "answer": "Aşağıda kullanıcıdan çok boyutlu bir dizinin elemanlarını almanın basit bir örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#define ROWS 3\n#define COLS 3\n\nvoid veriGirişi(int dizi[ROWS][COLS]) {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"Dizi[%d][%d] = \", i, j);\n            scanf(\"%d\", &dizi[i][j]);\n        }\n    }\n}\n\nint main() {\n    int dizi[ROWS][COLS];\n    veriGirişi(dizi);\n    return 0;\n}\n```\nBu kod, kullanıcıdan dizi elemanlarını alır. Ancak, kontrol eklenerek (örn. geçerli bir sayı girilmesi) daha sağlam bir çözüm oluşturulabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119380"
  },
  {
    "question": "Çok boyutlu dizilerde sınır kontrolü nasıl yapılır?",
    "answer": "Dizi elemanlarına erişirken sınır kontrolü yapmak kritik öneme sahiptir. Aşağıda, bir dizinin elemanlarına erişim sırasında sınır kontrolü yapan bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#define ROWS 3\n#define COLS 3\n\nvoid elemanYazdır(int dizi[ROWS][COLS], int satir, int sutun) {\n    if (satir >= 0 && satir < ROWS && sutun >= 0 && sutun < COLS) {\n        printf(\"Dizi[%d][%d] = %d\\n\", satir, sutun, dizi[satir][sutun]);\n    } else {\n        printf(\"Hatalı dizi indeksi!\\n\");\n    }\n}\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    elemanYazdır(dizi, 1, 1); // Geçerli erişim\n    elemanYazdır(dizi, 3, 3); // Hatalı erişim\n    return 0;\n}\n```\nBu durumda, dizi sınırları aşılmaya çalışıldığında bir hata mesajı verilecektir. Bu, programın güvenliğini artırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119400"
  },
  {
    "question": "Çok boyutlu dizilerle çalışırken bellek sızıntılarını nasıl önleyebiliriz?",
    "answer": "Dinamik bellek kullanırken bellek sızıntılarını önlemek için, tahsis edilen her bellek alanının serbest bırakılması önemlidir. Aşağıda bu durumu gösteren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int satir = 5, sutun = 5;\n    int** matris = (int**)malloc(satir * sizeof(int*));\n    for (int i = 0; i < satir; i++) {\n        matris[i] = (int*)malloc(sutun * sizeof(int));\n    }\n    // Bellek işlemleri\n    for (int i = 0; i < satir; i++) {\n        free(matris[i]);\n    }\n    free(matris); // Tüm bellek serbest bırakılıyor.\n    return 0;\n}\n```\nHer malloc çağrısına karşılık bir free çağrısı yapılır. Bu, bellek sızıntılarını önlemenin temel yoludur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119423"
  },
  {
    "question": "Çok boyutlu dizilerde initialize etme işlemi nasıl yapılır?",
    "answer": "Çok boyutlu dizileri initialize etmek için aşağıdaki gibi bir yöntem kullanılabilir:\n\n```c\n#include <stdio.h>\n#define ROWS 3\n#define COLS 3\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nBu yöntem, dizinin başlangıç değerlerini belirlemek için kullanılır. Ayrıca, kullanılan sabit değerlerin bir yapı ile değiştirilmesi, daha esnek bir kod yapısı sağlar.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119444"
  },
  {
    "question": "Çok boyutlu dizilerde döngü içinde koşullar nasıl daha etkili hale getirilebilir?",
    "answer": "Çok boyutlu dizilerle çalışırken koşul kontrollerinin döngü içinde etkili bir şekilde yapılması önemlidir. Aşağıda, bu durumu gösteren bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#define ROWS 5\n#define COLS 5\n\nint main() {\n    int dizi[ROWS][COLS] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25}};\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            if (dizi[i][j] % 2 == 0) {\n                printf(\"%d is even\\n\", dizi[i][j]);\n            } else {\n                printf(\"%d is odd\\n\", dizi[i][j]);\n            }\n        }\n    }\n    return 0;\n}\n```\nBu örnekte her bir elemanın tek veya çift olup olmadığını kontrol ederiz. Ancak, koşulların sayısını azaltmak ve daha az işlem yapmak için farklı bir yaklaşım (örneğin, bir filtreleme algoritması) kullanılabilir.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:56:14.119469"
  },
  {
    "question": "Bir 2D dizi oluşturup, bu dizideki her elemanı sırayla 1'den başlayarak atamak istiyorum. Ancak diziyi kullanıcıdan alacağım boyutlara göre dinamik olarak oluşturmalıyım. Bu kodu nasıl yazabilirim?",
    "answer": "2D diziyi dinamik olarak oluşturmak için, öncelikle bir pointer dizisi oluşturmanız gerekiyor. Kullanıcıdan satır ve sütun sayısını aldıktan sonra, her satır için bir dizi oluşturup atama yapabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows, cols;\n    printf(\"Satır sayısını girin: \");\n    scanf(\"%d\", &rows);\n    printf(\"Sütun sayısını girin: \");\n    scanf(\"%d\", &cols);\n\n    int **array = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        array[i] = malloc(cols * sizeof(int));\n    }\n\n    int count = 1;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            array[i][j] = count++;\n        }\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", array[i][j]);\n        }\n        printf('\\n');\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < rows; i++) {\n        free(array[i]);\n    }\n    free(array);\n\n    return 0;\n}\n```\nBu kod, kullanıcıdan alacağı satır ve sütun sayısına göre 2D dizi oluşturur ve her elemanı 1'den başlayarak doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262547"
  },
  {
    "question": "3D bir dizi oluşturup, bu dizinin her elemanını rastgele sayılarla doldurmak istiyorum. Bunun için en iyi yaklaşım nedir?",
    "answer": "3D diziyi dinamik olarak oluşturmak için 2D diziler dizisi kullanabilirsiniz. Her bir 2D diziyi rastgele sayılarla doldurmak için 'rand' fonksiyonunu kullanabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    int x, y, z;\n    printf(\"X boyutunu girin: \");\n    scanf(\"%d\", &x);\n    printf(\"Y boyutunu girin: \");\n    scanf(\"%d\", &y);\n    printf(\"Z boyutunu girin: \");\n    scanf(\"%d\", &z);\n\n    int ***array = malloc(x * sizeof(int **));\n    for (int i = 0; i < x; i++) {\n        array[i] = malloc(y * sizeof(int *));\n        for (int j = 0; j < y; j++) {\n            array[i][j] = malloc(z * sizeof(int));\n        }\n    }\n\n    srand(time(NULL));\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            for (int k = 0; k < z; k++) {\n                array[i][j][k] = rand() % 100; // 0-99 arasında rastgele sayı\n            }\n        }\n    }\n\n    // Diziyi yazdırma\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            for (int k = 0; k < z; k++) {\n                printf(\"%d \", array[i][j][k]);\n            }\n            printf('\\n');\n        }\n        printf(\"\\n\");\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            free(array[i][j]);\n        }\n        free(array[i]);\n    }\n    free(array);\n\n    return 0;\n}\n```\nBu kod, 3D dizi oluşturur ve her elemanını 0 ile 99 arasında rastgele sayılarla doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262629"
  },
  {
    "question": "Bir 2D diziyi döndürmek istiyorum. Yani, dizinin satırlarını ve sütunlarını yer değiştirmeliyim. Bunu nasıl yapabilirim?",
    "answer": "2D dizinin döndürülmesi, satır ve sütunların yer değiştirilmesi anlamına gelir. Bunu yapabilmek için, yeni bir 2D dizi oluşturup, eski dizinin elemanlarını yeni dizide uygun pozisyona atayabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid rotateMatrix(int **matrix, int rows, int cols) {\n    int **rotated = malloc(cols * sizeof(int *));\n    for (int i = 0; i < cols; i++) {\n        rotated[i] = malloc(rows * sizeof(int));\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            rotated[j][i] = matrix[i][j];\n        }\n    }\n\n    // Eski diziyi temizleme\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    // Yeni diziyi yazdırma\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            printf(\"%d \", rotated[i][j]);\n        }\n        printf('\\n');\n    }\n\n    // Yeni diziyi temizleme\n    for (int i = 0; i < cols; i++) {\n        free(rotated[i]);\n    }\n    free(rotated);\n}\n\nint main() {\n    int rows = 2, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = i * cols + j + 1;\n        }\n    }\n\n    rotateMatrix(matrix, rows, cols);\n\n    return 0;\n}\n```\nBu kod, verilen 2D diziyi döndürerek yeni bir dizi oluşturur ve yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262699"
  },
  {
    "question": "Dördüncü boyutlu bir dizi oluşturmak istiyorum. Bunun için nasıl bir yapı kullanmalıyım ve örnek bir kod verebilir misin?",
    "answer": "Dördüncü boyutlu bir dizi, 3D dizilerin dizisi (yani bir 3D dizi içinde başka diziler) şeklinde oluşturulabilir. Bu yapıyı oluşturmak için benzer bir yöntemle ilerleyebilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int w, x, y, z;\n    printf(\"W boyutunu girin: \");\n    scanf(\"%d\", &w);\n    printf(\"X boyutunu girin: \");\n    scanf(\"%d\", &x);\n    printf(\"Y boyutunu girin: \");\n    scanf(\"%d\", &y);\n    printf(\"Z boyutunu girin: \");\n    scanf(\"%d\", &z);\n\n    int ****array = malloc(w * sizeof(int ***));\n    for (int i = 0; i < w; i++) {\n        array[i] = malloc(x * sizeof(int **));\n        for (int j = 0; j < x; j++) {\n            array[i][j] = malloc(y * sizeof(int *));\n            for (int k = 0; k < y; k++) {\n                array[i][j][k] = malloc(z * sizeof(int));\n            }\n        }\n    }\n\n    int count = 1;\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < x; j++) {\n            for (int k = 0; k < y; k++) {\n                for (int l = 0; l < z; l++) {\n                    array[i][j][k][l] = count++;\n                }\n            }\n        }\n    }\n\n    // Diziyi yazdırma\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < x; j++) {\n            for (int k = 0; k < y; k++) {\n                for (int l = 0; l < z; l++) {\n                    printf(\"%d \", array[i][j][k][l]);\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < x; j++) {\n            for (int k = 0; k < y; k++) {\n                free(array[i][j][k]);\n            }\n            free(array[i][j]);\n        }\n        free(array[i]);\n    }\n    free(array);\n\n    return 0;\n}\n```\nBu kod, dördüncü boyutlu bir dizi oluşturur ve her elemanını 1'den başlayarak doldurur.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262760"
  },
  {
    "question": "Bir 2D dizinin belirli bir satırını veya sütununu silmek istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Bir 2D diziden bir satır silmek için, silmek istediğiniz satırın diziden çıkartılması ve dizinin geri kalanının uygun şekilde kaydırılması gerekir. Bunun için yeni bir dizi oluşturabilir ve silinen satır hariç tüm elemanları taşıyabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = i * cols + j + 1;\n        }\n    }\n\n    int rowToDelete = 1; // Silinecek satır\n\n    int **newMatrix = malloc((rows - 1) * sizeof(int *));\n    for (int i = 0, new_i = 0; i < rows; i++) {\n        if (i != rowToDelete) {\n            newMatrix[new_i++] = matrix[i];\n        }\n    }\n    // İlk dizinin belleğini temizleme\n    free(matrix);\n\n    // Yeni diziyi yazdırma\n    for (int i = 0; i < rows - 1; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", newMatrix[i][j]);\n        }\n        printf('\\n');\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < rows - 1; i++) {\n        free(newMatrix[i]);\n    }\n    free(newMatrix);\n    return 0;\n}\n```\nBu kod, belirli bir satırı silerek yeni bir dizi oluşturur ve geriye kalan elemanları yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262810"
  },
  {
    "question": "Bir 2D dizideki elemanların toplamını hesaplamak istiyorum. En iyi yöntem nedir?",
    "answer": "2D dizideki elemanların toplamını hesaplamak için basit bir döngü kullanabilirsiniz. Tüm satır ve sütunlar üzerinde döngü kurarak her elemanı toplayabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = (i + 1) * (j + 1); // Dizi elemanlarını doldurma\n        }\n    }\n\n    int sum = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            sum += matrix[i][j];\n        }\n    }\n\n    printf(\"Toplam: %d\\n\", sum);\n\n    // Belleği temizleme\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\n```\nBu kod, 2D dizideki tüm elemanların toplamını hesaplar ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262856"
  },
  {
    "question": "Bir 2D dizinin transpozesini almak istiyorum. Kodda nasıl bir optimizasyon yapabilirim?",
    "answer": "2D dizinin transpozesini almak için, mevcut dizinin boyutunu ve yapısını kullanarak yeni bir dizi oluşturmalısınız. Ancak, mevcut diziyi değiştirmeden direkt olarak transpoze alarak orijinal diziyi koruyabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid transpose(int **matrix, int rows, int cols) {\n    int **transposed = malloc(cols * sizeof(int *));\n    for (int i = 0; i < cols; i++) {\n        transposed[i] = malloc(rows * sizeof(int));\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    // Yeni diziyi yazdırma\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            printf(\"%d \", transposed[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < cols; i++) {\n        free(transposed[i]);\n    }\n    free(transposed);\n}\n\nint main() {\n    int rows = 2, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = (i + 1) * (j + 1);\n        }\n    }\n\n    transpose(matrix, rows, cols);\n\n    // Belleği temizleme\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\n```\nBu kod, 2D dizi transpozunu alır ve yeni bir dizi oluşturarak sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262902"
  },
  {
    "question": "Bir 2D dizide belirli bir elemanın varlığını kontrol etmek istiyorum. En iyi yöntem nedir?",
    "answer": "Bir 2D dizide belirli bir elemanın varlığını kontrol etmek için döngüler aracılığıyla her bir elemanı kontrol edebilirsiniz. Eğer eleman bulunursa, döngüyü kırabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = (i + 1) * (j + 1);\n        }\n    }\n\n    int target = 5; // Kontrol edilecek eleman\n    int found = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == target) {\n                found = 1;\n                break;\n            }\n        }\n        if (found) break;\n    }\n\n    if (found) {\n        printf(\"Eleman bulundu!\\n\");\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n\n    // Belleği temizleme\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\n```\nBu kod, belirli bir elemanın 2D dizide var olup olmadığını kontrol eder ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "arrays_2d",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Çok boyutlu diziler",
    "timestamp": "2025-06-01T14:57:28.262951"
  },
  {
    "question": "Kullanıcının girdiği bir ismin uzunluğunu bulan bir C programının eksik kısmını tamamla: #include <stdio.h> int main() { char name[100]; printf(\"Adınızı girin: \"); scanf(\"%s\", name); int length = ; printf(\"İsminizin uzunluğu: %d\", length); return 0; }",
    "answer": "Eksik kısım: 'strlen(name)'. Düzgün kod: 'int length = strlen(name);'. Bu fonksiyon, verilen stringin uzunluğunu döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.727495"
  },
  {
    "question": "Bir stringi büyük harflere çeviren C kodunun eksik kısmını tamamla: #include <stdio.h> #include <ctype.h> int main() { char str[100]; printf(\"Bir metin girin: \"); scanf(\"%s\", str); ; printf(\"Büyük harfli hali: %s\", str); return 0; }",
    "answer": "Eksik kısım: 'for (int i = 0; str[i] != '\\0'; i++) { str[i] = toupper(str[i]); }'. Bu döngü, her bir karakteri büyük harfe çevirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.727608"
  },
  {
    "question": "Kullanıcının girdiği bir stringin sonuna başka bir string ekleyen bir C programının eksik kısmını tamamla: #include <stdio.h> #include <string.h> int main() { char str1[100], str2[100]; printf(\"İlk metni girin: \"); scanf(\"%s\", str1); printf(\"İkinci metni girin: \"); scanf(\"%s\", str2); ; printf(\"Birleşik metin: %s\", str1); return 0; }",
    "answer": "Eksik kısım: 'strcat(str1, str2);'. Bu fonksiyon, str2'yi str1'in sonuna ekler.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.727757"
  },
  {
    "question": "Bir stringin kaç tane 'a' harfi içerdiğini bulan C programının eksik kısmını tamamla: #include <stdio.h> int main() { char str[100]; printf(\"Bir metin girin: \"); scanf(\"%s\", str); int count = 0; ; printf(\"'a' harfi sayısı: %d\", count); return 0; }",
    "answer": "Eksik kısım: 'for (int i = 0; str[i] != '\\0'; i++) { if (str[i] == 'a') count++; }'. Bu döngü, string içerisindeki 'a' karakterlerini sayar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.727851"
  },
  {
    "question": "Bir stringin tersini yazdıran C kodunun eksik kısmını tamamla: #include <stdio.h> #include <string.h> int main() { char str[100]; printf(\"Bir metin girin: \"); scanf(\"%s\", str); ; printf(\"Ters metin: %s\", str); return 0; }",
    "answer": "Eksik kısım: 'strrev(str);'. Bu fonksiyon, verilen stringi tersine çevirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.727934"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki kelime sayısını bulan C programının eksik kısmını tamamla: #include <stdio.h> #include <string.h> int main() { char str[100]; printf(\"Bir cümle girin: \"); fgets(str, sizeof(str), stdin); int count = 0; ; printf(\"Kelime sayısı: %d\", count); return 0; }",
    "answer": "Eksik kısım: 'char *token = strtok(str, \" \"); while (token != NULL) { count++; token = strtok(NULL, \" \"); }'. Bu döngü, cümledeki kelimeleri sayar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.728019"
  },
  {
    "question": "Bir stringin belirli bir indeksinden başlayarak alt string almak için eksik kısmı doldurun: #include <stdio.h> #include <string.h> int main() { char str[100]; printf(\"Bir metin girin: \"); scanf(\"%s\", str); char substring[50]; ; printf(\"Alt string: %s\", substring); return 0; }",
    "answer": "Eksik kısım: 'strncpy(substring, str + start_index, length);'. Bu fonksiyon, str'den belirtilen uzunlukta bir alt string alır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.728100"
  },
  {
    "question": "Kullanıcıdan alınan bir cümledeki boşlukları kaldıran bir C programının eksik kısmını tamamla: #include <stdio.h> int main() { char str[100]; printf(\"Bir cümle girin: \"); fgets(str, sizeof(str), stdin); ; printf(\"Boşluksuz cümle: %s\", str); return 0; }",
    "answer": "Eksik kısım: 'char result[100]; int j = 0; for (int i = 0; str[i] != '\\0'; i++) { if (str[i] != ' ') result[j++] = str[i]; } result[j] = '\\0';'. Bu döngü, boşlukları atlayarak yeni bir dizi oluşturur.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.728185"
  },
  {
    "question": "Bir stringin içinde bir karakterin ilk gördüğü indeksi bulan C programının eksik kısmını tamamla: #include <stdio.h> int main() { char str[100]; char ch; printf(\"Bir metin girin: \"); scanf(\"%s\", str); printf(\"Aranacak karakteri girin: \"); scanf(\" %c\", &ch); int index = ; printf(\"Karakterin indeksi: %d\", index); return 0; }",
    "answer": "Eksik kısım: 'for (int i = 0; str[i] != '\\0'; i++) { if (str[i] == ch) { index = i; break; } }'. Bu döngü, belirtilen karakterin ilk indeksini bulur.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.728282"
  },
  {
    "question": "Kullanıcının girdiği bir stringin tüm harflerini küçük harfe çeviren C programının eksik kısmını tamamla: #include <stdio.h> #include <ctype.h> int main() { char str[100]; printf(\"Bir metin girin: \"); scanf(\"%s\", str); ; printf(\"Küçük harfli hali: %s\", str); return 0; }",
    "answer": "Eksik kısım: 'for (int i = 0; str[i] != '\\0'; i++) { str[i] = tolower(str[i]); }'. Bu döngü, her bir karakteri küçük harfe çevirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:57:59.728456"
  },
  {
    "question": "Bir kullanıcının girdiği bir cümledeki kelimeleri sayan bir program tamamlayın. Eksik kısım: int kelimeSayisi(char *cumle) { ... }",
    "answer": "int kelimeSayisi(char *cumle) {\n    int sayi = 0;\n    char *token = strtok(cumle, \" \");\n    while (token != NULL) {\n        sayi++;\n        token = strtok(NULL, \" \");\n    }\n    return sayi;\n}\n\n// Bu fonksiyon, girilen cümleyi boşluk karakterlerine göre böler ve her bir kelimeyi sayarak toplam kelime sayısını döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.970857"
  },
  {
    "question": "Bir stringin tersini yazdıran bir fonksiyonu tamamlayın. Eksik kısım: void tersYaz(char *str) { ... }",
    "answer": "void tersYaz(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(str[i]);\n    }\n    putchar('\\n');\n}\n\n// Bu fonksiyon, verilen stringin her karakterini ters sırayla yazdırır. strlen ile stringin uzunluğunu bulup, son karakterden başlayarak geriye doğru döngü ile yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.970907"
  },
  {
    "question": "Bir stringin belirli bir karakterin ilk bulunduğu indeksini bulan bir fonksiyonu tamamlayın. Eksik kısım: int karakterIndeksi(char *str, char ch) { ... }",
    "answer": "int karakterIndeksi(char *str, char ch) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ch) {\n            return i;\n        }\n    }\n    return -1; // Karakter bulunamazsa -1 döndürür.\n}\n\n// Bu fonksiyon, verilen stringde belirtilen karakterin ilk geçtiği indeksi döndürür. Eğer karakter bulunamazsa -1 döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.970959"
  },
  {
    "question": "Bir stringin tüm harflerini büyük harfe çeviren bir fonksiyonu tamamlayın. Eksik kısım: void buyukHarfYap(char *str) { ... }",
    "answer": "void buyukHarfYap(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 32;\n        }\n    }\n}\n\n// Bu fonksiyon, verilen stringin her bir karakterini kontrol eder ve küçük harfleri büyük harfe dönüştürür. ASCII değerlerinden yararlanarak küçük harfleri büyük harf hale getirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.970999"
  },
  {
    "question": "Bir stringin içinde bir alt stringin olup olmadığını kontrol eden bir fonksiyonu tamamlayın. Eksik kısım: int altStringVarMi(char *str, char *alt) { ... }",
    "answer": "int altStringVarMi(char *str, char *alt) {\n    if (strstr(str, alt) != NULL) {\n        return 1; // Alt string mevcut.\n    }\n    return 0; // Alt string mevcut değil.\n}\n\n// Bu fonksiyon, strstr fonksiyonunu kullanarak verilen string içinde alt stringin var olup olmadığını kontrol eder. Varsa 1, yoksa 0 döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971042"
  },
  {
    "question": "Bir stringin içindeki tüm boşlukları kaldıran bir fonksiyonu tamamlayın. Eksik kısım: void boslukKaldir(char *str) { ... }",
    "answer": "void boslukKaldir(char *str) {\n    int j = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            str[j++] = str[i];\n        }\n    }\n    str[j] = '\\0'; // Yeni sonlandırıcı ekle.\n}\n\n// Bu fonksiyon, stringdeki boşluk karakterlerini kaldırır ve kalan karakterleri kaydırarak sonlandırıcıyı doğru yere yerleştirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971078"
  },
  {
    "question": "Bir stringdeki sesli harfleri sayan bir fonksiyonu tamamlayın. Eksik kısım: int sesliHarfSayisi(char *str) { ... }",
    "answer": "int sesliHarfSayisi(char *str) {\n    int sayi = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u' || \n            str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U') {\n            sayi++;\n        }\n    }\n    return sayi;\n}\n\n// Bu fonksiyon, verilen stringdeki sesli harfleri sayarak toplam sayıyı döndürür. Hem küçük hem de büyük harfleri kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971124"
  },
  {
    "question": "Bir stringi diğerine kopyalayan bir fonksiyonu tamamlayın. Eksik kısım: void stringKopyala(char *hedef, char *kaynak) { ... }",
    "answer": "void stringKopyala(char *hedef, char *kaynak) {\n    while (*kaynak != '\\0') {\n        *hedef = *kaynak;\n        hedef++;\n        kaynak++;\n    }\n    *hedef = '\\0'; // Kopyalama işleminden sonra sonlandırıcı ekle.\n}\n\n// Bu fonksiyon, kaynak stringi hedef stringe kopyalar ve sonuna null karakter ekleyerek sonlandırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971161"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan bir fonksiyonu tamamlayın. Eksik kısım: int stringUzunlugu(char *str) { ... }",
    "answer": "int stringUzunlugu(char *str) {\n    int uzunluk = 0;\n    while (str[uzunluk] != '\\0') {\n        uzunluk++;\n    }\n    return uzunluk;\n}\n\n// Bu fonksiyon, verilen stringin sonuna kadar giderek karakter sayısını hesaplar ve geriye döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971193"
  },
  {
    "question": "Bir stringdeki tüm harfleri küçük harfe çeviren bir fonksiyonu tamamlayın. Eksik kısım: void kucukHarfYap(char *str) { ... }",
    "answer": "void kucukHarfYap(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] = str[i] + 32;\n        }\n    }\n}\n\n// Bu fonksiyon, verilen stringin her bir karakterini kontrol eder ve büyük harfleri küçük harfe dönüştürür. ASCII değerlerinden yararlanarak büyük harfleri küçük harf haline getirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:58:27.971228"
  },
  {
    "question": "C dilinde bir stringin uzunluğunu bulmak için eksik olan kısmı tamamlayın: int string_length(char *str) { /* eksik kod */ }",
    "answer": "C dilinde bir stringin uzunluğunu bulmak için döngü kullanarak karakterleri sayabiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nint string_length(char *str) {\n    int length = 0;\n    while (*str != '\\0') {\n        length++;\n        str++;\n    }\n    return length;\n}\n```\nBu fonksiyon, verilen stringin sonunu gösteren null karakterine kadar her bir karakteri sayarak toplam uzunluğu döner.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493068"
  },
  {
    "question": "Kullanıcıdan alınan bir stringin içindeki tüm küçük harfleri büyük harflere dönüştürmek için eksik kodu tamamlayın: void to_uppercase(char *str) { /* eksik kod */ }",
    "answer": "Kullanıcıdan alınan bir stringin tüm küçük harflerini büyük harflere dönüştürmek için ASCII değerlerinden yararlanabiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nvoid to_uppercase(char *str) {\n    while (*str) {\n        if (*str >= 'a' && *str <= 'z') {\n            *str = *str - ('a' - 'A');\n        }\n        str++;\n    }\n}\n```\nBu fonksiyon, stringin her karakterini kontrol ederek küçük harfleri büyük harflere dönüştürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493166"
  },
  {
    "question": "İki stringi birleştirmek için eksik kodu tamamlayın: char* concatenate_strings(char *str1, char *str2) { /* eksik kod */ }",
    "answer": "İki stringi birleştirip yeni bir string oluşturmak için önce yeterli alan ayırmalıyız. İşte eksik kısmın tamamlanmış hali:\n\n```c\nchar* concatenate_strings(char *str1, char *str2) {\n    int len1 = string_length(str1);\n    int len2 = string_length(str2);\n    char *result = malloc(len1 + len2 + 1);\n    if (result == NULL) return NULL; // Bellek kontrolü\n    strcpy(result, str1);\n    strcat(result, str2);\n    return result;\n}\n```\nBu fonksiyon, iki stringin uzunluklarını hesaplar, yeterli bellek ayırır ve ardından `strcpy` ve `strcat` kullanarak birleştirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493236"
  },
  {
    "question": "Bir stringin sadece rakamlardan oluşup oluşmadığını kontrol etmek için eksik kodu tamamlayın: int is_numeric(char *str) { /* eksik kod */ }",
    "answer": "Bir stringin sadece rakamları içerip içermediğini kontrol etmek için her karakteri kontrol etmeliyiz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nint is_numeric(char *str) {\n    while (*str) {\n        if (*str < '0' || *str > '9') {\n            return 0; // Değil\n        }\n        str++;\n    }\n    return 1; // Sadece rakamlardan oluşuyor\n}\n```\nBu fonksiyon, stringin her karakterini kontrol ederek rakam olmayan bir karakter bulursa 0 döner, aksi takdirde 1 döner.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493305"
  },
  {
    "question": "Kullanıcıdan alınan bir stringin tersini oluşturmak için eksik kodu tamamlayın: void reverse_string(char *str) { /* eksik kod */ }",
    "answer": "Bir stringin tersini oluşturmak için iki uçtan başlayarak karakterleri değiştirebiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nvoid reverse_string(char *str) {\n    int len = string_length(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n    }\n}\n```\nBu fonksiyon, stringin uzunluğunun yarısı kadar döngü döner ve iki karakteri yer değiştirir, böylece stringi tersine çevirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493373"
  },
  {
    "question": "Bir stringdeki tüm boşluk karakterlerini silmek için eksik kodu tamamlayın: void remove_spaces(char *str) { /* eksik kod */ }",
    "answer": "Boşluk karakterlerini silmek için orijinal stringin üzerinden geçip boşluk olmayan karakterleri yeni bir yere yazabiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nvoid remove_spaces(char *str) {\n    char *ptr = str;\n    while (*str) {\n        if (*str != ' ') {\n            *ptr++ = *str;\n        }\n        str++;\n    }\n    *ptr = '\\0'; // Sonunu null ile belirt\n}\n```\nBu fonksiyon, stringin her karakterini kontrol ederek boşluk olmayanları baştan itibaren yerleştirir ve sonuna null karakter ekler.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493439"
  },
  {
    "question": "Bir stringdeki belirli bir karakterin sayısını bulmak için eksik kodu tamamlayın: int count_character(char *str, char ch) { /* eksik kod */ }",
    "answer": "Belirli bir karakterin sayısını bulmak için string boyunca döngü yaparak her bir karakteri kontrol edebiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nint count_character(char *str, char ch) {\n    int count = 0;\n    while (*str) {\n        if (*str == ch) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n```\nBu fonksiyon, verilen karakteri sayarak toplam sayısını döner.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493562"
  },
  {
    "question": "Kullanıcının girdiği bir stringin palindrome olup olmadığını kontrol etmek için eksik kodu tamamlayın: int is_palindrome(char *str) { /* eksik kod */ }",
    "answer": "Bir stringin palindrome olup olmadığını kontrol etmek için baştan ve sondan karşılaştırma yapmamız gerekir. İşte eksik kısmın tamamlanmış hali:\n\n```c\nint is_palindrome(char *str) {\n    int len = string_length(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return 0; // Palindrome değil\n        }\n    }\n    return 1; // Palindrome\n}\n```\nBu fonksiyon, stringin baş ve son karakterlerini karşılaştırarak palindrome olup olmadığını döner.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493648"
  },
  {
    "question": "Bir stringin tüm alt stringlerini oluşturmak için eksik kodu tamamlayın: void generate_substrings(char *str) { /* eksik kod */ }",
    "answer": "Bir stringin tüm alt stringlerini oluşturmak için iki döngü kullanarak her bir alt stringi elde edebiliriz. İşte eksik kısmın tamamlanmış hali:\n\n```c\nvoid generate_substrings(char *str) {\n    int len = string_length(str);\n    for (int i = 0; i < len; i++) {\n        for (int j = i; j < len; j++) {\n            for (int k = i; k <= j; k++) {\n                putchar(str[k]);\n            }\n            putchar('\\n');\n        }\n    }\n}\n```\nBu fonksiyon, tüm alt stringleri üreterek her bir alt stringi ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:08.493711"
  },
  {
    "question": "C dilinde bir string'in uzunluğunu nasıl bulabilirim? Aşağıdaki kodda hata var mı?",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    int length = strlen(str);\n    printf(\"Uzunluk: %d\\n\", length);\n    return 0;\n}\n``` \nBu kod doğrudur ve `strlen` fonksiyonu ile string'in uzunluğunu doğru bir şekilde bulur. Eğer fonksiyonu kullanırken `#include <string.h>` kütüphanesini eklemezseniz, derleyici hata verecektir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.762840"
  },
  {
    "question": "Bir string içinde belirli bir karakterin bulunup bulunmadığını nasıl kontrol ederim? Aşağıdaki kod hatalı.",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    if (strchr(str, 'a') != NULL) {\n        printf(\"Karakter bulundu.\\n\");\n    }\n    return 0;\n}\n``` \nBurada `strchr` fonksiyonu ile 'a' karakterinin string içinde olup olmadığını kontrol ediyorsunuz. Eğer `#include <string.h>` eklenmezse, `strchr` tanımsız olur ve hata verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.762889"
  },
  {
    "question": "İki string'in eşit olup olmadığını nasıl kontrol edebilirim? Aşağıdaki kodda hata var mı?",
    "answer": "Kodunuz şöyle olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[] = \"Hello\";\n    char str2[] = \"Hello\";\n    if (strcmp(str1, str2) == 0) {\n        printf(\"String'ler eşit.\\n\");\n    }\n    return 0;\n}\n``` \nBu kod doğrudur. `strcmp` fonksiyonu ile iki string'in karşılaştırmasını yapıyorsunuz. Eğer `#include <string.h>` eklenmezse, derleyici hata verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.762945"
  },
  {
    "question": "String'leri birleştirirken hata yapma ihtimalim var mı? Aşağıdaki kodda ne hata var?",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[20] = \"Merhaba\";\n    char str2[] = \" Dunya\";\n    strcat(str1, str2);\n    printf(\"Birlestirilmis: %s\\n\", str1);\n    return 0;\n}\n``` \nBu kod doğrudur. Ancak, `str1` dizisinin boyutunun `str2`'yi alacak kadar büyük olduğundan emin olmalısınız. Aksi takdirde bellek taşması hatası alırsınız.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.762975"
  },
  {
    "question": "Bir string'i ters çevirmek için hangi fonksiyonu kullanmalıyım? Aşağıdaki kodda bir hata var mı?",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    reverse(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n``` \nBu kod doğrudur ve bir string'i ters çevirir. Eğer `str` dizisi sabit (const) olarak tanımlanmışsa, değiştirmeye çalıştığınız için hata alırsınız. Sabit tanımlamadan kaçının.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763006"
  },
  {
    "question": "Bir string'in başındaki ve sonundaki boşlukları nasıl kaldırırım? Aşağıdaki kod hatalı.",
    "answer": "Kodunuz şöyle olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid trim(char str[]) {\n    char *end;\n    while (isspace(*str)) str++;\n    end = str + strlen(str) - 1;\n    while (end > str && isspace(*end)) end--;\n    *(end + 1) = '\\0';\n}\n\nint main() {\n    char str[] = \"   Merhaba   \";\n    trim(str);\n    printf(\"Trimlenmiş: '%s'\\n\", str);\n    return 0;\n}\n``` \nBu kod doğrudur. Ancak `isspace` fonksiyonu için `#include <ctype.h>` eklemeniz gerekir, yoksa tanımsız olur.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763034"
  },
  {
    "question": "Bir string'i büyük harfe nasıl çeviririm? Aşağıdaki kodda bir hata var mı?",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid toUpperCase(char str[]) {\n    for (int i = 0; str[i]; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nint main() {\n    char str[] = \"merhaba\";\n    toUpperCase(str);\n    printf(\"Buyuk Harf: %s\\n\", str);\n    return 0;\n}\n``` \nBu kod doğrudur. `toupper` fonksiyonu için `#include <ctype.h>` eklemeniz gerektiğini unutmayın.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763060"
  },
  {
    "question": "String'teki karakterleri saymak için nasıl bir yöntem izleyebilirim? Aşağıdaki kod hatalı.",
    "answer": "Kodunuz şöyle olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        count++;\n    }\n    printf(\"Karakter sayisi: %d\\n\", count);\n    return 0;\n}\n``` \nBu kod doğrudur. `str` stringindeki toplam karakter sayısını doğru bir şekilde sayar. Eğer döngü koşulu `str[i] != '\\0'` yerine `str[i] != 0` olsaydı, yine çalışırdı fakat daha az okunaklı olurdu.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763087"
  },
  {
    "question": "Bir string içinde alt string ararken hangi fonksiyonu kullanmalıyım? Aşağıdaki kodda hata var mı?",
    "answer": "Kodunuz şu şekilde olabilir: \n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dunya\";\n    char *result = strstr(str, \"Dunya\");\n    if (result != NULL) {\n        printf(\"Alt string bulundu: %s\\n\", result);\n    }\n    return 0;\n}\n``` \nBu kod doğrudur. `strstr` fonksiyonu ile alt stringi arıyorsunuz. Eğer `#include <string.h>` eklenmezse, derleyici hata verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763116"
  },
  {
    "question": "String'in içinde sayı kontrolü yapmak istiyorum. Aşağıdaki kodda bir hata var mı?",
    "answer": "Kodunuz şöyle olabilir: \n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"12345\";\n    int isNumber = 1;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isdigit(str[i])) {\n            isNumber = 0;\n            break;\n        }\n    }\n    if (isNumber) {\n        printf(\"String bir sayidir.\\n\");\n    } else {\n        printf(\"String bir sayi degildir.\\n\");\n    }\n    return 0;\n}\n``` \nBu kod doğrudur. `isdigit` fonksiyonu ile karakterlerin sayı olup olmadığını kontrol ediyorsunuz. Eğer `#include <ctype.h>` eklemezseniz, `isdigit` tanımsız olur ve derleyici hata verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T14:59:55.763143"
  },
  {
    "question": "C dilinde bir string'in uzunluğunu hesaplamak için kullanılan strlen fonksiyonu neden beklenenden fazla bir değer döndürüyor?",
    "answer": "strlen fonksiyonu, string'in sonundaki null karakteri (\\0) saymaz. Eğer string'in sonuna yanlışlıkla fazladan bir karakter eklenmişse veya string düzgün sonlandırılmamışsa, strlen beklenenden daha büyük bir değer döndürebilir. Bu durumu önlemek için, string'in doğru bir şekilde sonlandırıldığından emin olun.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592807"
  },
  {
    "question": "C dilinde iki string'in karşılaştırılması için strcmp fonksiyonu neden yanlış sonuç döndürüyor?",
    "answer": "strcmp fonksiyonu, iki string'i karşılaştırırken ASCII değerlerine göre sıralar. Eğer string'lerden biri sonlandırılmamışsa veya bellekte geçersiz bir konumda başlıyorsa, beklenmedik sonuçlar elde edebilirsiniz. Her iki string'in de doğru bir şekilde sonlandığından ve geçerli bellek alanlarında bulunduğundan emin olun.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592852"
  },
  {
    "question": "C dilinde bir string'i başka bir string'e kopyalarken strcpy fonksiyonu neden buffer overflow hatası veriyor?",
    "answer": "strcpy fonksiyonu, hedef string'in boyutunu kontrol etmez. Eğer kaynak string, hedef string'den daha uzunsa, bellekte buffer overflow hatası oluşur. Bu durumda, hedef string'in boyutunu yeterli şekilde tanımlamak veya strlcpy gibi daha güvenli bir alternatif kullanmak önemlidir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592887"
  },
  {
    "question": "C dilinde bir string'in içindeki tüm boşluk karakterlerini silmek için yazılan bir fonksiyon neden çalışmıyor?",
    "answer": "Boşlukları silen bir fonksiyonda, orijinal string üzerinde değişiklik yapmaya çalışıyorsanız ancak bu değişiklikleri doğru bir şekilde kaydetmiyorsanız, orijinal string değişmeden kalır. Örneğin, yeni bir dizi oluşturmadan sadece mevcut dizi üzerinde değişiklik yapmaya çalışmak hatalıdır. Yeni bir string oluşturarak boşlukları çıkarıp, sonucu bu yeni string'e yazmalısınız.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592920"
  },
  {
    "question": "C dilinde bir string'i tersine çevirmek için yazılan kod neden beklenmeyen bir sonuç veriyor?",
    "answer": "String'i tersine çevirirken, string üzerinde aynı anda okuma ve yazma işlemleri yapıyorsanız, veriler karışabilir. Bu nedenle, string'yi tersine çevirmek için ayrı bir dizi oluşturun ve orijinal diziye erişmeden işlemleri gerçekleştirin.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592949"
  },
  {
    "question": "C dilinde bir string'in istenilen bir karakter ile değiştirilmesi işlemi neden başarısız oluyor?",
    "answer": "Eğer string sabit bir dizi olarak tanımlandıysa, içindeki karakterleri değiştirmek bellekte hataya yol açabilir. C dilinde string'ler genellikle karakter dizileri olarak tanımlandıkları için, değiştirme işlemi yapılmadan önce uygun bir belleğe yazılmalıdır. Bunu yapmak için, dinamik bellek allocate edilerek string'in kopyası üzerinde değişiklikler yapılmalıdır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.592980"
  },
  {
    "question": "C dilinde string birleştirme işlemi neden beklenmeyen sonuç veriyor?",
    "answer": "String birleştirme işlemi yapılırken, hedef string'in yeterli boyutta olup olmadığı kontrol edilmezse, buffer overflow hatası meydana gelebilir. Birleştirme işlemini yapmadan önce hedef string'in boyutunun yeterli olduğundan emin olun veya strncat gibi güvenli bir yöntem kullanın.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.593003"
  },
  {
    "question": "C dilinde bir string içinde geçen bir alt string'in bulunması için yazılan kod neden çalışmıyor?",
    "answer": "Substring arama işlemi sırasında başlangıç noktasını doğru ayarlamamışsanız veya arama işlemi sonuna kadar gitmiyorsa, arama sonuç vermez. Bu tür işlemleri yaparken, döngü koşullarını dikkatlice ayarlamak ve null karaktere kadar kontrol sağlamak önemlidir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.593033"
  },
  {
    "question": "C dilinde dinamik olarak oluşturulmuş bir string üzerinde strlen fonksiyonu neden hatalı çalışıyor?",
    "answer": "Dinamik bellekte oluşturulan string'lerin sonuna doğru bir null karakter (\\0) eklenmediğinde strlen doğru bir şekilde çalışmaz. Dinamik dizi oluşturduktan sonra, string'in sonuna kendi başınıza bir null karakter eklemeyi unutmayın.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.593060"
  },
  {
    "question": "C dilinde bir string'in tüm karakterlerini büyük harfe çeviren bir fonksiyon neden beklenmeyen sonuçlar veriyor?",
    "answer": "Eğer karakterleri değiştirmek için doğrudan string üzerinde işlem yapıyorsanız ve string'in imzasına dikkat etmiyorsanız, bellek hatalarına neden olabilirsiniz. Karakter dönüşümü yaparken ASCII değerlerini kullanarak veya toupper fonksiyonunu kullanarak yeni bir dizi oluşturun ve sonuçları bu diziye yazın.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.593096"
  },
  {
    "question": "C dilinde bir string'in sonuna bir başka string eklenirken kaynak string'in kaybolması neden olabiliyor?",
    "answer": "Eğer kaynak string'i birleştirme işlemi sırasında hedef string ile aynı bellek alanını paylaşıyorsanız, kaynak string'in içeriği hedef string ile değiştirilecektir. Bu tür hatalardan kaçınmak için kaynak ve hedef string'lerin farklı bellek konumlarında olduğundan emin olun.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:00:43.593126"
  },
  {
    "question": "C dilinde bir string'i nasıl tersten yazdırabilirim?",
    "answer": "Bir string'i tersten yazdırmak için, string'in sonundan başlayarak karakterleri bir döngü ile okuyabiliriz. Öncelikle, string'in uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabiliriz. Ardından, bir 'for' döngüsü ile bu uzunluktan başlayarak geriye doğru gidip, her karakteri ekrana yazdırabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    int length = strlen(str);\n    for (int i = length - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    return 0;\n}\n```\nBu kod, 'Merhaba' string'ini 'abahreM' olarak yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419608"
  },
  {
    "question": "C dilinde bir string içinde belirli bir karakterin sayısını nasıl bulabilirim?",
    "answer": "Bir string içinde belirli bir karakterin sayısını bulmak için, string'in her bir karakterini kontrol eden bir döngü kullanabiliriz. Eğer döngüdeki karakter aradığımız karakterle eşleşiyorsa, bir sayacı artırabiliriz. İşte bunu gerçekleştiren bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char ch = 'a';\n    int count = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", ch, count);\n    return 0;\n}\n```\nBu kod, 'Merhaba Dünya!' string'inde 'a' karakterinin kaç kez geçtiğini sayar ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419672"
  },
  {
    "question": "C dilinde iki string'in birbirine eşit olup olmadığını nasıl kontrol ederim?",
    "answer": "İki string'in eşit olup olmadığını kontrol etmek için 'strcmp' fonksiyonunu kullanabiliriz. Bu fonksiyon, iki string'in içeriğini karşılaştırır ve eşitlerse 0 döndürür. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[] = \"Test\";\n    char str2[] = \"Test\";\n    if (strcmp(str1, str2) == 0) {\n        printf(\"Stringler eşit.\\n\");\n    } else {\n        printf(\"Stringler eşit değil.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, 'Test' ve 'Test' string'lerinin eşit olduğunu kontrol eder ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419729"
  },
  {
    "question": "C dilinde bir string'i başka bir string'in içine nasıl ekleyebilirim?",
    "answer": "Bir string'i başka bir string'in içine eklemek için 'strcat' fonksiyonunu kullanabiliriz. Bu fonksiyon, ilk string'in sonuna ikinci string'i ekler. İlk olarak, yeterli boyutta bir buffer oluşturmalıyız ki, iki string'in toplam uzunluğu bu buffer'da sığabilsin. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = \"Merhaba\";\n    char str2[] = \" Dünya!\";\n    strcat(str1, str2);\n    printf(\"Birleştirilmiş string: %s\\n\", str1);\n    return 0;\n}\n```\nBu kod, 'Merhaba' ve ' Dünya!' string'lerini birleştirerek 'Merhaba Dünya!' sonucunu verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419772"
  },
  {
    "question": "C dilinde bir string'in belirli bir kısmını nasıl alabilirim?",
    "answer": "Bir string'in belirli bir kısmını almak için 'strncpy' fonksiyonunu kullanabiliriz. Bu fonksiyon, belirli bir sayıda karakteri bir string'den başka bir string'e kopyalar. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char subStr[10];\n    strncpy(subStr, str + 8, 6);\n    subStr[6] = '\\0'; // Null karakter ekleyerek sonlandır\n    printf(\"Alınan kısım: %s\\n\", subStr);\n    return 0;\n}\n```\nBu kod, 'Dünya!' kelimesini alır ve 'Alınan kısım: Dünya!' olarak yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419813"
  },
  {
    "question": "C dilinde bir string içinde bir alt string'in var olup olmadığını nasıl kontrol ederim?",
    "answer": "Bir string içinde belirli bir alt string'in var olup olmadığını kontrol etmek için 'strstr' fonksiyonunu kullanabiliriz. Bu fonksiyon, ilk string içinde ikinci string'in ilk geçtiği yeri döndürür. Eğer bulunamazsa NULL döner. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char subStr[] = \"Dünya\";\n    if (strstr(str, subStr) != NULL) {\n        printf(\"Alt string bulundu.\\n\");\n    } else {\n        printf(\"Alt string bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, 'Merhaba Dünya!' string'i içinde 'Dünya' alt string'inin bulunup bulunmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419863"
  },
  {
    "question": "C dilinde bir string'in tüm küçük harflerle yazılışını nasıl elde ederim?",
    "answer": "Bir string'i küçük harflere dönüştürmek için her bir karakteri kontrol ederek 'tolower' fonksiyonunu kullanabiliriz. 'for' döngüsü ile string'in her karakterini küçük harf haline getirebiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    for (int i = 0; str[i]; i++) {\n        str[i] = tolower(str[i]);\n    }\n    printf(\"Küçük harflerle: %s\\n\", str);\n    return 0;\n}\n```\nBu kod, 'Merhaba Dünya!' string'ini 'merhaba dünya!' olarak yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419908"
  },
  {
    "question": "C dilinde bir string içinde bulunan boşlukları nasıl kaldırabilirim?",
    "answer": "Bir string içinde bulunan boşlukları kaldırmak için, yeni bir string oluşturarak boşluk olmayan karakterleri bu yeni string'e kopyalayabiliriz. İşte bunu yapan bir kod örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \" Merhaba Dünya! \";\n    char result[50];\n    int j = 0;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] != ' ') {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0'; // Null karakter ekleyerek sonlandır\n    printf(\"Boşluklar kaldırıldı: '%s'\\n\", result);\n    return 0;\n}\n```\nBu kod, ' Merhaba Dünya! ' string'indeki boşlukları kaldırarak 'MerhabaDünya!' sonucunu verir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.419948"
  },
  {
    "question": "C dilinde bir string içinde her bir kelimenin baş harfini nasıl büyük yapabilirim?",
    "answer": "Bir string içindeki her kelimenin baş harfini büyük yapmak için, her bir kelimenin ilk karakterini kontrol ederek 'toupper' fonksiyonunu kullanabiliriz. Bu işlem için bir döngü ve boşlukları kontrol edebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"merhaba dünya! nasılsınız?\";\n    int capitalize = 1; // Baş harfi büyük yapma durumu\n    for (int i = 0; str[i]; i++) {\n        if (capitalize && isalpha(str[i])) {\n            str[i] = toupper(str[i]);\n            capitalize = 0; // İlk harfi büyük yaptık, bir sonraki boşluğa kadar küçük kalacak\n        }\n        if (str[i] == ' ') {\n            capitalize = 1; // Boşluk gördüğümüzde bir sonraki harf büyük olacak\n        }\n    }\n    printf(\"Sonuç: %s\\n\", str);\n    return 0;\n}\n```\nBu kod, 'merhaba dünya! nasılsınız?' cümlesini 'Merhaba Dünya! Nasılsınız?' olarak yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:25.420001"
  },
  {
    "question": "C dilinde bir stringin uzunluğunu nasıl bulabilirim?",
    "answer": "C dilinde bir stringin uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabiliriz. Bu fonksiyon, stringin sonundaki null karakterine kadar olan karakterlerin sayısını döndürür. Örnek: \n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    int length = strlen(str);\n    printf(\"Stringin uzunluğu: %d\\n\", length);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449315"
  },
  {
    "question": "C dilinde iki stringi nasıl birleştirebilirim?",
    "answer": "İki stringi birleştirmek için 'strcat' fonksiyonunu kullanabiliriz. Bu fonksiyon, ikinci stringi birinci stringin sonuna ekler. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = \"Merhaba \";\n    char str2[] = \"Dünya!\";\n    strcat(str1, str2);\n    printf(\"Birleşik string: %s\\n\", str1);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449349"
  },
  {
    "question": "C dilinde bir stringi nasıl tersine çevirebilirim?",
    "answer": "Bir stringi tersine çevirmek için bir döngü kullanarak karakterleri baştan sona doğru okur ve yeni bir stringde ters sırayla saklayabiliriz. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char* str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    reverseString(str);\n    printf(\"Ters string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449368"
  },
  {
    "question": "C dilinde bir stringin belirli bir karakter içeriğini nasıl kontrol edebilirim?",
    "answer": "'strchr' fonksiyonunu kullanarak bir stringde belirli bir karakterin olup olmadığını kontrol edebiliriz. Bu fonksiyon, karakteri bulursa onun adresini döner, bulamazsa NULL döner. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    char ch = 'a';\n    if (strchr(str, ch) != NULL) {\n        printf(\"'%c' karakteri var.\\n\", ch);\n    } else {\n        printf(\"'%c' karakteri yok.\\n\", ch);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449394"
  },
  {
    "question": "C dilinde bir stringi büyük harfe nasıl dönüştürebilirim?",
    "answer": "Bir stringin tüm karakterlerini büyük harfe dönüştürmek için 'toupper' fonksiyonunu kullanabiliriz. Her karakteri tek tek kontrol ederek bu fonksiyonu uygulayabiliriz. Örnek:\n\n#include <stdio.h>\n#include <ctype.h>\n\nvoid toUpperCase(char* str) {\n    for (int i = 0; str[i]; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nint main() {\n    char str[] = \"merhaba\";\n    toUpperCase(str);\n    printf(\"Büyük harfli string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449414"
  },
  {
    "question": "C dilinde bir stringin içindeki bir kelimeyi nasıl arayabilirim?",
    "answer": "Bir string içinde belirli bir kelimeyi aramak için 'strstr' fonksiyonunu kullanabiliriz. Bu fonksiyon, kelimenin bulunduğu yerin adresini döner. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    char word[] = \"Dünya\";\n    if (strstr(str, word) != NULL) {\n        printf(\"Kelime bulundu!\\n\");\n    } else {\n        printf(\"Kelime bulunamadı.\\n\");\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449437"
  },
  {
    "question": "C dilinde bir stringin içindeki boşlukları nasıl kaldırabilirim?",
    "answer": "Bir stringin içindeki boşlukları kaldırmak için, yeni bir string oluşturup boşluk olmayan karakterleri bu yeni stringe ekleyebiliriz. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpaces(char* str) {\n    char result[100];\n    int j = 0;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] != ' ') {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0';\n    strcpy(str, result);\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    removeSpaces(str);\n    printf(\"Boşluksuz string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449458"
  },
  {
    "question": "C dilinde bir stringdeki tüm küçük harfleri nasıl büyük harfe çeviririm?",
    "answer": "Tüm küçük harfleri büyük harfe çevirmek için 'tolower' fonksiyonunu kullanarak her karakteri kontrol edebiliriz. Örnek:\n\n#include <stdio.h>\n#include <ctype.h>\n\nvoid toUpperCase(char* str) {\n    for (int i = 0; str[i]; i++) {\n        str[i] = (str[i] >= 'a' && str[i] <= 'z') ? str[i] - 32 : str[i];\n    }\n}\n\nint main() {\n    char str[] = \"merhaba\";\n    toUpperCase(str);\n    printf(\"Büyük harfli string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449482"
  },
  {
    "question": "C dilinde bir stringin sonuna bir karakter eklemek için ne yapmalıyım?",
    "answer": "Bir stringin sonuna karakter eklemek için öncelikle stringin uzunluğunu kontrol edip o pozisyona karakteri ekleyebiliriz. Örnek:\n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[50] = \"Merhaba\";\n    char ch = '!';\n    int len = strlen(str);\n    str[len] = ch;\n    str[len + 1] = '\\0';\n    printf(\"Güncellenmiş string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:02:52.449525"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan bir fonksiyon yaz.",
    "answer": "C dilinde bir stringin uzunluğunu hesaplamak için, stringin sonundaki null karakterine (\\0) kadar olan karakter sayısını sayabiliriz. Aşağıdaki kod, verilen bir stringin uzunluğunu hesaplayan bir fonksiyonu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint stringLength(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    const char *myString = \"Merhaba, Dünya!\";\n    int length = stringLength(myString);\n    printf(\"String uzunluğu: %d\\n\", length);\n    return 0;\n}\n```\n\nBu kod, stringin sonuna kadar giderek karakterleri sayar ve toplam uzunluğu döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175834"
  },
  {
    "question": "Bir stringin tüm harflerini büyük harfe döndüren bir fonksiyon yaz.",
    "answer": "Bir stringin tüm karakterlerini büyük harfe dönüştürmek için ASCII değerlerini kullanabiliriz. Aşağıda, bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid toUpperCase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 32;\n        }\n    }\n}\n\nint main() {\n    char myString[] = \"merhaba\";\n    toUpperCase(myString);\n    printf(\"Büyük harfli string: %s\\n\", myString);\n    return 0;\n}\n```\n\nBu kod, küçük harfleri büyük harflere dönüştürür ve stringi günceller.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175878"
  },
  {
    "question": "İki stringin eşit olup olmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "İki stringin eşitliğini kontrol etmek için karakter karakter karşılaştırma yapabiliriz. Aşağıda bunun için bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint areStringsEqual(const char *str1, const char *str2) {\n    while (*str1 && (*str1 == *str2)) {\n        str1++;\n        str2++;\n    }\n    return *str1 == *str2;\n}\n\nint main() {\n    const char *string1 = \"test\";\n    const char *string2 = \"test\";\n    if (areStringsEqual(string1, string2)) {\n        printf(\"Stringler eşit.\\n\");\n    } else {\n        printf(\"Stringler eşit değil.\\n\");\n    }\n    return 0;\n}\n```\n\nBu fonksiyon, iki stringin her bir karakterini karşılaştırır ve eşit olup olmadıklarını döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175906"
  },
  {
    "question": "Bir stringdeki belirli bir karakterin sayısını hesaplayan bir fonksiyon yaz.",
    "answer": "Bir stringde belirli bir karakterin kaç kez geçtiğini saymak için döngü kullanabiliriz. İşte bu işlemi gerçekleştiren bir fonksiyon:\n\n```c\n#include <stdio.h>\n\nint countCharacter(const char *str, char ch) {\n    int count = 0;\n    while (*str) {\n        if (*str == ch) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *myString = \"merhaba dünya\";\n    char character = 'a';\n    int count = countCharacter(myString, character);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", character, count);\n    return 0;\n}\n```\n\nBu kod, istenen karakterin sayısını döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175931"
  },
  {
    "question": "Bir stringin tersini döndüren bir fonksiyon yaz.",
    "answer": "Stringi tersine çevirmek için, stringin uzunluğunu hesaplayıp, karakterleri baştan sona değil, sondan başa doğru alabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid reverseString(char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    for (int i = 0; i < length / 2; i++) {\n        char temp = str[i];\n        str[i] = str[length - 1 - i];\n        str[length - 1 - i] = temp;\n    }\n}\n\nint main() {\n    char myString[] = \"merhaba\";\n    reverseString(myString);\n    printf(\"Ters string: %s\\n\", myString);\n    return 0;\n}\n```\n\nBu fonksiyon, stringin ilk ve son karakterlerini değiştirerek tersine çevirir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175950"
  },
  {
    "question": "Bir stringin içinde bir alt stringin var olup olmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "Bir stringin içinde başka bir stringin var olup olmadığını kontrol etmek için, her karakteri karşılaştırarak başlayabiliriz. Aşağıdaki örnek bunu gösterir:\n\n```c\n#include <stdio.h>\n\nint containsSubstring(const char *str, const char *substr) {\n    int i, j;\n    for (i = 0; str[i] != '\\0'; i++) {\n        for (j = 0; substr[j] != '\\0' && str[i + j] == substr[j]; j++);\n        if (substr[j] == '\\0') {\n            return 1; // Alt string bulundu\n        }\n    }\n    return 0; // Alt string bulunamadı\n}\n\nint main() {\n    const char *myString = \"merhaba dünya\";\n    const char *substring = \"dünya\";\n    if (containsSubstring(myString, substring)) {\n        printf(\"Alt string bulundu.\\n\");\n    } else {\n        printf(\"Alt string bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\n\nBu fonksiyon, aranan alt stringi ana string içinde bulmaya çalışır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.175981"
  },
  {
    "question": "Bir stringin tüm boşluk karakterlerini kaldıran bir fonksiyon yaz.",
    "answer": "Boşluk karakterlerini kaldırmak için bir yeni string oluşturabiliriz. Aşağıda bunun için bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid removeSpaces(const char *str, char *result) {\n    while (*str) {\n        if (*str != ' ') {\n            *result = *str;\n            result++;\n        }\n        str++;\n    }\n    *result = '\\0'; // Sonlandırıcı karakter ekle\n}\n\nint main() {\n    const char *myString = \"merhaba dünya\";\n    char result[100];\n    removeSpaces(myString, result);\n    printf(\"Boşluksuz string: %s\\n\", result);\n    return 0;\n}\n```\n\nBu kod, tüm boşlukları kaldırarak yeni bir string oluşturur.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.176004"
  },
  {
    "question": "İki stringi birleştiren bir fonksiyon yaz.",
    "answer": "İki stringi birleştirmek için, ikinci stringin her karakterini ilk stringin sonuna ekleyebiliriz. Aşağıdaki kod bunu göstermektedir:\n\n```c\n#include <stdio.h>\n\nvoid concatenateStrings(char *dest, const char *src) {\n    while (*dest) {\n        dest++; // Hedef stringin sonuna git\n    }\n    while (*src) {\n        *dest = *src; // Kaynağı hedefe kopyala\n        dest++;\n        src++;\n    }\n    *dest = '\\0'; // Sonlandırıcı karakter ekle\n}\n\nint main() {\n    char str1[100] = \"Merhaba\";\n    char str2[] = \" Dünya\";\n    concatenateStrings(str1, str2);\n    printf(\"Birleşmiş string: %s\\n\", str1);\n    return 0;\n}\n```\n\nBu fonksiyon, iki stringi birleştirerek ilk stringin sonuna ekler.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.176022"
  },
  {
    "question": "Bir stringin her kelimesinin ilk harfini büyük yapan bir fonksiyon yaz.",
    "answer": "Bir stringdeki her kelimenin ilk harfini büyük yapmak için, boşluk karakterlerini kontrol edebiliriz. İşte bu işlemi gerçekleştiren bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid capitalizeWords(char *str) {\n    int capitalizeNext = 1; // İlk kelimenin ilk harfi büyük olmalı\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ' ') {\n            capitalizeNext = 1; // Boşluk bulduğunda bir sonraki harf büyük olmalı\n        } else if (capitalizeNext) {\n            if (str[i] >= 'a' && str[i] <= 'z') {\n                str[i] = str[i] - 32; // Küçük harfi büyük yap\n            }\n            capitalizeNext = 0;\n        }\n    }\n}\n\nint main() {\n    char myString[] = \"merhaba dünya programcıları\";\n    capitalizeWords(myString);\n    printf(\"Büyük harfler: %s\\n\", myString);\n    return 0;\n}\n```\n\nBu kod, her kelimenin ilk harfini büyük yaparak stringi günceller.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:03:36.176046"
  },
  {
    "question": "C dilinde bir string içinde belirli bir karakterin kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Bir string içinde belirli bir karakterin kaç kez geçtiğini bulmak için bir döngü kullanabiliriz. Aşağıdaki örnek, 'a' karakterinin bir stringde kaç kez bulunduğunu saymaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint karakterSay(const char *str, char karakter) {\n    int sayac = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == karakter) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    const char *metin = \"Merhaba, dünya! Merhaba!\";\n    char aranan = 'a';\n    int sonuc = karakterSay(metin, aranan);\n    printf(\"'%c' karakteri %d kez bulundu.\\n\", aranan, sonuc);\n    return 0;\n}\n```\nBu kod, verilen metinde 'a' karakterinin kaç kez geçtiğini bulur ve sonucu konsola yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918567"
  },
  {
    "question": "İki stringi birleştirmek için kendi fonksiyonumu nasıl yazabilirim?",
    "answer": "İki stringi birleştirmek için yeterli bellek ayırarak ve karakterleri döngü ile kopyalayarak bir fonksiyon yazabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* birlestir(const char *str1, const char *str2) {\n    int uzunluk1 = strlen(str1);\n    int uzunluk2 = strlen(str2);\n    char *birlesmis = malloc(uzunluk1 + uzunluk2 + 1);\n    if (birlesmis == NULL) return NULL;\n    strcpy(birlesmis, str1);\n    strcat(birlesmis, str2);\n    return birlesmis;\n}\n\nint main() {\n    char *metin1 = \"Merhaba, \";\n    char *metin2 = \"Dünya!\";\n    char *sonuc = birlestir(metin1, metin2);\n    printf(\"Birleşmiş metin: %s\\n\", sonuc);\n    free(sonuc);\n    return 0;\n}\n```\nBu kod, iki stringi birleştirir ve sonucu konsola yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918626"
  },
  {
    "question": "Bir stringin tersini almak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir stringin tersini almak için, stringin sonundan başlayarak yeni bir string oluşturabiliriz. İşte bunun bir örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(const char *str, char *ters) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk; i++) {\n        ters[i] = str[uzunluk - 1 - i];\n    }\n    ters[uzunluk] = '\\0'; // NULL karakter ile sonlandır\n}\n\nint main() {\n    const char *metin = \"Merhaba\";\n    char ters[100];\n    tersCevir(metin, ters);\n    printf(\"Ters metin: %s\\n\", ters);\n    return 0;\n}\n```\nBu kod, verilen bir stringin tersini alır ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918665"
  },
  {
    "question": "Bir stringdeki tüm büyük harfleri küçük harfe çeviren bir fonksiyon nasıl yazabilirim?",
    "answer": "Stringdeki tüm büyük harfleri küçük harfe çevirmek için, her karakteri kontrol edip büyük harf olup olmadığını belirleyebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid buyuktenKucuge(const char *str, char *sonuc) {\n    int i = 0;\n    while (str[i] != '\\0') {\n        sonuc[i] = tolower(str[i]);\n        i++;\n    }\n    sonuc[i] = '\\0'; // NULL ile sonlandır\n}\n\nint main() {\n    const char *metin = \"MerHaba Dünya!\";\n    char sonuc[100];\n    buyuktenKucuge(metin, sonuc);\n    printf(\"Küçük harfler: %s\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, verilen bir stringdeki tüm büyük harfleri küçük harfe çevirir ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918720"
  },
  {
    "question": "İki stringin eşit olup olmadığını kontrol eden bir fonksiyon yazabilir misin?",
    "answer": "İki stringin eşit olup olmadığını kontrol etmek için, her iki stringin uzunluklarını ve içeriklerini karşılaştırabiliriz. Aşağıda bu kontrolü yapan bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint esittir(const char *str1, const char *str2) {\n    return strcmp(str1, str2) == 0;\n}\n\nint main() {\n    const char *metin1 = \"Merhaba\";\n    const char *metin2 = \"Merhaba\";\n    if (esittir(metin1, metin2)) {\n        printf(\"İki string eşittir.\\n\");\n    } else {\n        printf(\"İki string eşit değildir.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, iki stringin eşit olup olmadığını kontrol eder ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918765"
  },
  {
    "question": "Bir stringdeki özel karakterleri nasıl kaldırabilirim?",
    "answer": "Bir stringdeki özel karakterleri kaldırmak için, geçerli karakterleri yeni bir stringe kopyalayabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid ozelKarakterKaldir(const char *str, char *sonuc) {\n    int i = 0, j = 0;\n    while (str[i] != '\\0') {\n        if (isalnum(str[i]) || isspace(str[i])) {\n            sonuc[j++] = str[i];\n        }\n        i++;\n    }\n    sonuc[j] = '\\0'; // NULL ile sonlandır\n}\n\nint main() {\n    const char *metin = \"Merhaba! @Dünya#\";\n    char sonuc[100];\n    ozelKarakterKaldir(metin, sonuc);\n    printf(\"Temizlenmiş metin: %s\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, bir stringdeki özel karakterleri kaldırır ve yalnızca alfanümerik ve boşluk karakterlerini tutar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918798"
  },
  {
    "question": "Bir stringin belirli bir alt stringi içerip içermediğini kontrol eden bir fonksiyon nasıl yazabilirim?",
    "answer": "Bir stringin belirli bir alt stringi içerip içermediğini kontrol etmek için strstr fonksiyonunu kullanabiliriz. Aşağıdaki kod örneğinde bu kontrolü gerçekleştiren bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint altStringVarMi(const char *str, const char *altStr) {\n    return strstr(str, altStr) != NULL;\n}\n\nint main() {\n    const char *metin = \"Merhaba Dünya!\";\n    const char *altMetin = \"Dünya\";\n    if (altStringVarMi(metin, altMetin)) {\n        printf(\"Alt string mevcut.\\n\");\n    } else {\n        printf(\"Alt string mevcut değil.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, bir stringin belirli bir alt stringi içerip içermediğini kontrol eder ve sonucu yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918848"
  },
  {
    "question": "Bir stringin kelime sayısını nasıl bulabilirim?",
    "answer": "Bir stringdeki kelime sayısını bulmak için, boşluk karakterlerini kontrol ederek kelimeleri sayabiliriz. İşte bu işlemi yapan bir fonksiyon örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint kelimeSay(const char *str) {\n    int sayac = 0;\n    int inKelime = 0;\n    while (*str) {\n        if (isspace(*str)) {\n            inKelime = 0;\n        } else if (inKelime == 0) {\n            inKelime = 1;\n            sayac++;\n        }\n        str++;\n    }\n    return sayac;\n}\n\nint main() {\n    const char *metin = \"Merhaba Dünya! Bu bir test metnidir.\";\n    int sonuc = kelimeSay(metin);\n    printf(\"Kelime sayısı: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, verilen bir stringdeki kelime sayısını bulur ve sonucu konsola yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918880"
  },
  {
    "question": "Bir stringdeki en uzun kelimeyi nasıl bulabilirim?",
    "answer": "Bir stringdeki en uzun kelimeyi bulmak için her kelimeyi ayırarak uzunluklarını kontrol edebiliriz. Aşağıdaki kod örneği bu işlemi gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid enUzunKelimeBul(const char *str, char *enUzunKelime) {\n    int enUzun = 0, uzunluk = 0;\n    const char *kelimeBaslangici = str;\n    while (*str) {\n        if (isspace(*str) || *(str + 1) == '\\0') {\n            if (*(str + 1) == '\\0') uzunluk++;\n            if (uzunluk > enUzun) {\n                enUzun = uzunluk;\n                strncpy(enUzunKelime, kelimeBaslangici, uzunluk);\n                enUzunKelime[uzunluk] = '\\0'; // NULL ile sonlandır\n            }\n            uzunluk = 0;\n            kelimeBaslangici = str + 1;\n        } else {\n            uzunluk++;\n        }\n        str++;\n    }\n}\n\nint main() {\n    const char *metin = \"Merhaba Dünya bu bir test metnidir.\";\n    char enUzun[100];\n    enUzunKelimeBul(metin, enUzun);\n    printf(\"En uzun kelime: %s\\n\", enUzun);\n    return 0;\n}\n```\nBu kod, verilen bir stringdeki en uzun kelimeyi bulur ve sonucu ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:16.918920"
  },
  {
    "question": "C dilinde bir string değişkeninin uzunluğunu hesaplamak için hangi fonksiyonu kullanmalıyız ve bu fonksiyonun işleyişi nasıldır?",
    "answer": "C dilinde string uzunluğunu hesaplamak için 'strlen' fonksiyonunu kullanırız. Bu fonksiyon, verilen stringin sonuna kadar giderek karakter sayısını sayar ve null ('\\0') karakterine ulaştığında sayımı durdurur. Kullanırken, string'in NULL terminatörü ile sonlandığından emin olmalıyız. Örnek: 'strlen(\"Merhaba\")' 7 döndürür.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.187713"
  },
  {
    "question": "Bir string içindeki belirli bir karakteri değiştirmek için nasıl bir yaklaşım izlemeliyiz?",
    "answer": "Belirli bir karakteri değiştirmek için, öncelikle stringi bir dizi olarak tanımlamalıyız. Ardından, döngü kullanarak dizinin her bir elemanını kontrol edebiliriz. Örneğin, 'e' harfini 'a' ile değiştirmek için şu şekilde bir kod yazabiliriz: 'for (int i = 0; str[i] != '\\0'; i++) if (str[i] == 'e') str[i] = 'a';'. Bu sayede tüm string üzerinde değişiklik yapabiliriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.187779"
  },
  {
    "question": "C dilinde string birleştirmek için hangi fonksiyonu kullanmalıyız, bunların sınırlamaları nelerdir?",
    "answer": "String birleştirmek için 'strcat' fonksiyonunu kullanırız. Ancak, bu fonksiyonun kullanımı sırasında dikkat etmemiz gereken en önemli nokta, hedef dizinin yeterli bellek alanına sahip olduğundan emin olmaktır. Eğer yeterli alan yoksa, bellek taşması (buffer overflow) riski taşır. Örnek: 'strcat(dest, src);' ile 'dest' dizisinin sonuna 'src' dizisini ekleriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.187834"
  },
  {
    "question": "Bir stringin, başka bir string içinde olup olmadığını kontrol etmek için hangi fonksiyonu kullanmalıyız?",
    "answer": "Bir stringin başka bir string içinde olup olmadığını kontrol etmek için 'strstr' fonksiyonunu kullanırız. Bu fonksiyon, arama stringini bulursa, ilk bulunduğu yerin adresini döner; bulamazsa NULL döner. Kullanım örneği: 'if (strstr(mainStr, subStr) != NULL) { printf(\"Bulundu.\"); }' şeklindedir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.187899"
  },
  {
    "question": "C dilinde bir stringin kopyasını almak için hangi fonksiyonu kullanmalıyız ve bu fonksiyonun ön koşulları nelerdir?",
    "answer": "Bir stringin kopyasını almak için 'strcpy' fonksiyonunu kullanırız. Bu fonksiyon, kaynak stringi hedef stringe kopyalar. Ancak, hedef dizinin yeterli bellek alanına sahip olması gerekmektedir. Aksi takdirde, bellek taşması gerçekleşebilir. Örnek kullanım: 'strcpy(dest, src);' şeklindedir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.187960"
  },
  {
    "question": "C dilinde bir string içerisindeki tüm harfleri büyük harfe çevirmek için ne yapmalıyız?",
    "answer": "Bütün harfleri büyük harfe çevirmek için bir döngü kullanarak her karakteri kontrol etmeli ve 'toupper' fonksiyonunu kullanmalıyız. Örnek: 'for (int i = 0; str[i] != '\\0'; i++) str[i] = toupper(str[i]);' ile tüm stringi büyük harfe çevirebiliriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188011"
  },
  {
    "question": "C dilinde bir stringin tüm boşluk karakterlerini kaldırmak için nasıl bir çözüm geliştirebiliriz?",
    "answer": "Boşlukları kaldırmak için bir döngü ile stringin her bir karakterini kontrol edebiliriz. Boşluk olmayan karakterleri başka bir diziye kopyalarız. Örnek: 'for (int i = 0, j = 0; str[i] != '\\0'; i++) if (str[i] != ' ') newStr[j++] = str[i]; newStr[j] = '\\0';' şeklinde bir çözüm üretebiliriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188063"
  },
  {
    "question": "C dilinde bir stringin tersini almak için hangi yöntemleri kullanabiliriz?",
    "answer": "Bir stringin tersini almak için, bir döngü ile stringin sonundan başlayarak, yeni bir diziye karakterleri kopyalayabiliriz. Ayrıca, temp değişkeni kullanarak swap işlemi ile daha az bellek kullanabiliriz. Örnek: 'for (int i = 0; i < len; i++) reversed[i] = str[len - 1 - i]; reversed[len] = '\\0';' ile stringi tersine çevirebiliriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188113"
  },
  {
    "question": "C dilinde belirli bir karakterin string içinde kaç kez geçtiğini nasıl bulabiliriz?",
    "answer": "Belirli bir karakterin string içinde kaç kez geçtiğini bulmak için bir döngü kullanarak stringi tarayabiliriz. Her bulunduğunda sayacı artırarak sonuca ulaşabiliriz. Örnek: 'for (int i = 0; str[i] != '\\0'; i++) if (str[i] == targetChar) count++;'. Bu şekilde, 'count' değişkeni aranan karakterin sayısını tutar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188166"
  },
  {
    "question": "C dilinde iki stringin eşit olup olmadığını kontrol etmek için hangi fonksiyonu kullanmalıyız?",
    "answer": "İki stringin eşit olup olmadığını kontrol etmek için 'strcmp' fonksiyonunu kullanırız. Bu fonksiyon, iki stringi karşılaştırır ve eşitlerse 0, ilk stringin ikinci stringden büyükse pozitif, küçükse negatif bir değer döndürür. Kullanım örneği: 'if (strcmp(str1, str2) == 0) { printf(\"Eşit\"); }' şeklindedir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188221"
  },
  {
    "question": "C dilinde bir stringi belirli bir karaktere göre ayırmak için nasıl bir yöntem kullanabiliriz?",
    "answer": "Stringi belirli bir karaktere göre ayırmak için 'strtok' fonksiyonunu kullanırız. Bu fonksiyon, stringi parçalara ayırarak her bir parçayı döndürür. Her çağrıda, bir sonraki parçayı almak için NULL parametresi vermeliyiz. Örnek: 'char *token = strtok(str, \",\");' ile virgülle ayırabiliriz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:04:40.188277"
  },
  {
    "question": "Bir dizideki tüm stringleri birleştiren bir fonksiyon yazdım, ama performans sorunları yaşıyorum. Bunu nasıl optimize edebilirim?",
    "answer": "String birleştirme işlemi için C dilinde en iyi yöntem, stringlerin uzunluğunu önceden hesaplamak ve bir buffer oluşturup tüm stringleri bu buffer'a kopyalamaktır. Aşağıda bu yöntemin bir örneğini bulabilirsiniz:\n\n```c\nchar* concatenate_strings(char** strings, int count) {\n    int total_length = 0;\n    for (int i = 0; i < count; i++) {\n        total_length += strlen(strings[i]);\n    }\n\n    char* result = (char*)malloc(total_length + 1);\n    if (result == NULL) return NULL; // Hata kontrolü\n\n    char* p = result;\n    for (int i = 0; i < count; i++) {\n        p = stpcpy(p, strings[i]);\n    }\n    return result;\n}\n```\nBu yöntemle, her string birleştirme işlemi için yeni bir string oluşturmak yerine, sadece bir kez bellek ayırarak performansı artırmış olursunuz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.910760"
  },
  {
    "question": "Bir stringin içinde belirli bir karakterin kaç kez geçtiğini saymak için yazdığım kod, büyük/küçük harf duyarlılığına neden oluyor. Bunu nasıl düzeltebilirim?",
    "answer": "Büyük/küçük harf duyarlılığını kaldırmak için, stringi sayma işlemi öncesinde ya tümüyle küçük veya büyük harfe dönüştürebilirsiniz. İşte bu durumu sağlayacak bir fonksiyon:\n\n```c\nint count_char(const char* str, char ch) {\n    int count = 0;\n    char lower_ch = tolower(ch);\n\n    while (*str) {\n        if (tolower(*str) == lower_ch) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n```\nBu fonksiyon, verilen karakterin string içinde kaç kez geçtiğini sayar ve büyük/küçük harf farkını göz ardı eder.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.910854"
  },
  {
    "question": "String karşılaştırma işlemi sırasında, iki stringin eşit olup olmadığını kontrol etmek için yazdığım fonksiyon hatalı hale geliyor. Bunun nedeni ne olabilir?",
    "answer": "String karşılaştırma işlemlerinde, NULL kontrollerini yapmak önemlidir. Eğer bir veya her iki string NULL ise, bu durum hatalı sonuçlar verir. Aşağıda geliştirilmiş bir karşılaştırma fonksiyonu bulunmaktadır:\n\n```c\nint safe_string_compare(const char* str1, const char* str2) {\n    if (str1 == NULL || str2 == NULL) {\n        return (str1 == str2) ? 0 : -1; // Eşitlik durumu\n    }\n    return strcmp(str1, str2);\n}\n```\nBu şekilde, NULL durumu kontrol edilmiş olur ve hata olasılığı en aza indirilir.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.910922"
  },
  {
    "question": "Bir stringin belirli bir pozisyona substring eklemek istiyorum. Bunu yaparken performansı artırmak için ne yapabilirim?",
    "answer": "Substring ekleme işlemleri için, hedef stringin uzunluğunu ve ekleme yapılan pozisyonu dikkate alarak yeterli bellek ayırmak önemlidir. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği bulabilirsiniz:\n\n```c\nchar* insert_substring(char* target, const char* substring, int position) {\n    int target_len = strlen(target);\n    int substring_len = strlen(substring);\n\n    // Pozisyon kontrolü\n    if (position < 0 || position > target_len) return NULL;\n\n    char* result = (char*)malloc(target_len + substring_len + 1);\n    if (result == NULL) return NULL;\n\n    strncpy(result, target, position);\n    strcpy(result + position, substring);\n    strcpy(result + position + substring_len, target + position);\n    return result;\n}\n```\nBu fonksiyon, hedef stringin uzunluğuna göre uygun bellek ayırır ve substring eklemesini optimize eder.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.910981"
  },
  {
    "question": "Bir stringdeki boşlukları temizlemek için yazdığım fonksiyon, çalışmıyor gibi görünüyor. Hataları nasıl düzeltebilirim?",
    "answer": "Bir stringdeki boşlukları temizlemek için her bir karakteri kontrol etmek ve sadece boş olmayan karakterleri yeni bir stringe kopyalamak gerekebilir. Aşağıdaki örnekte bu işlemi gerçekleştiren bir fonksiyon yer almaktadır:\n\n```c\nchar* trim_whitespace(const char* str) {\n    if (str == NULL) return NULL;\n\n    int length = strlen(str);\n    char* result = (char*)malloc(length + 1);\n    if (result == NULL) return NULL;\n\n    int j = 0;\n    for (int i = 0; i < length; i++) {\n        if (str[i] != ' ') {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0'; // Null terminator ekle\n    return result;\n}\n```\nBu fonksiyon, boşlukları temizlerken uygun bellek yönetimini de sağlar.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.911043"
  },
  {
    "question": "Bir stringdeki tüm harflerin sırasını tersine çevirmek için yazdığım fonksiyon, bellek sızıntısı yaratıyor. Bunu nasıl önleyebilirim?",
    "answer": "Bellek sızıntısını önlemek için, kullanmadığınız bellek alanlarını serbest bırakmayı unutmamalısınız. Aşağıda, string ters çevirme işlemi yapan bir fonksiyon ve bellek yönetimi ile ilgili önlemleri bulabilirsiniz:\n\n```c\nchar* reverse_string(const char* str) {\n    if (str == NULL) return NULL;\n\n    int length = strlen(str);\n    char* reversed = (char*)malloc(length + 1);\n    if (reversed == NULL) return NULL;\n\n    for (int i = 0; i < length; i++) {\n        reversed[i] = str[length - 1 - i];\n    }\n    reversed[length] = '\\0'; // Null terminator ekle\n    return reversed;\n}\n\n// Kullanım\nchar* original = \"Merhaba\";\nchar* reversed = reverse_string(original);\n// İşlemlerden sonra serbest bırakmayı unutmayın\nfree(reversed);\n```\nBu şekilde, bellek sızıntısını önlemiş olursunuz.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.911105"
  },
  {
    "question": "String kopyalamak için kullanılan `strcpy` fonksiyonu, buffer overflow hatasına neden olabiliyor. Bunu nasıl güvenli bir hale getirebiliriz?",
    "answer": "Buffer overflowunu önlemek için, `strncpy` fonksiyonunu kullanmak daha güvenli bir yaklaşımdır. Aşağıda güvenli bir string kopyalama işlemi için yazılmış bir fonksiyon örneği bulunmaktadır:\n\n```c\nvoid safe_strcpy(char* dest, const char* src, size_t dest_size) {\n    if (dest == NULL || src == NULL || dest_size == 0) return;\n    strncpy(dest, src, dest_size - 1);\n    dest[dest_size - 1] = '\\0'; // Null terminatör ekle\n}\n```\nBu fonksiyon, hedef bufferın boyutunu hesaba katarak kopyalama işlemini yapar ve buffer taşmasını önler.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.911172"
  },
  {
    "question": "Bir stringdeki tüm karakterlerin frekansını bulmak için yazdığım kod, çok fazla bellek kullanıyor. Bunu nasıl optimize edebilirim?",
    "answer": "Karakter frekanslarını tutarken, sadece gerekli olan karakter setlerini kullanmak önemlidir. Örneğin, ASCII karakterleri için bir dizi kullanabilirsiniz. Aşağıda bu durumu gösteren bir örnek bulunmaktadır:\n\n```c\nvoid char_frequency(const char* str, int freq[256]) {\n    memset(freq, 0, 256 * sizeof(int)); // Frekans dizisini sıfırla\n    while (*str) {\n        freq[(unsigned char)*str]++;\n        str++;\n    }\n}\n```\nBu fonksiyon, stringdeki her bir karakterin frekansını tutmak için sadece 256 elemanlı bir dizi kullanır ve bellek kullanımını azaltır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.911233"
  },
  {
    "question": "Bir stringin belirli bir karakter dizisiyle bitip bitmediğini kontrol etmek istiyorum, fakat performansı artırmak için ne yapmalıyım?",
    "answer": "Stringin belirli bir karakter dizisiyle bitip bitmediğini kontrol etmek için, son kısmı kontrol etmek yeterlidir. Bu işlem için, hedef stringin uzunluğunu ve kontrol etmek istediğiniz dizinin uzunluğunu karşılaştırarak başlayabilirsiniz. Aşağıda bu durumu kontrol eden bir fonksiyon örneği verilmiştir:\n\n```c\nint ends_with(const char* str, const char* suffix) {\n    if (str == NULL || suffix == NULL) return 0;\n\n    int str_len = strlen(str);\n    int suffix_len = strlen(suffix);\n\n    if (suffix_len > str_len) return 0;\n\n    return strcmp(str + str_len - suffix_len, suffix) == 0;\n}\n```\nBu fonksiyon, gereksiz yere tüm stringi kontrol etmektense, sadece son kısmı karşılaştırarak performansı artırır.",
    "category": "arrays_strings",
    "topic": "string_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String temelleri",
    "timestamp": "2025-06-01T15:05:29.911294"
  },
  {
    "question": "Kullanıcının girdiği bir ismi büyük harfe çeviren kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char isim[50];\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    // Buraya kod yazın\n    printf(\"Büyük harfle: %s\", isim);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char isim[50];\n    printf(\"İsminizi girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    for (int i = 0; isim[i]; i++) {\n        isim[i] = toupper(isim[i]);\n    }\n    printf(\"Büyük harfle: %s\", isim);\n    return 0;\n}\n\n// Bu kodda fgets ile kullanıcının girdiği isim alınmakta ve toupper fonksiyonu ile her karakter büyük harfe çevrilmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.990663"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki boşlukları kaldıran kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    // Buraya kod yazın\n    printf(\"Boşluksuz cümle: %s\", cumle);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    char sonuc[100];\n    int j = 0;\n    for (int i = 0; cumle[i]; i++) {\n        if (cumle[i] != ' ') {\n            sonuc[j++] = cumle[i];\n        }\n    }\n    sonuc[j] = '\\0';\n    printf(\"Boşluksuz cümle: %s\", sonuc);\n    return 0;\n}\n\n// Bu kodda, boşluk olmayan karakterler yeni bir diziye kopyalanmakta ve sonuç olarak boşluksuz cümle elde edilmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.990764"
  },
  {
    "question": "Bir kelimenin palindrom olup olmadığını kontrol eden kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[50];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n    // Buraya kod yazın\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[50];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n    kelime[strcspn(kelime, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    int uzunluk = strlen(kelime);\n    int palindrom = 1;\n    for (int i = 0; i < uzunluk / 2; i++) {\n        if (kelime[i] != kelime[uzunluk - i - 1]) {\n            palindrom = 0;\n            break;\n        }\n    }\n    if (palindrom) {\n        printf(\"'%s' bir palindromdur.\\n\", kelime);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", kelime);\n    }\n    return 0;\n}\n\n// Bu kod, verilen kelimenin tersten okunuşuyla aynı olup olmadığını kontrol eder ve palindrom olup olmadığını bildirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.990842"
  },
  {
    "question": "Kullanıcının girdiği iki stringi birleştiren kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50], str2[50];\n    printf(\"Birinci stringi girin: \");\n    fgets(str1, sizeof(str1), stdin);\n    printf(\"İkinci stringi girin: \");\n    fgets(str2, sizeof(str2), stdin);\n    // Buraya kod yazın\n    printf(\"Birleşik string: %s\", str1);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50], str2[50];\n    printf(\"Birinci stringi girin: \");\n    fgets(str1, sizeof(str1), stdin);\n    printf(\"İkinci stringi girin: \");\n    fgets(str2, sizeof(str2), stdin);\n    str1[strcspn(str1, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    str2[strcspn(str2, \"\\n\")] = 0;\n    strcat(str1, str2);\n    printf(\"Birleşik string: %s\", str1);\n    return 0;\n}\n\n// strcat fonksiyonu, str2'yi str1'in sonuna ekler ve birleşik string elde edilir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.990944"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    // Buraya kod yazın\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    int uzunluk = strlen(str);\n    printf(\"Stringin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n\n// bu kod, kullanıcının girdiği stringin uzunluğunu hesaplar ve ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.991025"
  },
  {
    "question": "Kullanıcının girdiği bir stringin tüm harflerini küçük harfe çeviren kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    // Buraya kod yazın\n    printf(\"Küçük harfle: %s\", str);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    for (int i = 0; str[i]; i++) {\n        str[i] = tolower(str[i]);\n    }\n    printf(\"Küçük harfle: %s\", str);\n    return 0;\n}\n\n// tolower fonksiyonu ile kullanıcının girdiği tüm harfler küçük harfe çevrilir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.991111"
  },
  {
    "question": "Bir stringin sonundaki belirli bir karakteri kaldıran kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    // Buraya kod yazın\n    printf(\"Son karakter kaldırıldı: %s\", str);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    str[strlen(str) - 1] = '\\0'; // Son karakteri kaldır\n    printf(\"Son karakter kaldırıldı: %s\", str);\n    return 0;\n}\n\n// Bu kodda, stringin sonundaki son karakter, null karakter ile değiştirilerek kaldırılır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.991191"
  },
  {
    "question": "Bir stringdeki belirli bir karakterin kaç kez geçtiğini bulan kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    char aranan;\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"Aranacak karakteri girin: \");\n    // Buraya kod yazın\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", aranan, sayac);\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    char aranan;\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    printf(\"Aranacak karakteri girin: \");\n    scanf(\"%c\", &aranan);\n    int sayac = 0;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] == aranan) {\n            sayac++;\n        }\n    }\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", aranan, sayac);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği stringdeki belirli bir karakterin kaç kez geçtiğini sayar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.991294"
  },
  {
    "question": "Bir stringin tersini yazdıran kodu tamamla: \n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    // Buraya kod yazın\n    return 0;\n}",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldır\n    int uzunluk = strlen(str);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği stringin her karakterini tersten yazdırmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:06:22.991357"
  },
  {
    "question": "Kullanıcının girdiği bir stringin içindeki tüm boşlukları kaldırmak için bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid remove_spaces(char *str) {\n    int i, j = 0;\n    char temp[strlen(str) + 1]; // Geçici bir dizi tanımlıyoruz\n\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            temp[j++] = str[i];\n        }\n    }\n    temp[j] = '\\0'; // Geçici dizinin sonuna null karakter ekliyoruz\n    strcpy(str, temp); // Geçici diziyi orijinal diziye kopyalıyoruz\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    remove_spaces(str);\n    printf(\"Boşluk kaldırıldı: %s\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.916910"
  },
  {
    "question": "Kullanıcının girdiği bir stringin palindrom olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint is_palindrome(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return 0; // Palindrom değil\n        }\n    }\n    return 1; // Palindrom\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldırıyoruz\n    if (is_palindrome(str)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.916953"
  },
  {
    "question": "Bir stringin içindeki tüm küçük harfleri büyük harflere dönüştüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid to_uppercase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 32; // ASCII değerinden 32 çıkararak büyük harfe dönüştürüyoruz\n        }\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    to_uppercase(str);\n    printf(\"Büyük harflerle: %s\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.916985"
  },
  {
    "question": "Bir stringin içinde bir karakterin kaç kez geçtiğini bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint count_char(char *str, char c) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == c) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    char str[100];\n    char c;\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"Hangi karakterin sayısını bulmak istiyorsunuz? \");\n    scanf(\"%c\", &c);\n    int result = count_char(str, c);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", c, result);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917013"
  },
  {
    "question": "Kullanıcının girdiği stringin tersini yazdıran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldırıyoruz\n    reverse_string(str);\n    printf(\"Tersi: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917069"
  },
  {
    "question": "Verilen bir stringdeki belirli bir kelimeyi başka bir kelime ile değiştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid replace_word(char *str, const char *old_word, const char *new_word) {\n    char buffer[1000];\n    char *pos;\n    int index = 0;\n    int old_len = strlen(old_word);\n\n    while ((pos = strstr(str, old_word)) != NULL) {\n        strcpy(&buffer[index], str);\n        index += pos - str;\n        strcpy(&buffer[index], new_word);\n        index += strlen(new_word);\n        str = pos + old_len;\n    }\n    strcpy(&buffer[index], str);\n    strcpy(str, buffer);\n}\n\nint main() {\n    char str[100], old_word[50], new_word[50];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"Eski kelimeyi girin: \");\n    fgets(old_word, sizeof(old_word), stdin);\n    old_word[strcspn(old_word, \"\\n\")] = 0;\n    printf(\"Yeni kelimeyi girin: \");\n    fgets(new_word, sizeof(new_word), stdin);\n    new_word[strcspn(new_word, \"\\n\")] = 0;\n    replace_word(str, old_word, new_word);\n    printf(\"Yeni string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917110"
  },
  {
    "question": "Bir stringin içinde sadece sayılardan oluşup oluşmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint is_numeric(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isdigit(str[i])) {\n            return 0; // Sayı değil\n        }\n    }\n    return 1; // Sadece sayı\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    str[strcspn(str, \"\\n\")] = 0; // Yeni satır karakterini kaldırıyoruz\n    if (is_numeric(str)) {\n        printf(\"'%s' sadece sayılardan oluşmaktadır.\\n\", str);\n    } else {\n        printf(\"'%s' sadece sayılardan oluşmamaktadır.\\n\", str);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917138"
  },
  {
    "question": "İki stringin eşit olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint are_equal(char *str1, char *str2) {\n    return strcmp(str1, str2) == 0; // Stringlerin eşit olup olmadığını kontrol ediyoruz\n}\n\nint main() {\n    char str1[100], str2[100];\n    printf(\"İlk stringi girin: \");\n    fgets(str1, sizeof(str1), stdin);\n    printf(\"İkinci stringi girin: \");\n    fgets(str2, sizeof(str2), stdin);\n    str1[strcspn(str1, \"\\n\")] = 0;\n    str2[strcspn(str2, \"\\n\")] = 0;\n    if (are_equal(str1, str2)) {\n        printf(\"Stringler eşittir.\\n\");\n    } else {\n        printf(\"Stringler eşit değildir.\\n\");\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917163"
  },
  {
    "question": "Bir stringin başına ve sonuna belirli bir karakter ekleyen bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid add_characters(char *str, char c) {\n    int len = strlen(str);\n    memmove(&str[1], str, len + 1); // Mevcut stringi sağa kaydırıyoruz\n    str[0] = c; // Başına karakter ekliyoruz\n    str[len + 1] = c; // Sonuna karakter ekliyoruz\n    str[len + 2] = '\\0'; // Null karakter ekliyoruz\n}\n\nint main() {\n    char str[100];\n    char c;\n    printf(\"Bir string girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"Eklenecek karakteri girin: \");\n    scanf(\"%c\", &c);\n    add_characters(str, c);\n    printf(\"Yeni string: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:13.917187"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki tüm kelimeleri büyük harflere dönüştüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid buyukHarfYap(char *cumle) {\n    for (int i = 0; i < strlen(cumle); i++) {\n        cumle[i] = toupper(cumle[i]);\n    }\n}\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    buyukHarfYap(cumle);\n    printf(\"Büyük harfle: %s\", cumle);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği cümledeki tüm karakterleri büyük harfe dönüştürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936421"
  },
  {
    "question": "Bir dizideki tüm kelimeleri ters çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid kelimeTersCevir(char *kelime) {\n    int uzunluk = strlen(kelime);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char tmp = kelime[i];\n        kelime[i] = kelime[uzunluk - i - 1];\n        kelime[uzunluk - i - 1] = tmp;\n    }\n}\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", kelime);\n    kelimeTersCevir(kelime);\n    printf(\"Ters çevrilmiş kelime: %s\", kelime);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan bir kelimeyi ters çevirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936462"
  },
  {
    "question": "Bir string içinde geçen bütün 'a' harflerini 'e' harfi ile değiştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid aDenEyeCevir(char *str) {\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == 'a') {\n            str[i] = 'e';\n        }\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n    aDenEyeCevir(str);\n    printf(\"Sonuç: %s\", str);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği stringde 'a' harflerini 'e' harfi ile değiştirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936495"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki kelimeleri sayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint kelimeSay(char *cumle) {\n    int sayac = 0;\n    char *kelime = strtok(cumle, \" \");\n    while (kelime != NULL) {\n        sayac++;\n        kelime = strtok(NULL, \" \");\n    }\n    return sayac;\n}\n\nint main() {\n    char cumle[100];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n    printf(\"Kelime sayısı: %d\", kelimeSay(cumle));\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği cümledeki kelimelerin sayısını belirler.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936542"
  },
  {
    "question": "Kullanıcının girdiği bir stringin içinde belirli bir karakterin kaç kez geçtiğini bulan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint karakterSay(char *str, char ch) {\n    int sayac = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == ch) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char str[100], ch;\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n    printf(\"Aranacak karakteri girin: \");\n    scanf(\"%c\", &ch);\n    printf(\"'%c' karakteri %d kez geçiyor.\", ch, karakterSay(str, ch));\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği string içinde belirli bir karakterin kaç kez geçtiğini bulur.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936584"
  },
  {
    "question": "Bir stringdeki tüm boşlukları kaldıran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *str) {\n    int i, j = 0;\n    char temp[100];\n    for (i = 0; str[i]; i++) {\n        if (str[i] != ' ') {\n            temp[j++] = str[i];\n        }\n    }\n    temp[j] = '\\0';\n    strcpy(str, temp);\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir cümle girin: \");\n    fgets(str, sizeof(str), stdin);\n    boslukKaldir(str);\n    printf(\"Boşluksuz cümle: %s\", str);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği stringdeki tüm boşlukları kaldırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936606"
  },
  {
    "question": "Bir stringin tersini döndürüp yeni bir string olarak döndüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersString(char *str, char *tersStr) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk; i++) {\n        tersStr[i] = str[uzunluk - i - 1];\n    }\n    tersStr[uzunluk] = '\\0';\n}\n\nint main() {\n    char str[100], tersStr[100];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", str);\n    tersString(str, tersStr);\n    printf(\"Ters çevrilmiş kelime: %s\", tersStr);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan bir kelimenin tersini yeni bir string olarak döndürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:07:53.936633"
  },
  {
    "question": "Bir stringin içinde belirli bir karakterin kaç kez geçtiğini bulan bir fonksiyon yazdım. Ancak sonuç beklediğimden farklı. Hatanın sebebi nedir?",
    "answer": "Eğer karakter sayısı bulma fonksiyonunuzda döngüyü doğru ayarlamadıysanız, örneğin stringin sonuna geldiğinizde döngüyü devam ettiriyorsa, bu durumda yanlış bir sonuç alırsınız. İşte basit bir örnek:\n\n```c\nint character_count(const char *str, char c) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == c) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\nDoğru kullanım için döngü şartını kontrol edin.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085189"
  },
  {
    "question": "Stringlerdeki tüm boşlukları kaldıracak bir fonksiyon yazdım ama orijinal string değişmiyor. Neden?",
    "answer": "C dilinde stringler dizilerle temsil edilir ve bir stringi değiştirmek istiyorsanız, onu bir diziye atamalısınız. Eğer sadece okuma modunda bir pointer kullanıyorsanız, değişiklik yapamazsınız. Aşağıda düzgün bir şekilde boşlukları kaldıran bir fonksiyon örneği:\n\n```c\nvoid remove_spaces(char *str) {\n    int j = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            str[j++] = str[i];\n        }\n    }\n    str[j] = '\\0';\n}\n```\n\nBurada, boşluk olmayan karakterleri yeniden diziye atıyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085238"
  },
  {
    "question": "İki stringin eşit olup olmadığını kontrol eden bir fonksiyonum var fakat bazen yanlış sonuç veriyor. Hata nerede?",
    "answer": "Stringleri karşılaştırırken `==` operatörünü kullanıyorsanız, bu sadece pointerların eşitliğini kontrol eder. String içeriklerini karşılaştırmak için `strcmp()` fonksiyonunu kullanmalısınız. Örnek:\n\n```c\n#include <string.h>\n\nint strings_are_equal(const char *str1, const char *str2) {\n    return strcmp(str1, str2) == 0;\n}\n```\n\nBu şekilde string içeriklerini düzgün bir şekilde karşılaştırabilirsiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085277"
  },
  {
    "question": "Bir stringi tersine çevirmek için yazdığım fonksiyon bazen çökmelere yol açıyor. Hata nedir?",
    "answer": "Eğer stringi tersine çevirirken yetersiz bellek tahsis ettiyseniz veya orijinal stringi değiştirmeye çalışıyorsanız bellek hatası alabilirsiniz. Stringin uzunluğunu doğru hesaplamak ve yeterli bellek ayırmak kritik. İşte bir örnek:\n\n```c\n#include <stdlib.h>\n#include <string.h>\n\nchar* reverse_string(const char *str) {\n    int len = strlen(str);\n    char *reversed = (char *)malloc(len + 1);\n    if (reversed == NULL) return NULL; // bellek hatası kontrolü\n    for (int i = 0; i < len; i++) {\n        reversed[i] = str[len - 1 - i];\n    }\n    reversed[len] = '\\0';\n    return reversed;\n}\n```\n\nBellek sızıntılarını önlemek için `free()` ile bellek serbest bırakmayı unutmayın.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085310"
  },
  {
    "question": "Bir stringdeki tüm büyük harfleri küçük harfe çevirmek için yazdığım fonksiyon bazen çalışmıyor. Hata nerede?",
    "answer": "Eğer ASCII kodları ile çalışıyorsanız, 'A' ile 'a' arasındaki fark 32'dir. Bunu kontrol etmeden doğrudan değiştirmeye çalışıyorsanız, beklenmedik sonuçlar alabilirsiniz. İşte doğru kullanım:\n\n```c\nvoid to_lowercase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] += 32; // veya str[i] = str[i] + 32;\n        }\n    }\n}\n```\n\nBu şekilde büyük harfleri güvenli bir şekilde küçük harflere çevirebilirsiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085345"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan fonksiyonum bazen yanlış sonuç veriyor. Hata nerede?",
    "answer": "Eğer stringin sonuna '\\0' karakterini koymayı unuttuysanız veya doğru bir şekilde diziyi sonlandırmadıysanız, `strlen()` yanlış sonuç verecektir. Örneğin:\n\n```c\nint string_length(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n```\n\nBu kontrol, stringin doğru bir şekilde sonlandığından emin olmanızı sağlar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085375"
  },
  {
    "question": "Stringleri birleştiren fonksiyonu yazarken bellek taşması yaşıyorum. Hata nerede?",
    "answer": "Stringleri birleştirirken hedef dizinin boyutunu yeterli şekilde ayarlamadıysanız, taşma yapabilirsiniz. `strcat()` kullanırken, hedef dizinin yeterli boyutta olduğundan emin olmalısınız. İşte güvenli bir örnek:\n\n```c\nchar* safe_concat(const char *str1, const char *str2) {\n    size_t len1 = strlen(str1);\n    size_t len2 = strlen(str2);\n    char *result = (char *)malloc(len1 + len2 + 1);\n    strcpy(result, str1);\n    strcat(result, str2);\n    return result;\n}\n```\n\nBurada yeterli bellek ayırdığımızdan emin oluyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085403"
  },
  {
    "question": "Bir stringin içindeki tüm karakterleri değiştiren fonksiyonda bazen karakterler kayboluyor. Hata nerede?",
    "answer": "Eğer karakterleri değiştirme işlemini yaparken aynı diziyi kullanıyorsanız ve değiştirirken bazı karakterler üzerine yazılıyorsa, bu kayıplara neden olabilir. Bunu önlemek için geçici bir dizi kullanmalısınız. Örnek:\n\n```c\nvoid replace_chars(const char *str, char old, char new) {\n    char *temp = strdup(str); // Geçici kopya\n    for (int i = 0; temp[i] != '\\0'; i++) {\n        if (temp[i] == old) {\n            temp[i] = new;\n        }\n    }\n    printf(\"%s\\n\", temp);\n    free(temp);\n}\n```\n\nBu şekilde orijinal stringi değiştirmeden sonuç elde edersiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085434"
  },
  {
    "question": "Bir string içinde belirli bir alt stringin yerini değiştiren fonksiyonumda beklenmedik sonuçlar alıyorum. Hata nerede?",
    "answer": "Alt stringin yerini değiştirirken, var olan dizinin boyutunu aşmamaya dikkat etmelisiniz. Eğer yetersiz bellek ayırdıysanız ya da alt stringin uzunluğu hedefin uzunluğundan fazlaysa, taşma olur. İşte bir örnek:\n\n```c\nchar* replace_substring(char *str, const char *old, const char *new) {\n    char *result;\n    int i, count = 0;\n    int newlen = strlen(new);\n    int oldlen = strlen(old);\n\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (strstr(&str[i], old) == &str[i]) {\n            count++;\n            i += oldlen - 1;\n        }\n    }\n\n    result = (char *)malloc(i + count * (newlen - oldlen) + 1);\n    int j = 0;\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (strstr(&str[i], old) == &str[i]) {\n            strcpy(&result[j], new);\n            j += newlen;\n            i += oldlen - 1;\n        } else {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0';\n    return result;\n}\n```\n\nBu şekilde yeterli alan tahsis etmiş olursunuz ve taşmalardan kaçınırsınız.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:09:07.085469"
  },
  {
    "question": "Bir string'i büyük harflere dönüştürmek için hangi fonksiyonu kullanabilirim?",
    "answer": "Bir string'i büyük harflere dönüştürmek için 'strupr' fonksiyonu kullanılabilir. Ancak bu fonksiyon, bazı C kütüphanelerinde bulunmayabilir. Alternatif olarak, her karakteri tek tek kontrol edip 'toupper' fonksiyonu ile dönüştürebiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"merhaba\";\n    for (int i = 0; str[i]; i++) {\n        str[i] = toupper(str[i]);\n    }\n    printf(\"Büyük harf: %s\\n\", str);\n    return 0;\n}\n```\nBu kod, 'merhaba' string'ini 'MERHABA' olarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255523"
  },
  {
    "question": "String içindeki belirli bir karakterin sayısını nasıl bulabilirim?",
    "answer": "String içindeki belirli bir karakterin sayısını bulmak için bir döngü kullanarak her karakteri kontrol edebiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"programlama\";\n    char aranan = 'a';\n    int sayac = 0;\n\n    for (int i = 0; str[i]; i++) {\n        if (str[i] == aranan) {\n            sayac++;\n        }\n    }\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", aranan, sayac);\n    return 0;\n}\n```\nBu kod, 'programlama' string'inde 'a' karakterinin kaç kez geçtiğini sayar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255564"
  },
  {
    "question": "Bir string'den belirli bir karakteri nasıl çıkarabilirim?",
    "answer": "Bir string'den belirli bir karakteri çıkarmak için karakterleri kontrol edip, istenmeyen karakterleri atlayarak yeni bir string oluşturabiliriz. Örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"merhaba\";\n    char aranan = 'a';\n    char yeniStr[100];\n    int j = 0;\n\n    for (int i = 0; str[i]; i++) {\n        if (str[i] != aranan) {\n            yeniStr[j++] = str[i];\n        }\n    }\n    yeniStr[j] = '\\0'; // Sonlandırıcı karakter ekleniyor\n    printf(\"Yeni string: %s\\n\", yeniStr);\n    return 0;\n}\n```\nBu kod, 'merhaba' string'indeki 'a' karakterlerini çıkarır ve 'merhb' olarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255586"
  },
  {
    "question": "İki string'i birleştirmenin yolu nedir?",
    "answer": "İki string'i birleştirmek için 'strcat' fonksiyonu kullanılır. Bu fonksiyon, ikinci string'i birinci string'in sonuna ekler. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = \"Merhaba \";\n    char str2[] = \"Dünya!\";\n\n    strcat(str1, str2);\n    printf(\"Birleşik string: %s\\n\", str1);\n    return 0;\n}\n```\nBu kod, 'Merhaba ' ve 'Dünya!' string'lerini birleştirerek 'Merhaba Dünya!' olarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255606"
  },
  {
    "question": "Bir string'in başında veya sonunda boşlukları nasıl temizlerim?",
    "answer": "String'in başında veya sonunda bulunan boşlukları temizlemek için 'strtrim' benzeri bir fonksiyon kullanabiliriz. Ancak C dilinde bu fonksiyon yoktur, bu yüzden kendimiz yazmalıyız. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid trim(char *str) {\n    char *end;\n    while(isspace(*str)) str++;\n    if(*str == 0) return;\n    end = str + strlen(str) - 1;\n    while(end > str && isspace(*end)) end--;\n    *(end+1) = '\\0';\n}\n\nint main() {\n    char str[] = \"   Merhaba Dünya!   \";\n    trim(str);\n    printf(\"Trimlenmiş string: '%s'\\n\", str);\n    return 0;\n}\n```\nBu kod, string'in başındaki ve sonundaki boşlukları temizler.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255630"
  },
  {
    "question": "String içindeki bir alt string'i nasıl bulabilirim?",
    "answer": "String içinde bir alt string'i bulmak için 'strstr' fonksiyonu kullanılır. Bu fonksiyon, verilen alt string'in ana string içinde nerede bulunduğunu döner. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char *altStr = \"Dünya\";\n    char *bulunan = strstr(str, altStr);\n\n    if (bulunan) {\n        printf(\"Alt string bulundu: %s\\n\", bulunan);\n    } else {\n        printf(\"Alt string bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, 'Dünya' alt string'inin 'Merhaba Dünya!' içinde bulunup bulunmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255650"
  },
  {
    "question": "Bir string'i tersine çevirmek için ne yapabilirim?",
    "answer": "Bir string'i tersine çevirmek için, string'in sonundan başlayarak karakterleri yeni bir string'e ekleyebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    int uzunluk = strlen(str);\n    char ters[100];\n\n    for (int i = 0; i < uzunluk; i++) {\n        ters[i] = str[uzunluk - 1 - i];\n    }\n    ters[uzunluk] = '\\0'; // Sonlandırıcı karakter ekleniyor\n    printf(\"Ters string: %s\\n\", ters);\n    return 0;\n}\n```\nBu kod, 'Merhaba' string'ini ters çevirerek 'abahreM' olarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255675"
  },
  {
    "question": "String içinde bir karakterin ilk bulunduğu indisi nasıl bulabilirim?",
    "answer": "String içinde bir karakterin ilk bulunduğu indisi bulmak için bir döngü kullanarak karakterleri kontrol edebiliriz. Aşağıdaki örneği inceleyelim:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"programlama\";\n    char aranan = 'r';\n    int index = -1;\n\n    for (int i = 0; str[i]; i++) {\n        if (str[i] == aranan) {\n            index = i;\n            break; // İlk bulunan indisi bulunca çık\n        }\n    }\n    if (index != -1) {\n        printf(\"'%c' karakterinin ilk bulunduğu indeks: %d\\n\", aranan, index);\n    } else {\n        printf(\"Karakter bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, 'programlama' string'inde 'r' karakterinin ilk bulunduğu indeksi ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:10:17.255699"
  },
  {
    "question": "C dilinde bir stringi ters çevirmek için hangi yöntemleri kullanabilirim?",
    "answer": "Bir stringi ters çevirmek için, önce stringin uzunluğunu bulmamız gerekiyor. Ardından, bir döngü kullanarak her karakteri ters sırayla yeni bir diziye atayabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char str[]) {\n    int uzunluk = strlen(str);\n    char ters[uzunluk + 1]; // +1 for null character\n    for (int i = 0; i < uzunluk; i++) {\n        ters[i] = str[uzunluk - i - 1];\n    }\n    ters[uzunluk] = '\\0'; // Stringin sonunu belirt\n    printf(\"Ters: %s\\n\", ters);\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    tersCevir(str);\n    return 0;\n}\n```\nBu kod, \"Merhaba Dünya\" stringini ters çevirir ve \"aynüD abahreM\" olarak ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041290"
  },
  {
    "question": "C dilinde bir string içinde belirli bir alt stringin varlığını nasıl kontrol edebilirim?",
    "answer": "Bir string içinde belirli bir alt stringin varlığını kontrol etmek için `strstr` fonksiyonunu kullanabilirsiniz. Bu fonksiyon, eğer alt string bulunursa, ilk bulduğu konumu döner, aksi takdirde NULL döner. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    char altStr[] = \"Dünya\";\n    if (strstr(str, altStr) != NULL) {\n        printf(\"Alt string bulundu!\\n\");\n    } else {\n        printf(\"Alt string bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, \"Merhaba Dünya\" içinde \"Dünya\" alt stringinin var olup olmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041336"
  },
  {
    "question": "C dilinde bir stringi küçük harfe dönüştürmek için hangi fonksiyonu kullanabilirim?",
    "answer": "Bir stringi küçük harfe dönüştürmek için `tolower` fonksiyonunu kullanabilirsiniz. Bunu gerçekleştirmek için her bir karakteri döngü ile kontrol edip, küçük harfe dönüştürüp yeni diziye atayabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid kucukHarfYap(char str[]) {\n    int uzunluk = strlen(str);\n    char kucuk[uzunluk + 1];\n    for (int i = 0; i < uzunluk; i++) {\n        kucuk[i] = tolower(str[i]);\n    }\n    kucuk[uzunluk] = '\\0';\n    printf(\"Küçük harfler: %s\\n\", kucuk);\n}\n\nint main() {\n    char str[] = \"MerHaBa DüNYa\";\n    kucukHarfYap(str);\n    return 0;\n}\n```\nBu kod, \"MerHaBa DüNYa\" stringini küçük harflere dönüştürerek \"merhaba dünya\" olarak yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041363"
  },
  {
    "question": "C dilinde iki stringi birleştirmek için nasıl bir yöntem izleyebilirim?",
    "answer": "İki stringi birleştirmek için `strcat` fonksiyonunu kullanabilirsiniz. Bu fonksiyon, bir stringi diğerinin sonuna ekler. Dikkat etmeniz gereken şey, birleştirme sonucunda oluşacak stringin yeterli belleğe sahip olmasıdır. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = \"Merhaba\";\n    char str2[] = \" Dünya\";\n    strcat(str1, str2);\n    printf(\"Birleşik String: %s\\n\", str1);\n    return 0;\n}\n```\nBu kod, \"Merhaba\" ve \" Dünya\" stringlerini birleştirerek \"Merhaba Dünya\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041387"
  },
  {
    "question": "C dilinde bir stringin belirli bir karakterle başlamasını kontrol etmek için hangi yöntemleri kullanabilirim?",
    "answer": "Bir stringin belirli bir karakterle başlayıp başlamadığını kontrol etmek için stringin ilk karakterini kontrol edebilirsiniz. Bu, `if` koşulu ile yapılabilir. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    if (str[0] == 'M') {\n        printf(\"String 'M' ile başlıyor.\\n\");\n    } else {\n        printf(\"String 'M' ile başlamıyor.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, \"Merhaba\" stringinin 'M' ile başlayıp başlamadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041417"
  },
  {
    "question": "C dilinde bir stringdeki boşlukları nasıl kaldırabilirim?",
    "answer": "Bir stringdeki boşlukları kaldırmak için, boşluk olmayan karakterleri yeni bir diziye kopyalayarak boşlukları atlayabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char str[]) {\n    char sonuc[100];\n    int j = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            sonuc[j++] = str[i];\n        }\n    }\n    sonuc[j] = '\\0';\n    printf(\"Boşluksuz: %s\\n\", sonuc);\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    boslukKaldir(str);\n    return 0;\n}\n```\nBu kod, \"Merhaba Dünya\" stringinden boşlukları kaldırarak \"MerhabaDünya\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041447"
  },
  {
    "question": "C dilinde bir stringin birden fazla kopyasını nasıl oluşturabilirim?",
    "answer": "Bir stringin birden fazla kopyasını oluşturmak için `strdup` fonksiyonunu kullanabilirsiniz. Ancak, `strdup` fonksiyonu, belleği dinamik olarak tahsis ettiği için, sonrasında `free` ile belleği serbest bırakmalısınız. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    char* kopya1 = strdup(str);\n    char* kopya2 = strdup(str);\n    printf(\"Kopya 1: %s\\n\", kopya1);\n    printf(\"Kopya 2: %s\\n\", kopya2);\n    free(kopya1);\n    free(kopya2);\n    return 0;\n}\n```\nBu kod, \"Merhaba\" stringinin iki kopyasını oluşturup ekrana bastırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041469"
  },
  {
    "question": "C dilinde bir stringin belirli bir karakterle bitip bitmediğini nasıl kontrol edebilirim?",
    "answer": "Bir stringin belirli bir karakterle bitip bitmediğini kontrol etmek için stringin son karakterine erişebilirsiniz. Stringin uzunluğunu bulup, son karakteri kontrol edebilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    if (str[strlen(str) - 1] == 'a') {\n        printf(\"String 'a' ile bitiyor.\\n\");\n    } else {\n        printf(\"String 'a' ile bitmiyor.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, \"Merhaba\" stringinin 'a' ile bitip bitmediğini kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:13.041495"
  },
  {
    "question": "C dilinde bir stringin içeriğini başka bir stringe nasıl kopyalarım?",
    "answer": "C dilinde bir stringi başka bir stringe kopyalamak için 'strcpy' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, kaynak stringin içeriğini hedef stringe kopyalar. Örneğin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char source[] = \"Merhaba\";\n    char destination[50];\n    strcpy(destination, source);\n    printf(\"Hedef string: %s\\n\", destination);\n    return 0;\n}\n```\nBurada, 'source' stringinin içeriği 'destination' stringine kopyalanmakta ve sonuç ekrana yazdırılmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141215"
  },
  {
    "question": "Bir stringin belirli bir karakterle başlayıp başlamadığını nasıl kontrol edebilirim?",
    "answer": "C dilinde bir stringin belirli bir karakterle başlayıp başlamadığını kontrol etmek için 'strncmp' fonksiyonunu kullanabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    if (strncmp(str, \"Mer\", 3) == 0) {\n        printf(\"String 'Mer' ile başlıyor.\\n\");\n    } else {\n        printf(\"String 'Mer' ile başlamıyor.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, 'str' stringinin ilk üç karakterinin \"Mer\" ile eşleşip eşleşmediği kontrol edilmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141286"
  },
  {
    "question": "Bir stringdeki tüm boşlukları nasıl kaldırabilirim?",
    "answer": "C dilinde bir stringdeki tüm boşlukları kaldırmak için bir döngü ve yeni bir string oluşturmanız gerekir. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid remove_spaces(char *str) {\n    int i, j = 0;\n    char temp[100];\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            temp[j++] = str[i];\n        }\n    }\n    temp[j] = '\\0';\n    strcpy(str, temp);\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    remove_spaces(str);\n    printf(\"Boşluksuz String: %s\\n\", str);\n    return 0;\n}\n```\nBurada, 'remove_spaces' fonksiyonu boşlukları kaldırmakta ve sonucu ekrana yazdırmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141320"
  },
  {
    "question": "C dilinde bir stringin belirli bir karakter dizisini içerip içermediğini nasıl kontrol edebilirim?",
    "answer": "C dilinde bir stringin belirli bir karakter dizisini içerip içermediğini kontrol etmek için 'strstr' fonksiyonunu kullanabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"C dilinde programlama\";\n    if (strstr(str, \"program\") != NULL) {\n        printf(\"String 'program' içeriyor.\\n\");\n    } else {\n        printf(\"String 'program' içermiyor.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, 'str' stringinin 'program' dizisini içerip içermediği kontrol edilmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141368"
  },
  {
    "question": "Bir stringin tüm karakterlerini büyük harfe dönüştürmek için ne yapmalıyım?",
    "answer": "C dilinde bir stringin tüm karakterlerini büyük harfe dönüştürmek için 'toupper' fonksiyonunu kullanarak bir döngü oluşturmalısınız. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid to_uppercase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nint main() {\n    char str[] = \"merhaba dünya\";\n    to_uppercase(str);\n    printf(\"Büyük harfli String: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda 'to_uppercase' fonksiyonu, verilen stringin tüm karakterlerini büyük harf yapmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141410"
  },
  {
    "question": "C dilinde bir stringi tersine çevirmek için nasıl bir yol izlemeliyim?",
    "answer": "C dilinde bir stringi tersine çevirmek için bir döngü kullanarak stringin son karakterinden başlayıp ilk karakterine kadar gitmelisiniz. Aşağıdaki örnek bunu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    reverse_string(str);\n    printf(\"Ters çevrilmiş String: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda 'reverse_string' fonksiyonu, verilen stringi tersine çevirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141450"
  },
  {
    "question": "C dilinde bir stringdeki tüm karakterlerin sayısını nasıl bulabilirim?",
    "answer": "C dilinde bir stringdeki tüm karakterlerin sayısını bulmak için bir döngü kullanabilirsiniz. Ancak boşlukları ve özel karakterleri de saymak istiyorsanız aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint count_characters(char *str) {\n    int count = 0;\n    while(*str) {\n        count++;\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    int character_count = count_characters(str);\n    printf(\"Toplam karakter sayısı: %d\\n\", character_count);\n    return 0;\n}\n```\nBu örnekte 'count_characters' fonksiyonu stringdeki toplam karakter sayısını döndürmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141487"
  },
  {
    "question": "Bir stringdeki bir karakterin kaç kez tekrar ettiğini nasıl bulabilirim?",
    "answer": "C dilinde bir stringdeki bir karakterin kaç kez tekrar ettiğini bulmak için bir döngü kullanmalısınız. Aşağıdaki örnek bu işlemi göstermektedir:\n\n```c\n#include <stdio.h>\n\nint count_char(char *str, char c) {\n    int count = 0;\n    while (*str) {\n        if (*str == c) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    char ch = 'a';\n    int count = count_char(str, ch);\n    printf(\"'%c' karakterinin sayısı: %d\\n\", ch, count);\n    return 0;\n}\n```\nBu kodda 'count_char' fonksiyonu, belirtilen karakterin stringde kaç kez tekrar ettiğini döndürmektedir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141549"
  },
  {
    "question": "C dilinde bir stringdeki tüm özel karakterleri nasıl kaldırabilirim?",
    "answer": "C dilinde bir stringdeki tüm özel karakterleri kaldırmak için bir döngü ile kontrol edip yeni bir string oluşturmalısınız. Aşağıdaki örnekte bu işlem gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid remove_special_characters(char *str) {\n    char temp[100];\n    int j = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isalnum(str[i])) {\n            temp[j++] = str[i];\n        }\n    }\n    temp[j] = '\\0';\n    strcpy(str, temp);\n}\n\nint main() {\n    char str[] = \"Merhaba! Dünya @2023\";\n    remove_special_characters(str);\n    printf(\"Özel karakterler kaldırıldı: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda 'remove_special_characters' fonksiyonu, stringden tüm özel karakterleri kaldırmaktadır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:11:54.141586"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan fonksiyonu nasıl yazabilirim?",
    "answer": "C dilinde bir stringin uzunluğunu hesaplamak için bir fonksiyon yazabiliriz. Aşağıdaki kod, verilen bir stringin karakter sayısını döndüren 'string_length' fonksiyonunu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint string_length(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    int length = string_length(myString);\n    printf(\"String uzunluğu: %d\\n\", length);\n    return 0;\n}\n```\nBu fonksiyon, stringin sonuna kadar (null karakterine kadar) ilerleyerek karakter sayısını hesaplar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.228819"
  },
  {
    "question": "Bir stringin tüm karakterlerini küçük harfe çeviren bir fonksiyon yazabilir misin?",
    "answer": "Elbette! Aşağıdaki kod, verilen bir stringin tüm karakterlerini küçük harfe dönüştüren 'to_lower' fonksiyonunu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid to_lower(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\nint main() {\n    char myString[] = \"Merhaba Dünya!\";\n    to_lower(myString);\n    printf(\"Küçük harfli string: %s\\n\", myString);\n    return 0;\n}\n```\nBu fonksiyon, stringin her bir karakterini dolaşarak tolower fonksiyonu ile küçük harfe çevirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.228867"
  },
  {
    "question": "Bir stringde belirli bir karakterin kaç kez geçtiğini bulan bir fonksiyon yazabilir misin?",
    "answer": "Aşağıda, bir stringde belirli bir karakterin kaç kez geçtiğini sayan 'count_char' fonksiyonu bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint count_char(const char *str, char c) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == c) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    char character = 'a';\n    int count = count_char(myString, character);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", character, count);\n    return 0;\n}\n```\nBu fonksiyon, her karakteri kontrol ederek belirtilen karakterin sayısını toplar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.228897"
  },
  {
    "question": "Bir stringi ters çeviren bir fonksiyon nasıl yazılır?",
    "answer": "Aşağıdaki kod, bir stringi tersine çeviren 'reverse_string' fonksiyonunu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse_string(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length / 2; i++) {\n        char temp = str[i];\n        str[i] = str[length - i - 1];\n        str[length - i - 1] = temp;\n    }\n}\n\nint main() {\n    char myString[] = \"Merhaba\";\n    reverse_string(myString);\n    printf(\"Tersine çevrilmiş string: %s\\n\", myString);\n    return 0;\n}\n```\nBu fonksiyon, stringin baş ve son karakterlerini yer değiştirerek çalışır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.228951"
  },
  {
    "question": "Belirli bir kelimeyi bir string içinde arayan bir fonksiyon yazabilir misin?",
    "answer": "Verilen bir string içinde belirli bir kelimeyi aramak için 'find_word' fonksiyonunu yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint find_word(const char *str, const char *word) {\n    return strstr(str, word) != NULL;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    const char *wordToFind = \"Dünya\";\n    if (find_word(myString, wordToFind)) {\n        printf(\"Kelime bulundu.\\n\");\n    } else {\n        printf(\"Kelime bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu fonksiyon, strstr fonksiyonu kullanarak kelimeyi arar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.228992"
  },
  {
    "question": "Bir stringi belirli bir karakterle ayırıp parçalara ayıran bir fonksiyon yazabilir misin?",
    "answer": "Aşağıda, bir stringi belirli bir karakterle ayıran 'split_string' fonksiyonu yer almaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid split_string(const char *str, char delimiter) {\n    char buffer[100];\n    int index = 0;\n    for (int i = 0; ; i++) {\n        if (str[i] == delimiter || str[i] == '\\0') {\n            buffer[index] = '\\0';\n            printf(\"Parça: %s\\n\", buffer);\n            index = 0;\n            if (str[i] == '\\0') break;\n        } else {\n            buffer[index++] = str[i];\n        }\n    }\n}\n\nint main() {\n    const char *myString = \"Merhaba,Dünya,Programlama\";\n    split_string(myString, ',');\n    return 0;\n}\n```\nBu fonksiyon, verilen stringi belirli bir karakterle (örneğin, virgül) ayırarak parçalarını yazdırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.229019"
  },
  {
    "question": "Bir stringin ilk harfini büyük yapmak için bir fonksiyon yazabilir misin?",
    "answer": "Aşağıdaki kod, bir stringin ilk karakterini büyük harfe çeviren 'capitalize_first' fonksiyonunu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid capitalize_first(char *str) {\n    if (str[0] != '\\0') {\n        str[0] = toupper(str[0]);\n    }\n}\n\nint main() {\n    char myString[] = \"merhaba dünya!\";\n    capitalize_first(myString);\n    printf(\"Büyük harfle başlayan string: %s\\n\", myString);\n    return 0;\n}\n```\nBu fonksiyon, stringin ilk karakterini toupper fonksiyonu ile büyük harfe çevirir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.229049"
  },
  {
    "question": "Bir string içindeki boşlukları kaldıran bir fonksiyon yazabilir misin?",
    "answer": "Aşağıda, bir string içindeki tüm boşlukları kaldıran 'remove_spaces' fonksiyonu yer almaktadır:\n\n```c\n#include <stdio.h>\n\nvoid remove_spaces(char *str) {\n    char *ptr = str;\n    while (*str != '\\0') {\n        if (*str != ' ') {\n            *ptr++ = *str;\n        }\n        str++;\n    }\n    *ptr = '\\0';\n}\n\nint main() {\n    char myString[] = \"Merhaba Dünya!  \";\n    remove_spaces(myString);\n    printf(\"Boşluklar kaldırılmış string: '%s'\\n\", myString);\n    return 0;\n}\n```\nBu fonksiyon, orijinal stringdeki boşlukları atlayarak yeni bir string oluşturur.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:12:28.229074"
  },
  {
    "question": "Bir stringin uzunluğunu bulan bir fonksiyon yazın.",
    "answer": "String uzunluğunu bulmak için bir fonksiyon yazabiliriz. Bu fonksiyon, stringin sonuna kadar gidip karakter sayısını artırarak uzunluğu hesaplayabilir. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint string_length(const char *str) {\n    int length = 0;\n    while (*str != '\\0') {\n        length++;\n        str++;\n    }\n    return length;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    printf(\"Uzunluk: %d\\n\", string_length(myString));\n    return 0;\n}\n```\nBu fonksiyon, verilen stringin her bir karakterini sayarak toplam uzunluğu döndürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030177"
  },
  {
    "question": "İki stringi birleştiren bir fonksiyon yazın.",
    "answer": "İki stringi birleştirmek için bellek tahsis etmemiz ve her iki stringin karakterlerini yeni bir stringe kopyalamamız gerekecek. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* string_concat(const char *str1, const char *str2) {\n    int len1 = string_length(str1);\n    int len2 = string_length(str2);\n    char *result = malloc(len1 + len2 + 1);\n    if (result == NULL) return NULL;\n    while (*str1) {\n        *result++ = *str1++;\n    }\n    while (*str2) {\n        *result++ = *str2++;\n    }\n    *result = '\\0';\n    return result - (len1 + len2);\n}\n\nint main() {\n    char *result = string_concat(\"Merhaba\", \" Dünya!\");\n    printf(\"Birleştirilmiş String: %s\\n\", result);\n    free(result);\n    return 0;\n}\n```\nBu fonksiyon, iki string alır, birleştirir ve yeni bir string döner.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030213"
  },
  {
    "question": "Bir stringin belirli bir karakterle kaç kez tekrarlandığını bulan bir fonksiyon yazın.",
    "answer": "Belirli bir karakterin bir stringdeki tekrarını bulmak için stringi karakter karakter kontrol edebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint count_char(const char *str, char ch) {\n    int count = 0;\n    while (*str) {\n        if (*str == ch) count++;\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    char character = 'a';\n    printf(\"'%c' karakterinin tekrarı: %d\\n\", character, count_char(myString, character));\n    return 0;\n}\n```\nBu fonksiyon, verilen karakterin stringde kaç kez geçtiğini sayar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030253"
  },
  {
    "question": "Bir stringdeki tüm küçük harfleri büyük harflere dönüştüren bir fonksiyon yazın.",
    "answer": "Küçük harfleri büyük harflere dönüştürmek için her karakteri kontrol edip, küçükse büyük harfiyle değiştirebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* to_upper(const char *str) {\n    char *result = malloc(string_length(str) + 1);\n    char *ptr = result;\n    while (*str) {\n        *ptr++ = (*str >= 'a' && *str <= 'z') ? *str - 32 : *str;\n        str++;\n    }\n    *ptr = '\\0';\n    return result;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    char *upperString = to_upper(myString);\n    printf(\"Büyük harfli String: %s\\n\", upperString);\n    free(upperString);\n    return 0;\n}\n```\nBu fonksiyon, verilen stringin tüm küçük harflerini büyük harflere dönüştürerek yeni bir string döndürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030285"
  },
  {
    "question": "Bir stringin başındaki ve sonundaki boşlukları temizleyen bir fonksiyon yazın.",
    "answer": "Stringin başındaki ve sonundaki boşlukları temizlemek için, önce baştaki boşlukları atlayıp, sonra sonundaki boşlukları atlayabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* trim(const char *str) {\n    while (*str == ' ') str++;\n    const char *end = str + string_length(str) - 1;\n    while (end > str && *end == ' ') end--;\n    char *result = malloc(end - str + 2);\n    char *ptr = result;\n    while (str <= end) {\n        *ptr++ = *str++;\n    }\n    *ptr = '\\0';\n    return result;\n}\n\nint main() {\n    const char *myString = \"   Merhaba Dünya!   \";\n    char *trimmedString = trim(myString);\n    printf(\"Temizlenmiş String: '%s'\\n\", trimmedString);\n    free(trimmedString);\n    return 0;\n}\n```\nBu fonksiyon, verilen stringin başındaki ve sonundaki boşlukları temizler.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030310"
  },
  {
    "question": "Bir stringin tersini döndüren bir fonksiyon yazın.",
    "answer": "Stringin tersini döndürmek için, stringin sonundan başlayarak yeni bir string oluşturabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* reverse_string(const char *str) {\n    int len = string_length(str);\n    char *reversed = malloc(len + 1);\n    for (int i = 0; i < len; i++) {\n        reversed[i] = str[len - 1 - i];\n    }\n    reversed[len] = '\\0';\n    return reversed;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    char *reversedString = reverse_string(myString);\n    printf(\"Ters String: %s\\n\", reversedString);\n    free(reversedString);\n    return 0;\n}\n```\nBu fonksiyon, verilen stringin tersini döndürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030329"
  },
  {
    "question": "Bir stringin içinde başka bir stringin bulunup bulunmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "Bir stringin içinde başka bir stringin bulunup bulunmadığını kontrol etmek için iki stringi karşılaştırabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint contains(const char *str, const char *substr) {\n    while (*str) {\n        const char *p1 = str;\n        const char *p2 = substr;\n        while (*p1 && *p2 && *p1 == *p2) {\n            p1++;\n            p2++;\n        }\n        if (!*p2) return 1;\n        str++;\n    }\n    return 0;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    const char *substring = \"Dünya\";\n    if (contains(myString, substring)) {\n        printf(\"String içinde '%s' bulundu.\\n\", substring);\n    } else {\n        printf(\"String içinde '%s' bulunamadı.\\n\", substring);\n    }\n    return 0;\n}\n```\nBu fonksiyon, belirli bir substringin ana string içinde bulunup bulunmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030357"
  },
  {
    "question": "Bir stringdeki tüm sesli harfleri kaldıran bir fonksiyon yazın.",
    "answer": "Sesli harfleri kaldırmak için her karakteri kontrol edip, sesli harf değilse yeni bir stringe ekleyebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint is_vowel(char ch) {\n    return (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U');\n}\n\nchar* remove_vowels(const char *str) {\n    char *result = malloc(string_length(str) + 1);\n    char *ptr = result;\n    while (*str) {\n        if (!is_vowel(*str)) {\n            *ptr++ = *str;\n        }\n        str++;\n    }\n    *ptr = '\\0';\n    return result;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya!\";\n    char *noVowelsString = remove_vowels(myString);\n    printf(\"Sesli harfler çıkarıldığında: %s\\n\", noVowelsString);\n    free(noVowelsString);\n    return 0;\n}\n```\nBu fonksiyon, verilen stringdeki sesli harfleri kaldırarak yeni bir string döndürür.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030380"
  },
  {
    "question": "Bir stringin içinde belirli bir kelimenin kaç kez geçtiğini bulan bir fonksiyon yazın.",
    "answer": "Belirli bir kelimenin kaç kez geçtiğini bulmak için stringi tarayıp, her seferinde kelimeyi kontrol edebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint count_word(const char *str, const char *word) {\n    int count = 0;\n    const char *p = str;\n    while (*p) {\n        const char *p1 = p;\n        const char *p2 = word;\n        while (*p1 && *p2 && *p1 == *p2) {\n            p1++;\n            p2++;\n        }\n        if (!*p2) count++;\n        p++;\n    }\n    return count;\n}\n\nint main() {\n    const char *myString = \"Merhaba Dünya! Dünya harika bir yer!\";\n    const char *word = \"Dünya\";\n    printf(\"'%s' kelimesinin tekrarı: %d\\n\", word, count_word(myString, word));\n    return 0;\n}\n```\nBu fonksiyon, verilen kelimenin string içinde kaç kez geçtiğini sayar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:13:18.030405"
  },
  {
    "question": "C dilinde bir stringin içindeki tüm büyük harfleri küçük harfe dönüştüren bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'toLowerCase' fonksiyonu, verilen bir stringin içindeki tüm büyük harfleri küçük harfe dönüştürmektedir. Öncelikle stringin her bir karakterini kontrol eder, eğer karakter büyük harf ise onu küçük harfe çevirir ve yeni bir string oluşturur.\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid toLowerCase(char *str) {\n    for (int i = 0; str[i]; i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba DÜNYA!\";\n    toLowerCase(str);\n    printf(\"Küçük harfler: %s\\n\", str);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341133"
  },
  {
    "question": "İki stringin birbirinin anagramı olup olmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'areAnagrams' fonksiyonu, iki stringin anagram olup olmadığını kontrol eder. İlk olarak, her iki stringin uzunlukları kontrol edilir. Eğer uzunlukları eşit değilse anagram olamazlar. Daha sonra her iki stringin karakter frekansları bir dizi kullanılarak hesaplanır ve karşılaştırılır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint areAnagrams(char *str1, char *str2) {\n    int count[256] = {0};\n    if (strlen(str1) != strlen(str2)) return 0;\n    for (int i = 0; str1[i] && str2[i]; i++) {\n        count[str1[i]]++;\n        count[str2[i]]--;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (count[i] != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char str1[] = \"listen\";\n    char str2[] = \"silent\";\n    if (areAnagrams(str1, str2))\n        printf(\"Anagramdırlar.\\n\");\n    else\n        printf(\"Anagram değillerdir.\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341178"
  },
  {
    "question": "Bir stringin palindrom olup olmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'isPalindrome' fonksiyonu, verilen bir stringin palindrom olup olmadığını kontrol eder. Fonksiyon, stringin başından ve sonundan ilerleyerek karakterlerin eşit olup olmadığını kontrol eder.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int left = 0;\n    int right = strlen(str) - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return 0;\n        left++;\n        right--;\n    }\n    return 1;\n}\n\nint main() {\n    char str[] = \"racecar\";\n    if (isPalindrome(str))\n        printf(\"Palindromdur.\\n\");\n    else\n        printf(\"Palindrom değildir.\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341202"
  },
  {
    "question": "Bir stringin içinde belirli bir karakterin kaç kez geçtiğini bulan bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'countChar' fonksiyonu, verilen bir stringdeki belirli bir karakterin kaç kez geçtiğini bulur. Fonksiyon, stringin her karakterini kontrol ederek sayımı yapar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint countChar(char *str, char ch) {\n    int count = 0;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] == ch) count++;\n    }\n    return count;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char ch = 'a';\n    int count = countChar(str, ch);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", ch, count);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341230"
  },
  {
    "question": "Bir stringin içindeki tüm boşlukları kaldıran bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'removeSpaces' fonksiyonu, verilen bir stringin içindeki tüm boşlukları kaldırarak yeni bir string oluşturur. Yeni stringe boşluk olmayan karakterler eklenir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpaces(char *str) {\n    int j = 0;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] != ' ') {\n            str[j++] = str[i];\n        }\n    }\n    str[j] = '\\0';\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    removeSpaces(str);\n    printf(\"Boşluksuz: %s\\n\", str);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341252"
  },
  {
    "question": "Bir stringin içindeki tüm harflerin sıklığını döndüren bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'charFrequency' fonksiyonu, verilen bir stringdeki her bir karakterin sıklığını hesaplar ve sonuçları yazdırır. Karakter sıklığı, bir dizi kullanılarak saklanır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid charFrequency(char *str) {\n    int count[256] = {0};\n    for (int i = 0; str[i]; i++) {\n        count[str[i]]++;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (count[i] > 0) {\n            printf(\"'%c': %d\\n\", i, count[i]);\n        }\n    }\n}\n\nint main() {\n    char str[] = \"hello world\";\n    charFrequency(str);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341276"
  },
  {
    "question": "Bir stringi tersine çeviren bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'reverseString' fonksiyonu, verilen bir stringi tersine çevirir. Fonksiyon, baştan ve sondan karakterleri değiştirerek yeni bir string oluşturur.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    reverseString(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341298"
  },
  {
    "question": "Belirli bir stringin içinde başka bir stringin bulunup bulunmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'containsSubstring' fonksiyonu, verilen bir stringin içinde belirli bir alt stringin mevcut olup olmadığını kontrol eder. Fonksiyon, 'strstr' fonksiyonu kullanarak alt stringin konumunu kontrol eder.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint containsSubstring(char *str, char *subStr) {\n    return strstr(str, subStr) != NULL;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    char subStr[] = \"Dünya\";\n    if (containsSubstring(str, subStr))\n        printf(\"Alt string mevcut.\\n\");\n    else\n        printf(\"Alt string mevcut değil.\\n\");\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341327"
  },
  {
    "question": "Bir stringi belirli bir karakterle ayırarak yeni bir string dizisi oluşturan bir fonksiyon yaz.",
    "answer": "Aşağıdaki 'splitString' fonksiyonu, verilen bir stringi belirli bir ayırıcı karakterle ayırarak yeni bir string dizisi oluşturmaktadır. Fonksiyon, 'strtok' fonksiyonunu kullanarak kelimeleri ayırır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid splitString(char *str, char delim) {\n    char *token = strtok(str, &delim);\n    while (token != NULL) {\n        printf(\"%s\\n\", token);\n        token = strtok(NULL, &delim);\n    }\n}\n\nint main() {\n    char str[] = \"C,Python,Java\";\n    splitString(str, ',');\n    return 0;\n}\n```",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:02.341355"
  },
  {
    "question": "Bir stringin uzunluğunu bulmak için kendi fonksiyonunuzu nasıl yazarsınız?",
    "answer": "C dilinde bir stringin uzunluğunu bulmak için aşağıdaki gibi bir fonksiyon yazabilirsiniz. Bu fonksiyon, stringin sonundaki null karakterine kadar karakter sayar.\n\n```c\nint string_length(const char *str) {\n    int length = 0;\n    while (*str++) {\n        length++;\n    }\n    return length;\n}\n```\n\nBu kodda, `while` döngüsü stringin her bir karakterini kontrol eder ve her karakter için `length` değişkenini bir artırır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377317"
  },
  {
    "question": "Bir stringi ters çevirmek için bir fonksiyon yazın. Optimizasyon önerileriniz var mı?",
    "answer": "Stringi ters çevirmek için aşağıdaki gibi bir fonksiyon yazabilirsiniz. Bu fonksiyon bir dizi kullanarak stringi tersine çevirir.\n\n```c\nvoid reverse_string(char *str) {\n    int length = string_length(str);\n    for (int i = 0; i < length / 2; i++) {\n        char temp = str[i];\n        str[i] = str[length - i - 1];\n        str[length - i - 1] = temp;\n    }\n}\n```\n\nOptimizasyon olarak, `string_length` fonksiyonunu her çağırmak yerine bir defa çağırıp sonucu bir değişkende saklayabilirsiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377362"
  },
  {
    "question": "Stringde belirli bir karakterin sayısını sayan bir fonksiyon yazın. Performans iyileştirmeleri önerin.",
    "answer": "Aşağıdaki fonksiyon, verilen bir stringde belirli bir karakterin sayısını hesaplar:\n\n```c\nint count_char(const char *str, char c) {\n    int count = 0;\n    while (*str) {\n        if (*str == c) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n```\n\nPerformans iyileştirmesi olarak, stringin uzunluğuna bağlı olarak sadece bir döngü ile sayımı yaparak zaman karmaşıklığını O(n) düzeyinde tutmuş oluyorsunuz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377392"
  },
  {
    "question": "İki stringin eşit olup olmadığını kontrol eden bir fonksiyon yazın. Hata yönetimi ekleyin.",
    "answer": "Aşağıdaki gibi bir fonksiyon, iki stringin eşitliğini kontrol eder:\n\n```c\nint strings_equal(const char *str1, const char *str2) {\n    if (str1 == NULL || str2 == NULL) {\n        return 0; // null kontrolü\n    }\n    while (*str1 && (*str1 == *str2)) {\n        str1++;\n        str2++;\n    }\n    return *str1 == *str2;\n}\n```\n\nHata yönetimi için, null kontrolü ekleyerek olası erişim hatalarını önlüyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377423"
  },
  {
    "question": "Bir stringin içinde başka bir stringin olup olmadığını kontrol eden bir fonksiyon yazın. Performansı artırmak için önerilerde bulunun.",
    "answer": "Aşağıdaki fonksiyon, bir string içinde başka bir stringin varlığını kontrol eder:\n\n```c\nint contains_substring(const char *str, const char *substr) {\n    if (!str || !substr) return 0;\n    while (*str) {\n        const char *p1 = str;\n        const char *p2 = substr;\n        while (*p1 && *p2 && (*p1 == *p2)) {\n            p1++;\n            p2++;\n        }\n        if (!*p2) return 1; // alt string bulundu\n        str++;\n    }\n    return 0;\n}\n```\n\nPerformansı artırmak için, arama işlemini `strstr` gibi yerleşik fonksiyonlar kullanarak optimize edebilirsiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377460"
  },
  {
    "question": "Stringdeki tüm boşlukları kaldırmak için bir fonksiyon yazın. Kodunuzu nasıl optimize edersiniz?",
    "answer": "Aşağıdaki fonksiyon, stringdeki tüm boşlukları kaldırır:\n\n```c\nvoid remove_spaces(char *str) {\n    char *out = str;\n    while (*str) {\n        if (*str != ' ') {\n            *out++ = *str;\n        }\n        str++;\n    }\n    *out = '\\0'; // yeni son karakteri ekle\n}\n```\n\nBu kodda, bir 'out' pointer kullanarak boşluk olmayan karakterleri doğrudan yeni pozisyona kopyalıyoruz. Bu sayede ekstra bellek kullanımı önlenmiş olur.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377501"
  },
  {
    "question": "Bir stringin tüm harflerini büyük harfe dönüştüren bir fonksiyon yazın. Hata yönetimi ekleyin.",
    "answer": "Aşağıdaki fonksiyon, verilen bir stringin tüm harflerini büyük harfe dönüştürür:\n\n```c\nvoid to_uppercase(char *str) {\n    if (!str) return; // null kontrolü\n    while (*str) {\n        if (*str >= 'a' && *str <= 'z') {\n            *str -= 32; // ASCII dönüşümü\n        }\n        str++;\n    }\n}\n```\n\nHata yönetimi olarak, stringin null olup olmadığını kontrol ettik.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377550"
  },
  {
    "question": "Stringdeki tüm karakterlerin frekansını hesaplayan bir fonksiyon yazın. Verimliliği artırmanın yolları nelerdir?",
    "answer": "Aşağıdaki fonksiyon, stringdeki karakterlerin frekansını hesaplar:\n\n```c\nvoid char_frequency(const char *str) {\n    int freq[256] = {0}; // ASCII karakter seti\n    while (*str) {\n        freq[(unsigned char)*str]++;\n        str++;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (freq[i] > 0) {\n            printf(\"Karakter: %c, Frekans: %d\\n\", i, freq[i]);\n        }\n    }\n}\n```\n\nVerimliliği artırmak için, tek bir geçiş ile frekansları topladık. Bu sayede O(n) zaman karmaşıklığında çalışır.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377580"
  },
  {
    "question": "Bir stringin başına ve sonuna char ekleyen bir fonksiyon yazın. Bellek yönetimi konusunda önerilerde bulunun.",
    "answer": "Aşağıdaki fonksiyon, bir stringin başına ve sonuna belirtilen bir karakter ekler:\n\n```c\nchar* add_char_to_ends(const char *str, char c) {\n    if (!str) return NULL;\n    int length = string_length(str);\n    char *new_str = malloc(length + 3); // 2 char + null\n    if (!new_str) return NULL; // bellek kontrolü\n    new_str[0] = c;\n    strcpy(new_str + 1, str);\n    new_str[length + 1] = c;\n    new_str[length + 2] = '\\0';\n    return new_str;\n}\n```\n\nBellek yönetimi açısından, `malloc` kullanarak yeni bir string için yeterli bellek ayırdık; ayrıca bellek kontrolü de sağladık.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377612"
  },
  {
    "question": "Bir stringin içindeki tüm küçük harfleri büyük harfe çeviren ve aynı stringi kullanarak işlemi gerçekleştiren bir fonksiyon yazın. Performans iyileştirmesi önerin.",
    "answer": "Aşağıdaki fonksiyon, stringin içindeki tüm küçük harfleri büyük harfe çevirir:\n\n```c\nvoid convert_to_uppercase_in_place(char *str) {\n    if (!str) return; // null kontrolü\n    while (*str) {\n        if (*str >= 'a' && *str <= 'z') {\n            *str = *str - 32; // ASCII dönüşümü\n        }\n        str++;\n    }\n}\n```\n\nPerformans iyileştirmesi olarak, stringdeki her karakteri tek bir döngüde kontrol ederek ve dönüştürerek, ekstra bellek kullanımı olmadan işlemi gerçekleştiriyoruz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:14:36.377654"
  },
  {
    "question": "Bir C programında, iki string değişkenin içeriklerini birleştirmek için hangi fonksiyonu kullanmalıyım ve bunun performansını nasıl artırabilirim?",
    "answer": "C dilinde string birleştirmek için 'strcat' fonksiyonunu kullanabilirsiniz. Ancak, bu fonksiyon hedef string'in boyutunu aşabilir ve bellek hatalarına yol açabilir. Bunun yerine 'snprintf' fonksiyonunu kullanarak birleştirme işlemini güvenli bir şekilde yapabilirsiniz. Örnek: \n\n```c\nchar dest[100];\nchar src1[] = \"Hello, \";\nchar src2[] = \"World!\";\nsnprintf(dest, sizeof(dest), \"%s%s\", src1, src2);\n``` \nBu yöntemle, hedef buffer'ın boyutunu aşmamış olursunuz ve potansiyel hataları önleyebilirsiniz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726818"
  },
  {
    "question": "C dilinde bir stringi ters çevirmek için en etkili yöntem nedir?",
    "answer": "Bir stringi ters çevirmek için en etkili yöntem, baştan ve sondan iki işaretçi kullanarak swap yapmaktır. Bu yöntem O(n) zaman karmaşıklığına sahiptir. Örnek: \n\n```c\nvoid reverse_string(char *str) {\n    int start = 0;\n    int end = strlen(str) - 1;\n    while (start < end) {\n        char temp = str[start];\n        str[start] = str[end];\n        str[end] = temp;\n        start++;\n        end--;\n    }\n}\n``` \nBu fonksiyon, orijinal string üzerinde çalışır ve ekstra bellek kullanmadan ters çevirme işlemi yapar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726861"
  },
  {
    "question": "Bir string içindeki belirli bir karakterin sayısını bulmak için hangi yöntemi kullanmalıyım?",
    "answer": "Bir string içindeki belirli bir karakterin sayısını bulmak için döngü kullanarak her karakteri kontrol edebilirsiniz. O(n) zaman karmaşıklığına sahiptir. Örnek: \n\n```c\nint count_char(const char *str, char c) {\n    int count = 0;\n    while (*str) {\n        if (*str == c) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n``` \nBu fonksiyon, verilen karakterin toplam sayısını dönerken stringin sonuna kadar gider.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726895"
  },
  {
    "question": "C dilinde iki stringin eşit olup olmadığını kontrol ederken dikkat edilmesi gerekenler nelerdir?",
    "answer": "İki stringin eşit olup olmadığını kontrol etmek için 'strcmp' fonksiyonunu kullanmalısınız. Ancak, bu fonksiyonu kullanırken NULL kontrolü yapmayı unutmayın. Örnek: \n\n```c\nif (str1 != NULL && str2 != NULL && strcmp(str1, str2) == 0) {\n    printf(\"Stringler eşit.\");\n} else {\n    printf(\"Stringler eşit değil.\");\n}\n``` \nBu şekilde, NULL pointer'lar ile karşılaşma riskini ortadan kaldırmış olursunuz.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726923"
  },
  {
    "question": "C dilinde bir stringdeki kelimeleri saymak için etkili bir yöntem var mı?",
    "answer": "Stringdeki kelimeleri saymak için boşluk karakterlerini arayarak kelimeleri ayırabiliriz. Bir kelime başı ve sonunu kontrol ederek O(n) zaman karmaşıklığı ile yapabilirsiniz. Örnek: \n\n```c\nint word_count(const char *str) {\n    int count = 0;\n    int in_word = 0;\n    while (*str) {\n        if (isspace(*str)) {\n            in_word = 0;\n        } else if (in_word == 0) {\n            in_word = 1;\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n``` \nBu fonksiyon, kelimeleri doğru bir şekilde sayar.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726949"
  },
  {
    "question": "C dilinde bir stringin başındaki ve sonundaki boşlukları temizlemek için hangi yöntemi kullanmalıyım?",
    "answer": "Bir stringin başındaki ve sonundaki boşlukları temizlemek için iki işaretçi kullanarak baş ve son pozisyonlarını bulabilirsiniz. Örnek: \n\n```c\nchar* trim_whitespace(char *str) {\n    char *end;\n    while (isspace((unsigned char)*str)) str++;\n    end = str + strlen(str) - 1;\n    while (end > str && isspace((unsigned char)*end)) end--;\n    *(end + 1) = '\\0';\n    return str;\n}\n``` \nBu fonksiyon, stringin başındaki ve sonundaki boşlukları temizlerken orijinal stringin içeriğini kaybetmez.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.726978"
  },
  {
    "question": "C dilinde bir string içinde başka bir stringin varlığını kontrol etmek için hangi yöntemi kullanmalıyım?",
    "answer": "Bir string içinde başka bir stringin varlığını kontrol etmek için 'strstr' fonksiyonunu kullanabilirsiniz. Ancak, kendi implementasyonunuzu da yazmak isteyebilirsiniz. Örnek: \n\n```c\nchar* custom_strstr(const char *haystack, const char *needle) {\n    if (!*needle) return (char *)haystack;\n    for (; *haystack; haystack++) {\n        if (*haystack == *needle) {\n            const char *h = haystack, *n = needle;\n            while (*h && *n && *h == *n) {\n                h++;\n                n++;\n            }\n            if (!*n) return (char *)haystack;\n        }\n    }\n    return NULL;\n}\n``` \nBu fonksiyon, belirtilen string içinde aranan stringin olup olmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.727008"
  },
  {
    "question": "C dilinde bir stringin tüm harflerini büyük harfe dönüştürmek için nasıl bir yöntem kullanmalıyım?",
    "answer": "Bir stringin tüm harflerini büyük harfe dönüştürmek için 'toupper' fonksiyonunu kullanarak döngü ile her karakteri kontrol edebilirsiniz. Örnek: \n\n```c\nvoid to_uppercase(char *str) {\n    while (*str) {\n        *str = toupper((unsigned char)*str);\n        str++;\n    }\n}\n``` \nBu fonksiyon, verilen stringi büyük harflerle değiştirmek için etkili bir yöntemdir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.727036"
  },
  {
    "question": "C dilinde bir stringin uzunluğunu bulurken hangi yöntemleri kullanmalıyım?",
    "answer": "String uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabilirsiniz. Ancak, kendi implementasyonunuzu da yazabilirsiniz. Örnek: \n\n```c\nsize_t custom_strlen(const char *str) {\n    const char *s = str;\n    while (*s) s++;\n    return s - str;\n}\n``` \nBu fonksiyon, stringin uzunluğunu O(n) zaman karmaşıklığı ile bulur.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.727059"
  },
  {
    "question": "C dilinde bir string içinde belirli bir substringi değiştirmek istiyorum, bunu nasıl yapabilirim?",
    "answer": "Bir string içinde belirli bir substringi değiştirmek için, önce aradığınız substringin yerini bulmalı, ardından bu kısmı yeni stringle değiştirmelisiniz. Örnek: \n\n```c\nchar* replace_substring(const char *str, const char *old, const char *new) {\n    char *result;\n    int i, count = 0;\n    int newlen = strlen(new);\n    int oldlen = strlen(old);\n    for (i = 0; str[i]; i++) {\n        if (strstr(&str[i], old) == &str[i]) {\n            count++;\n            i += oldlen - 1;\n        }\n    }\n    result = (char *)malloc(i + count * (newlen - oldlen) + 1);\n    i = 0;\n    while (*str) {\n        if (strstr(str, old) == str) {\n            strcpy(&result[i], new);\n            i += newlen;\n            str += oldlen;\n        } else {\n            result[i++] = *str++;\n        }\n    }\n    result[i] = '\\0';\n    return result;\n}\n``` \nBu fonksiyon, belirtilen substringi bulup değiştirir. Bellek yönetimine dikkat etmek önemlidir.",
    "category": "arrays_strings",
    "topic": "string_functions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "String fonksiyonları",
    "timestamp": "2025-06-01T15:15:15.727086"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin uzunluğunu bulan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n\n    // Kelimenin uzunluğunu bulmak için strlen kullanıyoruz.\n    int uzunluk = strlen(kelime) - 1; // '\n' karakterini saymamak için -1 yaptık.\n    printf(\"Kelimenin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği kelimenin uzunluğunu hesaplar. 'fgets' ile girdi alırken sonuna eklenen '\n' karakterini saymamak için 'strlen' sonucundan 1 çıkarıyoruz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591396"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki boşluk karakterlerinin sayısını bulan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[200];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n\n    int boslukSayisi = 0;\n    for (int i = 0; i < strlen(cumle); i++) {\n        if (cumle[i] == ' ') {\n            boslukSayisi++;\n        }\n    }\n    printf(\"Cümlede bulunan boşluk sayısı: %d\\n\", boslukSayisi);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir cümle alır ve içinde bulunan boşluk karakterlerini sayar. 'for' döngüsü ile her bir karakter kontrol edilerek boşluklar sayılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591467"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin tersini bulan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n\n    // Ters kelimeyi depolamak için bir dizi tanımlıyoruz.\n    int uzunluk = strlen(kelime);\n    char tersKelime[100];\n\n    for (int i = 0; i < uzunluk - 1; i++) { // -1, '\n' için\n        tersKelime[i] = kelime[uzunluk - 2 - i];\n    }\n    tersKelime[uzunluk - 1] = '\\0'; // Dizi sonlandırma\n\n    printf(\"Ters kelime: %s\\n\", tersKelime);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği kelimeyi tersine çevirir. 'for' döngüsü ile kelimenin sonuna kadar gidilir ve her karakter ters sırada yeni dizide saklanır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591526"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki tüm karakterlerin büyük harf ile yazılmasını sağlayan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char cumle[200];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n\n    for (int i = 0; cumle[i] != '\\0'; i++) {\n        cumle[i] = toupper(cumle[i]);\n    }\n    printf(\"Büyük harflerle: %s\\n\", cumle);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği cümledeki tüm karakterleri büyük harfe çevirir. 'toupper' fonksiyonu ile her karakter kontrol edilerek büyük harfi elde edilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591584"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin içinde 'a' harfinin kaç kez geçtiğini bulan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n\n    int aSayisi = 0;\n    for (int i = 0; i < strlen(kelime); i++) {\n        if (kelime[i] == 'a' || kelime[i] == 'A') {\n            aSayisi++;\n        }\n    }\n    printf(\"'a' harfi %d kez geçiyor.\\n\", aSayisi);\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan kelimede 'a' veya 'A' harflerinin sayısını bulur. 'if' koşulu ile her bir karakter kontrol edilerek sayım yapılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591637"
  },
  {
    "question": "Kullanıcının girdiği bir kelimenin ilk ve son harfini değiştiren C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n\n    // İlk ve son harfleri değiştirmek için geçici değişkenler kullanıyoruz.\n    char ilkHarf = kelime[0];\n    char sonHarf = kelime[strlen(kelime) - 2]; // '\n' için -2\n    kelime[0] = sonHarf;\n    kelime[strlen(kelime) - 2] = ilkHarf;\n\n    printf(\"Değiştirilmiş kelime: %s\\n\", kelime);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği kelimenin ilk ve son harflerini değiştirir. Geçici değişkenler ile harfler saklanır ve dizide yerleri değiştirilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591771"
  },
  {
    "question": "Bir kelimenin içinde 'b' harfi varsa, bu kelimeyi 'bulundu' olarak değiştiren C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime[100];\n    printf(\"Bir kelime girin: \");\n    fgets(kelime, sizeof(kelime), stdin);\n\n    if (strchr(kelime, 'b') != NULL) {\n        strcpy(kelime, \"bulundu\");\n    }\n    printf(\"Kelime: %s\\n\", kelime);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği kelimede 'b' harfi olup olmadığını kontrol eder. Eğer varsa, kelime 'bulundu' olarak değiştirilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591836"
  },
  {
    "question": "Kullanıcının girdiği iki kelimeyi birleştirip ekrana yazan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kelime1[100];\n    char kelime2[100];\n    char birlesikKelime[200];\n\n    printf(\"Birinci kelimeyi girin: \");\n    fgets(kelime1, sizeof(kelime1), stdin);\n    printf(\"İkinci kelimeyi girin: \");\n    fgets(kelime2, sizeof(kelime2), stdin);\n\n    // Birleştirme işlemi\n    strcpy(birlesikKelime, kelime1);\n    strcat(birlesikKelime, kelime2);\n\n    printf(\"Birleşik kelime: %s\\n\", birlesikKelime);\n    return 0;\n}\n\n// Bu kod, iki kelime alır ve bunları birleştirerek ekrana yazdırır. 'strcpy' ve 'strcat' fonksiyonları ile birleştirme yapılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591880"
  },
  {
    "question": "Bir cümledeki tüm harflerin sayısını bulan C kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char cumle[200];\n    printf(\"Bir cümle girin: \");\n    fgets(cumle, sizeof(cumle), stdin);\n\n    int harfSayisi = 0;\n    for (int i = 0; i < strlen(cumle); i++) {\n        if (isalpha(cumle[i])) {\n            harfSayisi++;\n        }\n    }\n    printf(\"Cümlede toplam %d harf var.\\n\", harfSayisi);\n    return 0;\n}\n\n// Bu kod, kullanıcının girdiği cümledeki harflerin sayısını hesaplar. 'isalpha' fonksiyonu ile her karakter kontrol edilerek harf sayısı artırılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:15:47.591932"
  },
  {
    "question": "Kullanıcının girdiği bir stringin uzunluğunu hesaplayacak bir fonksiyon yazınız. Kodun eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint stringUzunlugu(char str[]) {\n    return strlen(str);\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"Girilen metnin uzunluğu: %d\\n\", stringUzunlugu(metin));\n    return 0;\n}\n\n// Açıklama: Bu kodda, kullanıcının girdiği metnin uzunluğunu hesaplamak için stringUzunlugu fonksiyonu strlen() fonksiyonunu kullanarak çalışmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978569"
  },
  {
    "question": "Bir karakter dizisini tersine çevirecek bir fonksiyon yazınız. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char str[]) {\n    int uzunluk = strlen(str);\n    for(int i = 0; i < uzunluk / 2; i++) {\n        char temp = str[i];\n        str[i] = str[uzunluk - i - 1];\n        str[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    tersCevir(metin);\n    printf(\"Tersine çevrilmiş metin: %s\", metin);\n    return 0;\n}\n\n// Açıklama: Bu kod, girilen bir metni tersine çeviren bir fonksiyon içermektedir. Ters çevirme işlemi döngü ile gerçekleştirilmiştir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978613"
  },
  {
    "question": "Kullanıcının girdiği bir dizi içindeki en fazla tekrar eden karakteri bulacak bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nchar enFazlaTekrarEden(char str[]) {\n    int sayi[256] = {0};\n    int enFazla = 0;\n    char karakter = ' ';\n    for(int i = 0; str[i]; i++) {\n        sayi[(int)str[i]]++;\n        if(sayi[(int)str[i]] > enFazla) {\n            enFazla = sayi[(int)str[i]];\n            karakter = str[i];\n        }\n    }\n    return karakter;\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"En fazla tekrar eden karakter: %c\\n\", enFazlaTekrarEden(metin));\n    return 0;\n}\n\n// Açıklama: Bu kod, bir karakter dizisindeki en fazla tekrar eden karakteri bulmak için bir dizi kullanarak sayım yapmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978652"
  },
  {
    "question": "Bir karakter dizisindeki tüm büyük harfleri küçük harfe çeviren bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid buyukHarfleriKucult(char str[]) {\n    for(int i = 0; str[i]; i++) {\n        if(str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] = str[i] + 32;\n        }\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    buyukHarfleriKucult(metin);\n    printf(\"Küçük harflere çevrilmiş metin: %s\", metin);\n    return 0;\n}\n\n// Açıklama: Bu kod, büyük harfleri küçük harflere çevirmek için ASCII değerleri kullanarak basit bir dönüşüm gerçekleştirmektedir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978685"
  },
  {
    "question": "Bir karakter dizisinin başındaki ve sonundaki boşlukları silen bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid boslukSil(char str[]) {\n    int i;\n    int uzunluk = strlen(str);\n\n    // Başındaki boşlukları sil\n    for(i = 0; i < uzunluk && str[i] == ' '; i++);\n\n    // Sonundaki boşlukları sil\n    while(uzunluk > i && str[uzunluk - 1] == ' ')\n        uzunluk--;\n\n    str[uzunluk] = '\\0';\n    memmove(str, str + i, uzunluk - i + 1);\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    boslukSil(metin);\n    printf(\"Boşluklar silinmiş metin: '%s'\\n\", metin);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir dizinin başındaki ve sonundaki boşlukları temizlemek için iki ayrı döngü kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978715"
  },
  {
    "question": "Kullanıcının girdiği bir stringin içinde belirli bir karakterin sayısını bulan bir fonksiyon yazınız. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint karakterSay(char str[], char ch) {\n    int sayac = 0;\n    for(int i = 0; str[i]; i++) {\n        if(str[i] == ch) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char metin[100], karakter;\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"Hangi karakterin sayısını bulmak istiyorsunuz? \");\n    scanf(\" %c\", &karakter);\n    printf(\"'%c' karakterinin sayısı: %d\\n\", karakter, karakterSay(metin, karakter));\n    return 0;\n}\n\n// Açıklama: Bu kod, girilen bir metinde belirli bir karakterin kaç kez geçtiğini bulmak için basit bir döngü kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978751"
  },
  {
    "question": "Bir stringin içindeki tüm sesli harfleri (a, e, i, o, u) sayan bir fonksiyon yazınız. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint sesliHarfSayisi(char str[]) {\n    int sayac = 0;\n    for(int i = 0; str[i]; i++) {\n        char c = str[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"Sesli harflerin sayısı: %d\\n\", sesliHarfSayisi(metin));\n    return 0;\n}\n\n// Açıklama: Bu kod, bir karakter dizisinde sesli harflerin sayısını bulmak için basit bir döngü ve koşul kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978797"
  },
  {
    "question": "Bir dizi içinde belirli bir kelimenin kaç kez geçtiğini bulan bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint kelimeSay(char str[], char kelime[]) {\n    int sayac = 0;\n    char *ptr = strstr(str, kelime);\n    while(ptr != NULL) {\n        sayac++;\n        ptr = strstr(ptr + 1, kelime);\n    }\n    return sayac;\n}\n\nint main() {\n    char metin[200], kelime[50];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    printf(\"Hangi kelimenin sayısını bulmak istiyorsunuz? \");\n    fgets(kelime, sizeof(kelime), stdin);\n    printf(\"'%s' kelimesinin sayısı: %d\\n\", kelime, kelimeSay(metin, kelime));\n    return 0;\n}\n\n// Açıklama: Bu kod, bir kelimenin bir dizi içinde kaç kez geçtiğini bulmak için strstr fonksiyonunu kullanmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978828"
  },
  {
    "question": "Kullanıcının girdiği bir stringin tüm harflerini büyük harfe çeviren bir fonksiyon yazın. Eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid harfleriBuyukYap(char str[]) {\n    for(int i = 0; str[i]; i++) {\n        if(str[i] >= 'a' && str[i] <= 'z') {\n            str[i] = str[i] - 32;\n        }\n    }\n}\n\nint main() {\n    char metin[100];\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n    harfleriBuyukYap(metin);\n    printf(\"Bütün harfler büyük: %s\", metin);\n    return 0;\n}\n\n// Açıklama: Bu kod, küçük harfleri büyük harflere çevirmek için ASCII değerlerini kullanarak dönüşüm gerçekleştirmektedir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:16:26.978858"
  },
  {
    "question": "Aşağıdaki kod parçasını tamamlayarak, bir karakter dizisinin uzunluğunu hesaplayın ve sonucu ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    int length = 0;\n\n    while (str[length] != '\\0') {\n        length++;\n    }\n\n    printf(\"Dizinin uzunluğu: %d\\n\", length);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298048"
  },
  {
    "question": "Verilen karakter dizisini ters çeviren bir fonksiyon yazın ve bunu ana fonksiyonda çağırın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevrilmiş dizi: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298093"
  },
  {
    "question": "Bir karakter dizisinde belirli bir karakterin kaç kez geçtiğini sayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint karakterSay(char str[], char ch) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    char str[] = \"Programlama dersi\";\n    char ch = 'r';\n    int sonuc = karakterSay(str, ch);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", ch, sonuc);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298121"
  },
  {
    "question": "İki karakter dizisini birleştiren bir fonksiyon yazın ve sonucu ekrana yazdırın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid birlestir(char str1[], char str2[], char sonuc[]) {\n    strcpy(sonuc, str1);\n    strcat(sonuc, str2);\n}\n\nint main() {\n    char str1[] = \"Merhaba\";\n    char str2[] = \" Dünya\";\n    char sonuc[50];\n    birlestir(str1, str2, sonuc);\n    printf(\"Birleşik dizi: %s\\n\", sonuc);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298148"
  },
  {
    "question": "Bir karakter dizisinde büyük harfleri küçük harflere çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid buyuktenKucuge(char str[]) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            str[i] += 32;\n        }\n    }\n}\n\nint main() {\n    char str[] = \"MerHaba\";\n    buyuktenKucuge(str);\n    printf(\"Küçük harfli dizi: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298174"
  },
  {
    "question": "Bir karakter dizisini, her kelimenin baş harfini büyük yapacak şekilde dönüştüren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid kelimeBasHarfleriniBuyut(char str[]) {\n    int i;\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (i == 0 || str[i - 1] == ' ') {\n            if (str[i] >= 'a' && str[i] <= 'z') {\n                str[i] -= 32;\n            }\n        }\n    }\n}\n\nint main() {\n    char str[] = \"merhaba dünya programlama\";\n    kelimeBasHarfleriniBuyut(str);\n    printf(\"Sonuç: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298205"
  },
  {
    "question": "Kullanıcının girdiği bir cümledeki boşlukları kaldıran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid bosluklariKaldir(char str[]) {\n    int i, j = 0;\n    char temp[100];\n\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            temp[j++] = str[i];\n        }\n    }\n    temp[j] = '\\0';\n    strcpy(str, temp);\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!  Nasıl gidiyor?\";\n    bosluklariKaldir(str);\n    printf(\"Boşluksuz dizi: %s\\n\", str);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298250"
  },
  {
    "question": "Bir karakter dizisinin palindrome olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint palindromeKontrol(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        if (str[i] != str[n - i - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char str[] = \"kayak\";\n    if (palindromeKontrol(str)) {\n        printf(\"'%s' bir palindrome'dur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrome değildir.\\n\", str);\n    }\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298287"
  },
  {
    "question": "Bir karakter dizisindeki tüm sesli harfleri sayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint sesliHarfSay(char str[]) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        char ch = str[i];\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\n            ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    int sonuc = sesliHarfSay(str);\n    printf(\"Sesli harf sayısı: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:17:00.298336"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için yazılan kodda, sonuç beklenildiği gibi çıkmıyor. Sorunu bul ve düzelt.",
    "answer": "Kodda, karakter dizisinin sonuna null karakter ('\\0') eklenmemiş. Bu nedenle, dizi ters çevrildiğinde sonlandırıcı karakter eksikliği nedeniyle bellek hatası oluşuyor. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nvoid reverseString(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n    str[n] = '\\0'; // Sonlandırıcı karakter ekle\n}\n```\n\nBu şekilde, dizi doğru şekilde tersine çevrilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414433"
  },
  {
    "question": "İki karakter dizisini birleştiren bir fonksiyonda, birleştirme işlemi beklenildiği gibi olmuyor. Hatanın nedenini ve çözümünü belirt.",
    "answer": "Kodda yeterli bellek ayrılmamış. Birleştirilen dizinin uzunluğu, her iki dizinin toplam uzunluğundan bir fazladır (sonlandırıcı için). Aşağıdaki gibi düzeltebilirsin:\n\n```c\nchar* concatenateStrings(const char *str1, const char *str2) {\n    int length1 = strlen(str1);\n    int length2 = strlen(str2);\n    char *result = malloc(length1 + length2 + 1);\n    strcpy(result, str1);\n    strcat(result, str2);\n    return result;\n}\n```\n\nBu şekilde, yeterli bellek ayrıldığından birleştirme işlemi düzgün çalışır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414532"
  },
  {
    "question": "Bir karakter dizisinde belirli bir karakterin sayısını sayan bir kod yazdım ama sonuç yanlış. Sorunu bul ve düzelt.",
    "answer": "Kodda, karakterlerin sayısını bulurken dizinin sonunu kontrol etmeyi unutmuş olabilirsin. Sonlandırıcı karakter kontrol edilmezse, dizi sonuna kadar gitmeyebilir. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nint countChar(const char *str, char ch) {\n    int count = 0;\n    while (*str) {\n        if (*str == ch) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n```\n\nBu şekilde, dizinin sonuna kadar giderek karakter sayısı doğru şekilde hesaplanır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414594"
  },
  {
    "question": "Bir karakter dizisinin içeriğini büyük harfe çeviren bir kodda, dizinin orijinal hali değişiyor. Hatanın sebebi nedir?",
    "answer": "Kodda, orijinal diziyi doğrudan değiştirdiğin için bu durum gerçekleşiyor. Değişikliklerin sadece kopya üzerinde yapılması gerekir. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nvoid toUpperCase(const char *str, char *result) {\n    while (*str) {\n        *result = toupper(*str);\n        str++;\n        result++;\n    }\n    *result = '\\0'; // Sonlandırıcı ekle\n}\n```\n\nBu kodda, orijinal dizi değiştirilmeden büyük harfe çevirme işlemi yapılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414653"
  },
  {
    "question": "Karakter dizisi ile ilgili bir arama fonksiyonu yazdım ama sonuç her zaman -1 dönüyor. Hatanın sebebi nedir?",
    "answer": "Fonksiyonda arama yapılırken, dizinin sonlandırıcı karakterini kontrol etmeyi unutmuş olabilirsin. Dizi sonuna kadar gitmeden arama işlemini tamamlayabilirsin. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nint findChar(const char *str, char ch) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\nBu şekilde, dizinin sonuna kadar giderek karakterin bulunup bulunmadığını kontrol edersin.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414710"
  },
  {
    "question": "Bir karakter dizisini kopyalayan bir fonksiyonda, hedef dizinin boyutunu kontrol etmeyi unuttum. Ne gibi sorunlar yaşanabilir?",
    "answer": "Hedef dizinin boyutunu kontrol etmemek, bellek taşmasına yol açabilir. Bu durum, programın çökmesine veya beklenmedik sonuçlara sebep olabilir. Aşağıdaki gibi düzeltmelisin:\n\n```c\nvoid safeCopy(char *dest, const char *src, size_t dest_size) {\n    size_t len = strlen(src);\n    if (len >= dest_size) {\n        len = dest_size - 1; // Hedef dizinin boyutuna göre kopyala\n    }\n    strncpy(dest, src, len);\n    dest[len] = '\\0'; // Sonlandırıcı ekle\n}\n```\n\nBu şekilde, hedef dizinin boyutunu kontrol ederek güvenli bir kopyalama işlemi gerçekleştirmiş olursun.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414770"
  },
  {
    "question": "Bir karakter dizisinde tekrarlanan karakterleri kaldıran bir fonksiyonda, sonuç beklenilen gibi değil. Hatanın nedeni nedir?",
    "answer": "Kodda, karakterleri kontrol ederken aynı karakterlerin nasıl kaydedileceğine dair bir önlem almadıysanız, yineleme hatası oluşabilir. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nvoid removeDuplicates(const char *src, char *dest) {\n    int index = 0;\n    for (int i = 0; src[i] != '\\0'; i++) {\n        int j;\n        for (j = 0; j < index; j++) {\n            if (dest[j] == src[i]) break;\n        }\n        if (j == index) {\n            dest[index++] = src[i];\n        }\n    }\n    dest[index] = '\\0';\n}\n```\n\nBu şekilde, dizideki tekrarlayan karakterler düzgün bir şekilde kaldırılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414828"
  },
  {
    "question": "Bir karakter dizisinin alt dizisini bulma işlevinde, beklenilen sonuçlar alınamıyor. Hatanın sebebi nedir?",
    "answer": "Alt dizi ararken, ana dizinin sonunu kontrol etmemek, alt dizinin sonunu kaçırmana sebep olabilir. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nint findSubstring(const char *str, const char *substr) {\n    int len = strlen(substr);\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (strncmp(&str[i], substr, len) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\nBu şekilde, ana dizi içinde alt diziyi doğru bir şekilde arayabilirsin.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414879"
  },
  {
    "question": "Bir karakter dizisinin belirli bir yerinden kesilmesi gerektiğinde, beklenen sonuç alınamıyor. Sorunun nedeni nedir?",
    "answer": "Kesme işlemini yaparken, dizinin sonunu kontrol etmemek veya sonuç dizisinin boyutunu ayarlamamak, hatalara yol açabilir. Aşağıdaki gibi düzeltebilirsin:\n\n```c\nvoid cutString(char *str, int start, int length) {\n    int len = strlen(str);\n    if (start >= len) return; // Başlangıç indeksinin sınır kontrolü\n    if (start + length >= len) length = len - start; // Uzunluk kontrolü\n    memmove(str + start, str + start + length, len - start - length + 1); // Kesi\n}\n```\n\nBu şekilde, dizi içinde doğru bir şekilde kesme işlemi uygulayabilirsin.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:05.414940"
  },
  {
    "question": "C dilinde bir karakter dizisini nasıl tanımlayabilirim?",
    "answer": "C dilinde karakter dizisi tanımlamak için 'char' anahtar kelimesini kullanarak bir dizi tanımlayabilirsiniz. Örneğin: 'char isim[20];' bu, en fazla 19 karakter içeren (sonlandırıcı null karakteri için 1 yer bırakılır) bir karakter dizisi oluşturur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425833"
  },
  {
    "question": "Karakter dizisine nasıl değer atayabilirim?",
    "answer": "Karakter dizisine değer atamak için 'strcpy' fonksiyonu kullanılabilir. Örnek: 'strcpy(isim, \"Ahmet\");' burada 'isim' dizisine 'Ahmet' değeri atanır. Bu fonksiyon <string.h> kütüphanesinde yer alır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425868"
  },
  {
    "question": "Karakter dizisinin uzunluğunu nasıl bulabilirim?",
    "answer": "Bir karakter dizisinin uzunluğunu bulmak için 'strlen' fonksiyonu kullanılır. Örnek: 'int uzunluk = strlen(isim);' burada 'isim' dizisinin uzunluğu 'uzunluk' değişkenine atanır. Bu fonksiyon da <string.h> kütüphanesinde yer alır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425907"
  },
  {
    "question": "Bir karakter dizisini nasıl ekrana yazdırabilirim?",
    "answer": "Karakter dizisini ekrana yazdırmak için 'printf' fonksiyonunu kullanabilirsiniz. Örnek: 'printf(\"İsim: %s\", isim);' burada 'isim' dizisinin içeriği ekrana yazdırılır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425926"
  },
  {
    "question": "Bir karakter dizisinde belirli bir karakterin bulunup bulunmadığını nasıl kontrol edebilirim?",
    "answer": "Bir karakter dizisinde belirli bir karakterin varlığını kontrol etmek için 'strchr' fonksiyonu kullanılabilir. Örnek: 'if (strchr(isim, 'a') != NULL)' bu, 'isim' dizisinde 'a' karakterinin olup olmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425953"
  },
  {
    "question": "Karakter dizilerini birleştirmek için ne yapmalıyım?",
    "answer": "Karakter dizilerini birleştirmek için 'strcat' fonksiyonu kullanılır. Örnek: 'strcat(isim, soyisim);' burada 'soyisim' dizisi 'isim' dizisinin sonuna eklenir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425974"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için nasıl bir yöntem izlemeliyim?",
    "answer": "Bir karakter dizisini tersine çevirmek için bir döngü kullanarak karakterlerin yerlerini değiştirebilirsiniz. Örneğin: 'for(int i = 0; i < uzunluk / 2; i++) { char temp = isim[i]; isim[i] = isim[uzunluk - i - 1]; isim[uzunluk - i - 1] = temp; }'",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.425999"
  },
  {
    "question": "Bir karakter dizisinin tüm karakterlerini küçük harfe nasıl dönüştürebilirim?",
    "answer": "Bunun için 'tolower' fonksiyonu kullanılabilir. Döngü ile her bir karakter üzerinde 'tolower' uygulanır. Örneğin: 'for(int i = 0; i < uzunluk; i++) { isim[i] = tolower(isim[i]); }' bu, 'isim' dizisindeki tüm karakterleri küçük harfe çevirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.426024"
  },
  {
    "question": "Karakter dizisi içinde belirli bir kelimenin geçip geçmediğini nasıl kontrol edebilirim?",
    "answer": "Bunu yapmak için 'strstr' fonksiyonu kullanılabilir. Örnek: 'if (strstr(isim, \"metin\") != NULL)' burada 'isim' dizisi içinde 'metin' kelimesinin varlığı kontrol edilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.426050"
  },
  {
    "question": "Bir karakter dizisinin içindeki tüm boşlukları nasıl kaldırabilirim?",
    "answer": "Boşlukları kaldırmak için döngü kullanarak her karakteri kontrol edebilir ve boşluk olmayanları yeni bir diziye kopyalayabilirsiniz. Örneğin: 'int j = 0; for(int i = 0; isim[i] != '\\0'; i++) { if(isim[i] != ' ') isim[j++] = isim[i]; } isim[j] = '\\0';' bu, boşlukları kaldırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.426072"
  },
  {
    "question": "Karakter dizisindeki tüm karakterlerin ASCII değerlerini nasıl yazdırabilirim?",
    "answer": "Bunun için döngü kullanarak her karakterin ASCII değerini 'printf' ile yazdırabilirsiniz. Örneğin: 'for(int i = 0; isim[i] != '\\0'; i++) { printf(\"%c: %d\\n\", isim[i], isim[i]); }' bu, her karakterin ASCII değerini gösterir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:18:55.426094"
  },
  {
    "question": "C dilinde bir karakter dizisinin uzunluğunu nasıl bulabilirim?",
    "answer": "C dilinde bir karakter dizisinin uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, dizinin sonundaki null karakteri ('\\0') saymaz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = 'Merhaba';\n    int length = strlen(str);\n    printf('Dizinin uzunluğu: %d\\n', length);\n    return 0;\n}\n```\nBu kod 'Dizinin uzunluğu: 7' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051087"
  },
  {
    "question": "C dilinde iki karakter dizisini birleştirmek için hangi fonksiyonu kullanmalıyım?",
    "answer": "İki karakter dizisini birleştirmek için 'strcat' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, bir dizinin sonuna diğerini ekler. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[20] = 'Merhaba';\n    char str2[] = ' Dunya';\n    strcat(str1, str2);\n    printf('%s\\n', str1);\n    return 0;\n}\n```\nBu kod 'Merhaba Dunya' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051148"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine çevirmek istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Bir karakter dizisini tersine çevirmek için bir döngü ile dizinin elemanlarını baştan sona doğru ve sondan başa doğru değiştirerek yeni bir dizi oluşturabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = 'Merhaba';\n    int len = strlen(str);\n    for(int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n    }\n    printf('Tersine çevrilmiş: %s\\n', str);\n    return 0;\n}\n```\nBu kod 'Tersine çevrilmiş: abahreM' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051194"
  },
  {
    "question": "C dilinde bir karakter dizisinde belirli bir karakterin sayısını nasıl bulabilirim?",
    "answer": "Belirli bir karakterin sayısını bulmak için bir döngü ile diziyi kontrol edebilirsiniz. Aşağıdaki örnekte, 'a' karakterinin dizide kaç kez geçtiğini sayıyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = 'Merhaba';\n    char ch = 'a';\n    int count = 0;\n    for(int i = 0; str[i] != '\\0'; i++) {\n        if(str[i] == ch) {\n            count++;\n        }\n    }\n    printf('Karakter %c %d kez geçiyor.\\n', ch, count);\n    return 0;\n}\n```\nÇıktı: 'Karakter a 2 kez geçiyor.'",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051236"
  },
  {
    "question": "C dilinde bir karakter dizisini küçük harfe dönüştürmek için ne yapmalıyım?",
    "answer": "Bir karakter dizisini küçük harfe dönüştürmek için 'tolower' fonksiyonunu kullanabilirsiniz. Her bir karakteri kontrol edip, küçük harf olup olmadığını kontrol ederek dönüştürebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = 'Merhaba Dunya';\n    for(int i = 0; str[i] != '\\0'; i++) {\n        str[i] = tolower(str[i]);\n    }\n    printf('Küçük harf: %s\\n', str);\n    return 0;\n}\n```\nBu kod 'Küçük harf: merhaba dunya' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051278"
  },
  {
    "question": "C dilinde bir karakter dizisinde belirli bir alt dizinin var olup olmadığını nasıl kontrol edebilirim?",
    "answer": "'strstr' fonksiyonunu kullanarak bir karakter dizisinde belirli bir alt dizinin varlığını kontrol edebilirsiniz. Eğer alt dizi mevcutsa, 'strstr' bu alt dizinin ilk bulunduğu adresi döndürür. Aşağıdaki örneğe bakabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = 'Merhaba Dunya';\n    char sub[] = 'Dunya';\n    if (strstr(str, sub) != NULL) {\n        printf('Alt dizi mevcut.\\n');\n    } else {\n        printf('Alt dizi mevcut değil.\\n');\n    }\n    return 0;\n}\n```\nBu kod 'Alt dizi mevcut.' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051329"
  },
  {
    "question": "C dilinde bir karakter dizisinin başına başka bir diziyi nasıl ekleyebilirim?",
    "answer": "Bir karakter dizisinin başına başka bir diziyi eklemek için, önce hedef dizinin yeterli boyutta olduğunu kontrol etmelisiniz. Ardından, 'strcpy' ve 'strcat' fonksiyonlarını kullanarak dizileri birleştirebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = 'Dunya';\n    char str2[] = 'Merhaba ';\n    strcpy(str1 + strlen(str2), str1);\n    strcpy(str1, str2);\n    printf('%s\\n', str1);\n    return 0;\n}\n```\nBu kod 'Merhaba Dunya' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051371"
  },
  {
    "question": "C dilinde bir karakter dizisinde boşlukları nasıl temizleyebilirim?",
    "answer": "Bir karakter dizisinde boşlukları temizlemek için, diziyi kontrol edip boş olmayan karakterleri yeni bir diziye kopyalayabilirsiniz. Aşağıdaki örnek bunu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = ' M e r h a b a '; \n    char cleanStr[50];\n    int j = 0;\n    for(int i = 0; str[i] != '\\0'; i++) {\n        if(str[i] != ' ') {\n            cleanStr[j++] = str[i];\n        }\n    }\n    cleanStr[j] = '\\0';\n    printf('Temizlenmiş dizi: %s\\n', cleanStr);\n    return 0;\n}\n```\nBu kod 'Temizlenmiş dizi: Merhaba' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051407"
  },
  {
    "question": "C dilinde bir karakter dizisinin belirli bir indeksindeki karakteri nasıl değiştirebilirim?",
    "answer": "Bir karakter dizisindeki belirli bir indeksin karakterini değiştirmek için, o indeksteki karakterin değerini doğrudan atayarak değişiklik yapabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = 'Merhaba';\n    str[3] = 'k';\n    printf('Güncellenmiş dizi: %s\\n', str);\n    return 0;\n}\n```\nBu kod 'Güncellenmiş dizi: Merhakba' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051451"
  },
  {
    "question": "C dilinde bir karakter dizisini birden fazla kez tekrarlamak istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Bir karakter dizisini belirli bir sayıda tekrarlamak için bir döngü ile dizi elemanlarını kopyalayarak yeni bir dizi oluşturabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = 'Merhaba';\n    int repeat = 3;\n    char result[100] = '';\n    for(int i = 0; i < repeat; i++) {\n        strcat(result, str);\n    }\n    printf('Tekrarlanmış dizi: %s\\n', result);\n    return 0;\n}\n```\nBu kod 'Tekrarlanmış dizi: MerhabaMerhabaMerhaba' çıktısını verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:19:43.051499"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine nasıl çevirebilirim?",
    "answer": "Bir karakter dizisini tersine çevirmek için, dizinin uzunluğunu bulup, iki uçtaki karakterleri yer değiştirerek ilerleyebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevrilmiş dizi: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda, `tersCevir` fonksiyonu dizi üzerinde yer değişimi yaparak karakter dizisini tersine çeviriyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419671"
  },
  {
    "question": "C dilinde bir karakter dizisinde belirli bir karakterin kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Belirli bir karakterin, bir karakter dizisinde kaç kez geçtiğini bulmak için, karakter dizisini döngü ile tarayarak her karakteri kontrol edebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint karakterSay(char str[], char aranan) {\n    int sayac = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == aranan) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char str[] = \"programlama\";\n    char aranan = 'a';\n    int sonuc = karakterSay(str, aranan);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", aranan, sonuc);\n    return 0;\n}\n```\nBu kodda, `karakterSay` fonksiyonu, verilen karakteri sayarak geri döndürüyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419733"
  },
  {
    "question": "C dilinde iki karakter dizisini birleştirmenin en etkili yolu nedir?",
    "answer": "İki karakter dizisini birleştirmek için `strcat` fonksiyonunu kullanabiliriz. Ancak, birleştirdiğimiz dizinin yeterince büyük olduğundan emin olmamız gerekiyor. İşte örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char dizi1[50] = \"Merhaba\";\n    char dizi2[] = \" Dünya!\";\n    strcat(dizi1, dizi2);\n    printf(\"Birleştirilmiş dizi: %s\\n\", dizi1);\n    return 0;\n}\n```\nBu örnekte, `strcat` fonksiyonu `dizi1` ve `dizi2` dizilerini birleştiriyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419772"
  },
  {
    "question": "C dilinde bir karakter dizisindeki tüm büyük harfleri küçük harflere nasıl dönüştürebilirim?",
    "answer": "Bir karakter dizisindeki büyük harfleri küçük harflere dönüştürmek için bir döngü ile karakterleri kontrol edip `tolower` fonksiyonunu kullanabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid buyuktenKucuge(char str[]) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba DÜNYA!\";\n    buyuktenKucuge(str);\n    printf(\"Küçük harfli dizi: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda, `buyuktenKucuge` fonksiyonu dizi üzerindeki her karakteri kontrol edip küçük harfe dönüştürüyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419807"
  },
  {
    "question": "C dilinde bir karakter dizisinin palindrome (tersiyle aynı) olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir karakter dizisinin palindrome olup olmadığını kontrol etmek için, dizinin başından ve sonundan başlayarak karşılaştırmalar yapabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint palindromeKontrol(char str[]) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        if (str[i] != str[n - i - 1]) {\n            return 0; // Değil\n        }\n    }\n    return 1; // Palindrome\n}\n\nint main() {\n    char str[] = \"level\";\n    if (palindromeKontrol(str)) {\n        printf(\"'%s' bir palindrome.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrome değil.\\n\", str);\n    }\n    return 0;\n}\n```\nBu kodda, `palindromeKontrol` fonksiyonu diziyi kontrol ederek dönüş değeri veriyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419838"
  },
  {
    "question": "C dilinde bir karakter dizisindeki tüm boşlukları kaldırmak için ne yapmalıyım?",
    "answer": "Bir karakter dizisindeki tüm boşlukları kaldırmak için, yeni bir dizi oluşturarak boşluk olmayan karakterleri kopyalayabiliriz. İşte örnek bir çözüm:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char str[]) {\n    int j = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] != ' ') {\n            str[j++] = str[i];\n        }\n    }\n    str[j] = '\\0'; // Yeni dizinin sonunu belirliyoruz\n}\n\nint main() {\n    char str[] = \"C dilinde karakter dizileri\";\n    boslukKaldir(str);\n    printf(\"Boşluksuz dizi: '%s'\\n\", str);\n    return 0;\n}\n```\nBu kodda, `boslukKaldir` fonksiyonu dizideki boşlukları atlayarak yeni bir dizi oluşturuyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419863"
  },
  {
    "question": "C dilinde iki karakter dizisinin eşit olup olmadığını nasıl kontrol edebilirim?",
    "answer": "İki karakter dizisinin eşitliğini kontrol etmek için `strcmp` fonksiyonunu kullanabiliriz. Eğer iki dizi eşitse, fonksiyon 0 dönecektir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char dizi1[] = \"Merhaba\";\n    char dizi2[] = \"Merhaba\";\n    if (strcmp(dizi1, dizi2) == 0) {\n        printf(\"Diziler eşit.\\n\");\n    } else {\n        printf(\"Diziler eşit değil.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, `strcmp` fonksiyonu dizilerin eşit olup olmadığını kontrol ediyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419887"
  },
  {
    "question": "C dilinde bir karakter dizisini bir başka diziye kopyalamanın en iyi yolu nedir?",
    "answer": "Bir karakter dizisini başka bir diziye kopyalamak için `strcpy` fonksiyonunu kullanabiliriz. Ancak, hedef dizinin yeterince büyük olduğundan emin olmalıyız. İşte örnek bir kullanım:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char kaynak[] = \"Merhaba Dünya!\";\n    char hedef[50]; // Yeterince büyük bir dizi\n    strcpy(hedef, kaynak);\n    printf(\"Kopyalanmış dizi: %s\\n\", hedef);\n    return 0;\n}\n```\nBu örnekte, `strcpy` fonksiyonu `kaynak` dizisini `hedef` dizisine kopyalıyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419913"
  },
  {
    "question": "C dilinde bir karakter dizisini belirli bir uzunluğa nasıl kısaltabilirim?",
    "answer": "Bir karakter dizisini belirli bir uzunluğa kısaltmak için, dizinin sonuna `\\0` karakterini ekleyerek kesebiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid kisalt(char str[], int uzunluk) {\n    if (uzunluk < strlen(str)) {\n        str[uzunluk] = '\\0'; // Dizi uzunluğunu kısıtlıyoruz\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya!\";\n    kisalt(str, 7);\n    printf(\"Kısaltılmış dizi: %s\\n\", str);\n    return 0;\n}\n```\nBu kodda, `kisalt` fonksiyonu belirtilen uzunluktan sonra dizi sonunu belirliyor.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:20:17.419937"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine çevirmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Karakter dizisini tersine çevirmek için bir fonksiyon yazabilirsiniz. Bu fonksiyon, dizinin başlangıcından ve sonundan iki işaretçi kullanarak karakterleri değiştirebilir. Aşağıda örnek bir implementasyon bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = dizi[i];\n        dizi[i] = dizi[uzunluk - 1 - i];\n        dizi[uzunluk - 1 - i] = temp;\n    }\n}\n\nint main() {\n    char dizi[] = \"Merhaba!\";\n    tersCevir(dizi);\n    printf(\"Tersine çevrilmiş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, \"Merhaba!\" ifadesini \"!abahreM\" olarak tersine çevirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092368"
  },
  {
    "question": "C dilinde bir karakter dizisindeki belirli bir karakterin sayısını nasıl bulabilirim?",
    "answer": "Bir karakter dizisindeki belirli bir karakterin sayısını bulmak için basit bir döngü kullanabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint karakterSay(char *dizi, char karakter) {\n    int sayac = 0;\n    for (int i = 0; dizi[i] != '\\0'; i++) {\n        if (dizi[i] == karakter) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"programlama\";\n    char aranan = 'r';\n    int sonuc = karakterSay(dizi, aranan);\n    printf(\"'%c' karakterinin sayısı: %d\\n\", aranan, sonuc);\n    return 0;\n}\n```\nBu kod, \"programlama\" dizisinde 'r' karakterinin kaç kez geçtiğini sayar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092430"
  },
  {
    "question": "C dilinde iki karakter dizisini birleştirmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "İki karakter dizisini birleştirmek için, ilk dizinin sonuna ikinci diziyi ekleyebilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid birleştir(char *hedef, const char *kaynak) {\n    strcat(hedef, kaynak);\n}\n\nint main() {\n    char dizi1[50] = \"Merhaba, \";\n    char dizi2[] = \"Dünya!\";\n    birleştir(dizi1, dizi2);\n    printf(\"Birleştirilmiş dizi: %s\\n\", dizi1);\n    return 0;\n}\n```\nBu kod, \"Merhaba, \" ve \"Dünya!\" dizilerini birleştirerek \"Merhaba, Dünya!\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092475"
  },
  {
    "question": "C dilinde bir karakter dizisini büyük harfe dönüştüren bir fonksiyon yazabilir misin?",
    "answer": "Bir karakter dizisini büyük harfe dönüştürmek için her karakteri kontrol ederek 'a' ile 'z' aralığında ise ASCII değerini değiştirerek büyük harflerine dönüştürebilirsiniz. İşte örnek bir fonksiyon:\n\n```c\n#include <stdio.h>\n\nvoid buyukHarfeCevir(char *dizi) {\n    for (int i = 0; dizi[i] != '\\0'; i++) {\n        if (dizi[i] >= 'a' && dizi[i] <= 'z') {\n            dizi[i] = dizi[i] - 32;\n        }\n    }\n}\n\nint main() {\n    char dizi[] = \"merhaba\";\n    buyukHarfeCevir(dizi);\n    printf(\"Büyük harfe çevrilmiş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, \"merhaba\" dizisini \"MERHABA\" olarak dönüştürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092549"
  },
  {
    "question": "C dilinde bir karakter dizisinde boşlukları kaldırmak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir karakter dizisindeki boşlukları kaldırmak için dizinin her karakterini kontrol ederek boşlukları atlayabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid bosluklariKaldir(char *dizi) {\n    int i, j = 0;\n    for (i = 0; dizi[i] != '\\0'; i++) {\n        if (dizi[i] != ' ') {\n            dizi[j++] = dizi[i];\n        }\n    }\n    dizi[j] = '\\0';\n}\n\nint main() {\n    char dizi[] = \"Bu bir deneme dizesidir.\";\n    bosluklariKaldir(dizi);\n    printf(\"Boşlukları kaldırılmış dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, \"Bu bir deneme dizesidir.\" dizisinden boşlukları kaldırarak \"Bubirdenemedizesidir.\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092597"
  },
  {
    "question": "C dilinde bir karakter dizisini belirli bir konumdan kesip almak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Karakter dizisinden belirli bir konumdan kesip almak için bir alt dizi oluşturabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid kes(char *kaynak, char *hedef, int baslangic, int uzunluk) {\n    strncpy(hedef, kaynak + baslangic, uzunluk);\n    hedef[uzunluk] = '\\0';  // Null terminatör ekle\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dünya!\";\n    char altDizi[20];\n    kes(dizi, altDizi, 8, 5);\n    printf(\"Kesilmiş dizi: %s\\n\", altDizi);\n    return 0;\n}\n```\nBu kod, \"Merhaba Dünya!\" dizisinden 8. indexten başlayarak 5 karakter keser ve \"Dünya\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092649"
  },
  {
    "question": "C dilinde bir karakter dizisinde belirli bir kelimenin var olup olmadığını kontrol etmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir karakter dizisinde belirli bir kelimenin var olup olmadığını kontrol etmek için 'strstr' fonksiyonunu kullanabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint kelimeVarMi(char *dizi, char *kelime) {\n    return strstr(dizi, kelime) != NULL;\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dünya!\";\n    char kelime[] = \"Dünya\";\n    if (kelimeVarMi(dizi, kelime)) {\n        printf(\"Kelime bulundu!\\n\");\n    } else {\n        printf(\"Kelime bulunamadı!\\n\");\n    }\n    return 0;\n}\n```\nBu kod, \"Merhaba Dünya!\" dizisinde \"Dünya\" kelimesinin var olup olmadığını kontrol eder.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092708"
  },
  {
    "question": "C dilinde bir karakter dizisini küçük harfe dönüştüren bir fonksiyon yazabilir misin?",
    "answer": "Bir karakter dizisini küçük harfe dönüştürmek için her karakteri kontrol ederek 'A' ile 'Z' aralığında ise ASCII değerini değiştirerek küçük harflerine dönüştürebilirsiniz. İşte örnek bir fonksiyon:\n\n```c\n#include <stdio.h>\n\nvoid kucukHarfeCevir(char *dizi) {\n    for (int i = 0; dizi[i] != '\\0'; i++) {\n        if (dizi[i] >= 'A' && dizi[i] <= 'Z') {\n            dizi[i] = dizi[i] + 32;\n        }\n    }\n}\n\nint main() {\n    char dizi[] = \"MERHABA\";\n    kucukHarfeCevir(dizi);\n    printf(\"Küçük harfe çevrilmiş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, \"MERHABA\" dizisini \"merhaba\" olarak dönüştürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092754"
  },
  {
    "question": "C dilinde bir karakter dizisinin uzunluğunu bulmak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Bir karakter dizisinin uzunluğunu bulmak için her karakteri kontrol eden bir döngü kullanabilirsiniz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint diziUzunlugu(char *dizi) {\n    int sayac = 0;\n    while (dizi[sayac] != '\\0') {\n        sayac++;\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"Merhaba!\";\n    int uzunluk = diziUzunlugu(dizi);\n    printf(\"Dizinin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n```\nBu kod, \"Merhaba!\" dizisinin uzunluğunu 8 olarak döndürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:21:21.092799"
  },
  {
    "question": "Bir karakter dizisinin tüm karakterlerini tersine çevirmek için bir fonksiyon yazın.",
    "answer": "Aşağıdaki kod, bir karakter dizisini tersine çeviren bir fonksiyon tanımlar. Bu fonksiyon, dizinin uzunluğunu bulur ve iki uçtan başlayarak karakterleri yer değiştirir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = dizi[i];\n        dizi[i] = dizi[uzunluk - i - 1];\n        dizi[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char dizi[] = \"Merhaba\";\n    tersCevir(dizi);\n    printf(\"Ters çevrilmiş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kodu çalıştırdığınızda \"Merhaba\" dizisi \"abahreM\" olarak tersine çevrilecektir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200706"
  },
  {
    "question": "Bir karakter dizisinde belirli bir karakterin kaç kez geçtiğini hesaplayan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, verilen bir karakter dizisi içinde aranan karakterin kaç kez geçtiğini sayar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint karakterSay(char *dizi, char aranan) {\n    int sayac = 0;\n    for (int i = 0; i < strlen(dizi); i++) {\n        if (dizi[i] == aranan) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"programming\";\n    char aranan = 'g';\n    int sonuc = karakterSay(dizi, aranan);\n    printf(\"'%c' karakteri %d kez geçiyor.\\n\", aranan, sonuc);\n    return 0;\n}\n```\nBu örnekte, 'g' karakterinin \"programming\" dizisinde 2 kez geçtiği hesaplanmaktadır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200777"
  },
  {
    "question": "Bir karakter dizisindeki tüm benzersiz karakterleri bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisindeki benzersiz karakterleri bulur ve bunları başka bir dizide saklar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid benzersizKarakterler(char *dizi) {\n    int uzunluk = strlen(dizi);\n    int mevcut[256] = {0};  // ASCII karakterlerini saymak için\n    printf(\"Benzersiz karakterler: \");\n    for (int i = 0; i < uzunluk; i++) {\n        if (mevcut[(int)dizi[i]] == 0) {\n            printf(\"%c \", dizi[i]);\n            mevcut[(int)dizi[i]] = 1;\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char dizi[] = \"programming\";\n    benzersizKarakterler(dizi);\n    return 0;\n}\n```\nBu kod \"programming\" dizisindeki benzersiz karakterleri ekrana yazdırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200820"
  },
  {
    "question": "Bir karakter dizisinin palindrom (tersiyle aynı) olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "Aşağıdaki kod, bir karakter dizisinin palindrom olup olmadığını kontrol eden bir fonksiyon içerir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint palindromMu(char *dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        if (dizi[i] != dizi[uzunluk - i - 1]) {\n            return 0;  // Palindrom değil\n        }\n    }\n    return 1;  // Palindrom\n}\n\nint main() {\n    char dizi[] = \"racecar\";\n    if (palindromMu(dizi)) {\n        printf(\"'%s' bir palindromdur.\\n\", dizi);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", dizi);\n    }\n    return 0;\n}\n```\nBu kod \"racecar\" dizisini kontrol eder ve palindrom olduğunu belirtir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200875"
  },
  {
    "question": "İki karakter dizisini birleştirip yeni bir dizi oluşturan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, iki karakter dizisini birleştirip yeni bir dizi oluşturur.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid birlestir(char *dizi1, char *dizi2, char *sonuc) {\n    strcpy(sonuc, dizi1);\n    strcat(sonuc, dizi2);\n}\n\nint main() {\n    char dizi1[] = \"Merhaba\";\n    char dizi2[] = \" Dunya\";\n    char sonuc[100];  // Yeterli alan ayırıyoruz\n    birlestir(dizi1, dizi2, sonuc);\n    printf(\"Birleşmiş dizi: %s\\n\", sonuc);\n    return 0;\n}\n```\nBu kod \"Merhaba\" ve \" Dunya\" dizilerini birleştirip \"Merhaba Dunya\" olarak sonuç verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200918"
  },
  {
    "question": "Bir karakter dizisindeki büyük harfleri küçük harflere dönüştüren bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisindeki tüm büyük harfleri küçük harflere dönüştürür.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid buyuktenKucuge(char *dizi) {\n    for (int i = 0; i < strlen(dizi); i++) {\n        if (dizi[i] >= 'A' && dizi[i] <= 'Z') {\n            dizi[i] += 32;  // ASCII değeri ile küçük harfe çevirme\n        }\n    }\n}\n\nint main() {\n    char dizi[] = \"Hello World!\";\n    buyuktenKucuge(dizi);\n    printf(\"Küçültülmüş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod \"Hello World!\" dizisini \"hello world!\" haline getirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.200962"
  },
  {
    "question": "Bir karakter dizisinin uzunluğunu hesaplayan bir fonksiyon yazın (strlen() kullanmadan).",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisinin uzunluğunu strlen() fonksiyonu kullanmadan hesaplar.\n\n```c\n#include <stdio.h>\n\nint diziUzunlugu(char *dizi) {\n    int uzunluk = 0;\n    while (dizi[uzunluk] != '\\0') {\n        uzunluk++;\n    }\n    return uzunluk;\n}\n\nint main() {\n    char dizi[] = \"Merhaba\";\n    int uzunluk = diziUzunlugu(dizi);\n    printf(\"Dizinin uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n```\nBu kod \"Merhaba\" dizisinin uzunluğunu 7 olarak hesaplar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.201006"
  },
  {
    "question": "Bir karakter dizisini bir sayı olarak yorumlayıp, o sayıyı döndüren bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisini alır ve bu diziyi bir tam sayıya dönüştürür.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint diziToSayi(char *dizi) {\n    int sonuc = 0;\n    for (int i = 0; dizi[i] != '\\0'; i++) {\n        sonuc = sonuc * 10 + (dizi[i] - '0');\n    }\n    return sonuc;\n}\n\nint main() {\n    char dizi[] = \"12345\";\n    int sayi = diziToSayi(dizi);\n    printf(\"Dizi sayıya çevirildi: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod \"12345\" dizisini 12345 sayısına dönüştürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.201053"
  },
  {
    "question": "Bir karakter dizisindeki boşlukları kaldıran bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisindeki tüm boşlukları kaldırır ve sonucu yeni bir dizide saklar.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid boslukKaldir(char *dizi, char *sonuc) {\n    int j = 0;\n    for (int i = 0; i < strlen(dizi); i++) {\n        if (dizi[i] != ' ') {\n            sonuc[j++] = dizi[i];\n        }\n    }\n    sonuc[j] = '\\0';  // Sonlandırıcı karakter\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dunya\";\n    char sonuc[100];\n    boslukKaldir(dizi, sonuc);\n    printf(\"Boşluklar kaldırıldı: %s\\n\", sonuc);\n    return 0;\n}\n```\nBu kod \"Merhaba Dunya\" dizisinden boşlukları kaldırarak \"MerhabaDunya\" sonucunu verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:00.201089"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine döndüren bir fonksiyon yazın.",
    "answer": "Aşağıda verilen fonksiyon, bir karakter dizisini alarak tersine çevirir. Fonksiyon, dizinin uzunluğunu hesaplayarak, baştaki ve sondaki karakterleri değiştirir. Bu işlem, dizinin ortasına ulaşana kadar devam eder.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char* dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = dizi[i];\n        dizi[i] = dizi[uzunluk - i - 1];\n        dizi[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char dizi[] = \"Merhaba\";\n    tersCevir(dizi);\n    printf(\"Ters çevrilmiş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, 'Merhaba' dizisini 'abahreM' olarak tersine çevirir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711171"
  },
  {
    "question": "C dilinde bir karakter dizisinde belirli bir karakterin kaç kez tekrar ettiğini bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, verilen bir karakter dizisi ve kontrol edilecek karakter ile bu karakterin dizide kaç kez tekrar ettiğini sayar.\n\n```c\n#include <stdio.h>\n\nint karakterSay(char* dizi, char hedef) {\n    int sayac = 0;\n    while (*dizi) {\n        if (*dizi == hedef) {\n            sayac++;\n        }\n        dizi++;\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"Merhaba dünya!\";\n    char hedef = 'a';\n    int sonuc = karakterSay(dizi, hedef);\n    printf(\"'%c' karakteri, %d kez tekrar ediyor.\\n\", hedef, sonuc);\n    return 0;\n}\n```\nBu kod, 'Merhaba dünya!' dizisinde 'a' karakterinin 2 kez geçtiğini gösterir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711218"
  },
  {
    "question": "C dilinde iki karakter dizisini birleştiren bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, iki karakter dizisini birleştirir ve sonucu yeni bir diziye kopyalar. Bellekte yeterli alan ayrıldığından emin olunmalıdır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* birlestir(char* dizi1, char* dizi2) {\n    int uzunluk1 = strlen(dizi1);\n    int uzunluk2 = strlen(dizi2);\n    char* sonuc = (char*)malloc(uzunluk1 + uzunluk2 + 1);\n    strcpy(sonuc, dizi1);\n    strcat(sonuc, dizi2);\n    return sonuc;\n}\n\nint main() {\n    char dizi1[] = \"Hello \";\n    char dizi2[] = \"World!\";\n    char* sonuc = birlestir(dizi1, dizi2);\n    printf(\"Birleştirilmiş dizi: %s\\n\", sonuc);\n    free(sonuc);\n    return 0;\n}\n```\nBu kod, 'Hello ' ve 'World!' dizilerini birleştirerek 'Hello World!' sonucunu üretir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711242"
  },
  {
    "question": "C dilinde bir karakter dizisinin palindrom olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, verilen bir karakter dizisinin palindrom olup olmadığını kontrol eder. Palindrom, tersten okunduğunda da aynı olan dizilerdir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint palindromMu(char* dizi) {\n    int uzunluk = strlen(dizi);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        if (dizi[i] != dizi[uzunluk - i - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char dizi[] = \"radar\";\n    if (palindromMu(dizi)) {\n        printf(\"'%s' bir palindromdur.\\n\", dizi);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", dizi);\n    }\n    return 0;\n}\n```\nBu kod, 'radar' dizesinin palindrom olduğunu doğrular.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711269"
  },
  {
    "question": "C dilinde bir karakter dizisinde küçük harfleri büyük harflere dönüştüren bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, verilen bir karakter dizisindeki tüm küçük harfleri büyük harflere dönüştürür. ASCII karakter seti kullanılarak dönüşüm gerçekleştirilir.\n\n```c\n#include <stdio.h>\n\nvoid kucuktenBuyuge(char* dizi) {\n    while (*dizi) {\n        if (*dizi >= 'a' && *dizi <= 'z') {\n            *dizi = *dizi - ('a' - 'A');\n        }\n        dizi++;\n    }\n}\n\nint main() {\n    char dizi[] = \"merhaba dünya!\";\n    kucuktenBuyuge(dizi);\n    printf(\"Büyük harflere dönüştürülmüş dizi: %s\\n\", dizi);\n    return 0;\n}\n```\nBu kod, 'merhaba dünya!' dizisini 'MERHABA DÜNYA!' olarak dönüştürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711303"
  },
  {
    "question": "C dilinde bir karakter dizisinde en uzun kelimeyi bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, verilen bir karakter dizisindeki en uzun kelimeyi bulur. Kelimeler, boşluk karakterleri ile ayrılır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid enUzunKelimeBul(char* dizi, char* enUzunKelime) {\n    char* kelime = strtok(dizi, \" \");\n    while (kelime != NULL) {\n        if (strlen(kelime) > strlen(enUzunKelime)) {\n            strcpy(enUzunKelime, kelime);\n        }\n        kelime = strtok(NULL, \" \");\n    }\n}\n\nint main() {\n    char dizi[] = \"C dilinde karakter dizileri ile çalışmak çok eğlenceli\";\n    char enUzunKelime[100] = \"\";\n    enUzunKelimeBul(dizi, enUzunKelime);\n    printf(\"En uzun kelime: %s\\n\", enUzunKelime);\n    return 0;\n}\n```\nBu kod, 'C dilinde karakter dizileri ile çalışmak çok eğlenceli' dizesindeki en uzun kelimeyi bulur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711329"
  },
  {
    "question": "C dilinde bir karakter dizisinde tekrarlanan harfleri bulan bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisindeki tekrarlanan harfleri bulur ve bunları ekrana yazdırır. Tekrarlanan harfler, bir dizi içinde tutulur.\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid tekrarEdenHarfler(char* dizi) {\n    bool bulunmus[256] = { false };\n    bool tekrar[256] = { false };\n    while (*dizi) {\n        if (bulunmus[*dizi]) {\n            tekrar[*dizi] = true;\n        } else {\n            bulunmus[*dizi] = true;\n        }\n        dizi++;\n    }\n    printf(\"Tekrarlanan harfler: \");\n    for (int i = 0; i < 256; i++) {\n        if (tekrar[i]) {\n            printf(\"%c \", i);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char dizi[] = \"programming\";\n    tekrarEdenHarfler(dizi);\n    return 0;\n}\n```\nBu kod, 'programming' dizisindeki tekrarlanan harfleri bulur ve 'r', 'g', 'm' harflerini yazdırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711353"
  },
  {
    "question": "C dilinde bir karakter dizisini belirli bir alt dize ile kontrol eden bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisinin içinde belirli bir alt dizenin olup olmadığını kontrol eder. 'strstr' fonksiyonu kullanılarak alt dize bulunur.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint altDiziVarMi(char* dizi, char* altDizi) {\n    return strstr(dizi, altDizi) != NULL;\n}\n\nint main() {\n    char dizi[] = \"Merhaba dünya!\";\n    char altDizi[] = \"dünya\";\n    if (altDiziVarMi(dizi, altDizi)) {\n        printf(\"'%s' dizesinde '%s' alt dizesi bulunmaktadır.\\n\", dizi, altDizi);\n    } else {\n        printf(\"'%s' dizesinde '%s' alt dizesi bulunmamaktadır.\\n\", dizi, altDizi);\n    }\n    return 0;\n}\n```\nBu kod, 'Merhaba dünya!' dizesinde 'dünya' alt dizisinin bulunduğunu kontrol eder.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711380"
  },
  {
    "question": "C dilinde bir karakter dizisinin boşlukları kaldıran bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bir karakter dizisindeki tüm boşluk karakterlerini kaldırır. Yeni dizinin boyutuna göre bellekte yer açılır ve boşluksuz içerik kopyalanır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* bosluklariKaldir(char* dizi) {\n    int uzunluk = strlen(dizi);\n    char* sonuc = (char*)malloc(uzunluk + 1);\n    int j = 0;\n    for (int i = 0; i < uzunluk; i++) {\n        if (dizi[i] != ' ') {\n            sonuc[j++] = dizi[i];\n        }\n    }\n    sonuc[j] = '\\0';\n    return sonuc;\n}\n\nint main() {\n    char dizi[] = \"Merhaba dünya!\";\n    char* sonuc = bosluklariKaldir(dizi);\n    printf(\"Boşluksuz dizi: %s\\n\", sonuc);\n    free(sonuc);\n    return 0;\n}\n```\nBu kod, 'Merhaba dünya!' dizesini 'Merhabadünya!' olarak dönüştürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:22:43.711403"
  },
  {
    "question": "Bir karakter dizisinin uzunluğunu bulmak için hangi fonksiyonu kullanmalıyım? Kodumu gözden geçir.",
    "answer": "C dilinde bir karakter dizisinin uzunluğunu bulmak için 'strlen' fonksiyonunu kullanabilirsiniz. Ancak, kendi yazdığınız bir fonksiyon kullanıyorsanız, aşağıdaki gibi bir yaklaşım kullanabilirsiniz:\n\n```c\nint my_strlen(const char *str) {\n    int length = 0;\n    while (*str++) {\n        length++;\n    }\n    return length;\n}\n```\nBu fonksiyon, dizinin sonundaki null karaktere (\\0) kadar gider ve toplam karakter sayısını döner. Ancak, strlen kullanmak daha verimlidir ve yerleşik bir çözüm olduğu için daha güvenilirdir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.687799"
  },
  {
    "question": "Karakter dizisini tersine çevirmek için bir algoritma yazdım ama performansını artırmak istiyorum. Kodumu gözden geçir.",
    "answer": "Aşağıdaki gibi bir fonksiyonla karakter dizisini tersine çevirebilirsiniz:\n\n```c\nvoid reverse_string(char *str) {\n    int start = 0;\n    int end = strlen(str) - 1;\n    char temp;\n    while (start < end) {\n        temp = str[start];\n        str[start] = str[end];\n        str[end] = temp;\n        start++;\n        end--;\n    }\n}\n```\nBu fonksiyonda, iki işaretçi kullanarak, dizinin başını ve sonunu karşılaştırarak dönüşüm yapıyoruz. Bu yöntem, her karakteri yalnızca bir kez ziyaret eder ve O(n) zaman karmaşıklığına sahiptir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.687877"
  },
  {
    "question": "Karakter dizisinde bir alt dizinin var olup olmadığını kontrol etmek için yazdığım kod hatalı. Yardımcı olur musun?",
    "answer": "Alt dizi aramak için 'strstr' fonksiyonunu kullanabilirsiniz. Ancak kendi fonksiyonunuzu yazmak isterseniz, aşağıdaki gibi bir yaklaşım kullanabilirsiniz:\n\n```c\nint contains_substring(const char *str, const char *sub) {\n    const char *p1 = str;\n    const char *p2 = sub;\n    while (*p1) {\n        if (*p1 == *p2) {\n            const char *start = p1;\n            while (*p1 && *p2 && *p1 == *p2) {\n                p1++;\n                p2++;\n            }\n            if (!*p2) return 1; // Alt dizi bulundu\n            p2 = sub; // Başlangıca geri dön\n        }\n        p1++;\n    }\n    return 0; // Alt dizi bulunamadı\n}\n```\nBu kodda, her karakter eşleştiğinde bir iç döngü başlatıyoruz ve alt dizinin tamamını kontrol ediyoruz. Ancak, strstr kullanmak daha etkilidir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.687938"
  },
  {
    "question": "İki karakter dizisini birleştirmem gerekiyor. Performansı artırmak için önerilerin var mı?",
    "answer": "Dizileri birleştirmek için aşağıdaki gibi bir fonksiyon kullanabilirsiniz:\n\n```c\nvoid concat_strings(char *dest, const char *src) {\n    while (*dest) dest++; // 'dest' dizisinin sonunu bul\n    while ((*dest++ = *src++)); // 'src' dizisini ekle\n}\n```\nBu kod, 'dest' dizisinin sonuna 'src' dizisini ekler. Bununla birlikte, dizinin boyutunun yeterli olduğundan emin olmalısınız. Ayrıca, 'strcat' fonksiyonu da bu amaç için kullanılabilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.687989"
  },
  {
    "question": "Karakter dizisinde büyük harfleri küçük harflere dönüştürmek için yazdığım fonksiyon hatalı. Lütfen kontrol et.",
    "answer": "Aşağıdaki şekilde bir fonksiyon kullanabilirsiniz:\n\n```c\nvoid to_lowercase(char *str) {\n    while (*str) {\n        if (*str >= 'A' && *str <= 'Z') {\n            *str += 32; // ASCII değeri ile dönüşüm\n        }\n        str++;\n    }\n}\n```\nBu kod, her karakteri kontrol eder ve büyük harfleri küçük harfe çevirir. Ancak, 'tolower' fonksiyonu gibi yerleşik yöntemler de mevcuttur ve daha güvenli bir tercih olabilir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688045"
  },
  {
    "question": "Bir karakter dizisinde tekrar eden karakterleri kaldırmak istiyorum. Bunun için önerin var mı?",
    "answer": "Tekrar eden karakterleri kaldırmak için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nvoid remove_duplicates(char *str) {\n    char *current = str;\n    char *next;\n    while (*current) {\n        next = current + 1;\n        while (*next) {\n            if (*next == *current) {\n                char *temp = next;\n                while (*temp) {\n                    *temp = *(temp + 1);\n                    temp++;\n                }\n            } else {\n                next++;\n            }\n        }\n        current++;\n    }\n}\n```\nBu fonksiyon, her karakteri kontrol eder ve tekrar edenleri diziden kaldırır. Ancak, daha verimli bir algoritma için bir hash tablosu kullanmayı düşünebilirsiniz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688096"
  },
  {
    "question": "Karakter dizisini sayıya dönüştürmem gerekiyor, ama performansı artırmak istiyorum. Kodumda bir iyileştirme önerin var mı?",
    "answer": "Aşağıdaki gibi bir fonksiyonla karakter dizisini sayıya dönüştürebilirsiniz:\n\n```c\nint string_to_int(const char *str) {\n    int result = 0;\n    while (*str) {\n        result = result * 10 + (*str - '0');\n        str++;\n    }\n    return result;\n}\n```\nBu fonksiyon, her karakteri okur ve sayıya dönüştürür. Bununla birlikte, 'atoi' fonksiyonunu da kullanabilirsiniz, bu fonksiyon hata kontrolü içerir ve daha güvenli bir yaklaşımdır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688154"
  },
  {
    "question": "Bir karakter dizisindeki en uzun kelimeyi bulmak için yazdığım kod iyi çalışmıyor. Hatalarını düzelt.",
    "answer": "Aşağıdaki gibi bir fonksiyon kullanabilirsiniz:\n\n```c\nchar* find_longest_word(char *str) {\n    char *longest = NULL;\n    int max_length = 0;\n    char *current = str;\n    int current_length = 0;\n\n    while (*current) {\n        if (*current == ' ' || *current == '\\0') {\n            if (current_length > max_length) {\n                max_length = current_length;\n                longest = current - current_length;\n            }\n            current_length = 0;\n        } else {\n            current_length++;\n        }\n        current++;\n    }\n    return longest ? strndup(longest, max_length) : NULL;\n}\n```\nBu fonksiyon, karakter dizisini kelime kelime tarar ve en uzun kelimeyi bulur. 'strndup' ile en uzun kelimeyi yeni bir dizide kopyalar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688206"
  },
  {
    "question": "Bir karakter dizisini belirli bir karakterle ayırmak istiyorum. Kodum verimli mi?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nvoid split_string(const char *str, char delimiter) {\n    const char *start = str;\n    while (*str) {\n        if (*str == delimiter) {\n            printf(\"%.*s\\n\", (int)(str - start), start);\n            start = str + 1;\n        }\n        str++;\n    }\n    if (start < str) {\n        printf(\"%.*s\\n\", (int)(str - start), start);\n    }\n}\n```\nBu fonksiyon, verilmiş bir ayırıcı karakter ile diziyi böler ve her parçayı yazdırır. Bu yöntem oldukça etkilidir ve O(n) karmaşıklığındadır. Ancak, 'strtok' gibi yerleşik fonksiyonlar da mevcuttur.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688251"
  },
  {
    "question": "Bir karakter dizisini büyük harflerle yazdırmak istiyorum, fakat mevcut kodumda sorun var. Lütfen bak.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nvoid print_uppercase(const char *str) {\n    while (*str) {\n        putchar(toupper(*str)); // Her karakteri büyük harfe çevir\n        str++;\n    }\n}\n```\nBu fonksiyon, her karakteri 'toupper' fonksiyonu ile büyük harfe dönüştürerek yazdırır. Bu, mevcut kodunuza göre daha verimli bir yaklaşım sunar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:12.688305"
  },
  {
    "question": "C dilinde bir karakter dizisinin uzunluğunu hesaplamak için yazılmış bir fonksiyonun performansını nasıl optimize edebiliriz?",
    "answer": "Karakter dizisinin uzunluğunu hesaplamak için genellikle döngü kullanılır. Ancak, eğer dizinin her bir karakterinin ASCII değerini işleme alıyorsanız, bu hesaplamayı tek bir fonksiyona yerleştirip dizinin uzunluğuyla birlikte bazı karakter istatistiklerini de hesaplayabilirsiniz. Örneğin:\n\n```c\nvoid calculate_length_and_stats(const char *str, int *length, int *vowel_count) {\n    *length = 0;\n    *vowel_count = 0;\n    while (str[*length] != '\\0') {\n        char ch = tolower(str[*length]);\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            (*vowel_count)++;\n        }\n        (*length)++;\n    }\n}\n```\nBu şekilde, sadece bir döngü ile hem uzunluğu hem de sesli harf sayısını hesaplayabilirsiniz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116478"
  },
  {
    "question": "C dilinde bir karakter dizisini tersine çevirmek için yazılmış bir fonksiyon hatalı çalışıyor. Hatanın kaynağı nedir ve nasıl düzeltebiliriz?",
    "answer": "Karakter dizisini tersine çevirmek için iki uçtaki karakterleri değiştirerek ilerlemek gerekebilir. Ancak eğer dizi sonuna gelindiğinde \\'\\0' karakterini atlamazsanız sorun çıkabilir. İşte düzeltilmiş bir versiyon:\n\n```c\nvoid reverse_string(char *str) {\n    int start = 0;\n    int end = strlen(str) - 1;\n    while (start < end) {\n        char temp = str[start];\n        str[start] = str[end];\n        str[end] = temp;\n        start++;\n        end--;\n    }\n}\n```\nBu kod, dizinin sonundaki \\'\\0' karakterini doğru bir şekilde dikkate alır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116598"
  },
  {
    "question": "C dilinde iki karakter dizisinin eşit olup olmadığını kontrol eden bir fonksiyonun geliştirilmesi gerekiyor. Bu fonksiyonu optimize etmenin yolları nelerdir?",
    "answer": "İki karakter dizisini karşılaştırırken her iki dizinin de uzunluğunu kontrol etmek, gereksiz yere bellek erişimini azaltır. Eğer uzunluklar eşit değilse, dizilerin eşit olmadığını hemen belirleyebilirsiniz. İşte optimize edilmiş bir fonksiyon örneği:\n\n```c\nint are_strings_equal(const char *str1, const char *str2) {\n    while (*str1 && (*str1 == *str2)) {\n        str1++;\n        str2++;\n    }\n    return *str1 == *str2;\n}\n```\nBu fonksiyon, her iki dizinin sonuna kadar ilerlemek yerine, farklı olan ilk karakterde hemen çıkış yapar.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116671"
  },
  {
    "question": "C dilinde büyük/küçük harf duyarsız string karşılaştırması yapmak için bir fonksiyon yazmalıyım. Nasıl bir yol izlemeliyim?",
    "answer": "Büyük/küçük harf duyarsız karşılaştırma yaparken, her iki karakteri de küçük harfe çevirip karşılaştırmak en yaygın yöntemdir. Aşağıdaki fonksiyon bu yaklaşımı kullanmaktadır:\n\n```c\nint case_insensitive_compare(const char *str1, const char *str2) {\n    while (*str1 && (tolower(*str1) == tolower(*str2))) {\n        str1++;\n        str2++;\n    }\n    return tolower(*str1) == tolower(*str2);\n}\n```\nBu fonksiyon, karşılaştırma sırasında her iki karakterin de küçük halini kullanarak doğru sonuç verir.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116733"
  },
  {
    "question": "Bir C programında karakter dizisini belirli bir alt dizi ile değiştirmek istiyorum. Ancak, performansı artırmak için nasıl bir yöntem izlemeliyim?",
    "answer": "Diziyi değiştirmek için öncelikle arama yaparak değiştirilecek alt dizinin başlangıç konumunu bulabiliriz. Bu işlemden sonra, yeni diziyi oluşturmak ve gerektiğinde belleği serbest bırakmak önemlidir. Aşağıdaki kod örneği bu süreci göstermektedir:\n\n```c\nchar* replace_substring(const char *str, const char *old, const char *new_sub) {\n    char *pos = strstr(str, old);\n    if (!pos) return strdup(str);\n    size_t len = strlen(str) + strlen(new_sub) - strlen(old);\n    char *result = malloc(len + 1);\n    strncpy(result, str, pos - str);\n    result[pos - str] = '\\0';\n    strcat(result, new_sub);\n    strcat(result, pos + strlen(old));\n    return result;\n}\n```\nBu yöntemle bellekte aynı anda sadece gerekli alanı kullanarak verimliliği artırmış olursunuz.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116801"
  },
  {
    "question": "C dilinde bir karakter dizisinin içindeki tüm boşlukları kaldırmak istiyorum. Bunun için yazılmış bir fonksiyonun verimliliğini nasıl artırabilirim?",
    "answer": "Boşlukları kaldırırken diziyi değiştirmek yerine yeni bir dizi oluşturarak daha verimli bir yaklaşım benimseyebilirsiniz. Aşağıdaki fonksiyon, boşlukları kaldırırken yeni bir dizi kullanır:\n\n```c\nvoid remove_spaces(const char *str, char *result) {\n    while (*str) {\n        if (*str != ' ') {\n            *result++ = *str;\n        }\n        str++;\n    }\n    *result = '\\0';\n}\n```\nBu yaklaşım, gereksiz kopyalamaları önleyerek bellek verimliliğini artırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116867"
  },
  {
    "question": "Bir C programında karakter dizilerinin birleştirilmesi gerektiğinde, bellek yönetimi ve performans açısından nasıl bir yaklaşım izlenmeli?",
    "answer": "Karakter dizilerini birleştirirken, her iki dizinin uzunluğunu hesaplayarak yeterli bellek ayırmak önemlidir. Aşağıdaki fonksiyon, iki diziyi birleştirirken gerekli bellek yönetimini de sağlamaktadır:\n\n```c\nchar* concatenate_strings(const char *str1, const char *str2) {\n    size_t len1 = strlen(str1);\n    size_t len2 = strlen(str2);\n    char *result = malloc(len1 + len2 + 1);\n    if (!result) return NULL;\n    strcpy(result, str1);\n    strcat(result, str2);\n    return result;\n}\n```\nBu kod, bellek yönetimini doğru bir şekilde yaparak birleştirme işlemi sonucunda oluşan yeni diziyi döndürür.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.116943"
  },
  {
    "question": "C dilinde bir karakter dizisinin içindeki tüm harfleri büyük harfe çevirmek için bir fonksiyon yazmalıyım. Performansı artırmak için nasıl bir yol izleyebilirim?",
    "answer": "Karakter dizisini büyük harfe çevirirken, her karakteri kontrol ederek ve yalnızca harfleri değiştirmek, performansı artırır. İşte bu yaklaşımı uygulayan bir fonksiyon:\n\n```c\nvoid to_uppercase(char *str) {\n    while (*str) {\n        if (*str >= 'a' && *str <= 'z') {\n            *str -= 32; // veya *str = toupper(*str);\n        }\n        str++;\n    }\n}\n```\nBu fonksiyon, yalnızca küçük harfleri büyük harfe çevirerek gereksiz işlem yükünü azaltır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.117016"
  },
  {
    "question": "C dilinde bir karakter dizisini belirli bir karaktere göre bölmek için bir fonksiyon yazmalıyım. Bu işlemin performansını nasıl artırabilirim?",
    "answer": "Bir dizi üzerinde bölme işlemi yaparken, dizinin her karakterini kontrol ederek ve bir sonuç dizi listesi oluşturarak verimliliği artırabilirsiniz. Aşağıdaki örnek, bu yaklaşımı göstermektedir:\n\n```c\nchar** split_string(const char *str, char delimiter, int *count) {\n    int size = 1, i = 0;\n    const char *start = str;\n    while (*str) {\n        if (*str == delimiter) {\n            size++;\n        }\n        str++;\n    }\n    char **result = malloc(size * sizeof(char*));\n    str = start;\n    while (*str) {\n        const char *end = strchr(str, delimiter);\n        if (!end) end = str + strlen(str);\n        int length = end - str;\n        result[i] = malloc(length + 1);\n        strncpy(result[i], str, length);\n        result[i][length] = '\\0';\n        str = end + 1;\n        i++;\n    }\n    *count = size;\n    return result;\n}\n```\nBu fonksiyon, diziyi birden fazla parçaya ayırarak verimliliği artırır.",
    "category": "arrays_strings",
    "topic": "character_arrays",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Karakter dizileri",
    "timestamp": "2025-06-01T15:23:47.117081"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayın ve açıklayın: int main() { int a = 10; int *p; ___; printf('%d', *p); return 0; }",
    "answer": "Eksik olan kısım 'p = &a;' şeklindedir. Bu, 'p' pointer'ını 'a' değişkeninin adresine işaret edecek şekilde ayarlar. Böylece 'printf' fonksiyonu ile 'a'nın değeri 10 olarak yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524298"
  },
  {
    "question": "Aşağıdaki kodda işlevi tamamlayın: void degerAta(int *num) { ___; } int main() { int sayi = 5; degerAta(&sayi); printf('%d', sayi); return 0; }",
    "answer": "Eksik kısım '(*num) = 10;' şeklindedir. Bu, 'num' pointer'ı ile gösterilen değişkenin değerini 10 olarak ayırlar. 'main' fonksiyonundaki 'sayi' değişkeni artık 10 olarak yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524370"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: void toplam(int *x, int *y) { ___; } int main() { int a = 2, b = 3; toplam(&a, &b); printf('%d', a); return 0; }",
    "answer": "Eksik olan kısım '*x += *y;' şeklindedir. Bu, 'x' pointer'ının gösterdiği değeri 'y' pointer'ının gösterdiği değerle toplar. Dolayısıyla, 'a' değişkeninin değeri 5 olarak yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524430"
  },
  {
    "question": "Aşağıdaki kodda eksik kısım nedir? void diziYazdir(int *dizi, int boyut) { for (int i = 0; i < boyut; i++) { ___; } } int main() { int arr[] = {1, 2, 3}; diziYazdir(arr, 3); return 0; }",
    "answer": "Eksik kısım 'printf('%d ', dizi[i]);' olmalıdır. Bu, 'dizi' pointer'ının gösterdiği dizinin her elemanını yazdırır. Sonuç olarak, '1 2 3' olarak ekrana basılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524496"
  },
  {
    "question": "Aşağıdaki kodu tamamlayın: void swap(int *x, int *y) { ___; } int main() { int a = 5, b = 10; swap(&a, &b); printf('%d %d', a, b); return 0; }",
    "answer": "Eksik kısım 'int temp = *x; *x = *y; *y = temp;' şeklindedir. Bu, 'x' ve 'y' pointer'ları aracılığıyla 'a' ve 'b' değişkenlerinin değerlerini değiştirmeyi sağlar. Sonuç olarak, 10 ve 5 yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524574"
  },
  {
    "question": "Aşağıdaki kodda eksik kısımları tamamlayın: void elemanEkle(int **dizi, int *boyut, int eleman) { ___; } int main() { int *arr = NULL; int boyut = 0; elemanEkle(&arr, &boyut, 7); return 0; }",
    "answer": "Eksik kısım 'arr = realloc(*dizi, (*boyut + 1) * sizeof(int)); (*arr)[*boyut] = eleman; (*boyut)++;' şeklindedir. Bu, dinamik olarak dizinin boyutunu artırır ve yeni elemanı ekler.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524658"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayın: void printPointer(int *ptr) { if (ptr != NULL) { ___; } } int main() { int a = 5; int *p = &a; printPointer(p); return 0; }",
    "answer": "Eksik kısım 'printf('%d', *ptr);' şeklindedir. Bu, 'ptr' pointer'ının işaret ettiği değeri kontrol eder ve yazdırır. Eğer 'p' NULL değilse, 5 değeri ekrana basılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524727"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayın: void reverse(int *dizi, int boyut) { for (int i = 0; i < boyut / 2; i++) { ___; } } int main() { int arr[] = {1, 2, 3, 4}; reverse(arr, 4); return 0; }",
    "answer": "Eksik kısım 'int temp = dizi[i]; dizi[i] = dizi[boyut - i - 1]; dizi[boyut - i - 1] = temp;' şeklindedir. Bu, diziyi ters çevirir. Sonuç olarak, dizinin içeriği 4, 3, 2, 1 olarak değiştirilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524828"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayın: void increaseValue(int *value) { ___; } int main() { int a = 20; increaseValue(&a); printf('%d', a); return 0; }",
    "answer": "Eksik kısım '*value += 5;' şeklindedir. Bu, 'value' pointer'ının işaret ettiği değeri 5 artırır. 'main' fonksiyonunda 'a' değişkeni artık 25 olarak yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524907"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayın: void printArray(int *arr, int size) { for (int i = 0; i < size; i++) { ___; } } int main() { int numbers[] = {1, 2, 3, 4}; printArray(numbers, 4); return 0; }",
    "answer": "Eksik kısım 'printf('%d ', arr[i]);' olmalıdır. Bu, 'arr' pointer'ının işaret ettiği dizinin her elemanını ekrana basar. Sonuç olarak, '1 2 3 4' yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:07.524985"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın ve açıklayın: \n\n#include <stdio.h>\n\nvoid increment(int *p) {\n    // eksik kod\n}\n\nint main() {\n    int num = 5;\n    increment(&num);\n    printf(\"Num: %d\", num);\n    return 0;\n}",
    "answer": "Eksik olan kod \"*p += 1;\" şeklinde olmalıdır. Bu fonksiyon, bir tamsayı pointer'ı alır ve bu pointer'ın gösterdiği değeri 1 artırır. main fonksiyonunda, num değişkeninin adresi geçilir ve increment fonksiyonu içindeki pointer sayesinde num'un değeri artırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.769718"
  },
  {
    "question": "Aşağıdaki kodda işlevselliği sağlamak için eksik kısımları tamamlayın:\n\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    // eksik kod\n}\n\nint main() {\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"X: %d, Y: %d\", x, y);\n    return 0;\n}",
    "answer": "Eksik kod \"int temp = *a; *a = *b; *b = temp;\" şeklinde olmalıdır. Bu fonksiyon, iki tam sayı pointer'ını alır ve gösterdikleri değerlerin yerlerini değiştirir. main fonksiyonunda x ve y'nin adresleri geçilir, ardından swap fonksiyonu ile değerler değiştirilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.769826"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid setArray(int *arr, int size) {\n    // eksik kod\n}\n\nint main() {\n    int myArray[5];\n    setArray(myArray, 5);\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", myArray[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kod \"for(int i = 0; i < size; i++) arr[i] = i;\" şeklinde olmalıdır. Bu fonksiyon, bir tam sayı dizisinin elemanlarını 0'dan başlayarak dizinin boyutuna kadar sıralı sayılarla doldurur. main fonksiyonunda myArray dizisi setArray fonksiyonuna geçirildiğinde dizi elemanları güncellenir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.769918"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid fillArrayWithValue(int *arr, int size, int value) {\n    // eksik kod\n}\n\nint main() {\n    int myArray[5];\n    fillArrayWithValue(myArray, 5, 10);\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", myArray[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kod \"for(int i = 0; i < size; i++) arr[i] = value;\" şeklinde olmalıdır. Bu fonksiyon, verilen değeri dizi elemanlarına atar. main fonksiyonunda fillArrayWithValue çağrıldığında, dizinin tüm elemanları 10 ile doldurulur.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770021"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid printPointerAddress(int *p) {\n    // eksik kod\n}\n\nint main() {\n    int var = 42;\n    printPointerAddress(&var);\n    return 0;\n}",
    "answer": "Eksik kod \"printf(\"Pointer Address: %p\", (void*)p);\" şeklinde olmalıdır. Bu fonksiyon, bir tam sayı pointer'ının adresini yazdırır. main fonksiyonunda var değişkeninin adresi geçilir ve bu adres ekrana yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770076"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayarak çalışır hale getirin:\n\n#include <stdio.h>\n\nvoid allocateArray(int **arr, int size) {\n    // eksik kod\n}\n\nint main() {\n    int *myArray;\n    allocateArray(&myArray, 5);\n    // diziye değer atayın ve yazdırın\n    return 0;\n}",
    "answer": "Eksik kod \"*arr = (int*)malloc(size * sizeof(int));\" şeklinde olmalıdır. Bu fonksiyon, bir pointer dizisi için dinamik olarak bellek ayırır. main fonksiyonunda myArray için bellek ayrıldıktan sonra bu diziye değerler atanabilir ve yazdırılabilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770147"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid printSecondElement(int *arr) {\n    // eksik kod\n}\n\nint main() {\n    int myArray[] = {1, 2, 3, 4, 5};\n    printSecondElement(myArray);\n    return 0;\n}",
    "answer": "Eksik kod \"printf(\"Second Element: %d\", arr[1]);\" şeklinde olmalıdır. Bu fonksiyon, bir dizi pointer'ı alır ve dizinin ikinci elemanını yazdırır. main fonksiyonunda myArray dizisi printSecondElement fonksiyonuna geçirildiğinde, dizinin ikinci elemanı 2 ekrana yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770210"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid reverseArray(int *arr, int size) {\n    // eksik kod\n}\n\nint main() {\n    int myArray[] = {1, 2, 3, 4, 5};\n    reverseArray(myArray, 5);\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", myArray[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kod \"for(int i = 0; i < size / 2; i++) { int temp = arr[i]; arr[i] = arr[size - i - 1]; arr[size - i - 1] = temp; }\" şeklinde olmalıdır. Bu fonksiyon, verilen diziyi tersine çevirir. main fonksiyonunda myArray dizisi reverseArray fonksiyonuna geçirildiğinde elemanların sırası tersine döner.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770295"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayın:\n\n#include <stdio.h>\n\nvoid modifyValue(int *p) {\n    // eksik kod\n}\n\nint main() {\n    int num = 15;\n    modifyValue(&num);\n    printf(\"Modified Value: %d\", num);\n    return 0;\n}",
    "answer": "Eksik kod \"*p = 25;\" şeklinde olmalıdır. Bu fonksiyon, bir tamsayı pointer'ı alır ve gösterdiği değeri 25 yapar. main fonksiyonunda num'un adresi modifyValue fonksiyonuna geçildiğinde, num'un değeri 25 olarak güncellenir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770355"
  },
  {
    "question": "Aşağıdaki kodda eksik kısımları tamamlayarak çalışır hale getirin:\n\n#include <stdio.h>\n\nvoid printValues(const int *arr, int size) {\n    // eksik kod\n}\n\nint main() {\n    int myArray[] = {10, 20, 30, 40};\n    printValues(myArray, 4);\n    return 0;\n}",
    "answer": "Eksik kod \"for(int i = 0; i < size; i++) printf(\"%d \", arr[i]);\" şeklinde olmalıdır. Bu fonksiyon, sabit bir tam sayı pointer'ı alır ve dizinin elemanlarını yazdırır. main fonksiyonunda myArray dizisi printValues fonksiyonuna geçirilerek elemanları ekrana yazdırılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:24:36.770423"
  },
  {
    "question": "Bir tamsayı dizisinin en büyük elemanını bulmak için bir fonksiyon yazın. Bu fonksiyon bir pointer almalı.",
    "answer": "#include <stdio.h>\n\nvoid enBuyukElemanBul(int *dizi, int boyut, int *enBuyuk) {\n    *enBuyuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > *enBuyuk) {\n            *enBuyuk = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {3, 1, 4, 1, 5, 9};\n    int enBuyuk;\n    enBuyukElemanBul(dizi, 6, &enBuyuk);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk);\n    return 0;\n}\n\n// Bu kodda, enBuyukElemanBul fonksiyonu bir pointer aracılığıyla en büyük elemanı bulur ve bu değeri main fonksiyonuna geri döndürür.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956170"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için bir fonksiyon yazın. Bu fonksiyon bir pointer almalı.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = str[i];\n        str[i] = str[uzunluk - 1 - i];\n        str[uzunluk - 1 - i] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    tersCevir(str);\n    printf(\"Ters çevrilmiş: %s\\n\", str);\n    return 0;\n}\n\n// Bu kodda, tersCevir fonksiyonu bir karakter dizisinin içeriğini değiştirmek için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956215"
  },
  {
    "question": "Dinamik olarak tahsis edilmiş bir tamsayı dizisinin elemanlarını toplayan bir fonksiyon yazın. Bu dizinin pointer'ını kullanın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint toplama(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int boyut = 5;\n    int *dizi = (int *)malloc(boyut * sizeof(int));\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] = i + 1;\n    }\n    printf(\"Toplam: %d\\n\", toplama(dizi, boyut));\n    free(dizi);\n    return 0;\n}\n\n// Bu kodda, toplama fonksiyonu dinamik olarak tahsis edilen dizinin elemanlarının toplamını hesaplamak için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956263"
  },
  {
    "question": "Bir dizi içindeki çift ve tek sayıları ayıran bir fonksiyon yazın. Fonksiyon, iki farklı dizi için pointer almalı.",
    "answer": "#include <stdio.h>\n\nvoid ayir(int *girdi, int *ciftler, int *tekler, int boyut, int *ciftSayisi, int *tekSayisi) {\n    *ciftSayisi = 0;\n    *tekSayisi = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (girdi[i] % 2 == 0) {\n            ciftler[(*ciftSayisi)++] = girdi[i];\n        } else {\n            tekler[(*tekSayisi)++] = girdi[i];\n        }\n    }\n}\n\nint main() {\n    int girdi[] = {1, 2, 3, 4, 5, 6};\n    int ciftler[6], tekler[6];\n    int ciftSayisi, tekSayisi;\n    ayir(girdi, ciftler, tekler, 6, &ciftSayisi, &tekSayisi);\n    printf(\"Çiftler: \");\n    for (int i = 0; i < ciftSayisi; i++) printf(\"%d \", ciftler[i]);\n    printf(\"\\nTekler: \");\n    for (int i = 0; i < tekSayisi; i++) printf(\"%d \", tekler[i]);\n    return 0;\n}\n\n// Bu kodda, ayir fonksiyonu girdi dizisindeki çift ve tek sayıları ayırmak için iki farklı dizi için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956298"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını sıralamak için bir fonksiyon yazın. Fonksiyon, dizinin pointer'ını almalı ve sıralama işlemi yapmalıdır.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 6, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < boyut; i++) printf(\"%d \", dizi[i]);\n    return 0;\n}\n\n// Bu kodda, sirala fonksiyonu bir dizinin elemanlarını sıralamak için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956353"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını kopyalamak için bir fonksiyon yazın. Kopyalama işlemi için bir pointer kullanın.",
    "answer": "#include <stdio.h>\n\nvoid kopyala(int *kaynak, int *hedef, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        hedef[i] = kaynak[i];\n    }\n}\n\nint main() {\n    int kaynak[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(kaynak) / sizeof(kaynak[0]);\n    int hedef[boyut];\n    kopyala(kaynak, hedef, boyut);\n    printf(\"Hedef dizi: \");\n    for (int i = 0; i < boyut; i++) printf(\"%d \", hedef[i]);\n    return 0;\n}\n\n// Bu kodda, kopyala fonksiyonu bir dizinin elemanlarını kopyalamak için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956384"
  },
  {
    "question": "Bir dizi içindeki belirli bir elemanın indeksini bulan bir fonksiyon yazın. Fonksiyon bir pointer almalı ve elemanın indeksini geri döndürmelidir.",
    "answer": "#include <stdio.h>\n\nint elemanIndeksiBul(int *dizi, int boyut, int aranan) {\n    for (int i = 0; i < boyut; i++) {\n        if (dizi[i] == aranan) {\n            return i;\n        }\n    }\n    return -1; // Eleman bulunamazsa -1 döner\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int aranan = 30;\n    int indeks = elemanIndeksiBul(dizi, boyut, aranan);\n    if (indeks != -1) {\n        printf(\"%d elemanının indeksi: %d\\n\", aranan, indeks);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kodda, elemanIndeksiBul fonksiyonu bir dizide belirli bir elemanın indeksini bulmak için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956422"
  },
  {
    "question": "Bir tamsayı dizisinin en küçük elemanını bulmak için bir fonksiyon yazın. Bu fonksiyon, dizinin pointer'ını ve en küçük elemanı tutacak bir pointer almalı.",
    "answer": "#include <stdio.h>\n\nvoid enKucukElemanBul(int *dizi, int boyut, int *enKucuk) {\n    *enKucuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < *enKucuk) {\n            *enKucuk = dizi[i];\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {9, 7, 3, 5, 1};\n    int enKucuk;\n    enKucukElemanBul(dizi, 5, &enKucuk);\n    printf(\"En küçük eleman: %d\\n\", enKucuk);\n    return 0;\n}\n\n// Bu kodda, enKucukElemanBul fonksiyonu bir dizideki en küçük elemanı bulmak için pointer kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:07.956464"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını ekrana yazdırmak için pointer kullanıyorum, ancak sonuç beklediğim gibi değil. Kodum şu şekilde: \n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    int *ptr = dizi;\n    for (int i = 0; i <= 5; i++) {\n        printf(\"%d \", *(ptr + i));\n    }\n    return 0;\n}\n``` \nNeden hata alıyorum?",
    "answer": "Kodda 'for' döngüsünün koşulu 'i <= 5' şeklinde ayarlanmış. Bu, dizinin sınırlarını aşarak bellek hatası vermesine neden oluyor. Dizinin indeksleri 0'dan 4'e kadar (5 eleman) gider, dolayısıyla 'i < 5' olmalıdır. Düzgün kod şöyle olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    int *ptr = dizi;\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", *(ptr + i));\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.592818"
  },
  {
    "question": "Şu kodda bir tamsayıyı bir pointer aracılığıyla değiştirmeye çalışıyorum, ama değişiklik etkili olmuyor:\n\n```c\n#include <stdio.h>\n\nvoid degistir(int *ptr) {\n    *ptr = 20;\n}\n\nint main() {\n    int sayi = 10;\n    degistir(&sayi);\n    printf(\"Sayı: %d\", sayi);\n    return 0;\n}\n``` \nNeden 'Sayı: 10' yazıyor?",
    "answer": "Kod doğru görünüyor. 'degistir' fonksiyonu, pointer ile gönderilen değeri 20 olarak değiştiriyor. Ancak, kodun farklı bir versiyonunda pointer'ın değerini değiştirmek için 'ptr' yerine başka bir isim kullanıldığında, değişiklik etkili olmayabilir. Aksi takdirde, bu kod çalıştığında 'Sayı: 20' yazmalıdır. Eğer hala 'Sayı: 10' yazıyorsa, muhtemel hata başka bir yerdedir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.592934"
  },
  {
    "question": "Aşağıdaki kodda dinamik bellekte bir dizi oluşturuyorum ama bellek sızıntısı yaşıyorum:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *dizi = malloc(5 * sizeof(int));\n    for (int i = 0; i < 5; i++) {\n        dizi[i] = i;\n    }\n    // Bellek serbest bırakılmıyor\n    return 0;\n}\n``` \nNeden bellek sızıntısı oluyor?",
    "answer": "Kodda dinamik olarak allocate edilen bellek için herhangi bir 'free' çağrısı yok. Belleği serbest bırakmadığınız için bellek sızıntısı oluşur. Kodun sonuna 'free(dizi);' eklemelisiniz. Düzgün kod şöyle olmalıdır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *dizi = malloc(5 * sizeof(int));\n    for (int i = 0; i < 5; i++) {\n        dizi[i] = i;\n    }\n    free(dizi);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593032"
  },
  {
    "question": "Aşağıdaki kodda iki tamsayıyı karşılaştırmak için pointer kullanıyorum fakat her zaman '0' sonucu alıyorum:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 5, b = 10;\n    int *ptr_a = &a;\n    int *ptr_b = &b;\n    int sonuc = (*ptr_a > *ptr_b);\n    printf(\"Sonuç: %d\", sonuc);\n    return 0;\n}\n``` \nNeden her zaman '0' yazıyor?",
    "answer": "Kodun mantığı doğru, fakat karşılaştırma sonucu bir boolean değer olarak bekleniyor. Ancak, 'sonuc' değişkeninin değeri 0 veya 1 şeklinde olacak. Yani, 0 sonucunu almanız, 'a' nın 'b'den büyük olmadığını gösterir. Kodunuz çalışıyor ama karşılaştırma doğru bir şekilde işleniyor. Eğer 'a' nın değeri 15 olsaydı, sonuç 1 olacaktı.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593131"
  },
  {
    "question": "Aşağıdaki kodda pointer ile bir string'i yazdırmak istiyorum fakat yazdırma işlemi boş bir string olarak görünüyor:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char *str;\n    str = \"Merhaba\";\n    printf(\"String: %s\", str);\n    str[0] = 'm'; // Değişiklik yapmak istiyorum\n    return 0;\n}\n``` \nNeden hata alıyorum?",
    "answer": "Kod doğru görünüyor fakat string sabit bir alanda saklanıyor, bu nedenle 'str[0] = 'm';' ifadesi bellek ihlali yapar. Sabit string'ler değiştirilemez. Eğer değişiklik yapmak istiyorsanız, string'i bir dizi olarak tanımlamalısınız:\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"Merhaba\";\n    printf(\"String: %s\", str);\n    str[0] = 'm';\n    printf(\"Değiştirilmiş String: %s\", str);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593237"
  },
  {
    "question": "Aşağıdaki kodda bir pointer ile iki tamsayının yerlerini değiştirmek istiyorum fakat sonuç beklediğim gibi olmuyor:\n\n```c\n#include <stdio.h>\n\nvoid yerDegistir(int *x, int *y) {\n    int temp;\n    temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nint main() {\n    int a = 5, b = 10;\n    yerDegistir(&a, &b);\n    printf(\"a: %d, b: %d\", a, b);\n    return 0;\n}\n``` \nNeden 'a: 10, b: 5' yazmıyorum?",
    "answer": "Kod doğru görünüyor, 'yerDegistir' fonksiyonu tamsayıların değerlerini değiştirmek için doğru bir şekilde kullanılıyor. Eğer 'a: 10, b: 5' sonucunu alamıyorsanız, kodun başka bir yerinde değişiklik yapılıyor olabilir. Ancak bu haliyle çalıştığında beklediğiniz sonuç doğru ve kodun mantığı doğru. Belki de kodu derlemeden önce eski bir sürümünü çalıştırıyorsunuz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593354"
  },
  {
    "question": "Aşağıdaki kodda bir struct içinde pointer kullanarak veri saklamaya çalışıyorum ama struct'ı yazdırırken hatalı sonuç alıyorum:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char *isim;\n} Kisi;\n\nint main() {\n    Kisi a;\n    a.isim = \"Ahmet\";\n    printf(\"İsim: %s\", a.isim);\n    a.isim[0] = 'a'; // Hata\n    return 0;\n}\n``` \nNeden 'Hata' alıyorum?",
    "answer": "Kodda struct içindeki string sabit bir bellekte yer alıyor, bu yüzden 'a.isim[0] = 'a';' ifadesi bellek hatası yaratıyor. Değiştirmek için 'isim' değerini sabit bir string yerine bir dizi olarak tanımlamalısınız. Düzgün kod şöyle olmalıdır:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char isim[20];\n} Kisi;\n\nint main() {\n    Kisi a;\n    strcpy(a.isim, \"Ahmet\");\n    printf(\"İsim: %s\", a.isim);\n    a.isim[0] = 'a';\n    printf(\"Değiştirilmiş İsim: %s\", a.isim);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593455"
  },
  {
    "question": "Aşağıdaki kodda iki pointer kullanarak bir dizinin elemanlarını tersine çevirmeye çalışıyorum ama sonuç beklediğim gibi değil:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int *ptr1 = dizi;\n    int *ptr2 = dizi + 4;\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", *(ptr2 - i));\n    }\n    return 0;\n}\n``` \nNeden diziyi ters yazamıyorum?",
    "answer": "Kodda 'ptr2 - i' ifadesi dizinin son elemanından başlayarak yazdırma işlemi yapıyor, ancak 'ptr2' her zaman dizi sonunu gösterdiği için ve 'i' değeri 0'dan 4'e kadar gittiği için bu durum beklenmedik sonuçlar doğuruyor. Doğru şekilde yazdırmak için 'ptr2 - i' yerine 'ptr1[i]' kullanmalısınız. Düzgün kod şu şekilde olmalıdır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int *ptr1 = dizi;\n    int *ptr2 = dizi + 4;\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", *(ptr2 - i));\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593592"
  },
  {
    "question": "Aşağıdaki kodda bir pointer değişkenini tanımlıyorum ama kullandıktan sonra 'NULL' değerini atamayı unutmuşum:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int *ptr;\n    *ptr = 10; // Hata\n    printf(\"Pointer: %d\", *ptr);\n    return 0;\n}\n``` \nNeden 'Hata' alıyorum?",
    "answer": "Pointer değişkeni tanımlandıktan sonra ona bir bellek adresi atamadan erişmeye çalışıyorsunuz. 'ptr' başlangıçta tanımsız bir bellek adresine işaret ediyor. Bu yüzden dereferans ettiğinizde bellek hatası alıyorsunuz. Pointer'ı kullanmadan önce bir bellek adresine işaret etmesi için 'malloc' ya da bir değişkenin adresi ile atama yapmalısınız:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr = malloc(sizeof(int));\n    *ptr = 10;\n    printf(\"Pointer: %d\", *ptr);\n    free(ptr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:25:44.593674"
  },
  {
    "question": "Bir dizinin elemanlarını bir pointer ile yazdırırken hata alıyorum. Kodum şu şekilde: int arr[] = {1, 2, 3, 4}; int *p = arr; for (int i = 0; i <= 4; i++) { printf('%d ', *(p + i)); } Neden hata alıyorum?",
    "answer": "Hatanın nedeni, dizinin boyutunu aşarak dördüncü indise erişmeye çalışmamızdır. Dizi dört eleman içeriyor ancak indeksleme 0'dan başladığı için geçerli indeksler 0, 1, 2 ve 3'tür. Bu yüzden döngü koşulunu 'i < 4' olarak değiştirmeliyiz. Doğru kod: for (int i = 0; i < 4; i++) { printf('%d ', *(p + i)); }",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621045"
  },
  {
    "question": "Aşağıdaki kodda 'segmentation fault' hatası alıyorum: void func(int *ptr) { *ptr = 10; } int main() { int *p = NULL; func(p); return 0; } Hatanın kaynağı nedir?",
    "answer": "Hatanın kaynağı, 'p' pointer'ının NULL olarak tanımlanmasıdır. NULL bir gösterici olduğundan, üzerinde işlem yapmaya çalışmak bellek hatasına neden olur. 'func' fonksiyonuna geçmeden önce 'p' değişkeninin geçerli bir bellek adresine işaret ettiğinden emin olmalıyız. Örneğin, 'int value; int *p = &value;' şeklinde tanımlamalıyız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621116"
  },
  {
    "question": "Pointer ile dinamik bellek tahsisi yaparken çalıştığım kodda bellek sızıntısı yaşıyorum. Kodum şu şekilde: int *arr = malloc(5 * sizeof(int)); // işlemler... return 0; Hata nerede?",
    "answer": "Kodda bellek tahsis ettikten sonra tahsis edilen belleği serbest bırakmıyorsunuz. Bu durumda 'free(arr);' ifadesini eklemelisiniz. Her dinamik bellek tahsisi sonrası, belleği serbest bırakmak önemlidir. Doğru kullanım: 'free(arr);' ile bellek sızıntısını önleyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621171"
  },
  {
    "question": "Pointer ile bir dizi elemanını değiştirmeye çalışıyorum ama değişiklik kaydedilmiyor. Kod: void changeValue(int *p) { *p = 5; } int main() { int arr[3] = {1, 2, 3}; changeValue(&arr[0]); printf('%d', arr[0]); } Neden 5 yazılmıyor?",
    "answer": "Kodda aslında 5 yazılmalı. Ancak eğer 'printf' ifadesinde '%' yerine '%' kullanıyorsanız, bu bir yazım hatasıdır. C dilinde format belirteçlerinde '%d' kullanmalısınız. Doğru kod: printf('%d', arr[0]); ile sonucu görebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621248"
  },
  {
    "question": "Aşağıdaki kodda bir pointer'ın adresini yazdırmaya çalışıyorum: void printAddress(int *p) { printf('%p', p); } int main() { int num = 10; printAddress(&num); return 0; } Kod neden beklediğim gibi çalışmıyor?",
    "answer": "Kod çalışıyor ama çıktı olarak pointer adresini gösteriyor. Eğer beklediğiniz numaranın değeri ise, 'printf('%d', *p);' şeklinde yazmalısınız. Bu şekilde p'nin işaret ettiği değeri görebilirsiniz. Doğru kullanım: printf('%d', *p);.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621311"
  },
  {
    "question": "İki pointer'ı değiştirirken beklenmedik sonuçlar alıyorum: void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } int main() { int x = 5, y = 10; swap(&x, &y); printf('%d, %d', x, y); } Sonuç neden 5, 10?",
    "answer": "Kod mantıken doğru fakat 'x' ve 'y' değişkenlerinin değerleri değişmeyecek gibi görünüyor. Bunun nedeni, 'swap' fonksiyonunun çalıştığınız değerleri değiştirdiği ama değişkenlerin adreslerinin değişmediği düşüncesidir. Bu durumda değerler değiştirilmiş olmalı. Eğer x ve y değişkenlerinin değerleri doğru çıkmıyorsa, yazım hatalarını kontrol edin.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621391"
  },
  {
    "question": "Aşağıdaki kodda pointer'lar ile bir dizinin sonuna ekleme yapmaya çalışıyorum fakat dizinin boyutunu aşınca hata alıyorum: int *arr = malloc(3 * sizeof(int)); // eleman ekleme... free(arr); Kodda neyi düzeltmeliyim?",
    "answer": "Kodda, dizinin boyutunu aşmaya çalışıyorsunuz. Dinamik bellek tahsisi yaparken, bu boyutu en baştan doğru ayarlamalısınız. Eğer daha fazla eleman eklemek istiyorsanız, yeniden boyutlandırmalısınız. Örneğin, 'realloc' fonksiyonunu kullanabilirsiniz: arr = realloc(arr, yeni_boyut * sizeof(int));",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621454"
  },
  {
    "question": "Bir pointer ile bir stringi değiştirmeye çalışıyorum ama değişiklikler beklediğim gibi olmuyor: void changeString(char *str) { str = 'New String'; } int main() { char *text = 'Old String'; changeString(text); printf('%s', text); } Neden değişiklik olmuyor?",
    "answer": "Hatanın nedeni, 'changeString' fonksiyonunda 'str' parametresinin sadece yerel bir kopyasını değiştiriyorsunuz. Fonksiyonda 'str' pointer'ına yeni bir değer atamak, dışarıda 'text' değişkeninin işaret ettiği yeri değiştirmiyor. Bunun yerine, 'strcpy' kullanarak içeriği değiştirmelisiniz: 'strcpy(str, 'New String');'.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621553"
  },
  {
    "question": "Pointer ile bir dizinin ortalamasını alırken beklenmedik sonuçlar alıyorum. Kod şöyle: void average(int *arr, int size) { int total = 0; for (int i = 0; i <= size; i++) { total += *(arr + i); } printf('Average: %f', (float)total/size); } int main() { int nums[] = {1, 2, 3, 4, 5}; average(nums, 5); return 0; } Hata nerede?",
    "answer": "Dizinin son elemanına erişim hatalı, çünkü boyut 'size' olarak geçti, ancak geçerli indeksler 0'dan 'size-1'e kadar olmalıdır. Bu yüzden döngü koşulunu 'i < size' olarak değiştirmelisiniz. Ayrıca, ortalama hesaplamasında toplamı '[size]' yerine '[size - 1]' ile bölmelisiniz. Doğru kod: 'for (int i = 0; i < size; i++)'.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621659"
  },
  {
    "question": "Pointer'lar ile bir işlevde dizi elemanlarını sıralamak istiyorum ama sonuç beklediğim gibi olmuyor. Kod şu şekilde: void sort(int *arr, int size) { for (int i = 0; i < size; i++) { for (int j = i + 1; j < size; j++) { if (arr[i] > arr[j]) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } } int main() { int nums[] = {3, 2, 1}; sort(nums, 3); for (int i = 0; i < 3; i++) { printf('%d ', nums[i]); } } Output neden sıralı değil?",
    "answer": "Kodunuz doğru görünüyor, ancak çıktıyı kontrol ederken herhangi bir yazım hatası varsa, dizinin sıralı olarak basılmadığını düşünebilirsiniz. C dilinde 'printf' format belirteçlerinde dikkatli olmalısınız. Eğer yazım hatası yoksa, belirtilen diziyi düzgün bir şekilde sıralamakta sorun yaşamamalısınız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:08.621809"
  },
  {
    "question": "Bir fonksiyona pointer ile dizi göndermeye çalışırken neden 'Segmentation fault' hatası alıyorum?",
    "answer": "Bu hata, dizinin bellek alanına erişmeye çalışırken geçersiz bir adrese ulaşmaya çalıştığınızda ortaya çıkar. Fonksiyonu çağırmadan önce dizinin adresini doğru bir şekilde geçirdiğinizden emin olun. Örneğin: `void fonksiyon(int *dizi) { ... }` şeklinde tanımlayın ve çağırırken: `fonksiyon(dizi);` şeklinde kullanın.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019723"
  },
  {
    "question": "Pointer ile allocated bir dizinin değerlerini nasıl değiştirebilirim?",
    "answer": "Diziyi dinamik olarak allocate ettiyseniz (örneğin `malloc` veya `calloc` ile), dizinin elemanlarına pointer ile erişebilirsiniz. Örneğin: `int *dizi = (int *)malloc(5 * sizeof(int));` sonrasında `dizi[0] = 10;` şeklinde dizinin elemanının değerini değiştirebilirsiniz. Unutmayın, allocate ettiğiniz belleği kullanmadığınızda `free(dizi);` ile serbest bırakmalısınız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019772"
  },
  {
    "question": "Bir pointer'ı başka bir pointer'a atarken dikkat etmem gereken noktalar nelerdir?",
    "answer": "Pointer'ları atarken, hedef pointer'ın aynı türden bir veri tipini işaret ettiğinden emin olun. Örneğin, `int *p1; float *p2; p1 = (int *)p2;` ifadesi tehlikeli bir dönüşüm yapıyor ve bellek hatalarına yol açabilir. Her zaman doğru tür dönüşümlerini kullanmalısınız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019801"
  },
  {
    "question": "Pointer ile fonksiyon kullanarak bir değişkenin değerini nasıl değiştirebilirim?",
    "answer": "Fonksiyonun parametreleri olarak pointer'ları kullanmalısınız. Örneğin: `void degerDegistir(int *x) { *x = 20; }` fonksiyonu ile bir değişkenin değerini değiştirmek için `int a = 10; degerDegistir(&a);` şeklinde çağırmalısınız. Bu, `a` değişkeninin değerini `20` yapar.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019826"
  },
  {
    "question": "Pointer ile struct içindeki elemanlara nasıl erişebilirim?",
    "answer": "Struct içindeki elemanlara erişmek için önce struct için bir pointer tanımlamalı ve ardından `->` operatörünü kullanmalısınız. Örneğin: `struct Nokta { int x; int y; }; struct Nokta *n; n = (struct Nokta *)malloc(sizeof(struct Nokta)); n->x = 10; n->y = 20;` ile `Nokta` yapısının elemanlarına erişebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019874"
  },
  {
    "question": "Neden pointer'ı null olarak ayarlamak önemlidir?",
    "answer": "Pointer'ı null olarak ayarlamak, o pointer'ın geçersiz bir bellek adresini işaret etmediğini garanti eder. Bu, kullanmadığınız pointer'ların yanlışlıkla kullanılmasını önler. Örneğin: `int *p = NULL;` ile bir pointer'ı null olarak başlatmak, daha sonra `if (p != NULL)` kontrolü ile bellek erişim hatalarını önler.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019908"
  },
  {
    "question": "Bir pointer'ın bellek adresini nasıl yazdırabilirim?",
    "answer": "Pointer'ın bellekteki adresini yazdırmak için `%p` format belirtecini kullanabilirsiniz. Örneğin: `int a = 5; int *p = &a; printf(\"Pointer'in adresi: %p\\n\", (void*)p);` ile pointer'ın adresini ekrana yazdırabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.019936"
  },
  {
    "question": "Çok boyutlu bir dizinin pointer ile nasıl tanımlanacağını gösteriniz.",
    "answer": "Çok boyutlu bir diziyi pointer olarak tanımlamak için bir pointer dizisi kullanabilirsiniz. Örneğin: `int **dizi; dizi = (int **)malloc(x * sizeof(int *)); for (int i = 0; i < x; i++) dizi[i] = (int *)malloc(y * sizeof(int));` ile x boyutunda bir dizi oluşturabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.020099"
  },
  {
    "question": "Bir pointer'ın gösterdiği bellek alanını nasıl serbest bırakmalıyım?",
    "answer": "Dizinin veya struct'ın bellek alanını serbest bırakırken, `free` fonksiyonunu kullanmalısınız. Eğer diziyi dinamik olarak oluşturduysanız, her bir satır için `free(dizi[i]);` ve sonrasında `free(dizi);` ile belleği serbest bırakmalısınız. Bu, bellekte sızıntı olmasını önler.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.020162"
  },
  {
    "question": "Pointer kullanarak bir dizinin elemanlarını nasıl sıralayabilirim?",
    "answer": "Pointer ile dizinin elemanlarını sıralamak için bir sıralama algoritması yazabilirsiniz. Örneğin, `void sirala(int *dizi, int boyut) { ... }` şeklindeki bir fonksiyon ile dizinin pointer'ını alarak sıralama işlemini gerçekleştirebilirsiniz. Burada `dizi[i]` ile elemanlara erişebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.020198"
  },
  {
    "question": "Bir pointer'ın değerini nasıl kontrol edebilirim?",
    "answer": "Pointer'ın işaret ettiği değeri kontrol etmek için dereference operatörünü kullanabilirsiniz. Örneğin: `int a = 5; int *p = &a; if (*p == 5) { printf(\"Değer 5\"); }` şeklinde pointer'ın işaret ettiği değeri kontrol edebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:32.020232"
  },
  {
    "question": "Pointer nedir ve ne için kullanılır?",
    "answer": "Pointer, bir değişkenin bellekteki adresini tutan bir değişkendir. Genellikle bellek yönetimini kolaylaştırmak, dinamik bellek tahsis etmek veya büyük veri yapılarıyla çalışmak için kullanılır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431595"
  },
  {
    "question": "Bir pointer nasıl tanımlanır?",
    "answer": "Pointer tanımlamak için veri tipinin önüne yıldız (*) işareti eklenir. Örneğin, 'int *ptr;' ifadesi bir tamsayı pointer'ı tanımlar. Burada 'ptr', bir tamsayının bellekteki adresini tutacaktır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431627"
  },
  {
    "question": "Pointer ile bir değişkenin adresini nasıl alabilirim?",
    "answer": "Değişkenin adresini almak için '&' operatörünü kullanırız. Örneğin, 'int a = 10; int *ptr = &a;' ifadesinde 'ptr', 'a' değişkeninin adresini tutar.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431649"
  },
  {
    "question": "Pointer ile bir değişkenin değerine nasıl ulaşabilirim?",
    "answer": "Pointer ile bir değişkenin değerine ulaşmak için '*' operatörünü kullanırız. Örneğin, 'int a = 10; int *ptr = &a; int value = *ptr;' ifadesinde 'value' değişkeni '10' değerini alır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431687"
  },
  {
    "question": "Pointer'ları neden kullanmalıyım?",
    "answer": "Pointer'lar, bellek yönetimini optimize eder, büyük veri yapılarında kopyalama işlemlerini azaltır ve dinamik bellek tahsisini kolaylaştırır. Ayrıca, fonksiyonlara argüman olarak değişkenlerin adreslerini geçirerek performansı artırabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431714"
  },
  {
    "question": "Bir pointer'ın değeri nasıl değiştirilir?",
    "answer": "Pointer'ın değeri, yeni bir adres ile güncellenebilir. Örneğin, 'int a = 10; int *ptr = &a; int b = 20; ptr = &b;' ifadesi ile 'ptr' artık 'b' değişkeninin adresini tutar.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431745"
  },
  {
    "question": "Pointer ile dizilere nasıl erişebilirim?",
    "answer": "Diziler, bellek üzerinde ardışık yer kapladıkları için pointer kullanarak erişim sağlanabilir. Örneğin, 'int arr[] = {1, 2, 3}; int *ptr = arr; printf('%d', *(ptr + 1));' ifadesi, dizideki ikinci elemanı yani '2' değerini yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431762"
  },
  {
    "question": "NULL pointer nedir ve ne işe yarar?",
    "answer": "NULL pointer, herhangi bir geçerli adrese işaret etmeyen bir pointer'dır. Hatalı erişimleri önlemek için kullanılır ve programda bir pointer'ın henüz bir adrese atanmadığını belirtir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431780"
  },
  {
    "question": "Pointer ile fonksiyonlara nasıl argüman geçebilirim?",
    "answer": "Bir pointer ile fonksiyonlara argüman geçmek, değişkenin değerini değiştirmek için kullanılır. Örneğin, 'void update(int *p) { *p = 20; }' fonksiyonu, 'int a = 10; update(&a);' çağrısı ile 'a' değişkeninin değerini değiştirir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431799"
  },
  {
    "question": "Pointer aritmetiği nedir?",
    "answer": "Pointer aritmetiği, pointer'ların üzerinde toplama veya çıkarma işlemleri yaparak, bellek üzerindeki adresler arasında hareket etmemizi sağlar. Örneğin, bir tamsayı pointer'ı ile 'ptr + 1' yapıldığında, pointer bir sonraki tamsayıyı işaret eder.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431814"
  },
  {
    "question": "Pointer ve referans arasındaki fark nedir?",
    "answer": "Pointer, bir değişkenin bellekteki adresini tutan bir değişkendir ve 'NULL' olabilme özelliği vardır. Referans ise bir değişkenin alternatif bir isimidir ve her zaman geçerli bir nesneye işaret eder. Referanslar 'NULL' olamaz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:26:44.431831"
  },
  {
    "question": "Pointer nedir ve neden kullanılır?",
    "answer": "Pointer, bellekteki bir değişkenin adresini tutan bir değişkendir. C dilinde pointer kullanmanın başlıca avantajları arasında bellek yönetimini daha etkili bir şekilde yapmak, dinamik bellek tahsisi sağlamak ve fonksiyonlar arası veri aktarımını kolaylaştırmak bulunur. Örneğin, büyük veri yapıları üzerinde çalışırken, veri kopyalamak yerine sadece adreslerini kullanarak bellek tasarrufu sağlarız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414245"
  },
  {
    "question": "Bir pointer'ı nasıl tanımlarım ve başlatırım?",
    "answer": "Bir pointer tanımlamak için, değişken tipinin önüne '*' işareti eklenir. Örneğin, 'int *p;' ifadesi bir 'int' pointer'ının tanımını yapar. Başlatmak için bir değişkenin adresini alırız. 'int a = 10; p = &a;' ifadesi, 'p' pointer'ının 'a' değişkeninin adresini tutmasını sağlar.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414299"
  },
  {
    "question": "Pointer aritmetiği nedir ve nasıl çalışır?",
    "answer": "Pointer aritmetiği, pointer üzerinde matematiksel işlemler yapma işlemidir. C dilinde pointer ile yapılan toplama ve çıkarma işlemleri, pointer'ın işaret ettiği veri tipinin boyutuna göre hesaplanır. Örneğin, 'int *p;' ve 'p' üzerinde 'p++' işlemi gerçekleştirildiğinde, 'p' bir sonraki 'int' türündeki bellekteki konuma ilerler (genellikle 4 byte ileri).",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414333"
  },
  {
    "question": "Pointerlar ile dizilere nasıl erişirim?",
    "answer": "Diziler, bellekte ardışık bellek alanları olarak saklanır. Bir dizinin adı, ilk elemanın adresini gösteren bir pointer gibidir. Örneğin, 'int arr[5] = {1, 2, 3, 4, 5}; int *p = arr;' ifadesi ile 'p' dizinin ilk elemanını gösterir. Dizinin elemanlarına erişmek için 'p[i]' ifadesini kullanabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414364"
  },
  {
    "question": "Fonksiyonlara pointer göndererek veri nasıl aktarılır?",
    "answer": "C dilinde fonksiyonlara pointer göndererek, değişkenlerin adreslerini geçeriz. Bu sayede fonksiyon içerisinde yapılan değişiklikler, ana fonksiyonda da etkili olur. Örneğin, bir 'swap' fonksiyonu yazarken 'void swap(int *x, int *y)' şeklinde pointer alarak değişkenlerin değerlerini değiştirebiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414398"
  },
  {
    "question": "Null pointer nedir ve nasıl kullanılır?",
    "answer": "Null pointer, bir pointer'ın herhangi bir geçerli bellek adresi göstermediği durumdur. C dilinde 'NULL' anahtar kelimesi ile tanımlanır. Null pointer kullanmak, potansiyel bellek hatalarını önlemek için önemlidir. Örneğin, bir pointer'ın geçerli bir adres gösterip göstermediğini kontrol etmek için 'if (p != NULL)' şeklinde bir kontrol yapılabilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414429"
  },
  {
    "question": "Pointerların bellekteki alanı nasıl yönetilir?",
    "answer": "C dilinde dinamik bellek yönetimi için 'malloc', 'calloc', 'realloc' ve 'free' fonksiyonları kullanılır. 'malloc' ile bellek tahsis edilirken, bir pointer bu bellek alanını gösterir. Örneğin, 'int *arr = (int *)malloc(5 * sizeof(int));' ifadesi, 'arr' pointer'ına 5 tamsayı için bellekte alan tahsis eder. Kullanım tamamlandığında 'free(arr);' ile tahsis edilen bellek serbest bırakılmalıdır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414460"
  },
  {
    "question": "Pointer ve çok boyutlu diziler arasındaki ilişki nedir?",
    "answer": "Çok boyutlu diziler, iç içe diziler olarak düşünülebilir ve pointer kullanarak bu dizilere erişim sağlanabilir. Örneğin, 'int arr[3][4];' tanımlı bir iki boyutlu dizi için, 'int *p = &arr[0][0];' ile dizinin ilk elemanının adresi bir pointer'a atanabilir. Elemanlara erişmek için 'p[i * 4 + j]' gibi hesaplamalar yapabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414497"
  },
  {
    "question": "Pointer ile yapı (struct) nasıl kullanılır?",
    "answer": "Yapılar, birden fazla değişkenin bir arada tutulmasını sağlar. Pointer kullanarak bir yapıya erişmek için, yapı tipinin adresini alırız. Örneğin, 'struct Student { char name[20]; int age; };' tanımlı bir yapı için, 'struct Student *s;' ifadesi ile bir pointer tanımlanabilir. Belleğe yerleştirmek için 's = (struct Student *)malloc(sizeof(struct Student));' ifadesi kullanılır ve alan adına erişmek için 's->name' veya 's->age' şeklinde kullanabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414557"
  },
  {
    "question": "Pointer ve referans (reference) arasındaki fark nedir?",
    "answer": "C dilinde referans kavramı yoktur, ancak pointer ile benzer işlevsellik sağlanır. Referans genellikle bir değişkenin başka bir isimle erişilmesini sağlarken, pointer doğrudan bellekteki adresi tutar. Örneğin, bir pointer kullanarak bir değişkenin adresini geçebiliriz ve değişiklikler ana değişken üzerinde etkili olur. Bu, referansın işlevine benzer ancak C'de bu terim kullanılmaz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414596"
  },
  {
    "question": "Çift pointer (double pointer) nedir ve ne amaçla kullanılır?",
    "answer": "Çift pointer, bir pointer'ın adresini tutan bir pointer'dır. Genellikle dinamik bellek yönetimi ve iki boyutlu diziler gibi durumlarda kullanılır. Örneğin, 'int **p;' ifadesi ile bir çift pointer tanımlanabilir. Çift pointer kullanarak, bir dizinin dizisi gibi yapılar oluşturabiliriz. Bu sayede bellek alanını esnek bir şekilde yönetebiliriz ve fonksiyonlar arasında kompleks veri yapılarını kolayca aktarabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:07.414638"
  },
  {
    "question": "Bir pointer ile bir değişkenin adresini nasıl alabilirim?",
    "answer": "C dilinde bir değişkenin adresini almak için '&' operatörünü kullanırız. Örneğin: int a = 10; int *p = &a; burada p, a değişkeninin adresini tutar. Bu sayede p üzerinden a'nın değerine erişebilir veya a'nın değerini değiştirebiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415358"
  },
  {
    "question": "Pointer aritmetiği nedir ve nasıl kullanılır?",
    "answer": "Pointer aritmetiği, bir pointer'ın adresini artırmak veya azaltmak anlamına gelir. Örneğin, int *p; int a[5]; p = a; p++; bu durumda p, a dizisinin bir sonraki elemanının adresini tutacaktır. Bu özellik, dizilerle çalışırken oldukça kullanışlıdır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415393"
  },
  {
    "question": "Bir dizinin pointer'ını nasıl oluşturabilirim?",
    "answer": "Dizilerin kendisi bir pointer gibi davranır. Örneğin, int arr[5] = {1, 2, 3, 4, 5}; int *p = arr; burada p, arr dizisinin başlangıç adresini tutar. Bu sayede dizinin elemanlarına p ile erişebiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415412"
  },
  {
    "question": "Çift yönlü bağlı liste yapısını nasıl oluşturabilirim?",
    "answer": "Çift yönlü bağlı liste, her düğümün hem bir önceki hem de bir sonraki düğümün adresini tuttuğu bir yapıdır. Örneğin: typedef struct Node { int data; struct Node *next; struct Node *prev; } Node; burada her Node, bir tamsayı verisi ve iki pointer barındırır, bu sayede liste ileri ve geri yönlü gezilebilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415434"
  },
  {
    "question": "Pointer ile fonksiyonlara argüman geçişi nasıl yapılır?",
    "answer": "Pointer kullanarak bir fonksiyona değişkenin adresini geçebilirsiniz. Örneğin: void func(int *p) { *p = *p + 1; } int a = 5; func(&a); bu durumda a'nın değeri 6 olur. Bu yöntem, fonksiyonların değişkenler üzerindeki etkisini artırır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415455"
  },
  {
    "question": "NULL pointer nedir ve neden kullanılır?",
    "answer": "NULL pointer, bir pointer'ın geçerli bir adres göstermediğini belirtmek için kullanılır. Örneğin: int *ptr = NULL; bu, ptr'nin henüz bir değişkene atanmadığını gösterir. NULL kullanımı, bellek sızıntılarını önlemeye yardımcı olur ve hata ayıklama sürecini kolaylaştırır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415474"
  },
  {
    "question": "Dinamik bellek yönetimi için malloc ve free nasıl kullanılır?",
    "answer": "Dinamik bellek yönetimi için malloc fonksiyonu kullanarak bellek ayırırız. Örneğin, int *arr = (int*)malloc(5 * sizeof(int)); burada 5 tamsayı için bellek ayırıyoruz. Belleği kullandıktan sonra free(arr); ile belleği serbest bırakmayı unutmamalıyız.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415498"
  },
  {
    "question": "Pointer ile çok boyutlu dizileri nasıl tanımlayabilirim?",
    "answer": "Çok boyutlu diziler, pointer kullanarak tanımlanabilir. Örneğin: int **arr; arr = (int**)malloc(rows * sizeof(int*)); for(int i = 0; i < rows; i++) arr[i] = (int*)malloc(cols * sizeof(int)); burada iki boyutlu bir dizi için bellek ayırıyoruz ve her satır için ayrı bir bellek bloğu ayırıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415536"
  },
  {
    "question": "Pointer ile bir yapıyı nasıl kullanabilirim?",
    "answer": "Pointer kullanarak yapılarla çalışabiliriz. Örneğin: typedef struct { int x; int y; } Point; Point p = {1, 2}; Point *ptr = &p; printf('%d', ptr->x); burada ptr kullanarak yapının elemanlarına erişiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415554"
  },
  {
    "question": "Pointer ile string manipülasyonu nasıl yapılır?",
    "answer": "Stringler aslında char pointer'larıdır. Örneğin: char *str = 'Merhaba'; printf('%c', *(str + 2)); bu, str'nin 3. karakterini yani 'r' harfini yazdırır. Pointer ile string üzerinde gezinebilir ve manipülasyonlar yapabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415573"
  },
  {
    "question": "Pointer ile fonksiyonları nasıl çağırabilirim?",
    "answer": "Fonksiyonları pointer ile çağırmak için, fonksiyonun adresini kullanabiliriz. Örneğin: void func() { printf('Hello'); } void (*fptr)() = &func; fptr(); burada fptr, func fonksiyonuna işaret eder ve çağrıldığında 'Hello' yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:37.415590"
  },
  {
    "question": "Bir tam sayının adresini almak için nasıl bir pointer kullanabilirim?",
    "answer": "C dilinde bir tam sayının adresini almak için pointer tanımlayabiliriz. Örneğin: \n\n```c\nint sayi = 10;\nint *sayiPointer = &sayi; // sayi değişkeninin adresini alıyoruz\n```\nBurada 'sayiPointer' değişkeni 'sayi' değişkeninin adresini tutar.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641645"
  },
  {
    "question": "Bir dizinin elemanlarına pointer kullanarak nasıl erişebilirim?",
    "answer": "Dizinin elemanlarına pointer ile erişmek için dizinin ismini kullanarak bir pointer tanımlayabiliriz. Örnek: \n\n```c\nint dizi[] = {1, 2, 3, 4};\nint *diziPointer = dizi; // dizinin başlangıç adresi\nfor (int i = 0; i < 4; i++) {\n    printf(\"%d\\n\", *(diziPointer + i)); // pointer ile elemanlara erişim\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641738"
  },
  {
    "question": "Pointer ile bir değişkenin değerini nasıl değiştirebilirim?",
    "answer": "Pointer kullanarak bir değişkenin değerini değiştirmek için o değişkenin adresini kullanmalıyız. Örnek: \n\n```c\nint sayi = 5;\nint *sayiPointer = &sayi;\n*sayiPointer = 10; // sayi'nın değeri artık 10\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641775"
  },
  {
    "question": "Fonksiyona pointer argümanı geçmek neden faydalıdır?",
    "answer": "Fonksiyona pointer argümanı geçmek, değişkenin değerini fonksiyon içinde değiştirmemizi sağlar. Örnek: \n\n```c\nvoid degerArttir(int *p) {\n    (*p)++;\n}\nint main() {\n    int sayi = 5;\n    degerArttir(&sayi); // sayi 6 olacak\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641806"
  },
  {
    "question": "Pointer ile bir string'in uzunluğunu nasıl bulabilirim?",
    "answer": "Bir stringin uzunluğunu pointer ile bulmak için bir döngü kullanabiliriz. Örnek: \n\n```c\nchar *str = \"Merhaba\";\nint uzunluk = 0;\nwhile (*str != '\\0') {\n    uzunluk++;\n    str++;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641840"
  },
  {
    "question": "Bir pointer'ın NULL olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Pointer'ların NULL olup olmadığını kontrol etmek için basit bir if koşulu kullanabiliriz. Örnek: \n\n```c\nint *ptr = NULL;\nif (ptr == NULL) {\n    printf(\"Pointer NULL'dır.\");\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641876"
  },
  {
    "question": "Dizinin elemanlarını pointer kullanarak nasıl sıralayabilirim?",
    "answer": "Dizinin elemanlarını pointer kullanarak sıralamak için bir sıralama algoritması uygulayabiliriz. Örnek: \n\n```c\nvoid sıralama(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = i + 1; j < boyut; j++) {\n            if (*(dizi + i) > *(dizi + j)) {\n                int temp = *(dizi + i);\n                *(dizi + i) = *(dizi + j);\n                *(dizi + j) = temp;\n            }\n        }\n    }\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641908"
  },
  {
    "question": "Bir pointer'ı başka bir pointer'a nasıl atayabilirim?",
    "answer": "Bir pointer'ı başka bir pointer'a atamak oldukça kolaydır. Örnek: \n\n```c\nint sayi = 20;\nint *ptr1 = &sayi;\nint *ptr2 = ptr1; // ptr2, ptr1 ile aynı adresi tutar\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641941"
  },
  {
    "question": "Pointer kullanarak dinamik bellek nasıl ayırabilirim?",
    "answer": "Dinamik bellek ayırmak için malloc fonksiyonunu kullanabiliriz. Örnek: \n\n```c\nint *dizi = (int *)malloc(5 * sizeof(int)); // 5 elemanlı bir dizi için bellek ayırma\nif (dizi != NULL) {\n    for (int i = 0; i < 5; i++) {\n        dizi[i] = i + 1;\n    }\n}\nfree(dizi); // bellek serbest bırakma\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.641971"
  },
  {
    "question": "Çift yönlü linked list'te pointer kullanarak nasıl düğüm eklerim?",
    "answer": "Çift yönlü linked list'te yeni bir düğüm eklemek için gerekli yapıyı tanımlayıp bağlantıları güncellememiz gerekmektedir. Örnek: \n\n```c\nstruct Node {\n    int veri;\n    struct Node *onceki;\n    struct Node *sonraki;\n};\n\nvoid ekle(struct Node **baslangic, int yeniVeri) {\n    struct Node *yeniDugum = (struct Node *)malloc(sizeof(struct Node));\n    yeniDugum->veri = yeniVeri;\n    yeniDugum->sonraki = *baslangic;\n    yeniDugum->onceki = NULL;\n    if (*baslangic != NULL) {\n        (*baslangic)->onceki = yeniDugum;\n    }\n    *baslangic = yeniDugum;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:27:57.642007"
  },
  {
    "question": "Bir dizi içerisindeki maksimum değeri bulan bir fonksiyon yazın. Bu fonksiyon, dizinin ilk elemanının adresini pointer olarak almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nint find_max(int *arr, int size) {\n    int max = *arr;\n    for (int i = 1; i < size; i++) {\n        if (*(arr + i) > max) {\n            max = *(arr + i);\n        }\n    }\n    return max;\n}\n\nint main() {\n    int numbers[] = {3, 5, 7, 2, 8};\n    int max_value = find_max(numbers, 5);\n    printf(\"Maksimum değer: %d\\n\", max_value);\n    return 0;\n}\n``` Bu kodda, find_max fonksiyonu bir pointer alarak dizinin elemanlarına ulaşıyor ve maksimum değeri buluyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974468"
  },
  {
    "question": "İki tam sayının değerlerini değiştirerek takas yapan bir fonksiyon yazın. Bu fonksiyon, her iki tam sayının adreslerini almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Önce: x = %d, y = %d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"Sonra: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n``` Bu kod, swap fonksiyonu aracılığıyla iki tam sayının değerlerini değiştiriyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974539"
  },
  {
    "question": "Bir string'in uzunluğunu bulan bir fonksiyon yazın. Bu fonksiyon, string'in ilk karakterinin adresini pointer olarak almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nint string_length(char *str) {\n    int length = 0;\n    while (*(str + length) != '\\0') {\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    char my_string[] = \"Merhaba\";\n    int length = string_length(my_string);\n    printf(\"String uzunluğu: %d\\n\", length);\n    return 0;\n}\n``` Bu kod, bir string'in uzunluğunu hesaplamak için pointer kullanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974577"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir tamsayı dizisi oluşturan ve bu diziyi doldurup yazdıran bir program yazın. Dizinin boyutu kullanıcıdan alınmalıdır.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int size;\n    printf(\"Dizinin boyutunu giriniz: \");\n    scanf(\"%d\", &size);\n    int *arr = (int *)malloc(size * sizeof(int));\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Dizinin %d. elemanını giriniz: \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Dizi elemanları:\\n\");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    free(arr);\n    return 0;\n}\n``` Bu kod dinamik bellek kullanarak bir dizi oluşturuyor ve kullanıcıdan değerler alıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974616"
  },
  {
    "question": "Bir linked list yapısında eleman eklemek için gerekli fonksiyonu yazın. Fonksiyon, yeni bir elemanın değerini ve liste başının adresini almalıdır.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nvoid insert(struct Node **head, int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = *head;\n    *head = new_node;\n}\n\nvoid print_list(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n}\n\nint main() {\n    struct Node *head = NULL;\n    insert(&head, 1);\n    insert(&head, 2);\n    insert(&head, 3);\n    print_list(head);\n    return 0;\n}\n``` Bu kod, linked list yapısında yeni elemanlar eklemek için bir fonksiyon içeriyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974656"
  },
  {
    "question": "Bir 2D diziyi (matris) transpoze eden bir fonksiyon yazın. Fonksiyon, matrisin adresini ve boyutlarını almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid transpose(int (*matrix)[3], int rows, int cols) {\n    int transposed[3][3];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            printf(\"%d \", transposed[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    transpose(matrix, 3, 3);\n    return 0;\n}\n``` Bu kod, 2D dizinin transpozunu almak için bir fonksiyon içeriyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974690"
  },
  {
    "question": "Bir integer dizisinin ortalamasını bulan bir fonksiyon yazın. Bu fonksiyon, dizinin ilk elemanının adresini ve boyutunu almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nfloat calculate_average(int *arr, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += *(arr + i);\n    }\n    return (float)sum / size;\n}\n\nint main() {\n    int numbers[] = {10, 20, 30, 40, 50};\n    float average = calculate_average(numbers, 5);\n    printf(\"Ortalama: %.2f\\n\", average);\n    return 0;\n}\n``` Bu kod, bir dizinin ortalamasını hesaplamak için pointer kullanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974730"
  },
  {
    "question": "Bir karakter dizisindeki belirli bir karakterin sayısını bulan bir fonksiyon yazın. Fonksiyon, dizinin adresini ve aranacak karakteri almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nint count_character(char *str, char ch) {\n    int count = 0;\n    while (*str) {\n        if (*str == ch) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    char my_string[] = \"Merhaba Dünya!\";\n    char char_to_count = 'a';\n    int count = count_character(my_string, char_to_count);\n    printf(\"'%c' karakteri %d kez bulunuyor.\\n\", char_to_count, count);\n    return 0;\n}\n``` Bu kod, bir dizide belirli bir karakterin sayısını bulmak için pointer kullanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974773"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını tersine çeviren bir fonksiyon yazın. Bu fonksiyon, dizinin ilk elemanının adresini ve boyutunu almalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid reverse_array(int *arr, int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = *(arr + i);\n        *(arr + i) = *(arr + size - 1 - i);\n        *(arr + size - 1 - i) = temp;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    reverse_array(numbers, size);\n    printf(\"Tersine çevrilmiş dizi: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    return 0;\n}\n``` Bu kod, bir dizi elemanlarını tersine çevirmek için pointer kullanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:28:52.974809"
  },
  {
    "question": "Pointer ile bir dizinin elemanlarının toplamını hesaplamak için bir fonksiyon yazın. Kodu gözden geçirin ve iyileştirmeler önerin.",
    "answer": "Aşağıdaki kodda, dizinin elemanlarının toplamını hesaplamak için bir fonksiyon yazılmıştır. Ancak bazı iyileştirmeler mevcut.\n\n```c\n#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Toplam: %d\\n\", toplam(dizi, boyut));\n    return 0;\n}\n``` \n\nİyileştirme önerileri:\n1. Fonksiyona parametre olarak dizi boyutunu geçirmek yerine, pointer aritmetiği kullanarak daha okunabilir hale getirebilirsiniz.\n2. Toplam hesaplama işlemi içinde farklı bir değişken tanımlamak yerine, direkt toplamı dönebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.317754"
  },
  {
    "question": "Bir tamsayı dizisinde en büyük elemanı bulmak için bir fonksiyon yazın. Kodunuzu optimize edin.",
    "answer": "Aşağıdaki kodda en büyük elemanı bulmak için bir fonksiyon yazılmıştır. Ancak, performansı artırmak adına iyileştirmeler yapılabilir.\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int *dizi, int boyut) {\n    int enBuyuk = dizi[0]; // İlk elemanı başlangıç olarak al\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    return enBuyuk;\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 6, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk(dizi, boyut));\n    return 0;\n}\n``` \n\nOptimizasyon önerileri:\n1. `enBuyuk` değişkeni yerine, başlangıçta `dizi`'nin eleman sayısını kontrol ederek daha güvenli bir uygulama oluşturabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.317825"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için bir fonksiyon yazın ve kodunuzu gözden geçirin.",
    "answer": "Aşağıda bir karakter dizisini tersine çevirmek için yazılmış bir fonksiyon yer alıyor. Kod üzerinde bazı iyileştirmeler yapılabilir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = str[i];\n        str[i] = str[uzunluk - i - 1];\n        str[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevrildi: %s\\n\", str);\n    return 0;\n}\n``` \n\nİyileştirme önerileri:\n1. İlk olarak string uzunluğunu kontrol edin. Eğer uzunluk 0 ise, fonksiyonu direkt çıkarabilirsiniz.\n2. `temp` değişkeni için dinamik bellek kullanmak yerine, sadece geçici olarak bir karakter kullanmak daha verimli olacaktır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.317874"
  },
  {
    "question": "Dizideki her elemanın karesini almak için bir fonksiyon yazın ve bellek yönetimi açısından önerilerde bulunun.",
    "answer": "Aşağıdaki kod, bir dizideki her elemanın karesini almak için bir fonksiyon içermektedir. Ancak bellek yönetimi açısından dikkat edilmesi gereken noktalar var.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid karesiAl(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] *= dizi[i];\n    }\n}\n\nint main() {\n    int boyut = 5;\n    int *dizi = malloc(boyut * sizeof(int));\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] = i + 1; // 1, 2, 3, 4, 5\n    }\n    karesiAl(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \\n\", dizi[i]);\n    }\n    free(dizi);\n    return 0;\n}\n``` \n\nBellek yönetimi önerileri:\n1. `malloc` kullanarak dinamik bellek ayırdıktan sonra, program sonunda `free` ile belleği serbest bırakmayı unutmayın.\n2. `karesiAl` fonksiyonunu çağırmadan önce dizinin null olup olmadığını kontrol edin.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.317924"
  },
  {
    "question": "İki tamsayıyı takas yapmak için bir fonksiyon yazın. Kodunuzu gözden geçirin.",
    "answer": "Aşağıdaki fonksiyon, iki tamsayıyı takas etmek için yazılmıştır. Ancak bazı iyileştirmeler yapılabilir.\n\n```c\n#include <stdio.h>\n\nvoid takas(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    takas(&x, &y);\n    printf(\"x: %d, y: %d\\n\", x, y);\n    return 0;\n}\n``` \n\nİyileştirme önerileri:\n1. `temp` değişkeni ile iki değişkeni takas etmek yerine, mümkünse bitwise işlemlerle daha verimli bir takas gerçekleştirebilirsiniz.\n2. Fonksiyon parametrelerinin null olup olmadığını kontrol etmek, hata ayıklama açısından faydalı olacaktır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.317969"
  },
  {
    "question": "Bir dizideki elemanları sıralamak için bir fonksiyon yazın. Kodu optimize edin.",
    "answer": "Aşağıdaki kod, bir dizinin elemanlarını sıralamak için basit bir sıralama algoritması kullanmaktadır. Ancak performansı artırmak için iyileştirmeler yapılabilir.\n\n```c\n#include <stdio.h>\n\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {64, 34, 25, 12, 22};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` \n\nOptimizasyon önerileri:\n1. Daha verimli bir sıralama algoritması kullanmak (örneğin, quicksort veya mergesort) performansı önemli ölçüde artırabilir.\n2. Sıralama işlemi sırasında gereksiz karşılaştırmaları önlemek için, dizinin sıralı olup olmadığını kontrol etmek için bir bayrak (flag) kullanabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.318020"
  },
  {
    "question": "Bir dizinin ortalamasını hesaplamak için bir fonksiyon yazın. Kodunuzu gözden geçirin.",
    "answer": "Aşağıdaki kod, bir dizinin ortalamasını hesaplamak için yazılmıştır. Ancak okunabilirliği artırmak ve hata olasılığını azaltmak adına iyileştirilebilir.\n\n```c\n#include <stdio.h>\n\nfloat ortalama(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Ortalama: %.2f\\n\", ortalama(dizi, boyut));\n    return 0;\n}\n``` \n\nİyileştirme önerileri:\n1. Toplamın hesaplandığı döngüde, dizinin boyutu sıfırsa (0) kontrol ederek sıfıra bölme hatasını önleyebilirsiniz.\n2. `toplam` değişkeninin türünü `long` olarak değiştirerek büyük sayılarla çalışırken taşma olasılığını azaltabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.318062"
  },
  {
    "question": "Bir nesne dizisinin elemanlarını kopyalamak için bir fonksiyon yazın. Kodu gözden geçirin.",
    "answer": "Aşağıdaki kod, bir nesne dizisinin elemanlarını kopyalamak için yazılmıştır. Ancak bellek yönetimi açısından dikkat edilmesi gereken noktalar var.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char isim[50];\n} Nesne;\n\nvoid kopyala(Nesne *kaynak, Nesne *hedef, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        hedef[i] = kaynak[i];\n    }\n}\n\nint main() {\n    Nesne nesneler[2] = {{1, \"Nesne1\"}, {2, \"Nesne2\"}};\n    Nesne kopya[2];\n    kopyala(nesneler, kopya, 2);\n    for (int i = 0; i < 2; i++) {\n        printf(\"Kopya ID: %d, İsim: %s\\n\", kopya[i].id, kopya[i].isim);\n    }\n    return 0;\n}\n``` \n\nBellek yönetimi önerileri:\n1. Kopyalama işlemi sırasında kullanılan nesne dizisinin boyutunu geçmeyecek şekilde kontrol ekleyin.\n2. `memcpy` fonksiyonu kullanarak kopyalama işlemini daha hızlı hale getirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.318104"
  },
  {
    "question": "Bir dizi içindeki en küçük elemanı bulmak için bir fonksiyon yazın. Kodunuzu gözden geçirin ve iyileştirin.",
    "answer": "Aşağıdaki kod, bir dizinin en küçük elemanını bulmak için yazılmıştır. Ancak bazı noktalar geliştirme gerektiriyor.\n\n```c\n#include <stdio.h>\n\nint enKucuk(int *dizi, int boyut) {\n    int enKucuk = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] < enKucuk) {\n            enKucuk = dizi[i];\n        }\n    }\n    return enKucuk;\n}\n\nint main() {\n    int dizi[] = {9, 3, 5, 1, 7};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En küçük eleman: %d\\n\", enKucuk(dizi, boyut));\n    return 0;\n}\n``` \n\nİyileştirme önerileri:\n1. İlk önce dizinin boyutunu kontrol edin; eğer boyut 0 ise uygun bir hata mesajı döndürün.\n2. `enKucuk` değişkenini dizinin ilk elemanını alarak tanımlamak yerine, bir döngü ile karşılaştırma yaparak başlangıç değerini belirleyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:36.318156"
  },
  {
    "question": "Bir dizinin maksimum elemanını bulmak için bir fonksiyon yazdım. Ancak, dizinin boyutunu geçmeden erişim sağlamak için pointer kullanımında sorun yaşıyorum. Bunu nasıl düzeltebilirim?",
    "answer": "Dizinin maksimum elemanını bulmak için dizinin sonunu işaret eden bir pointer kullanmak iyi bir yöntemdir. Ayrıca, dizinin boyutunu geçmemek için döngü kontrolü sağlamak önemlidir. Aşağıdaki kodda bu yaklaşımı görebilirsiniz:\n\n```c\nint find_max(int *arr, size_t size) {\n    if (size == 0) return -1; // Hata kontrolü\n    int max = *arr;\n    for (int *p = arr; p < arr + size; p++) {\n        if (*p > max) max = *p;\n    }\n    return max;\n}\n```\nBu fonksiyonda, dizinin başlangıcını işaret eden bir pointer kullanarak, dizinin sonuna kadar güvenli bir şekilde döngü yapıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185496"
  },
  {
    "question": "Pointer ile dinamik hafıza yönetimi yaparken oluşabilecek bellek sızıntılarını nasıl önleyebilirim?",
    "answer": "Dinamik bellek kullanımı sırasında malloc veya calloc ile allocate ettiğiniz bellek alanını kullanmayı bitirdikten sonra mutlaka free() fonksiyonunu çağırmalısınız. Örneğin:\n\n```c\nint *array = (int *)malloc(10 * sizeof(int));\nif (array == NULL) return -1; // Hata kontrolü\n// ... Kullanım\nfree(array); // Bellek sızıntısını önlemek için\n```\nBellek sızıntılarını önlemek için, her allocate işleminden sonra ilgili belleği serbest bırakmayı unutmayın.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185581"
  },
  {
    "question": "Bir fonksiyondan bir pointer döndürdüm ama bu pointer'ın geçerliliğini nasıl sağlayabilirim?",
    "answer": "Fonksiyonun döndürdüğü pointer'ın geçerliliğini sağlamak için, döndürülen pointer'ın bir lokal değişkenin adresini göstermediğinden emin olmalısınız. Bunun için dinamik bellek kullanarak allocate edilen bir alanı döndürmelisiniz. Örneğin:\n\n```c\nint* create_array(size_t size) {\n    return (int *)malloc(size * sizeof(int));\n}\n```\nBu fonksiyonda, create_array fonksiyonu dynamic olarak allocate edilen bir array döndürmektedir. Kullanım sonrası free() ile serbest bırakmayı unutmayın.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185611"
  },
  {
    "question": "Bir yapı (struct) içinde pointer kullanarak veri sakladım. Ancak bu pointer'ı güncelleyince yapının içindeki veriye erişim kayboluyor. Neden böyle oluyor?",
    "answer": "Yapı içindeki pointer'ı güncellerken, sadece pointer'ın kendisini değiştiriyorsunuz ancak yapının içindeki pointer'ın gösterdiği veri kaybolabilir. Yapıyı güncellemeye çalışıyorsanız, pointer'ı güncelleyip yeni bir bellekte veri saklamanız gerekebilir:\n\n```c\ntypedef struct {\n    int *data;\n} MyStruct;\n\nvoid update_data(MyStruct *s, int new_value) {\n    s->data = malloc(sizeof(int)); // Dinamik allocate\n    *(s->data) = new_value;\n}\n```\nBu yapıda, struct içindeki pointer'ın gösterdiği veri kaybolmadan yeni bir değer atanabilir.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185666"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizinin elemanlarını nasıl artırabilirim?",
    "answer": "Pointer aritmetiği, dizinin elemanlarına erişim ve güncellemeyi kolaylaştırır. Aşağıdaki örnekte, bir dizinin elemanlarını 1 artıran bir fonksiyon görebilirsiniz:\n\n```c\nvoid increment_array(int *arr, size_t size) {\n    for (int *p = arr; p < arr + size; p++) {\n        (*p)++;\n    }\n}\n```\nBu fonksiyon, dizinin başlangıcını işaret eden bir pointer kullanarak her bir elemanı artırır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185691"
  },
  {
    "question": "Çok boyutlu bir diziyi pointer ile nasıl tanımlayıp kullanabilirim?",
    "answer": "Çok boyutlu diziler, bir pointer'ın pointer'ı olarak tanımlanabilir. Aşağıdaki örnekte, 2x3 boyutlu bir dizi tanımlayıp kullanıyoruz:\n\n```c\nint main() {\n    int rows = 2, cols = 3;\n    int **matrix = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = malloc(cols * sizeof(int));\n    }\n    // Kullanım\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = i + j;\n        }\n    }\n    // Bellek serbest bırakma\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n    return 0;\n}\n```\nBu kodda, 2x3 boyutlu bir matris oluşturup dinamik olarak bellekte yer açıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185721"
  },
  {
    "question": "Fonksiyon içinde tanımlanan pointer'ların dışarıda geçerliliği var mı?",
    "answer": "Fonksiyon içinde tanımlanan pointer'lar lokal bir değişkendir ve fonksiyon bitince geçerliliğini kaybeder. Eğer dışarıda kullanılmasını istiyorsanız, pointer'ı bir başvuru (reference) olarak kullanmalısınız. Örneğin:\n\n```c\nvoid create_buffer(char **buffer, size_t size) {\n    *buffer = malloc(size);\n}\n\nint main() {\n    char *my_buffer;\n    create_buffer(&my_buffer, 1024);\n    // Kullanım\n    free(my_buffer);\n    return 0;\n}\n```\nBurada, create_buffer fonksiyonu aracılığıyla dışarıda kullanılacak bir buffer oluşturuluyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185757"
  },
  {
    "question": "Bir yapı içinde diziyi pointer ile nasıl saklayabilirim?",
    "answer": "Bir yapı içinde dinamik olarak allocate edilmiş bir dizi saklamak için aşağıdaki gibi bir yapı tanımlayabilirsiniz:\n\n```c\ntypedef struct {\n    int *array;\n    size_t size;\n} IntArray;\n\nvoid init_array(IntArray *arr, size_t size) {\n    arr->size = size;\n    arr->array = malloc(size * sizeof(int));\n}\n\nvoid free_array(IntArray *arr) {\n    free(arr->array);\n}\n```\nBu yapıda IntArray, bir pointer ve boyut saklıyor. init_array fonksiyonu ile dizi allocate ediliyor ve free_array ile serbest bırakılıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185781"
  },
  {
    "question": "Bir fonksiyona pointer göndermek yerine değer göndermenin avantajları ve dezavantajları nelerdir?",
    "answer": "Pointer göndermek, büyük yapılar ve diziler için bellek tasarrufu sağlar çünkü sadece adresi gönderiyorsunuz. Ancak, değer gönderdiğinizde kopyalanan veri nedeniyle performans düşebilir. Ayrıca, pointer kullanımı hata yapma olasılığını artırır (örneğin, NULL pointer hatası). Değer gönderimi daha güvenlidir ancak büyük veriler için etkili değildir:\n\n```c\nvoid process_data(int data) { /* Değer ile işlem */ }\nvoid process_data_ptr(int *data) { /* Pointer ile işlem */ }\n```\nSonuç olarak, küçük veriler için değer, büyük veriler için pointer kullanmak daha mantıklıdır.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185809"
  },
  {
    "question": "Pointer kullanarak bir dizinin sıralanmasını nasıl gerçekleştirebilirim?",
    "answer": "Pointer kullanarak diziyi sıralamak için, sıralama algoritmalarından birini pointer aritmetiği ile uygulayabilirsiniz. Örneğin, basit bir bubble sort:\n\n```c\nvoid bubble_sort(int *arr, size_t size) {\n    for (size_t i = 0; i < size - 1; i++) {\n        for (size_t j = 0; j < size - 1 - i; j++) {\n            if (*(arr + j) > *(arr + j + 1)) {\n                int temp = *(arr + j);\n                *(arr + j) = *(arr + j + 1);\n                *(arr + j + 1) = temp;\n            }\n        }\n    }\n}\n```\nBu örnekte, dizinin elemanları pointer aritmetiği ile karşılaştırılıyor ve sıralanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer temelleri",
    "timestamp": "2025-06-01T15:29:54.185831"
  },
  {
    "question": "Kullanıcının girdiği n sayısına göre dinamik bir dizi oluştur ve değerleri al.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\");\n        return 1;\n    }\n\n    // Kullanıcıdan dizi elemanlarını alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. elemanı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Dizi elemanlarını yazdırma\n    printf(\"Dizi elemanları:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627310"
  },
  {
    "question": "Dinamik olarak bir karakter dizisi oluştur ve kullanıcıdan bir metin al.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int boyut;\n    printf(\"Lütfen metin boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    // Dinamik bellek ayırma\n    char *metin = (char *)malloc((boyut + 1) * sizeof(char));\n    if (metin == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\");\n        return 1;\n    }\n\n    printf(\"Metni girin: \");\n    scanf(\"%s\", metin);\n\n    printf(\"Girdiğiniz metin: %s\\n\", metin);\n\n    // Belleği serbest bırakma\n    free(metin);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627351"
  },
  {
    "question": "Kullanıcıdan bir tam sayılar listesi al ve bu sayıların toplamını hesapla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *sayılar = (int *)malloc(n * sizeof(int));\n    if (sayılar == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\");\n        return 1;\n    }\n\n    // Kullanıcıdan sayı al\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &sayılar[i]);\n    }\n\n    // Toplam hesaplama\n    int toplam = 0;\n    for (int i = 0; i < n; i++) {\n        toplam += sayılar[i];\n    }\n\n    printf(\"Toplam: %d\\n\", toplam);\n\n    // Belleği serbest bırakma\n    free(sayılar);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627377"
  },
  {
    "question": "Kullanıcının girdiği isimler için dinamik bir dizi oluştur ve isimleri ekrana yazdır.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    printf(\"Kaç tane isim gireceksiniz? \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    char **isimler = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        isimler[i] = (char *)malloc(50 * sizeof(char)); // Her isim için 50 karakter\n    }\n\n    // Kullanıcıdan isim alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. ismi girin: \", i + 1);\n        scanf(\"%s\", isimler[i]);\n    }\n\n    // İsimleri yazdırma\n    printf(\"Girdiğiniz isimler:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", isimler[i]);\n    }\n\n    // Belleği serbest bırakma\n    for (int i = 0; i < n; i++) {\n        free(isimler[i]);\n    }\n    free(isimler);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627403"
  },
  {
    "question": "Dinamik bir dizi ile kullanıcıdan alınan sayıları sıralayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid sirala(int *dizi, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (dizi[i] > dizi[j]) {\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\");\n        return 1;\n    }\n\n    // Kullanıcıdan eleman alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. elemanı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Sıralama\n    sirala(dizi, n);\n\n    // Sıralanmış diziyi yazdırma\n    printf(\"Sıralanmış dizi:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627425"
  },
  {
    "question": "Dinamik olarak bir tamsayı dizisi oluşturun, içindeki en büyük sayıyı bulun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\\n\");\n        return 1;\n    }\n\n    // Kullanıcıdan eleman alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. elemanı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // En büyük sayıyı bulma\n    int enBüyük = dizi[0];\n    for (int i = 1; i < n; i++) {\n        if (dizi[i] > enBüyük) {\n            enBüyük = dizi[i];\n        }\n    }\n\n    printf(\"En büyük sayı: %d\\n\", enBüyük);\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627452"
  },
  {
    "question": "Kullanıcıdan bir tam sayılar dizisi al ve dizinin ortalamasını hesapla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\\n\");\n        return 1;\n    }\n\n    // Kullanıcıdan sayı alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. sayıyı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Ortalama hesaplama\n    double toplam = 0;\n    for (int i = 0; i < n; i++) {\n        toplam += dizi[i];\n    }\n    double ortalama = toplam / n;\n\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627475"
  },
  {
    "question": "Dinamik bir dizi kullanarak kullanıcıdan alınan değerlerin en küçük ve en büyük değerlerini bulun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Lütfen dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek ayırma\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma başarısız oldu!\\n\");\n        return 1;\n    }\n\n    // Kullanıcıdan eleman alma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. elemanı girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // En küçük ve en büyük bulma\n    int enKucuk = dizi[0];\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < n; i++) {\n        if (dizi[i] < enKucuk) enKucuk = dizi[i];\n        if (dizi[i] > enBuyuk) enBuyuk = dizi[i];\n    }\n\n    printf(\"En küçük sayı: %d\\n\", enKucuk);\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:30:39.627503"
  },
  {
    "question": "Kullanıcının girdiği n sayısına göre dinamik olarak bir dizi oluştur ve bu diziyi kullanarak sayıların toplamını hesapla. Eksik kodu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, i;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int)); // Dinamik bellek ayırma\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    for (i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    int toplam = 0;\n    for (i = 0; i < n; i++) {\n        toplam += dizi[i];\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    free(dizi); // Belleği serbest bırakma\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201350"
  },
  {
    "question": "Kullanıcıdan alınan isimlerin dinamik olarak saklanması ve her ismin uzunluğunu hesaplanması için bir program yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    printf(\"Kaç isim gireceksiniz? \");\n    scanf(\"%d\", &n);\n    char **isimler = (char **)malloc(n * sizeof(char *)); // Dinamik bellek ayırma\n    for (int i = 0; i < n; i++) {\n        isimler[i] = (char *)malloc(100 * sizeof(char)); // Her isim için bellek ayırma\n        printf(\"İsim %d: \", i + 1);\n        scanf(\"%s\", isimler[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"%s'nin uzunluğu: %lu\\n\", isimler[i], strlen(isimler[i]));\n        free(isimler[i]); // Her isim için ayrılan bellek serbest bırakılıyor\n    }\n    free(isimler); // İsimler dizisi için ayrılan bellek serbest bırakılıyor\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201403"
  },
  {
    "question": "Bir dizi içindeki en büyük sayıyı bulmak için dinamik bellek kullanarak bir program yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int)); // Dinamik bellek ayırma\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    int enBuyuk = dizi[0];\n    for (int i = 1; i < n; i++) {\n        if (dizi[i] > enBuyuk) {\n            enBuyuk = dizi[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", enBuyuk);\n    free(dizi); // Belleği serbest bırakma\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201437"
  },
  {
    "question": "Dinamik bellek kullanarak bir iki boyutlu dizi oluşturun ve bu diziyi kullanarak matris toplamını hesaplayın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int satir, sutun;\n    printf(\"Satır sayısını girin: \");\n    scanf(\"%d\", &satir);\n    printf(\"Sütun sayısını girin: \");\n    scanf(\"%d\", &sutun);\n    int **matris = (int **)malloc(satir * sizeof(int *)); // Satır için bellek ayırma\n    for (int i = 0; i < satir; i++) {\n        matris[i] = (int *)malloc(sutun * sizeof(int)); // Her satıra sütun için bellek ayırma\n    }\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            printf(\"Matris[%d][%d]: \", i, j);\n            scanf(\"%d\", &matris[i][j]);\n        }\n    }\n    int toplam = 0;\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            toplam += matris[i][j];\n        }\n    }\n    printf(\"Matris toplamı: %d\\n\", toplam);\n    for (int i = 0; i < satir; i++) {\n        free(matris[i]); // Her satır için ayrılan bellek serbest bırakılıyor\n    }\n    free(matris); // Matris dizisi için ayrılan bellek serbest bırakılıyor\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201472"
  },
  {
    "question": "Dinamik bellek kullanarak bir öğrenci yapısı oluşturun ve birden fazla öğrencinin bilgilerini tutun. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct Ogrenci {\n    char isim[50];\n    int not;\n};\n\nint main() {\n    int n;\n    printf(\"Kaç öğrenci gireceksiniz? \");\n    scanf(\"%d\", &n);\n    struct Ogrenci *ogrenciler = (struct Ogrenci *)malloc(n * sizeof(struct Ogrenci)); // Dinamik bellek ayırma\n    for (int i = 0; i < n; i++) {\n        printf(\"Öğrenci %d ismini girin: \", i + 1);\n        scanf(\"%s\", ogrenciler[i].isim);\n        printf(\"Öğrenci %d notunu girin: \", i + 1);\n        scanf(\"%d\", &ogrenciler[i].not);\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"Öğrenci: %s, Not: %d\\n\", ogrenciler[i].isim, ogrenciler[i].not);\n    }\n    free(ogrenciler); // Belleği serbest bırakma\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201535"
  },
  {
    "question": "Bir diziyi dinamik olarak ters çeviren bir program yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int)); // Dinamik bellek ayırma\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Ters dizi: \");\n    for (int i = n - 1; i >= 0; i--) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    free(dizi); // Belleği serbest bırakma\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201581"
  },
  {
    "question": "Kullanıcıdan alınan kelimeleri dinamik bellek kullanarak saklayın ve kelimelerin toplam karakter sayısını hesaplayın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    printf(\"Kaç kelime gireceksiniz? \");\n    scanf(\"%d\", &n);\n    char **kelimeler = (char **)malloc(n * sizeof(char *)); // Dinamik bellek ayırma\n    for (int i = 0; i < n; i++) {\n        kelimeler[i] = (char *)malloc(100 * sizeof(char)); // Her kelime için bellek ayırma\n        printf(\"Kelime %d: \", i + 1);\n        scanf(\"%s\", kelimeler[i]);\n    }\n    int toplamKarakter = 0;\n    for (int i = 0; i < n; i++) {\n        toplamKarakter += strlen(kelimeler[i]);\n    }\n    printf(\"Toplam karakter sayısı: %d\\n\", toplamKarakter);\n    for (int i = 0; i < n; i++) {\n        free(kelimeler[i]); // Her kelime için bellek serbest bırakılıyor\n    }\n    free(kelimeler); // Kelimeler dizisi için ayrılan bellek serbest bırakılıyor\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201619"
  },
  {
    "question": "Dinamik bellek kullanarak bir tam sayı dizisini sıralamak için bir program yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid sirala(int *dizi, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int *dizi = (int *)malloc(n * sizeof(int)); // Dinamik bellek ayırma\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    sirala(dizi, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    free(dizi); // Belleği serbest bırakma\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:31:29.201650"
  },
  {
    "question": "Bir dizideki her bir elemanın karesini alıp, bu değerleri yeni bir dizide saklayacak bir fonksiyon yazın. Eksik kısımları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid kareleri_al(int *dizi, int uzunluk) {\n    int *kareler = (int *)malloc(uzunluk * sizeof(int));\n    if (kareler == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return;\n    }\n    for (int i = 0; i < uzunluk; i++) {\n        kareler[i] = dizi[i] * dizi[i];\n    }\n    printf(\"Kareler:\");\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\" %d\", kareler[i]);\n    }\n    printf(\"\\n\");\n    free(kareler);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int uzunluk = sizeof(dizi) / sizeof(dizi[0]);\n    kareleri_al(dizi, uzunluk);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969363"
  },
  {
    "question": "Kullanıcıdan bir dizi uzunluğu alıp, bu uzunlukta bir dizi oluşturan ve tüm elemanları sıfır atan bir fonksiyon yazın. Eksik kısımları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid dizi_oluştur(int uzunluk) {\n    int *dizi = (int *)malloc(uzunluk * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return;\n    }\n    for (int i = 0; i < uzunluk; i++) {\n        dizi[i] = 0;\n    }\n    printf(\"Dizi elemeleri:\");\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n    printf(\"\\n\");\n    free(dizi);\n}\n\nint main() {\n    int uzunluk;\n    printf(\"Dizi uzunluğunu girin: \");\n    scanf(\"%d\", &uzunluk);\n    dizi_oluştur(uzunluk);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969452"
  },
  {
    "question": "Verilen bir dizi içindeki negatif elemanları sayan bir fonksiyon yazın. Eksik alanları doldurun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint negatif_say(int *dizi, int uzunluk) {\n    int sayac = 0;\n    for (int i = 0; i < uzunluk; i++) {\n        if (dizi[i] < 0) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int uzunluk = 5;\n    int *dizi = (int *)malloc(uzunluk * sizeof(int));\n    dizi[0] = -1;\n    dizi[1] = 2;\n    dizi[2] = -3;\n    dizi[3] = 4;\n    dizi[4] = -5;\n\n    int negatiflerin_sayisi = negatif_say(dizi, uzunluk);\n    printf(\"Negatif eleman sayisi: %d\\n\", negatiflerin_sayisi);\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969504"
  },
  {
    "question": "Kullanıcının girdiği kelimeleri saklayacak bir dinamik dizi oluşturan bir fonksiyon yazın. Eksik kısımları doldurun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid kelime_dizisi_oluştur(int kelime_sayisi) {\n    char **kelimeler = (char **)malloc(kelime_sayisi * sizeof(char *));\n    for (int i = 0; i < kelime_sayisi; i++) {\n        kelimeler[i] = (char *)malloc(100 * sizeof(char)); // 100 karakterlik kelimeler\n        printf(\"Kelime %d: \", i + 1);\n        scanf(\"%s\", kelimeler[i]);\n    }\n    printf(\"Girilen kelimeler:\");\n    for (int i = 0; i < kelime_sayisi; i++) {\n        printf(\" %s\", kelimeler[i]);\n        free(kelimeler[i]);\n    }\n    printf(\"\\n\");\n    free(kelimeler);\n}\n\nint main() {\n    int kelime_sayisi;\n    printf(\"Kaç kelime gireceksiniz?: \");\n    scanf(\"%d\", &kelime_sayisi);\n    kelime_dizisi_oluştur(kelime_sayisi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969575"
  },
  {
    "question": "Dinamik bir dizi kullanarak kullanıcıdan girilen sayıları toplamak için bir fonksiyon yazın. Eksik kısımları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint toplam_hesapla(int *dizi, int uzunluk) {\n    int toplam = 0;\n    for (int i = 0; i < uzunluk; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int uzunluk;\n    printf(\"Dizi uzunluğunu girin: \");\n    scanf(\"%d\", &uzunluk);\n    int *dizi = (int *)malloc(uzunluk * sizeof(int));\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\"Eleman %d: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n    int toplam = toplam_hesapla(dizi, uzunluk);\n    printf(\"Toplam: %d\\n\", toplam);\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969636"
  },
  {
    "question": "Dinamik bir dizi kullanarak kullanıcıdan alınan karakterleri saklayan bir program yazın. Eksik alanları doldurun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int karakter_sayisi;\n    printf(\"Kaç karakter gireceksiniz?: \");\n    scanf(\"%d\", &karakter_sayisi);\n    char *karakterler = (char *)malloc(karakter_sayisi * sizeof(char));\n    for (int i = 0; i < karakter_sayisi; i++) {\n        printf(\"Karakter %d: \", i + 1);\n        scanf(\" %c\", &karakterler[i]);\n    }\n    printf(\"Girilen karakterler:\");\n    for (int i = 0; i < karakter_sayisi; i++) {\n        printf(\" %c\", karakterler[i]);\n    }\n    printf(\"\\n\");\n    free(karakterler);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969689"
  },
  {
    "question": "Kullanıcıdan bir dizi boyutu alarak bu boyutta bir dizi oluşturan ve rastgele sayılar atan bir fonksiyon yazın. Eksik kısımları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid rastgele_dizi_oluştur(int boyut) {\n    int *dizi = (int *)malloc(boyut * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\\n\");\n        return;\n    }\n    srand(time(NULL)); // Rastgele sayı üretimi için seed ayarı\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] = rand() % 100; // 0-99 arasında rastgele sayılar\n    }\n    printf(\"Dizi elemanları:\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n    printf(\"\\n\");\n    free(dizi);\n}\n\nint main() {\n    int boyut;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n    rastgele_dizi_oluştur(boyut);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969756"
  },
  {
    "question": "Dinamik olarak tahsis edilmiş bir dizi elemanlarını tersine çeviren bir fonksiyon yazın. Eksik kısımları tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid ters_cevir(int *dizi, int uzunluk) {\n    for (int i = 0; i < uzunluk / 2; i++) {\n        int temp = dizi[i];\n        dizi[i] = dizi[uzunluk - 1 - i];\n        dizi[uzunluk - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int uzunluk = 5;\n    int *dizi = (int *)malloc(uzunluk * sizeof(int));\n    dizi[0] = 1;\n    dizi[1] = 2;\n    dizi[2] = 3;\n    dizi[3] = 4;\n    dizi[4] = 5;\n\n    printf(\"Orijinal Dizi:\");\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n    printf(\"\\n\");\n\n    ters_cevir(dizi, uzunluk);\n\n    printf(\"Ters Dizi:\");\n    for (int i = 0; i < uzunluk; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n    printf(\"\\n\");\n    free(dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969812"
  },
  {
    "question": "Bir dizi içerisindeki çift sayıları bulan ve yeni bir dizide saklayan bir fonksiyon yazın. Eksik alanları doldurun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint* cift_sayilari_bul(int *dizi, int uzunluk, int *cift_sayisi) {\n    int *cift_dizi = (int *)malloc(uzunluk * sizeof(int));\n    *cift_sayisi = 0;\n    for (int i = 0; i < uzunluk; i++) {\n        if (dizi[i] % 2 == 0) {\n            cift_dizi[*cift_sayisi] = dizi[i];\n            (*cift_sayisi)++;\n        }\n    }\n    return cift_dizi;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int uzunluk = sizeof(dizi) / sizeof(dizi[0]);\n    int cift_sayisi;\n    int *cift_dizi = cift_sayilari_bul(dizi, uzunluk, &cift_sayisi);\n\n    printf(\"Çift sayılar:\");\n    for (int i = 0; i < cift_sayisi; i++) {\n        printf(\" %d\", cift_dizi[i]);\n    }\n    printf(\"\\n\");\n    free(cift_dizi);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:27.969869"
  },
  {
    "question": "Dinamik bellek tahsisi için kullanılan fonksiyon nedir?",
    "answer": "C dilinde dinamik bellek tahsisi için genellikle 'malloc' fonksiyonu kullanılır. Örnek: int *arr = (int *)malloc(10 * sizeof(int)); Bu kod, 10 tamsayı saklayacak kadar bellek ayırır. Eğer malloc başarıyla bellek tahsis edemezse, NULL döner. Bu yüzden bellek tahsisinden sonra her zaman NULL kontrolü yapmak önemlidir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385420"
  },
  {
    "question": "malloc kullandıktan sonra bellek sızıntısını nasıl önleyebilirim?",
    "answer": "Bellek sızıntısını önlemek için, malloc ile tahsis edilen belleği kullanmayı bitirdikten sonra 'free' fonksiyonu ile serbest bırakmalısınız. Örnek: free(arr); Bu kod ile arr dizisine tahsis edilen bellek serbest bırakılır. Eğer free çağrılmazsa, programın belleği zamanla dolacak ve performans düşüklüğüne neden olacaktır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385458"
  },
  {
    "question": "calloc fonksiyonu ile malloc arasındaki fark nedir?",
    "answer": "calloc fonksiyonu, bellek tahsisi yaparken tahsis edilen alanı sıfırlar. Örnek: int *arr = (int *)calloc(10, sizeof(int)); Bu kod, 10 tamsayı için bellek tahsis eder ve tüm alanı sıfırlar. malloc ise sadece bellek tahsis eder, içeriği sıfırlamaz, bu nedenle kullanılmadan önce sıfırlanması gerekir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385478"
  },
  {
    "question": "realloc fonksiyonu nasıl çalışır ve ne zaman kullanılır?",
    "answer": "realloc, daha önce tahsis edilmiş bir bellek bloğunu yeni bir boyuta genişletmek veya daraltmak için kullanılır. Örnek: arr = (int *)realloc(arr, 20 * sizeof(int)); Bu kod, daha önce oluşturulmuş arr dizisini 20 tamsayı kapasitesine genişletir. Eğer bellek tahsisi başarısız olursa, orijinal bellek bloğu etkilenmez, ancak bellek taşmasını önleme açısından dikkatli olunmalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385500"
  },
  {
    "question": "free fonksiyonunu yanlış kullanmanın sonuçları nelerdir?",
    "answer": "free fonksiyonunu yanlış kullanmak, programda ciddi hatalara yol açabilir. Örneğin, bir bellek bloğunun iki kez serbest bırakılması (double free) veya serbest bırakılmamış bir bellek bloğuna erişim (dangling pointer) hatalarına neden olabilir. Bu tür hatalar genellikle programın çökmesine veya beklenmeyen davranışlara yol açar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385537"
  },
  {
    "question": "Belli bir türde dinamik bellek tahsisi yapmanın avantajları nelerdir?",
    "answer": "Dinamik bellek tahsisinin avantajları arasında bellek yönetiminin daha esnek olması ve programın çalışma zamanında bellek ihtiyacının ayarlanabilir olması sayılabilir. Örneğin, bir dizinin boyutunu kullanıcıdan aldığımızda, bu boyuta uygun bellek tahsis edebiliriz. Bu, statik bellekte boyutun önceden belirlenmesi gerekliliğini ortadan kaldırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385561"
  },
  {
    "question": "Dinamik belleğin sızmasını tespit etmek için kullanılabilecek bir araç nedir?",
    "answer": "Valgrind, dinamik bellek sızıntılarını tespit etmek için yaygın olarak kullanılan bir araçtır. Programı Valgrind ile çalıştırarak, hangi bellek bloklarının serbest bırakılmadığını ve hangi hataların yapıldığını görebilirsiniz. Örnek kullanım: valgrind --leak-check=full ./program. Bu, bellekteki sızıntıları ve hataları detaylı bir şekilde raporlar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385586"
  },
  {
    "question": "Bir struct yapısına dinamik bellek nasıl tahsis edilir?",
    "answer": "Bir struct yapısına dinamik bellek tahsis etmek için de malloc veya calloc kullanılabilir. Örnek: typedef struct { int id; char name[20]; } Student; Student *s = (Student *)malloc(sizeof(Student)); Bu kod, Student yapısının bir örneği için dinamik bellek tahsisi yapar. Yapı elemanlarına erişim için s->id veya s->name kullanabilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385606"
  },
  {
    "question": "Dinamik dizi oluştururken, bellek alanını daha verimli kullanmanın yolu nedir?",
    "answer": "Dinamik dizi oluştururken, gerektiğinde boyutu artırmak için realloc fonksiyonu kullanılabilir. Başlangıçta küçük bir boyut ile başlayıp, ihtiyaç duyuldukça boyutu artırarak bellek alanının verimli kullanılmasını sağlayabilirsiniz. Örneğin: int *arr = (int *)malloc(2 * sizeof(int)); Daha sonra gerektiğinde realloc ile boyutunu artırabilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385631"
  },
  {
    "question": "Dinamik bellek tahsisi yapıldıktan sonra kullanıma kapatmanın en iyi yolu nedir?",
    "answer": "Dinamik bellek tahsisi yaptıktan sonra, kullanıma kapatmanın en iyi yolu, bellek alanını serbest bırakmak ve işaretçiyi NULL yapmak olacaktır. Örnek: free(arr); arr = NULL; Bu, işaretçinin geçersiz bir bellek adresine işaret etmesini önler ve sonraki erişimlerin hatalı olmasını engeller.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:32:58.385655"
  },
  {
    "question": "Dizi boyutunu dinamik olarak ayarlamak için malloc kullandım, fakat programım 'Segmentation fault' hatası veriyor. Nedenini açıklayabilir misin?",
    "answer": "Segmentation fault hatası, genellikle bir bellek alanına erişim hatası olduğunda meydana gelir. Bu durumda, malloc ile bellek ayırdıktan sonra bu bellek alanına erişim sağlamadığınızda veya yanlış bir şekilde eriştiğinizde bu hata oluşabilir. Örneğin, malloc'dan dönen işaretçinin NULL olup olmadığını kontrol etmemek, bu hatayı tetikleyebilir. Aşağıda doğru bir kullanım örneği verilmiştir:\n\n```c\nint *arr = malloc(sizeof(int) * n);\nif (arr == NULL) {\n    perror(\"Bellek ayıramadı\");\n    exit(EXIT_FAILURE);\n}\n```\nBu şekilde, belleği başarıyla ayırdığınızdan emin olabilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205670"
  },
  {
    "question": "Dinamik olarak oluşturduğum bir yapı için belleği serbest bırakmayı unuttum. Ne gibi sorunlar yaşarım?",
    "answer": "Belleği serbest bırakmamak, bellek sızıntısına neden olur. Programınız çalıştıkça kullanılmayan bellek alanları birikir ve bu durum sistem kaynaklarını etkiler. Uzun vadede performans düşüşü ve bellek yetersizliği sorunları yaşanabilir. Yapı için bellek serbest bırakmak için 'free' fonksiyonunu kullanmalısınız:\n\n```c\nstruct MyStruct *s = malloc(sizeof(struct MyStruct));\n// İşlemler...\nfree(s);\n```\nBu şekilde bellek sızıntısını önleyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205718"
  },
  {
    "question": "Bir işaretçiyi yeniden kullanmak için free ettim ve sonrasında ona erişmeye çalıştım. Hatanın nedeni nedir?",
    "answer": "Free ettiğiniz bir işaretçi, artık geçerli bir bellek alanını işaret etmez. Bu işlemden sonra işaretçiye erişmeye çalıştığınızda, 'Dangling pointer' hatası alırsınız. Bu tür bir hatayı önlemek için işaretçiyi serbest bıraktıktan sonra NULL değerine atamak en iyi uygulamadır:\n\n```c\nfree(ptr);\nptr = NULL;\n```\nBu, işaretçinin artık geçerli bir bellek alanını işaret etmediğini belirtir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205750"
  },
  {
    "question": "Bir dizi için belleği ayırdım ama daha sonra yanlışlıkla daha az bellek ayırdım. Bu durumda ne gibi sorunlar yaşayabilirim?",
    "answer": "Yanlışlıkla daha az bellek ayırdığınızda, bellek taşması (buffer overflow) hatası ile karşılaşabilirsiniz. Bu, dizi sınırları dışında bir bellek alanına yazmaya çalıştığınızda gerçekleşir. Bu durum programın beklenmedik bir şekilde çalışmasına veya çökmesine neden olabilir. Dizi için doğru miktarda bellek ayırmak ve sınırları kontrol etmek çok önemlidir:\n\n```c\nint *arr = malloc(sizeof(int) * size);\nif (index < size) {\n    arr[index] = value;\n}\n```\nBu şekilde, dizinin sınırları içinde kalmış olursunuz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205786"
  },
  {
    "question": "Dinamik bellek kullanırken, bir işaretçi ile başka bir işaretçiye değer atadım. Bu bir sorun yaratır mı?",
    "answer": "Evet, bu bir sorun yaratabilir. Eğer iki işaretçi aynı bellek alanını işaret ediyorsa ve birisi free edilirse, diğer işaretçi geçersiz bir bellek alanını işaret edebilir. Bu durumda 'Dangling pointer' hatası alırsınız. İşaretçilerin her birinin kendi belleğine sahip olduğundan emin olmalısınız. Aşağıda bir örnek verilmiştir:\n\n```c\nint *ptr1 = malloc(sizeof(int));\nint *ptr2 = ptr1;\nfree(ptr1);\n// ptr2 artık geçersiz bir işaretçi\n```\nBunu önlemek için, işaretçiyi serbest bırakmadan önce kopyalayabilirsiniz veya her işaretçi için ayrı bellek ayırmalısınız.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205819"
  },
  {
    "question": "Bir yapı içinde başka bir dinamik bellek alanı işaretçisi kullanmak istiyorum. Hangi bellek yönetimi sorunları ile karşılaşabilirim?",
    "answer": "Bir yapı içinde dinamik bellek işaretçileri kullanmak, yapı serbest bırakıldığında bu işaretçilerin de serbest bırakılmasını gerektirir. Aksi halde, bellek sızıntıları yaşayabilirsiniz. Yapı içindeki her bir işaretçi için free fonksiyonunu çağırmalısınız:\n\n```c\nstruct MyStruct {\n    int *data;\n};\n\nstruct MyStruct *s = malloc(sizeof(struct MyStruct));\ns->data = malloc(sizeof(int) * size);\n// İşlemler...\nfree(s->data);\nfree(s);\n```\nBu şekilde, hem yapı hem de içindeki işaretçi için bellek serbest bırakılmış olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205855"
  },
  {
    "question": "Dinamik bir diziye eleman eklemek istiyorum, ama belleği yeniden boyutlandırmam gerektiğinde sorun yaşıyorum. Neden böyle bir durum ortaya çıkıyor?",
    "answer": "Belleği yeniden boyutlandırmak için 'realloc' fonksiyonunu kullanmalısınız. Ancak, eğer 'realloc' başarısız olursa NULL döndürür ve işaretçiniz kaybolur. Bu nedenle, işaretçiyi güncellemeden önce geçici bir işaretçi kullanarak kontrol etmeniz önemlidir:\n\n```c\nint *new_ptr = realloc(old_ptr, new_size);\nif (new_ptr == NULL) {\n    // Hata durumu\n} else {\n    old_ptr = new_ptr;\n}\n```\nBu şekilde, bellek yeniden boyutlandırma işlemi sırasında veri kaybını önleyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205898"
  },
  {
    "question": "Dinamik olarak ayırdığım belleği kullanmaya çalıştığımda 'Invalid pointer' hatası alıyorum. Bunun nedeni ne olabilir?",
    "answer": "Invalid pointer hatası, genellikle daha önce serbest bırakılmış bir bellek alanına erişmeye çalıştığınızda meydana gelir. Eğer bir işaretçiyi serbest bıraktıysanız ve sonra bu işaretçiyi kullanmaya çalışıyorsanız bu hatayı alırsınız. Belleği serbest bırakırken işaretçiyi NULL yapmak, bu durumu önlemenin iyi bir yoludur:\n\n```c\nfree(ptr);\nptr = NULL;\n```\nBu sayede işaretçi geçersiz hale gelecektir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205933"
  },
  {
    "question": "Dinamik bellek kullanan bir fonksiyonda belleği yönetimi ile ilgili dikkat etmem gereken en önemli noktalar nelerdir?",
    "answer": "Dinamik bellek yönetiminde dikkat edilmesi gereken birkaç ana nokta vardır: 1) Her 'malloc' veya 'calloc' işlemi sonrasında işaretçinin NULL olup olmadığını kontrol edin. 2) Belleği serbest bırakmayı unutmayın, her 'malloc' ve 'calloc' için bir 'free' olmalıdır. 3) 'realloc' kullanırken eski işaretçinin kaybolmaması için geçici bir işaretçi kullanın. 4) Dangling pointer hatalarını önlemek için serbest bırakılan işaretçileri NULL yapın. Bu noktaları dikkate alarak dinamik bellek yönetimini daha sağlıklı bir şekilde gerçekleştirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:33:39.205965"
  },
  {
    "question": "Dinamik bellek tahsisi sırasında neden 'malloc' fonksiyonunun dönüş değerini kontrol etmeliyiz?",
    "answer": "'malloc' fonksiyonu, istenen boyutta bellek tahsis edemezse NULL döner. Bu durumda, programın çökmesini engellemek için dönüş değerini kontrol etmek gerekir. Örnek: \n\n```c\nint *arr = (int *)malloc(10 * sizeof(int));\nif (arr == NULL) {\n    fprintf(stderr, \"Bellek tahsis hatası!\\n\");\n    exit(1);\n}\n```\nUygulama sırasında bellek yetersizliğinden kaynaklanan hataları önlemek için bu kontrol hayati öneme sahiptir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963827"
  },
  {
    "question": "Bir dizinin boyutunu dinamik olarak belirlemek için nasıl bir yaklaşım izlemeliyiz?",
    "answer": "Dizinin boyutunu dinamik olarak belirlemek için, önce kullanıcıdan boyutu girmesini isteyebiliriz ve ardından bu boyuta göre bellekte yer açmalıyız. Örnek: \n\n```c\nint size;\nprintf(\"Dizinin boyutunu girin: \");\nsscanf(\"%d\", &size);\nint *arr = (int *)malloc(size * sizeof(int));\nif (arr == NULL) {\n    fprintf(stderr, \"Bellek tahsis hatası!\\n\");\n    exit(1);\n}\n```\nBu şekilde, kullanıcıdan alınan boyuta göre bellek tahsis edilmiş olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963871"
  },
  {
    "question": "Dinamik olarak tahsis edilmiş bir belleği serbest bırakmadığımızda ne tür sorunlar yaşayabiliriz?",
    "answer": "Dinamik olarak tahsis edilen bellek, serbest bırakılmadığı takdirde bellek sızıntısına neden olur. Bu, zamanla uygulamanın bellek tüketimini artırarak sistemin yavaşlamasına veya çökmesine yol açabilir. Örnek: \n\n```c\nint *arr = (int *)malloc(100 * sizeof(int));\n// bazı işlemler...\n// free(arr); // Bu satır çıkarıldığında bellek sızıntısı oluşur.\n```\nHer 'malloc' sonrası uygun şekilde 'free' çağrılmalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963901"
  },
  {
    "question": "Birden fazla bellek alanı tahsis ettikten sonra bunları nasıl serbest bırakmalıyız?",
    "answer": "Her tahsis edilen bellek bloğu için ayrı ayrı 'free' fonksiyonunu çağırmalıyız. Ayrıca, serbest bırakılan işaretçileri NULL yaparak 'dangling pointer' sorununu önleyebiliriz. Örnek: \n\n```c\nint *arr1 = (int *)malloc(50 * sizeof(int));\nint *arr2 = (int *)malloc(100 * sizeof(int));\n// İşlemler...\nfree(arr1);\narr1 = NULL;\nfree(arr2);\narr2 = NULL;\n```\nBu yöntem, serbest bırakılan bellek alanına erişimi engeller.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963926"
  },
  {
    "question": "Çok boyutlu diziler için dinamik bellek tahsisini nasıl gerçekleştirebiliriz?",
    "answer": "Çok boyutlu diziler için, her satır için ayrı bir bellek tahsis etmemiz gerekebilir. Örnek: \n\n```c\nint rows = 3, cols = 4;\nint **matrix = (int **)malloc(rows * sizeof(int *));\nfor (int i = 0; i < rows; i++) {\n    matrix[i] = (int *)malloc(cols * sizeof(int));\n}\n// Bellek kullanımından sonra:\nfor (int i = 0; i < rows; i++) {\n    free(matrix[i]);\n}\nfree(matrix);\n```\nBu yapı, bellek yönetimini daha esnek hale getirir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963960"
  },
  {
    "question": "Bellek tahsisinde 'calloc' ve 'malloc' arasındaki fark nedir?",
    "answer": "'calloc' fonksiyonu, belleği sıfırla doldurarak tahsis eder, 'malloc' ise sadece tahsis eder. Bu, 'calloc' kullanarak kullanılacak bellek alanının başlangıç değerinin sıfır olmasını sağladığı için daha güvenli bir seçim olabilir. Örnek: \n\n```c\nint *arr1 = (int *)malloc(10 * sizeof(int));\nint *arr2 = (int *)calloc(10, sizeof(int));\n// arr1 içindeki değerler rastgele, arr2 içindeki tüm değerler 0 ile başlar.\n```\nBu, hata olasılığını azaltır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.963986"
  },
  {
    "question": "Dinamik bellekte, işaretçilerin yanlış kullanımı hangi sorunlara yol açar?",
    "answer": "Yanlış işaretçi kullanımı, 'dangling pointer' veya 'uninitialized pointer' gibi sorunlar yaratabilir. Dangling pointer, serbest bırakılmış bir bellek alanını işaret ederken; uninitialized pointer, başlangıç değeri verilmemiş bir işaretçidir. Her iki durumda da bellek hataları meydana gelebilir. Örnek: \n\n```c\nint *ptr;\n// printf(\"%d\", *ptr); // Uninitialized pointer hatası.\nfree(ptr); // Dangling pointer hatası.\n```\nBunlar, programın çökmesine neden olabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.964011"
  },
  {
    "question": "Bellek yönetimi sırasında hata kontrolü için hangi yöntemleri kullanmalıyız?",
    "answer": "Bellek yönetimi sırasında hata kontrolü için, 'malloc' ve 'calloc' sonrası dönüş değerlerini kontrol etmenin yanı sıra, 'free' işlemlerinden sonra işaretçiyi NULL yapmayı ve bellek tahsisi sırasında işlemlerin başarılı olup olmadığını kontrol etmeyi kullanmalıyız. Örnek: \n\n```c\nint *arr = (int *)malloc(10 * sizeof(int));\nif (arr) {\n    // işlemler...\n    free(arr);\n    arr = NULL; // Dangling pointer hatasını önler.\n} else {\n    fprintf(stderr, \"Bellek tahsis hatası!\\n\");\n}\n```\nBu stratejiler, programın güvenilirliğini artırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.964036"
  },
  {
    "question": "Dinamik bellek tahsisinde, 'realloc' fonksiyonu nasıl çalışır ve hangi durumlarda kullanmalıyız?",
    "answer": "'realloc' fonksiyonu, daha önce tahsis edilmiş bir bellek bloğunun boyutunu değiştirmek için kullanılır. Eğer bellek bloğu yeterli miktarda boş alan içeriyorsa, mevcut alanı genişletir; aksi halde yeni bir alan tahsis eder. Örnek: \n\n```c\nint *arr = (int *)malloc(5 * sizeof(int));\narr = (int *)realloc(arr, 10 * sizeof(int));\nif (arr == NULL) {\n    fprintf(stderr, \"Bellek yeniden tahsis hatası!\\n\");\n    exit(1);\n}\n```\nBu işlem, dinamik dizilerin boyutunu gerektiğinde güncellemeye olanak tanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.964066"
  },
  {
    "question": "Dinamik bellek yönetiminde sık yapılan hatalar nelerdir?",
    "answer": "Sık yapılan hatalar arasında bellek sızıntısı, serbest bırakılmayan bellek alanları, yanlış boyutta tahsis yapma ve dangling pointer kullanımı bulunmaktadır. Bu hatalar, uygulamanın çökmesine veya bellek sızıntısına neden olabilir. Örnek: \n\n```c\nint *arr = (int *)malloc(10 * sizeof(int));\narr[10] = 5; // Geçersiz bellek erişimi.\n// free(arr) çağrılmadan çıkılması bellek sızıntısına yol açar.\n```\nBu nedenle, dikkatli bir bellek yönetimi gereklidir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:03.964086"
  },
  {
    "question": "Dinamik bellek yönetimi nedir?",
    "answer": "Dinamik bellek yönetimi, program çalışırken bellek alanını ihtiyaç duyulduğunda ayırma ve serbest bırakma işlemidir. C dilinde bu, genellikle 'malloc', 'calloc', 'realloc' ve 'free' işlevleri ile gerçekleştirilir. Dinamik bellek kullanımı, programın esnekliğini artırır ve bellek kullanımını optimize eder.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543123"
  },
  {
    "question": "malloc() fonksiyonu nasıl çalışır?",
    "answer": "malloc() fonksiyonu, belirtilen boyutta bellek tahsis etmek için kullanılır. Örneğin, 'int* ptr = (int*)malloc(10 * sizeof(int));' ifadesi, 10 tamsayı saklayacak kadar bellek ayırır. Eğer bellek tahsisi başarısız olursa, fonksiyon NULL döner.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543158"
  },
  {
    "question": "calloc() ile malloc() arasındaki fark nedir?",
    "answer": "calloc(), 'contiguous allocation' anlamına gelir ve bellek alanını ayırırken, ayırdığı bellek alanını sıfırlarla başlatır. Örneğin, 'int* ptr = (int*)calloc(10, sizeof(int));' ifadesi, 10 tamsayı için bellek tahsis eder ve tüm elemanları 0 ile başlatır. malloc() ise yalnızca bellek tahsis eder ve içeriği belirsiz olabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543181"
  },
  {
    "question": "Realloc() fonksiyonu ne işe yarar?",
    "answer": "realloc() fonksiyonu, daha önce tahsis edilmiş bir bellek bloğunu yeniden boyutlandırmak için kullanılır. Örneğin, 'ptr = realloc(ptr, 20 * sizeof(int));' ifadesi, daha önce 'ptr' ile tahsis edilen belleği 20 tamsayıyı saklayacak şekilde genişletir. Eğer genişletme mümkün değilse, yeni bir bellek alanı ayırır ve eski içerikleri yeni alana kopyalar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543199"
  },
  {
    "question": "Dinamik bellek tahsisi sonrası bellek sızıntısını nasıl önleyebiliriz?",
    "answer": "Bellek sızıntısını önlemek için, dinamik olarak tahsis edilen bellek alanını kullanmayı bitirdikten sonra 'free()' fonksiyonu ile serbest bırakmalıyız. Örneğin, 'free(ptr);' ifadesi ile 'ptr' ile gösterilen bellek alanı serbest bırakılır. Unutulmamalıdır ki, serbest bırakılmamış bellek, sızıntıya ve potansiyel program çökmesine neden olabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543222"
  },
  {
    "question": "Dinamik bellek alanını serbest bırakmadan tekrar kullanabilir miyiz?",
    "answer": "Hayır, bellek alanını serbest bıraktıktan sonra, o alana erişmek belirsiz davranışlara yol açar. Eğer serbest bırakılmış bir bellek alanına erişim sağlarsanız, programınızın çökmesine veya beklenmeyen sonuçlara neden olabilirsiniz. Her zaman kullandığınız bellek alanını serbest bıraktıktan sonra o işaretçiyi NULL yapmanız önerilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543245"
  },
  {
    "question": "Dinamik bellek tahsisi için en iyi uygulamalar nelerdir?",
    "answer": "En iyi uygulamalar arasında, her tahsis işlemi sonrası NULL kontrolü yapmak, bellek alanını kullandıktan sonra serbest bırakmak, ve mümkünse tahsis edilen bellek boyutunu sabit tutmak sayılabilir. Ayrıca, işaretçilerinizi NULL yapmayı unutmayın, böylece yanlışlıkla kullanılmalarını engellersiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543267"
  },
  {
    "question": "Neden dinamik bellek kullanmalıyım?",
    "answer": "Dinamik bellek kullanmanın avantajları arasında bellek alanını programın çalışma zamanında ihtiyaçlara göre ayarlayabilmek, büyük veri yapıları için bellek yönetimini kolaylaştırmak ve bellek kullanımını optimize etmek yer alır. Bu, programın daha verimli ve esnek olmasını sağlar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543283"
  },
  {
    "question": "Dinamik bellek yönetimi ile sabit bellek yönetimi arasındaki farklar nelerdir?",
    "answer": "Sabit bellek yönetiminde, bellek boyutu derleme zamanında belirlenir ve program çalıştığında değiştirilemez. Dinamik bellek yönetiminde ise bellek boyutu çalışma zamanında belirlenebilir ve ihtiyaç duyuldukça ayırıp serbest bırakabilirsiniz. Dinamik bellek, daha fazla esneklik sunarken, dikkatli bir yönetim gerektirir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543308"
  },
  {
    "question": "Bir diziyi dinamik olarak nasıl tanımlarım?",
    "answer": "Bir diziyi dinamik olarak tanımlamak için öncelikle bir işaretçi oluşturmanız ve ardından 'malloc' veya 'calloc' işlevlerini kullanarak bellek tahsis etmeniz gerekir. Örneğin: `int* dizi = (int*)malloc(n * sizeof(int));` burada 'n', dizinin boyutudur. Sonrasında, diziyi kullanmayı bitirdikten sonra 'free(dizi);' ile bellek serbest bırakılmalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:30.543326"
  },
  {
    "question": "Dinamik bellek nedir ve neden kullanılır?",
    "answer": "Dinamik bellek, programın çalışması sırasında ihtiyaç duyulan bellek alanının runtime (çalışma zamanında) tahsis edilmesini sağlar. Statik bellek kullanımında, bellek program derlenirken ayrılır. Dinamik bellek sayesinde bellek kullanımı daha esnek hale gelir; örneğin, kullanıcıdan alınan verilere göre programın ihtiyaç duyduğu bellek miktarı değişebilir ve daha iyi kaynak yönetimi sağlar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283596"
  },
  {
    "question": "C dilinde dinamik bellek tahsisi nasıl yapılır?",
    "answer": "C dilinde dinamik bellek tahsisi için 'malloc()', 'calloc()', 'realloc()' ve 'free()' fonksiyonları kullanılır. 'malloc()', belirtilen byte sayısı kadar bellek ayırır ve bu belleği döner. Örneğin: 'int *arr = (int *)malloc(5 * sizeof(int));' ifadesi, 5 tamsayıyı saklayacak yeterli bellek alanı tahsis eder.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283640"
  },
  {
    "question": "malloc() ile calloc() arasındaki fark nedir?",
    "answer": "'malloc()' sadece bellek tahsis ederken, 'calloc()' hem bellek tahsis eder hem de tahsis edilen alanı sıfırlarla doldurur. Örneğin, 'int *arr = (int *)calloc(5, sizeof(int));' ifadesi, 5 tamsayıyı saklayacak şekilde bellek ayırır ve her birini 0 ile başlatır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283663"
  },
  {
    "question": "Dinamik bellek tahsisinde bellek sızıntısı nedir ve nasıl önlenir?",
    "answer": "Bellek sızıntısı, tahsis edilen dinamik bellek alanının serbest bırakılmaması durumudur. Bu, programın uzun süre çalışması halinde bellek tüketiminin artmasına yol açar. Bellek sızıntısını önlemek için her 'malloc()', 'calloc()', veya 'realloc()' kullanımından sonra 'free()' fonksiyonu ile bellek alanı serbest bırakılmalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283688"
  },
  {
    "question": "realloc() fonksiyonu nasıl çalışır?",
    "answer": "'realloc()' fonksiyonu, mevcut bir bellek bloğunu yeniden boyutlandırmak için kullanılır. Örneğin, 'arr = (int *)realloc(arr, 10 * sizeof(int));' ifadesi, daha önce tahsis edilen 'arr' dizisinin boyutunu 10 tamsayıya çıkarır. Eğer yeni boyut daha küçükse bellek daraltılır; daha büyükse yeni alan tahsis edilir ve eski veriler yeni alana kopyalanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283706"
  },
  {
    "question": "Dinamik bellek kullanımında NULL kontrolü neden önemlidir?",
    "answer": "Dinamik bellek tahsisinde 'malloc()' veya benzeri fonksiyonlar, yeterli bellek yoksa NULL döner. Bu nedenle, bellek tahsisi sonrası NULL kontrolü yapmak önemlidir. Örneğin: 'if (arr == NULL) { /* hata işlemleri */ }' ifadesi ile bellek tahsisinin başarılı olup olmadığını kontrol edebiliriz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283727"
  },
  {
    "question": "Yinelenen veri yapıları için dinamik bellek nasıl yönetilir?",
    "answer": "Yinelenen veri yapıları için dinamik bellek, genellikle bağlı listeler gibi veri yapıları kullanılarak yönetilir. Her bir düğüm için dinamik bellek tahsis edilir. Örneğin, yeni bir düğüm eklerken 'Node *newNode = (Node *)malloc(sizeof(Node));' ile bellek tahsis edilir ve ardından bu düğüm uygun bir yere bağlanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283749"
  },
  {
    "question": "Dizi yerine dinamik bellek kullanmanın avantajları nelerdir?",
    "answer": "Dinamik bellek kullanmanın avantajları arasında bellek israfının önlenmesi, verinin boyutuna göre bellek tahsis edebilme ve çalıştırma sırasında bellek yönetimini optimize etme yer alır. Örneğin, kullanıcıdan alınan veri sayısı programın başlangıcında bilinmiyorsa, dinamik bellek kullanılarak gereksiz bellek tahsisi yapılmamış olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283769"
  },
  {
    "question": "Dinamik bellek tahsisinin performans üzerindeki etkileri nelerdir?",
    "answer": "Dinamik bellek tahsisi, statik tahsise göre daha esnek olmasına rağmen, performans açısından daha maliyetli olabilir. Her bellek tahsisi ve serbest bırakılması zaman alır. Ayrıca, bellek parçalanması gibi durumlar performansı olumsuz etkileyebilir. Bu nedenle, mümkün olduğunca bellek tahsis sayısını minimize etmek faydalıdır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283794"
  },
  {
    "question": "Dinamik bellek tahsisinin sınırlamaları nelerdir?",
    "answer": "Dinamik bellek tahsisinin sınırlamaları arasında bellek sızıntısı riskleri, bellek parçalanması ve tahsis edilebilecek bellek miktarının sınırlı olması yer alır. Özellikle büyük veri yapıları için bellek tahsis etmek zor olabilir ve bu durum sistem kaynakları üzerinde baskı yaratabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283812"
  },
  {
    "question": "Dinamik bellek ve yığın bellek kullanımı arasındaki farklar nelerdir?",
    "answer": "Dinamik bellek, çalışma zamanında bellek tahsis ederken, yığın bellek (stack memory) fonksiyon çağrıları sırasında otomatik olarak tahsis edilir. Yığın bellek, fonksiyon tamamlandığında otomatik olarak serbest bırakılırken, dinamik bellek için geliştiricinin 'free()' ile bellek alanını serbest bırakması gerekir. Yığın bellek genellikle daha hızlıdır, ancak sınırlıdır; dinamik bellek ise daha esnek ama daha maliyetli olabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:34:52.283835"
  },
  {
    "question": "Dinamik bellek yönetimi nedir ve neden kullanılır?",
    "answer": "Dinamik bellek yönetimi, programın çalışma anında bellek tahsis etmesine ve serbest bırakmasına olanak tanır. Sabit boyutlu dizilerin sınırlamalarını aşmak ve bellek kullanımını optimize etmek için kullanılır. Bu, bellek alanını gerektiği gibi ayırıp kullanmayı sağlar, böylece gereksiz bellek tüketimi önlenir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.959872"
  },
  {
    "question": "malloc() fonksiyonunun nasıl çalıştığını açıklayabilir misin?",
    "answer": "malloc() fonksiyonu, belirli bir byte miktarını dinamik olarak ayırmak için çağrılır. Bu işlem, bellekte yeterli alan varsa başarılı olur ve bu alanın başlangıç adresini döner. Eğer yeterli alan yoksa, NULL döner. Örnek: int *arr = (int *)malloc(10 * sizeof(int)); burada 10 tamsayıya yetecek kadar bellek ayrılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.959930"
  },
  {
    "question": "free() fonksiyonu ne işe yarar ve nasıl kullanılır?",
    "answer": "free() fonksiyonu, daha önce malloc() veya benzeri fonksiyonlarla tahsis edilen bellek alanını serbest bırakmak için kullanılır. Bu, bellek sızıntılarını önler. Örnek: int *arr = (int *)malloc(10 * sizeof(int)); // bellek tahsisi; free(arr); // bellek serbest bırakma.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.959979"
  },
  {
    "question": "Dinamik bellek yönetiminde bellek sızıntısını nasıl önleyebilirim?",
    "answer": "Bellek sızıntısını önlemek için, tahsis edilen her bellek bloğunun programın sonunda kesinlikle serbest bırakıldığından emin olunmalıdır. Ayrıca, bellek tahsis ettikten sonra, işlevlerde kullanıldıktan sonra hemen serbest bırakmak iyi bir pratiktir. Belirli bir alan kullanıldıktan sonra onu NULL olarak ayarlamak da önemlidir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960050"
  },
  {
    "question": "Dinamik olarak ayrılan bellek için nasıl bir hata kontrolü yapabilirim?",
    "answer": "Bellek tahsisi işlemlerinden sonra, dönen işaretçinin NULL olup olmadığını kontrol ederek hata kontrolü yapılabilir. Örnek: int *arr = (int *)malloc(10 * sizeof(int)); if (arr == NULL) { perror(\"Bellek tahsis edilemedi\"); exit(EXIT_FAILURE); }.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960091"
  },
  {
    "question": "Dinamik bellek yönetiminde çok boyutlu dizilerin nasıl tahsis edileceğini açıklayabilir misin?",
    "answer": "Çok boyutlu diziler dinamik olarak ayrılırken, genellikle dizinin her boyutu için ayrı bellek alanı tahsis edilir. Örnek: int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i < rows; i++) { matrix[i] = (int *)malloc(cols * sizeof(int)); } burada 'matrix' için iki boyutlu bir bellek alanı oluşturulmuş olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960138"
  },
  {
    "question": "Dinamik bellek yönetiminde işlemci üzerindeki etki ile ilgili neler söyleyebilirsin?",
    "answer": "Dinamik bellek yönetimi, işlemcinin bellek yönetimini etkiler. Bellek tahsis ve serbest bırakma işlemleri, işlemcinin performansı üzerinde etkili olabilir. Çok sayıda ve sık bellek tahsisi, belleğin parçalanmasına yol açabilir; bu nedenle dikkatli kullanılmalıdır. Daha iyi bir performans için bellek havuzları gibi teknikler kullanılabilir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960194"
  },
  {
    "question": "Bir linked list yapısı nasıl dinamik olarak oluşturulur?",
    "answer": "Linked list, genellikle düğüm başına dinamik bellek tahsisi gerektirir. Her düğüm, bir veri alanı ve bir sonraki düğüme işaret eden bir işaretçi içerir. Örneğin: struct Node { int data; struct Node *next; }; struct Node *head = (struct Node *)malloc(sizeof(struct Node)); burada bir linked list düğümü oluşturulmuş olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960231"
  },
  {
    "question": "Dinamik bellek yönetiminin avantajları ve dezavantajları nelerdir?",
    "answer": "Avantajları arasında esneklik, bellek kullanımının optimize edilmesi ve büyük veri yapılarını yönetme yeteneği bulunur. Dezavantajları ise bellek sızıntıları, performans kaybı ve karmaşık hata ayıklama süreçleridir. Projelerde iyi bir bellek yönetimi stratejisi uygulamak bu dezavantajların üstesinden gelinmesine yardımcı olur.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:07.960267"
  },
  {
    "question": "Dinamik bellek kullanarak bir tamsayı dizisi oluşturmanın adımlarını açıkla.",
    "answer": "Dinamik bellek kullanarak bir tamsayı dizisi oluşturmak için öncelikle 'malloc' fonksiyonunu kullanmalıyız. Aşağıda bu işlemin nasıl yapılacağına dair bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek allocated\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", &dizi[i]);\n    }\n\n    // Dizi elemanlarını yazdırma\n    printf(\"Dizi elemanları:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}\n```\nBu kodda kullanıcıdan dizi boyutu alınıyor, 'malloc' ile bellek tahsis ediliyor, dizinin elemanları atanıyor ve ardından bellek serbest bırakılıyor.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.225828"
  },
  {
    "question": "Dinamik bellek ile bir yapı (struct) oluştur ve nasıl kullanıldığını göster.",
    "answer": "Aşağıda bir 'Person' yapısı tanımlanmış ve dinamik bellek ile nasıl kullanılacağı gösterilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char isim[50];\n    int yas;\n} Person;\n\nint main() {\n    // Dinamik bellek allocation\n    Person *kişi = (Person *)malloc(sizeof(Person));\n    if (kişi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    // Kişi bilgilerini alma\n    printf(\"İsim girin: \");\n    scanf(\"%s\", kişi->isim);\n    printf(\"Yaş girin: \");\n    scanf(\"%d\", &kişi->yas);\n\n    // Bilgileri yazdırma\n    printf(\"İsim: %s, Yaş: %d\\n\", kişi->isim, kişi->yas);\n\n    // Belleği serbest bırakma\n    free(kişi);\n    return 0;\n}\n```\nBu kodda bir 'Person' yapısı dinamik olarak oluşturulmakta ve sonra kullanıcıdan bilgiler alınarak yazdırılmaktadır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.225892"
  },
  {
    "question": "Bir dinamik dizi için bellek tahsisi ve erişimi nasıl yapılır?",
    "answer": "Dinamik bir dizi için bellek tahsis etmek ve elemanlarına erişmek için 'malloc' ve dizin operatörü kullanılır. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    // Dizi elemanlarına erişim ve atama\n    for (int i = 0; i < n; i++) {\n        dizi[i] = i + 1; // 1'den n'e kadar değer atama\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanı: %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}\n```\nBu kod, dinamik bir dizi oluşturur, elemanlara atama yapar ve ardından elemanları yazdırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.225932"
  },
  {
    "question": "Dinamik bellekle bir karakter dizisi oluştur ve kullanıcıdan girdi al.",
    "answer": "Dinamik bellek ile bir karakter dizisi (string) oluşturmak için aşağıdaki adımları izleyebiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int boyut;\n    printf(\"Karakter dizisinin boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n\n    // Dinamik bellek tahsisi\n    char *karakterDizisi = (char *)malloc((boyut + 1) * sizeof(char)); // +1 for null terminator\n    if (karakterDizisi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    // Kullanıcıdan girdi alma\n    printf(\"Karakter dizisini girin: \");\n    scanf(\"%s\", karakterDizisi);\n\n    // Girdiyi yazdırma\n    printf(\"Girdiğiniz karakter dizisi: %s\\n\", karakterDizisi);\n\n    // Belleği serbest bırakma\n    free(karakterDizisi);\n    return 0;\n}\n```\nBu kodda, kullanıcıdan bir karakter dizisi almak için dinamik bellek allocations yapılmakta ve ardından alınan girdi yazdırılmaktadır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.225974"
  },
  {
    "question": "Dinamik bellekle iki boyutlu bir dizi nasıl oluşturulur?",
    "answer": "İki boyutlu bir dizi oluşturmak için dinamik bellek tahsisi yapmamız gerekiyor. Aşağıdaki örnek, bu işlemi göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int satir, sutun;\n    printf(\"Satır sayısını girin: \");\n    scanf(\"%d\", &satir);\n    printf(\"Sütun sayısını girin: \");\n    scanf(\"%d\", &sutun);\n\n    // Satırlar için bellek tahsisi\n    int **matris = (int **)malloc(satir * sizeof(int *));\n    for (int i = 0; i < satir; i++) {\n        matris[i] = (int *)malloc(sutun * sizeof(int));\n    }\n\n    // Elemanlara değer atama\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            matris[i][j] = i * sutun + j + 1;\n        }\n    }\n\n    // Matris elemanlarını yazdırma\n    printf(\"Matris elemanları:\\n\");\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            printf(\"%d \", matris[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Belleği serbest bırakma\n    for (int i = 0; i < satir; i++) {\n        free(matris[i]);\n    }\n    free(matris);\n    return 0;\n}\n```\nBu kod, dinamik olarak iki boyutlu bir dizi oluşturur, elemanları atar ve ardından yazdırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.226009"
  },
  {
    "question": "Dinamik bellek yönetiminde 'realloc' fonksiyonu nasıl kullanılır?",
    "answer": "'realloc' fonksiyonu, daha önceden tahsis edilmiş bir bellek alanının boyutunu değiştirmek için kullanılır. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Başlangıç dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < n; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi boyutunu değiştirme\n    printf(\"Yeni dizi boyutunu girin: \");\n    int yeniBoyut;\n    scanf(\"%d\", &yeniBoyut);\n    dizi = (int *)realloc(dizi, yeniBoyut * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\");\n        return 1;\n    }\n\n    // Yeni dizi elemanlarına değer atama\n    for (int i = n; i < yeniBoyut; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < yeniBoyut; i++) {\n        printf(\"Dizinin %d. elemanı: %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}\n```\nBu kod, başlangıçta bir dizi oluşturur, daha sonra kullanıcıdan yeni boyutu alarak 'realloc' ile dizinin boyutunu değiştirir ve yeni değerler atar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.226048"
  },
  {
    "question": "Dinamik bellek üzerinde hata kontrolü nasıl yapılır?",
    "answer": "Dinamik bellek üzerinde hata kontrolü, bellek tahsisi sonrası dönen pointer'ın NULL olup olmadığını kontrol ederek yapılır. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int *)malloc(n * sizeof(int));\n    // Hata kontrolü\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < n; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanı: %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırakma\n    free(dizi);\n    return 0;\n}\n```\nBu kod, dinamik bellek tahsisi sonrası bir hata olup olmadığını kontrol eder ve uygun şekilde bir hata mesajı verir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.226082"
  },
  {
    "question": "Dinamik bellekte bellek sızıntısını önlemek için ne yapılmalı?",
    "answer": "Bellek sızıntısını önlemek için, tahsis edilen bellek kullanıldıktan sonra mutlaka 'free' fonksiyonu ile serbest bırakılmalıdır. Aşağıda bir örnek gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Dinamik bellek tahsisi\n    int *dizi = (int *)malloc(n * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek tahsisi başarısız!\\n\");\n        return 1;\n    }\n\n    // Diziye değer atama\n    for (int i = 0; i < n; i++) {\n        dizi[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizinin %d. elemanı: %d\\n\", i, dizi[i]);\n    }\n\n    // Belleği serbest bırakma (sızıntıyı önlemek için)\n    free(dizi);\n    return 0;\n}\n```\nBu kod, dinamik olarak tahsis edilen belleği serbest bırakmayı gösterir. Eğer bu işlem yapılmazsa, bellek sızıntısı meydana gelir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:35:57.226117"
  },
  {
    "question": "Bir dizi oluşturmak için dinamik bellek nasıl yönetilir?",
    "answer": "Dinamik bellek yönetimi için 'malloc' fonksiyonunu kullanabiliriz. Örneğin, kullanıcıdan öğe sayısını alıp, ardından bu sayıda bir tamsayı dizisi oluşturabiliriz. Kod: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Öğe sayısını girin: \");\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek tahsisi başarısız.\");\n        return 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    free(arr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.138905"
  },
  {
    "question": "Dinamik olarak ayrılmış bir dizinin eleman sayısını nasıl değiştirebiliriz?",
    "answer": "Dizinin boyutunu değiştirmek için 'realloc' fonksiyonunu kullanabiliriz. Örneğin, başlangıçta 5 elemanlı bir dizi oluşturup, sonrasında boyutunu 10'a çıkarabiliriz. Kod: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n = 5;\n    int *arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n\n    n = 10;\n    arr = (int *)realloc(arr, n * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek yeniden tahsisi başarısız.\");\n        return 1;\n    }\n\n    for (int i = 5; i < n; i++) {\n        arr[i] = i + 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    free(arr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.138947"
  },
  {
    "question": "Dinamik bellek sızıntısını nasıl önleyebiliriz?",
    "answer": "Dinamik bellek sızıntısını önlemek için, her 'malloc' veya 'calloc' çağrısından sonra belleği serbest bırakmayı (free) unutmamalıyız. Ayrıca, kullanılmayan bellek alanlarını serbest bırakmak için kod yapımızı dikkatlice düzenlemeliyiz. Örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    if (arr == NULL) {\n        return 1;\n    }\n    // Bellek kullanımı\n    free(arr); // Belleği serbest bırakıyoruz.\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.138967"
  },
  {
    "question": "Dinamik bellek alanında hata kontrolü nasıl yapılır?",
    "answer": "Dinamik bellek tahsisinde her zaman başarılı olup olmadığını kontrol etmeliyiz. 'malloc' veya 'calloc' fonksiyonlarının döndürdüğü değer NULL ise, bellek tahsisi başarısız olmuştur. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(1000000000 * sizeof(int)); // Hata olasılığı yüksek\n    if (arr == NULL) {\n        printf(\"Hata: Bellek tahsisi başarısız.\");\n        return 1;\n    }\n    // Bellek kullanımı\n    free(arr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.138986"
  },
  {
    "question": "Bir yapı (struct) içindeki dinamik bellek yönetimi nasıl yapılır?",
    "answer": "Bir yapı içinde dinamik bellek kullanmak için, yapının içinde bir gösterici (pointer) tanımlayabiliriz. Yapıyı oluşturarak dinamik bellek tahsisi yapabiliriz. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *arr;\n    int size;\n} DynamicArray;\n\nint main() {\n    DynamicArray dArr;\n    dArr.size = 5;\n    dArr.arr = (int *)malloc(dArr.size * sizeof(int));\n\n    if (dArr.arr == NULL) {\n        return 1;\n    }\n\n    for (int i = 0; i < dArr.size; i++) {\n        dArr.arr[i] = i + 1;\n    }\n\n    for (int i = 0; i < dArr.size; i++) {\n        printf(\"%d \", dArr.arr[i]);\n    }\n\n    free(dArr.arr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.139012"
  },
  {
    "question": "Dinamik bellek kullanarak bir matris oluşturmanın en iyi yolu nedir?",
    "answer": "Dinamik bellek kullanarak bir matris oluşturmanın en iyi yolu, iki boyutlu diziyi bir gösterici dizisi ile temsil etmektir. Her satır için ayrı bellek tahsis edebiliriz. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 4;\n    int **matrix = (int **)malloc(rows * sizeof(int *));\n\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = (int *)malloc(cols * sizeof(int));\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = i * j;\n        }\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.139036"
  },
  {
    "question": "Bir karakter dizisi için dinamik bellek yönetimi nasıl yapılır?",
    "answer": "Karakter dizisi için dinamik bellek yönetimi 'malloc' ile yapılabilir. Kullanıcıdan bir kelime girişi alıp, bu kelimeyi dinamik olarak saklayabiliriz. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str;\n    str = (char *)malloc(100 * sizeof(char)); // 100 karakter için bellek tahsis\n\n    printf(\"Bir kelime girin: \");\n    fgets(str, 100, stdin);\n\n    printf(\"Girdiğiniz kelime: %s\", str);\n\n    free(str);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.139058"
  },
  {
    "question": "Bir linked list için dinamik bellek yönetimi nasıl yapılır?",
    "answer": "Linked list oluştururken, her düğüm için dinamik bellek kullanmamız gerekir. Düğüm yapısına göre 'malloc' ile bellek tahsis edebiliriz. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode* createNode(int data) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n\n    Node *temp = head;\n    while (temp != NULL) {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n\n    // Bellek serbest bırakma işlemi burada yapılmalıdır.\n    temp = head;\n    while (temp != NULL) {\n        Node *next = temp->next;\n        free(temp);\n        temp = next;\n    }\n\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.139080"
  },
  {
    "question": "Dinamik bellek yönetiminde neden 'calloc' kullanmalıyız?",
    "answer": "'calloc', 'malloc' ile benzer bir işlevi görür, ancak tahsis edilen belleği sıfır ile başlatır. Bu, bellek sızıntılarını önlemek ve kullanımdan önce belleğin temiz olduğunu garanti etmek için faydalıdır. Kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n = 5;\n    int *arr = (int *)calloc(n, sizeof(int)); // Bellek sıfır ile başlatılıyor.\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]); // Hepsi 0 olarak gösterilecektir.\n    }\n\n    free(arr);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:36:32.139100"
  },
  {
    "question": "Dinamik bellek tahsisi ile bir dizi oluşturan ve bu dizinin elemanlarını kullanıcıdan alan bir program yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizinin boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    int *dizi = (int *)malloc(n * sizeof(int)); // Dinamik bellek tahsisi\n    if (dizi == NULL) { // Hata kontrolü\n        printf(\"Bellek tahsis edilemedi!\");\n        return 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizi[%d] = \", i);\n        scanf(\"%d\", &dizi[i]); // Kullanıcıdan veri al\n    }\n\n    printf(\"Dizinin elemanları: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n\n    free(dizi); // Belleği serbest bırak\n    return 0;\n}\n``` Bu program, kullanıcıdan bir dizi boyutu alır, dinamik olarak bellek tahsis eder, dizinin elemanlarını kullanıcıdan alır ve çıktısını verir. Belleği serbest bırakmak için 'free' fonksiyonu kullanılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984061"
  },
  {
    "question": "Dinamik olarak tahsis edilmiş bir 2D dizi oluşturan ve bu dizinin elemanlarını sıfırlayan bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid diziSifirla(int **dizi, int satir, int sutun) {\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            dizi[i][j] = 0;\n        }\n    }\n}\n\nint main() {\n    int satir = 3, sutun = 4;\n    int **dizi = (int **)malloc(satir * sizeof(int *));\n    for (int i = 0; i < satir; i++) {\n        dizi[i] = (int *)malloc(sutun * sizeof(int));\n    }\n\n    diziSifirla(dizi, satir, sutun);\n\n    for (int i = 0; i < satir; i++) {\n        for (int j = 0; j < sutun; j++) {\n            printf(\"%d \", dizi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < satir; i++) {\n        free(dizi[i]);\n    }\n    free(dizi);\n    return 0;\n}\n``` Bu kod, 2D diziyi dinamik olarak tahsis eder ve tüm elemanlarını sıfırlar. 'diziSifirla' fonksiyonu, verilen 2D diziyi sıfırlar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984108"
  },
  {
    "question": "Dinamik bellek tahsisi ile bir yapı dizisi oluşturun ve bu yapıya veri ekleme ve silme işlemlerini gerçekleştiren fonksiyonlar yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char isim[50];\n} Kisi;\n\nKisi* kisiEkle(Kisi* dizi, int *boyut, int id, char *isim) {\n    dizi = (Kisi *)realloc(dizi, (*boyut + 1) * sizeof(Kisi));\n    dizi[*boyut].id = id;\n    strcpy(dizi[*boyut].isim, isim);\n    (*boyut)++;\n    return dizi;\n}\n\nvoid kisiSil(Kisi* dizi, int *boyut, int id) {\n    for (int i = 0; i < *boyut; i++) {\n        if (dizi[i].id == id) {\n            for (int j = i; j < *boyut - 1; j++) {\n                dizi[j] = dizi[j + 1];\n            }\n            (*boyut)--;\n            dizi = (Kisi *)realloc(dizi, (*boyut) * sizeof(Kisi));\n            break;\n        }\n    }\n}\n\nint main() {\n    Kisi *dizi = NULL;\n    int boyut = 0;\n\n    dizi = kisiEkle(dizi, &boyut, 1, \"Ali\");\n    dizi = kisiEkle(dizi, &boyut, 2, \"Ayşe\");\n\n    printf(\"Kişiler:\n\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"ID: %d, İsim: %s\\n\", dizi[i].id, dizi[i].isim);\n    }\n\n    kisiSil(dizi, &boyut, 1);\n\n    printf(\"Silindikten sonra kişiler:\n\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"ID: %d, İsim: %s\\n\", dizi[i].id, dizi[i].isim);\n    }\n\n    free(dizi);\n    return 0;\n}\n``` Bu kod, dinamik olarak bir 'Kisi' yapısı dizisi oluşturur, eleman ekler ve siler. 'kisiEkle' ve 'kisiSil' fonksiyonları, dinamik bellek yönetimini etkin bir şekilde kullanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984145"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir bağlantılı liste oluşturun ve bu listeye eleman ekleme ve tüm elemanları görüntüleme işlemlerini gerçekleştirin.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int veri;\n    struct Node* sonraki;\n} Node;\n\nvoid elemanEkle(Node** bas, int veri) {\n    Node* yeniEleman = (Node*)malloc(sizeof(Node));\n    yeniEleman->veri = veri;\n    yeniEleman->sonraki = *bas;\n    *bas = yeniEleman;\n}\n\nvoid listeGoster(Node* bas) {\n    Node* temp = bas;\n    while (temp != NULL) {\n        printf(\"%d -> \", temp->veri);\n        temp = temp->sonraki;\n    }\n    printf(\"NULL\\n\");\n}\n\nvoid listeyiTemizle(Node* bas) {\n    Node* temp;\n    while (bas != NULL) {\n        temp = bas;\n        bas = bas->sonraki;\n        free(temp);\n    }\n}\n\nint main() {\n    Node* bas = NULL;\n    elemanEkle(&bas, 10);\n    elemanEkle(&bas, 20);\n    elemanEkle(&bas, 30);\n\n    printf(\"Bağlantılı Liste: \");\n    listeGoster(bas);\n\n    listeyiTemizle(bas); // Belleği serbest bırak\n    return 0;\n}\n``` Bu program, dinamik olarak bir bağlantılı liste oluşturur ve eleman ekler. 'listeyiTemizle' fonksiyonu ile bellek sızıntılarını önlemek için tüm liste elemanları serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984184"
  },
  {
    "question": "Dinamik bellek kullanarak bir yığın (stack) veri yapısı oluşturun ve bu yığın üzerinde push ve pop işlemleri gerçekleştirin.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Stack {\n    int *dizi;\n    int ust; \n    int boyut;\n} Stack;\n\nStack* stackOlustur(int boyut) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->boyut = boyut;\n    stack->ust = -1; // Boş yığın\n    stack->dizi = (int*)malloc(boyut * sizeof(int));\n    return stack;\n}\n\nint stackPush(Stack* stack, int veri) {\n    if (stack->ust < stack->boyut - 1) {\n        stack->dizi[++(stack->ust)] = veri;\n        return 1; // Başarılı\n    }\n    return 0; // Yığın dolu\n}\n\nint stackPop(Stack* stack) {\n    if (stack->ust >= 0) {\n        return stack->dizi[(stack->ust)--];\n    }\n    return -1; // Yığın boş\n}\n\nvoid stackTemizle(Stack* stack) {\n    free(stack->dizi);\n    free(stack);\n}\n\nint main() {\n    Stack* stack = stackOlustur(5);\n    stackPush(stack, 10);\n    stackPush(stack, 20);\n    stackPush(stack, 30);\n\n    printf(\"Pop edilen: %d\\n\", stackPop(stack));\n    printf(\"Pop edilen: %d\\n\", stackPop(stack));\n\n    stackTemizle(stack);\n    return 0;\n}\n``` Bu kod, dinamik bellek kullanarak bir yığın oluşturur ve üzerine eleman ekler ve çıkarır. 'stackTemizle' fonksiyonu ile bellek serbest bırakılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984220"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir ağaç (tree) veri yapısı oluşturun ve bu ağaçta eleman ekleme işlemini gerçekleştirin.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int veri;\n    struct Node* sol;\n    struct Node* sag;\n} Node;\n\nNode* yeniDugum(int veri) {\n    Node* dugum = (Node*)malloc(sizeof(Node));\n    dugum->veri = veri;\n    dugum->sol = dugum->sag = NULL;\n    return dugum;\n}\n\nNode* agacaEkle(Node* dugum, int veri) {\n    if (dugum == NULL) {\n        return yeniDugum(veri);\n    }\n    if (veri < dugum->veri) {\n        dugum->sol = agacaEkle(dugum->sol, veri);\n    } else {\n        dugum->sag = agacaEkle(dugum->sag, veri);\n    }\n    return dugum;\n}\n\nvoid inOrderYazdir(Node* dugum) {\n    if (dugum != NULL) {\n        inOrderYazdir(dugum->sol);\n        printf(\"%d \", dugum->veri);\n        inOrderYazdir(dugum->sag);\n    }\n}\n\nvoid agaciTemizle(Node* dugum) {\n    if (dugum != NULL) {\n        agaciTemizle(dugum->sol);\n        agaciTemizle(dugum->sag);\n        free(dugum);\n    }\n}\n\nint main() {\n    Node* dugum = NULL;\n    dugum = agacaEkle(dugum, 50);\n    dugum = agacaEkle(dugum, 30);\n    dugum = agacaEkle(dugum, 70);\n    dugum = agacaEkle(dugum, 20);\n    dugum = agacaEkle(dugum, 40);\n\n    printf(\"Ağaç elemanları (In-Order): \");\n    inOrderYazdir(dugum);\n    printf(\"\\n\");\n\n    agaciTemizle(dugum);\n    return 0;\n}\n``` Bu kod, dinamik bellek kullanarak bir ikili ağaç oluşturur ve eleman ekleme işlemi gerçekleştirir. 'inOrderYazdir' fonksiyonu ağaç elemanlarını sıralı olarak yazdırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984254"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir metin dosyasını okuyup, bu dosyanın içeriğini dinamik olarak tahsis edilmiş bir diziye kaydeden bir program yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* dosyadanOku(const char* dosyaAdi) {\n    FILE *dosya = fopen(dosyaAdi, \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return NULL;\n    }\n\n    fseek(dosya, 0, SEEK_END);\n    long boyut = ftell(dosya);\n    fseek(dosya, 0, SEEK_SET);\n\n    char *icerik = (char *)malloc((boyut + 1) * sizeof(char));\n    fread(icerik, sizeof(char), boyut, dosya);\n    icerik[boyut] = '\\0';\n\n    fclose(dosya);\n    return icerik;\n}\n\nint main() {\n    char *icerik = dosyadanOku(\"metin.txt\"); // 'metin.txt' dosyasını okuyun\n    if (icerik != NULL) {\n        printf(\"Dosya içeriği:\n%s\", icerik);\n        free(icerik);\n    }\n    return 0;\n}\n``` Bu program, belirli bir metin dosyasını okuyarak içeriğini dinamik olarak tahsis edilmiş bir diziye kaydeder. Okunan içerik daha sonra ekrana yazdırılır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984293"
  },
  {
    "question": "Dinamik bellek yönetimi ile bir karakter dizisini ters çeviren bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* tersCevir(const char* str) {\n    int uzunluk = strlen(str);\n    char *ters = (char *)malloc((uzunluk + 1) * sizeof(char));\n    for (int i = 0; i < uzunluk; i++) {\n        ters[i] = str[uzunluk - 1 - i];\n    }\n    ters[uzunluk] = '\\0';\n    return ters;\n}\n\nint main() {\n    char *str = \"Merhaba Dünya\";\n    char *ters = tersCevir(str);\n    printf(\"Ters: %s\\n\", ters);\n    free(ters);\n    return 0;\n}\n``` Bu kod, verilen bir karakter dizisini dinamik olarak tahsis edilmiş bir diziye ters çevirir. 'tersCevir' fonksiyonu, dizinin her bir karakterini ters sırayla yerleştirir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984319"
  },
  {
    "question": "Dinamik bellek yönetimi kullanarak bir 'kuyruk' veri yapısı oluşturun ve bu yapıda eleman ekleme ve çıkarma işlemlerini gerçekleştirin.",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int veri;\n    struct Node* sonraki;\n} Node;\n\ntypedef struct Kuyruk {\n    Node* on;\n    Node* arka;\n} Kuyruk;\n\nKuyruk* kuyrukOlustur() {\n    Kuyruk* kuyruk = (Kuyruk*)malloc(sizeof(Kuyruk));\n    kuyruk->on = kuyruk->arka = NULL;\n    return kuyruk;\n}\n\nvoid kuyrukEkle(Kuyruk* kuyruk, int veri) {\n    Node* yeniDugum = (Node*)malloc(sizeof(Node));\n    yeniDugum->veri = veri;\n    yeniDugum->sonraki = NULL;\n    if (kuyruk->arka == NULL) {\n        kuyruk->on = kuyruk->arka = yeniDugum;\n    } else {\n        kuyruk->arka->sonraki = yeniDugum;\n        kuyruk->arka = yeniDugum;\n    }\n}\n\nint kuyrukCikar(Kuyruk* kuyruk) {\n    if (kuyruk->on == NULL) {\n        return -1; // Kuyruk boş\n    }\n    Node* temp = kuyruk->on;\n    int veri = temp->veri;\n    kuyruk->on = kuyruk->on->sonraki;\n    free(temp);\n    return veri;\n}\n\nvoid kuyruguTemizle(Kuyruk* kuyruk) {\n    while (kuyruk->on != NULL) {\n        kuyrukCikar(kuyruk);\n    }\n    free(kuyruk);\n}\n\nint main() {\n    Kuyruk* kuyruk = kuyrukOlustur();\n    kuyrukEkle(kuyruk, 1);\n    kuyrukEkle(kuyruk, 2);\n    kuyrukEkle(kuyruk, 3);\n\n    printf(\"Çıkarılan: %d\\n\", kuyrukCikar(kuyruk));\n    printf(\"Çıkarılan: %d\\n\", kuyrukCikar(kuyruk));\n\n    kuyruguTemizle(kuyruk);\n    return 0;\n}\n``` Bu program, dinamik bellek kullanarak bir kuyruk oluşturur, eleman ekler ve çıkarır. 'kuyruguTemizle' fonksiyonu kuyruk üzerindeki tüm elemanları serbest bırakır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:32.984355"
  },
  {
    "question": "Dinamik bellek tahsisi için malloc yerine calloc kullanmanın avantajları nelerdir?",
    "answer": "calloc, belleği tahsis ederken aynı zamanda bellek alanını sıfırlar. Eğer tamsayı dizisi gibi önceden tanımlı bir veri yapısı kullanıyorsanız, bu sıfırlama işlemi önemli olabilir. malloc kullanırken, tahsis edilen bellek içeriği belirsiz olabilir, bu da hatalara yol açabilir. Örneğin:\n\n```c\nint *array = (int *)calloc(n, sizeof(int)); // Belleği tahsis eder ve sıfırlar\n```\n\nBunun yerine malloc kullanırsanız:\n```c\nint *array = (int *)malloc(n * sizeof(int)); // Belleği tahsis eder ama sıfırlamaz\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.614996"
  },
  {
    "question": "Bir diziye dinamik olarak bellek tahsis ettiğinizde, bellek sızıntısını önlemek için nelere dikkat etmelisiniz?",
    "answer": "Dinamik bellek tahsisi yaptığınızda, tahsis edilen bellek alanını serbest bırakmayı unutmamalısınız. Aksi takdirde, bellek sızıntısına neden olursunuz. Tahsis edilen belleği kullanmayı bitirdikten sonra, free() fonksiyonunu çağırarak belleği serbest bırakmalısınız. Örneğin:\n\n```c\nint *array = (int *)malloc(n * sizeof(int));\n// Belleği kullan\nfree(array); // Belleği serbest bırak\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615044"
  },
  {
    "question": "Dinamik bellek tahsisinde, NULL kontrolü neden önemlidir?",
    "answer": "NULL kontrolü, bellek tahsisinin başarılı olup olmadığını kontrol etmenizi sağlar. Eğer malloc veya calloc fonksiyonu bellek tahsisi yapamazsa, NULL döner. Bu durumda, NULL kontrolü yapmazsanız, programınız bellek erişim hatasıyla çökebilir. Örneğin:\n\n```c\nint *ptr = (int *)malloc(size);\nif (ptr == NULL) {\n    fprintf(stderr, \"Bellek tahsisi başarısız!\");\n    exit(1);\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615070"
  },
  {
    "question": "Dinamik bellek yönetiminde, bir veri yapısının boyutunu nasıl güncelleyebilirsiniz?",
    "answer": "Bir veri yapısının boyutunu güncellemek için, yeni boyut için yeni bir bellek alanı tahsis edip, mevcut verileri bu alana kopyalamanız gerekir. Örneğin, bir dizi boyutunu artırmak istiyorsanız:\n\n```c\nint *new_array = (int *)realloc(old_array, new_size * sizeof(int));\nif (new_array == NULL) {\n    // Hata durumu\n}\nold_array = new_array; // Eski gösterici güncelle\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615098"
  },
  {
    "question": "Çok boyutlu diziler için dinamik bellek tahsisi nasıl yapılır?",
    "answer": "Çok boyutlu diziler için dinamik bellek tahsisi, genellikle dizi işaretçileri kullanarak yapılır. İlk olarak, birinci boyut için bellek tahsis edilir, ardından her bir elemanı için ikinci boyut için bellek tahsis edilir. Örneğin:\n\n```c\nint **array = (int **)malloc(rows * sizeof(int *));\nfor (int i = 0; i < rows; i++) {\n    array[i] = (int *)malloc(cols * sizeof(int));\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615138"
  },
  {
    "question": "Dinamik bellek tahsisinde double free hatası nedir ve nasıl önlenir?",
    "answer": "Double free hatası, aynı belleği birden fazla kez serbest bırakmaya çalıştığınızda meydana gelir. Bu durum, programınızın çökmesine neden olabilir. Bunun önlenmesi için, belleği serbest bıraktıktan sonra işaretçiyi NULL yapmalısınız. Örneğin:\n\n```c\nfree(ptr);\nptr = NULL; // İşaretçiyi NULL yap\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615173"
  },
  {
    "question": "Bellek sızıntısını tespit etmek için hangi araçları kullanabilirsiniz?",
    "answer": "Bellek sızıntılarını tespit etmek için çeşitli araçlar bulunmaktadır. En yaygın olanları Valgrind ve AddressSanitizer'dır. Valgrind ile programınızı çalıştırarak sızıntıları görebilir ve hangi satırlarda sızıntı olduğunu tespit edebilirsiniz. Örneğin:\n\n```bash\nvalgrind --leak-check=full ./your_program\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615200"
  },
  {
    "question": "Dinamik bellek tahsisinde bir dizi elemanlarına erişim nasıl optimize edilebilir?",
    "answer": "Dizinin elemanlarına erişimi optimize etmek için, bellek erişimini azaltmak amacıyla, diziyi tek bir tahsis alanı olarak oluşturabilir ve elemanlara indekslerle erişim sağlayabilirsiniz. Bunun dışında, belleği sıralı bir şekilde tahsis etmek, önbellek yerleşimini iyileştirebilir:\n\n```c\nint *array = (int *)malloc(rows * cols * sizeof(int));\nfor (int i = 0; i < rows; i++) {\n    for (int j = 0; j < cols; j++) {\n        array[i * cols + j]; // Erişim\n    }\n}\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615224"
  },
  {
    "question": "Bir yapı için dinamik bellek tahsisi yaparken dikkat edilmesi gereken hususlar nelerdir?",
    "answer": "Bir yapı için dinamik bellek tahsis ederken, yapının tüm elemanlarını doğru şekilde tahsis ettiğinizden emin olmalısınız. Ayrıca, yapının içindeki dinamik olarak tahsis edilen bellek alanlarını da serbest bırakmayı unutmayın. Örneğin:\n\n```c\ntypedef struct {\n    int *data;\n    int size;\n} MyStruct;\n\nMyStruct *s = (MyStruct *)malloc(sizeof(MyStruct));\ns->data = (int *)malloc(s->size * sizeof(int));\n\n// İşlemler\n\nfree(s->data);\nfree(s);\n```",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:37:52.615249"
  },
  {
    "question": "Bir dinamik dizi oluştururken 'malloc' ve 'realloc' kullanımını optimize etmek için hangi stratejileri uygulayabilirim?",
    "answer": "Dizi boyutunu belirlerken, başlangıçta tahmini bir boyut kullanmak ve gerektiğinde 'realloc' ile boyutu artırmak etkili bir yaklaşımdır. Ancak, 'realloc' çağrısı sırasında yeni bellek alanı tahsis edilmesi gerektiği için, sık sık çağrılmamalıdır. Bunun yerine, boyut artışını bir faktör (örneğin, 2 katına çıkarma) ile gerçekleştirmek, bellek yönetiminde performansı artırır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.797884"
  },
  {
    "question": "Dinamik bellekte sızıntıları önlemek için hangi kontrolleri yapmalıyım?",
    "answer": "Dinamik bellek tahsisinden sonra her zaman 'free' fonksiyonunu çağırarak bellek sızıntılarını önleyebilirsiniz. Ayrıca, 'malloc' veya 'calloc' çağrısının sonucunu kontrol ederek NULL döndürme durumuna karşı önlem almanız önemlidir. Programın her yerinde kullandığınız belleklerin işaretçilerini NULL yapmak da, yanlışlıkla iki kez 'free' etmeyi önler.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.797943"
  },
  {
    "question": "Çok boyutlu dinamik diziler oluştururken dikkat etmem gereken en önemli noktalar nelerdir?",
    "answer": "Çok boyutlu diziler için her boyut için ayrı bir bellek tahsisi yapmalısınız. Örneğin, bir 2D dizi için her satır için ayrı bir dizi tahsis edip, bu dizilerin işaretçilerini ana diziye atamalısınız. Bu yaklaşım, her bir satırın farklı boyutlarda olmasına olanak tanır. Ayrıca, tüm belleği serbest bırakmadan önce her satırı ayrı ayrı 'free' etmeyi unutmayın.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.797993"
  },
  {
    "question": "Dinamik bellek yönetimi ile ilgili bir yapının performansını artırmak için ne tür veri yapıları kullanmalıyım?",
    "answer": "Dinamik bellek yönetimi için en iyi performansı sağlamak adına, bağlı listeler veya ağaç yapıları gibi dinamik veri yapıları kullanabilirsiniz. Bu yapılar, bellek tahsisi ve serbest bırakma işlemlerini daha verimli hale getirir. Özellikle, bağlantılı listelerde her eleman için ayrı bir bellek tahsisi yapılarak, gerektiğinde yalnızca belirli bir parçanın serbest bırakılması sağlanır.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798047"
  },
  {
    "question": "Dinamik bellek tahsisinde kötü bellek yönetiminin sonuçları nelerdir?",
    "answer": "Kötü bellek yönetimi, bellek sızıntılarına, bellek aşımı hatalarına ve programın çökmesine neden olabilir. Bellek sızıntıları, kullanılmayan bellek alanlarının serbest bırakılmamasıyla sonuçlanır; bu da sistemin belleğini yavaşça tüketir. Bellek aşımı ise, bir bellek bloğunun sınırlarını aşarak diğer verilere zarar vermek anlamına gelir ve genellikle tanımsız davranışlara yol açar.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798084"
  },
  {
    "question": "Birden fazla thread'in dinamik bellek üzerinde güvenli bir şekilde erişimini nasıl sağlayabilirim?",
    "answer": "Birden fazla thread'in dinamik bellek alanına erişimi sırasında 'mutex' veya 'semaphores' gibi eşzamanlama mekanizmaları kullanmalısınız. Bu sayede, aynı anda birden fazla thread'in bellek alanına erişimini kontrol altında tutarak yarış koşullarını önleyebilirsiniz. Ayrıca, bellek tahsisi işlemlerini thread-safe hale getirmek için uygun kütüphaneler veya fonksiyonlar kullanın.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798141"
  },
  {
    "question": "Bellek tahsisi sırasında oluşabilecek hataları nasıl ele alabilirim?",
    "answer": "Bellek tahsis işlemlerinde, her 'malloc', 'calloc' veya 'realloc' çağrısından sonra dönen işaretçinin NULL olup olmadığını kontrol etmelisiniz. Eğer NULL ise, uygun bir hata mesajı vererek programın bu durumu yönetmesine olanak tanıyabilirsiniz. Ayrıca, dinamik bellek hatası durumunda programın nasıl kurtulacağına dair bir strateji geliştirmeniz önemlidir.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798180"
  },
  {
    "question": "Dinamik bellek yönetimi sırasında hangi durumlarda 'free' fonksiyonunu çağırmalıyım?",
    "answer": "Dinamik olarak tahsis edilen her bellek alanı için, artık kullanılmadığı anında veya programın sona ermesi sırasında 'free' fonksiyonunu çağırmalısınız. Özellikle, döngülerde veya fonksiyonlar arasında dinamik bellek tahsisi yapıyorsanız, bellek alanını serbest bırakmayı unutmamak çok önemlidir. Ayrıca, bellek alanına olan erişimin sona erdiği durumlarda 'free' çağrısını gerçekleştirerek bellek sızıntılarını önleyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798230"
  },
  {
    "question": "Dinamik bellek kullanarak büyük veri setleri ile çalışırken nelere dikkat etmeliyim?",
    "answer": "Büyük veri setleri ile çalışırken bellek yönetimi oldukça kritik hale gelir. İlk olarak, bellek tahsis işlemlerini mümkün olduğunca az sayıda yapmalısınız; bu nedenle verileri kümeler halinde yükleyip işlemek daha verimli olabilir. Ek olarak, veri setini işlemek için uygun algoritmaları seçmek ve bellek kullanımını optimize etmek önemlidir. Gerektiğinde 'mmap' gibi sistem çağrılarını da değerlendirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798278"
  },
  {
    "question": "Dinamik bellek alanının daima temiz kalmasını sağlamak için hangi teknikleri kullanmalıyım?",
    "answer": "Dinamik bellek alanını temiz tutmak için, bellek tahsis ettiğiniz her alan için bir temizleme fonksiyonu yazabilirsiniz. Bu fonksiyon, belleğin serbest bırakılmasını ve ilgili işaretçilerin NULL yapılmasını sağlar. Ayrıca, bellek sızıntılarını kontrol etmek için bir bellek analiz aracı kullanabilir ve düzenli olarak kodunuzu gözden geçirerek potansiyel sorunları tespit edebilirsiniz.",
    "category": "pointers_memory",
    "topic": "dynamic_memory",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dinamik bellek yönetimi",
    "timestamp": "2025-06-01T15:38:26.798322"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan yeri tamamlayın: int arr[5] = {1, 2, 3, 4, 5}; int *ptr = arr; printf(\"%d\", *(ptr + __));",
    "answer": "Eksik olan yer '2' olmalı. Kodun tamamı şöyle olmalı: int arr[5] = {1, 2, 3, 4, 5}; int *ptr = arr; printf(\"%d\", *(ptr + 2)); Bu kod, 'ptr' işaretçisini kullanarak arr dizisinin 3. elemanını (değeri 3) ekrana yazdırır. Pointer aritmetiği kullanarak dizinin elemanlarına ulaşabiliyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292034"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: char str[] = \"Merhaba\"; char *p = str; printf(\"%c\", __);",
    "answer": "Eksik olan yer '*(p + 3)' olmalı. Kodun tamamı: char str[] = \"Merhaba\"; char *p = str; printf(\"%c\", *(p + 3)); Bu kod, 'p' işaretçisinin gösterdiği yerden 3. indeksi alır ve 'h' karakterini yazdırır. Pointer aritmetiği, dizilerin elemanlarına erişim sağlamak için oldukça kullanışlıdır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292091"
  },
  {
    "question": "Aşağıdaki kodun tamamlanması için gereken eksik yeri yazın: float values[4] = {1.1, 2.2, 3.3, 4.4}; float *fp = values; printf(\"%.1f\", __);",
    "answer": "Eksik olan kısım '*(fp + 1)' olmalıdır. Kodun tamamı: float values[4] = {1.1, 2.2, 3.3, 4.4}; float *fp = values; printf(\"%.1f\", *(fp + 1)); Bu kod, 'fp' işaretçisinin 1. indeksten (2.2) değerini yazdırır. Pointer aritmetiği ile dizinin elemanlarına kolayca ulaşabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292149"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int numbers[3] = {10, 20, 30}; int *np = numbers; printf(\"%d\", *(np + __));",
    "answer": "Eksik olan yer '1' olmalıdır. Kodun tamamı: int numbers[3] = {10, 20, 30}; int *np = numbers; printf(\"%d\", *(np + 1)); Bu kod, dizinin 2. elemanını (20) yazdırır. Pointer aritmetiği ile dizinin elemanlarına erişim sağlamak mümkündür.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292194"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan yeri tamamlayın: double prices[5] = {10.5, 20.75, 30.0, 15.25, 5.0}; double *dp = prices; printf(\"%.2f\", *(dp + __));",
    "answer": "Eksik olan kısım '4' olmalıdır. Kodun tamamı: double prices[5] = {10.5, 20.75, 30.0, 15.25, 5.0}; double *dp = prices; printf(\"%.2f\", *(dp + 4)); Bu kod, dizinin 5. elemanını (5.0) yazdırır. Pointer aritmetiği, dizideki elemanlara ulaşmak için etkili bir yöntemdir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292249"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int array[6] = {1, 2, 3, 4, 5, 6}; int *ptr = array; printf(\"%d\", *(ptr + __));",
    "answer": "Eksik olan yer '3' olmalıdır. Kodun tamamı: int array[6] = {1, 2, 3, 4, 5, 6}; int *ptr = array; printf(\"%d\", *(ptr + 3)); Bu kod, dizinin 4. elemanını (4) yazdırır. Pointer aritmetiği, dizinin her elemanına kolay erişim sağlar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292297"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan yeri tamamlayın: char letters[4] = {'a', 'b', 'c', 'd'}; char *lp = letters; printf(\"%c\", *(lp + __));",
    "answer": "Eksik olan kısım '2' olmalıdır. Kodun tamamı: char letters[4] = {'a', 'b', 'c', 'd'}; char *lp = letters; printf(\"%c\", *(lp + 2)); Bu kod, dizinin 3. elemanını (c) yazdırır. Pointer aritmetiği, karakter dizileri üzerinde de etkili bir şekilde kullanılabilir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292348"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int arr[4] = {5, 10, 15, 20}; int *ptr = arr; printf(\"%d\", *(ptr + __));",
    "answer": "Eksik olan kısım '0' olmalıdır. Kodun tamamı: int arr[4] = {5, 10, 15, 20}; int *ptr = arr; printf(\"%d\", *(ptr + 0)); Bu kod, dizinin 1. elemanını (5) yazdırır. Pointer aritmetiği sayesinde dizinin ilk elemanına erişim sağlıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292392"
  },
  {
    "question": "Aşağıdaki kod parçasında eksik olan kısmı tamamlayın: float data[3] = {3.14, 2.71, 1.61}; float *dp = data; printf(\"%.2f\", *(dp + __));",
    "answer": "Eksik olan kısım '1' olmalıdır. Kodun tamamı: float data[3] = {3.14, 2.71, 1.61}; float *dp = data; printf(\"%.2f\", *(dp + 1)); Bu kod, dizinin 2. elemanını (2.71) yazdırır. Pointer aritmetiği ile dizideki elemanlara erişim sağlanabilir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292440"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int nums[5] = {100, 200, 300, 400, 500}; int *np = nums; printf(\"%d\", *(np + __));",
    "answer": "Eksik olan kısım '3' olmalıdır. Kodun tamamı: int nums[5] = {100, 200, 300, 400, 500}; int *np = nums; printf(\"%d\", *(np + 3)); Bu kod, dizinin 4. elemanını (400) yazdırır. Pointer aritmetiği ile dizinin belirli bir elemanına kolayca ulaşabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:38:49.292487"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını çiftlerini bulmak için bir fonksiyon yazın. Fonksiyon, dizinin ilk elemanını bir pointer ile almalı ve pointer aritmetiği kullanarak dizinin sonuna kadar gitmelidir.",
    "answer": "#include <stdio.h>\n\nvoid ciftleriBul(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            printf(\"%d \\n\", *(dizi + i));\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    ciftleriBul(dizi, boyut);\n    return 0;\n}\n\n// Açıklama: Bu kodda, 'ciftleriBul' fonksiyonu bir tamsayı dizisini pointer alarak elemanlarını kontrol eder. Pointer aritmetiği kullanarak dizideki her bir elemanı kontrol ediyor ve çift olanları yazdırıyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.261730"
  },
  {
    "question": "Bir karakter dizisindeki sesli harfleri sayan bir fonksiyon yazın. Bu fonksiyon, karakter dizisine pointer ile erişmeli ve aritmetik kullanarak sesli harfleri saymalıdır.",
    "answer": "#include <stdio.h>\n#include <stdbool.h>\n\nint sesliHarfSay(char *dizi) {\n    int sayac = 0;\n    while (*dizi != '\\0') {\n        if (*dizi == 'a' || *dizi == 'e' || *dizi == 'ı' || *dizi == 'i' || *dizi == 'o' || *dizi == 'ö' || *dizi == 'u' || *dizi == 'ü') {\n            sayac++;\n        }\n        dizi++;\n    }\n    return sayac;\n}\n\nint main() {\n    char dizi[] = \"Merhaba Dünya\";\n    int sayi = sesliHarfSay(dizi);\n    printf(\"Sesli harf sayısı: %d\\n\", sayi);\n    return 0;\n}\n\n// Açıklama: 'sesliHarfSay' fonksiyonu karakter dizisini pointer ile alır. Pointer aritmetiği kullanarak dizinin her karakterini kontrol eder ve sesli harfleri sayar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.261824"
  },
  {
    "question": "İki tamsayı dizisini toplayıp sonuçları başka bir diziye yazan bir fonksiyon yazın. Fonksiyon toplam işlemini pointer aritmetiği kullanarak yapmalıdır.",
    "answer": "#include <stdio.h>\n\nvoid diziTopla(int *dizi1, int *dizi2, int *sonuc, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        *(sonuc + i) = *(dizi1 + i) + *(dizi2 + i);\n    }\n}\n\nint main() {\n    int dizi1[] = {1, 2, 3};\n    int dizi2[] = {4, 5, 6};\n    int sonuc[3];\n    int boyut = sizeof(dizi1) / sizeof(dizi1[0]);\n    diziTopla(dizi1, dizi2, sonuc, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \\n\", sonuc[i]);\n    }\n    return 0;\n}\n\n// Açıklama: 'diziTopla' fonksiyonu iki tamsayı dizisini pointer ile alır ve aritmetik kullanarak elemanlarını toplar, sonuçları üçüncü bir dizide saklar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.261912"
  },
  {
    "question": "Bir tamsayı dizisinde en büyük elemanı bulan bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı ve pointer aritmetiği kullanarak en büyük değeri bulmalıdır.",
    "answer": "#include <stdio.h>\n\nint enBuyukBul(int *dizi, int boyut) {\n    int enBuyuk = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > enBuyuk) {\n            enBuyuk = *(dizi + i);\n        }\n    }\n    return enBuyuk;\n}\n\nint main() {\n    int dizi[] = {3, 5, 7, 2, 8};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int enBuyuk = enBuyukBul(dizi, boyut);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk);\n    return 0;\n}\n\n// Açıklama: 'enBuyukBul' fonksiyonu diziyi pointer ile alarak en büyük elemanı bulur. Pointer aritmetiği ile dizi elemanlarına ulaşılır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.261997"
  },
  {
    "question": "Bir dizideki negatif sayıları pozitif yapmak için bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı ve aritmetik kullanarak her elemanı kontrol etmelidir.",
    "answer": "#include <stdio.h>\n\nvoid negatifleriPozitifYap(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) < 0) {\n            *(dizi + i) = -*(dizi + i);\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {-1, 2, -3, 4, -5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    negatifleriPozitifYap(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \\n\", dizi[i]);\n    }\n    return 0;\n}\n\n// Açıklama: 'negatifleriPozitifYap' fonksiyonu diziyi pointer ile alarak negatif elemanları pozitif yapar. Pointer aritmetiği ile her eleman kontrol edilir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.262068"
  },
  {
    "question": "Bir dizideki tüm elemanların toplamını hesaplayan bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı ve aritmetik kullanarak toplamı bulmalıdır.",
    "answer": "#include <stdio.h>\n\nint toplamHesapla(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int toplam = toplamHesapla(dizi, boyut);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n// Açıklama: 'toplamHesapla' fonksiyonu diziyi pointer ile alır ve pointer aritmetiği ile tüm elemanların toplamını hesaplar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.262134"
  },
  {
    "question": "Bir dizideki elemanların ortalamasını hesaplayan bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı, toplamı bulmak için pointer aritmetiği kullanmalıdır.",
    "answer": "#include <stdio.h>\n\nfloat ortalamaHesapla(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    float ortalama = ortalamaHesapla(dizi, boyut);\n    printf(\"Ortalama: %.2f\\n\", ortalama);\n    return 0;\n}\n\n// Açıklama: 'ortalamaHesapla' fonksiyonu diziyi pointer ile alarak toplamı bulur ve ortalamayı hesaplar. Aritmetik kullanarak dizinin her elemanına ulaşılır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.262203"
  },
  {
    "question": "Bir dizideki elemanları tersine çeviren bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı ve pointer aritmetiği kullanarak elemanları yer değiştirerek tersine çevirmelidir.",
    "answer": "#include <stdio.h>\n\nvoid tersCevir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = *(dizi + i);\n        *(dizi + i) = *(dizi + (boyut - 1 - i));\n        *(dizi + (boyut - 1 - i)) = temp;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    tersCevir(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \\n\", dizi[i]);\n    }\n    return 0;\n}\n\n// Açıklama: 'tersCevir' fonksiyonu diziyi pointer ile alır ve pointer aritmetiği ile elemanları yer değiştirerek tersine çevirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.262279"
  },
  {
    "question": "Bir dizi içindeki en küçük tamsayıyı bulan bir fonksiyon yazın. Fonksiyon diziyi pointer ile almalı ve aritmetik kullanarak en küçük değeri bulmalıdır.",
    "answer": "#include <stdio.h>\n\nint enKucukBul(int *dizi, int boyut) {\n    int enKucuk = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) < enKucuk) {\n            enKucuk = *(dizi + i);\n        }\n    }\n    return enKucuk;\n}\n\nint main() {\n    int dizi[] = {3, 1, 4, 1, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int enKucuk = enKucukBul(dizi, boyut);\n    printf(\"En küçük eleman: %d\\n\", enKucuk);\n    return 0;\n}\n\n// Açıklama: 'enKucukBul' fonksiyonu diziyi pointer ile alarak en küçük elemanı bulur. Pointer aritmetiği ile dizi elemanlarına ulaşılır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:39:27.262348"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın ve açıklayın: \n\n#include <stdio.h>\n\nvoid main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n    // Buraya kod ekle\n    printf(\"Sonuç: %d\", *ptr);\n}",
    "answer": "Eksik kısımda, pointerın hangi elemana işaret edeceğini ayarlamak için aritmetik işlemler yapılabilir. Kod şu şekilde tamamlanabilir:\n\nptr += 2; // 3. elemana (30) işaret eder.\n\nSonuç olarak, eklediğimiz kod ile pointer, arr dizisinin üçüncü elemanına işaret eder ve bu yüzden çıktı 30 olacaktır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089058"
  },
  {
    "question": "Aşağıdaki kodda, kullanıcıdan bir dizi boyutu alarak dizinin elemanlarının toplamını bulan bir fonksiyon yazın. Kodun eksik kısmını tamamlayın: \n\n#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int dizi[n];\n    for(int i = 0; i < n; i++) {\n        printf(\"Dizi elemanını girin: \");\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Toplam: %d\", toplam(dizi, n));\n    return 0;\n}",
    "answer": "Eksik kısımda toplam fonksiyonunu yazmalıyız. Aşağıdaki gibi tamamlayabiliriz:\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return toplam;\n}\n\nBurada, pointer aritmetiği kullanılarak dizinin elemanlarına erişiyoruz. 'dizi + i' ifadesi, dizinin i. elemanına işaret eder.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089224"
  },
  {
    "question": "Aşağıdaki kodda bir diziyi tersine çeviren bir fonksiyon yazın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nvoid tersCevir(int *dizi, int boyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    tersCevir(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nvoid tersCevir(int *dizi, int boyut) {\n    for (int i = 0; i < boyut / 2; i++) {\n        int temp = *(dizi + i);\n        *(dizi + i) = *(dizi + (boyut - 1 - i));\n        *(dizi + (boyut - 1 - i)) = temp;\n    }\n}\n\nBurada, dizinin elemanlarını yer değiştiriyoruz. Pointer aritmetiği sayesinde dizinin ilk ve son elemanlarına erişiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089353"
  },
  {
    "question": "Aşağıdaki kodda iki diziyi birleştiren bir fonksiyon yazın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nvoid birleştir(int *dizi1, int boyut1, int *dizi2, int boyut2, int *sonuc) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int dizi1[] = {1, 2, 3};\n    int dizi2[] = {4, 5, 6};\n    int boyut1 = sizeof(dizi1) / sizeof(dizi1[0]);\n    int boyut2 = sizeof(dizi2) / sizeof(dizi2[0]);\n    int sonuc[boyut1 + boyut2];\n    birleştir(dizi1, boyut1, dizi2, boyut2, sonuc);\n    for (int i = 0; i < boyut1 + boyut2; i++) {\n        printf(\"%d \", sonuc[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nvoid birleştir(int *dizi1, int boyut1, int *dizi2, int boyut2, int *sonuc) {\n    for (int i = 0; i < boyut1; i++) {\n        *(sonuc + i) = *(dizi1 + i);\n    }\n    for (int i = 0; i < boyut2; i++) {\n        *(sonuc + (boyut1 + i)) = *(dizi2 + i);\n    }\n}\n\nBu kodda, iki dizinin elemanları, pointer aritmetiği kullanılarak sonuç dizisine kopyalanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089534"
  },
  {
    "question": "Aşağıdaki kodda bir dizinin en büyük elemanını bulan bir fonksiyon yazın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nint enBuyuk(int *dizi, int boyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int dizi[] = {3, 1, 4, 1, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\", enBuyuk(dizi, boyut));\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nint enBuyuk(int *dizi, int boyut) {\n    int max = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > max) {\n            max = *(dizi + i);\n        }\n    }\n    return max;\n}\n\nKodda, dizinin ilk elemanı ile başlayarak diğer elemanlar kontrol ediliyor ve en büyük değer bulunuyor. Pointer aritmetiği sayesinde dizinin her elemanına erişim sağlanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089638"
  },
  {
    "question": "Aşağıdaki kodda kullanıcıdan alınan bir dizinin elemanlarının ortalamasını hesaplayın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nfloat ortalama(int *dizi, int boyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int n;\n    printf(\"Dizi boyutunu girin: \");\n    scanf(\"%d\", &n);\n    int dizi[n];\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizi elemanını girin: \");\n        scanf(\"%d\", &dizi[i]);\n    }\n    printf(\"Ortalama: %.2f\", ortalama(dizi, n));\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nfloat ortalama(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return (float)toplam / boyut;\n}\n\nBurada, dizinin elemanlarının toplamı hesaplanıyor ve ardından ortalama bulunuyor. Pointer aritmetiği kullanılarak dizinin her elemanına erişim sağlanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089771"
  },
  {
    "question": "Aşağıdaki kodda, bir dizinin tüm elemanlarını çift veya tek olarak ayıran bir fonksiyon yazın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nvoid ayır(int *dizi, int boyut, int **ciftler, int *ciftBoyut, int **tekler, int *tekBoyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int *ciftler, *tekler;\n    int ciftBoyut = 0, tekBoyut = 0;\n    ayır(dizi, boyut, &ciftler, &ciftBoyut, &tekler, &tekBoyut);\n    // Çift ve tek dizilerini yazdır...\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nvoid ayır(int *dizi, int boyut, int **ciftler, int *ciftBoyut, int **tekler, int *tekBoyut) {\n    *ciftBoyut = 0;\n    *tekBoyut = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            (*ciftBoyut)++;\n        } else {\n            (*tekBoyut)++;\n        }\n    }\n    *ciftler = (int *)malloc(*ciftBoyut * sizeof(int));\n    *tekler = (int *)malloc(*tekBoyut * sizeof(int));\n\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            *(*ciftler + (*ciftBoyut - 1)) = *(dizi + i);\n            (*ciftBoyut)--;\n        } else {\n            *(*tekler + (*tekBoyut - 1)) = *(dizi + i);\n            (*tekBoyut)--;\n        }\n    }\n}\n\nBu kodda, verilen dizideki elemanlar çift ve tek olarak ayrılıyor. Pointer aritmetiği kullanarak dizilere elemanlar ekleniyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.089938"
  },
  {
    "question": "Aşağıdaki kodda, bir dizinin tüm pozitif elemanlarını bulan ve yeni bir diziye atan bir fonksiyon yazın. Eksik kısmı tamamlayın: \n\n#include <stdio.h>\n\nint *pozitifleriBul(int *dizi, int boyut, int *yeniBoyut) {\n    // Buraya kod ekle\n}\n\nint main() {\n    int dizi[] = {-1, 2, -3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int yeniBoyut;\n    int *pozitifler = pozitifleriBul(dizi, boyut, &yeniBoyut);\n    for (int i = 0; i < yeniBoyut; i++) {\n        printf(\"%d \", pozitifler[i]);\n    }\n    return 0;\n}",
    "answer": "Eksik kısmı aşağıdaki gibi tamamlayabiliriz:\n\nint *pozitifleriBul(int *dizi, int boyut, int *yeniBoyut) {\n    *yeniBoyut = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) > 0) {\n            (*yeniBoyut)++;\n        }\n    }\n    int *pozitifler = (int *)malloc(*yeniBoyut * sizeof(int));\n    int j = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) > 0) {\n            *(pozitifler + j) = *(dizi + i);\n            j++;\n        }\n    }\n    return pozitifler;\n}\n\nBu fonksiyon, negatif olmayan elemanları buluyor ve bunları yeni bir diziye atıyor. Pointer aritmetiği kullanarak dizinin elemanlarına erişim sağlanıyor.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:19.090084"
  },
  {
    "question": "Bir dizinin elemanlarını yazdırmak için aşağıdaki kodda sorun nedir? int arr[] = {1, 2, 3, 4, 5}; int *p = arr; for (int i = 0; i <= 5; i++) { printf(\"%d \", *(p + i)); }",
    "answer": "Kodda 'i <= 5' ifadesi hatalıdır. Dizinin boyutu 5 olduğu için, en son indeks 4'tür. Doğru koşul 'i < 5' olmalıdır. Aksi takdirde, dizinin sınırları dışına çıkarak bellek hatası alabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992150"
  },
  {
    "question": "Aşağıdaki kodda neden 'Segmentation fault' hatası alınıyor? int *ptr = NULL; *ptr = 10;",
    "answer": "Kodda 'ptr' işaretçisi NULL olarak tanımlanmıştır. NULL bir işaretçi olduğundan, üzerine değer atamaya çalışmak, geçersiz bellek alanına yazmaya çalışmak anlamına gelir. Bu nedenle 'Segmentation fault' hatası alırsınız. 'ptr' için geçerli bir bellek alanı ayırmalısınız.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992197"
  },
  {
    "question": "Aşağıdaki kodda dizinin elemanlarını tersine yazdırırken neden beklenen sonucu elde edemiyorum? int arr[] = {1, 2, 3, 4, 5}; int *p = arr; for (int i = 0; i < 5; i++) { printf(\"%d \", *(p + (5 - i))); }",
    "answer": "Kodda '*(p + (5 - i))' ifadesi hatalıdır. '5 - i' değeri 5 olduğunda, belirtilen dizinin sınırını aşar. Dizinin en son indeksi 4'tür. Doğru kullanım '*(p + (4 - i))' olmalıdır, böylece elemanları doğru bir şekilde tersine yazdırabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992261"
  },
  {
    "question": "Aşağıdaki kodda hangi hata var? char str[] = \"Hello\"; char *p = str; p[6] = 'A';",
    "answer": "Dizinin boyutu 6'dır (5 karakter + 1 null sonlandırıcı). Ancak, dizinin 6. indeksi (p[6]) geçersizdir. Bu, bellek hatasına neden olabilir. Dizi boyutunun sınırlarını aşmamaya dikkat edin.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992293"
  },
  {
    "question": "Aşağıdaki kodda neden 'undefined behavior' var? int a = 5; int *p = &a; printf(\"%d\", *(p + 1));",
    "answer": "Kodda '*(p + 1)' ifadesi belirsiz bir bellek alanına erişmeye çalışır. 'p' işaretçisi 'a' değişkenini gösterirken, 'p + 1' ifadesi geçersiz bir alana işaret eder. Geçersiz bellek erişimi 'undefined behavior' ile sonuçlanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992329"
  },
  {
    "question": "Aşağıdaki kodda hangi hata var? int arr[3] = {1, 2, 3}; int *p = arr; for (int i = 0; i <= 3; i++) { p[i] = i * 2; }",
    "answer": "Kodda 'i <= 3' ifadesi hatalıdır. Dizinin eleman sayısı 3 olduğundan, geçerli indeksler 0'dan 2'ye kadardır. 'i < 3' kullanmalısınız. Aksi takdirde, dizinin sınırları dışına çıkarsınız.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992374"
  },
  {
    "question": "Aşağıdaki kodda neden doğru çalışmıyor? double arr[2] = {1.1, 2.2}; double *p = arr; for (int i = 0; i < 2; i++) { printf(\"%.1f \", *(p + i)); }",
    "answer": "Kod doğru çalışıyor, ancak dizinin boyutunu kontrol etmek ve erişim sınırlarını kontrol etmek önemlidir. Eğer dizinin boyutu ve döngü sayısı eşleşmezse, geçersiz bellek erişimi riski vardır. Bu durumda kod hatasızdır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992426"
  },
  {
    "question": "Aşağıdaki kodda neden 'memory leak' oluşuyor? int *ptr = malloc(sizeof(int)); ptr = NULL;",
    "answer": "Kodda 'malloc' ile ayrılan bellek, 'ptr = NULL' ataması ile kaybolur. Bu bellek artık erişilebilir olmadığından, bellek sızıntısı (memory leak) oluşur. Belleği kullanmadan önce, kullanılacak olan alanın kaybolmadığından emin olun.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992463"
  },
  {
    "question": "Aşağıdaki kodda neden istenmeyen bir sonuç alıyorum? int arr[5] = {0}; int *p = arr; for (int i = 0; i < 5; i++) { *(p + i) += i; } printf(\"%d\", arr[5]);",
    "answer": "Kodda 'arr[5]' ifadesi geçersizdir, çünkü dizinin son indeksi 4'tür. Bu durum bellek erişim hatasına neden olabilir. Sonuç olarak, dizinin son elemanına erişmeye çalışmak yerine geçerli bir indeksteki değeri yazdırmalısınız.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992530"
  },
  {
    "question": "Aşağıdaki kodda hangi hata var? int a = 10; int *p = &a; *p += 1; printf(\"%d\", p);",
    "answer": "Kodda 'printf(\"%d\", p);' ifadesi hatalıdır. 'p' bir işaretçi değişkenidir ve doğrudan yazdırmak için '%d' formatı kullanmak uygun değildir. Bunun yerine '%p' formatı kullanılmalıdır. Yani, 'printf(\"%p\", (void *)p);' şeklinde olmalıdır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:40:44.992564"
  },
  {
    "question": "Bir int dizisi tanımlandı ve ardından bir işlevde bu dizinin elemanlarına erişim sağlanmaya çalışıldı. Ancak işlev içinde dizinin elemanlarına işaretçi ile erişirken 'segmentation fault' hatası alıyorum. Neden olabilir?",
    "answer": "Bu hata, dizinin işaretçisinin doğru bir şekilde tanımlanmamış olmasından kaynaklanıyor olabilir. Dizi işaretçisi işlev içinde uygun bir şekilde geçilmediyse veya dizinin elemanlarına erişim için işaretçi aritmetiği hatalı kullanıldıysa bu hatayı alırsınız. Dizi işaretçisini şu şekilde doğru bir şekilde geçirin:\n\n```c\nvoid fonksiyon(int *dizi) {\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n}\n\nint main() {\n    int dizi[5] = {1, 2, 3, 4, 5};\n    fonksiyon(dizi);\n    return 0;\n}\n```\nBurada dizinin başlangıç adresini işleve geçiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.259793"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir char dizisini ters çevirmeye çalışıyorum, fakat sonuç beklediğim gibi çıkmıyor. Hata nerede?",
    "answer": "Muhtemelen dizinin başlangıç adresini yanlış kullanıyorsunuz. Diziye erişirken başlangıç adresini almayı unutmuş olabilirsiniz. Dizi işaretçisini kullanarak şu şekilde ters çevirebilirsiniz:\n\n```c\nvoid tersCevir(char *dizi, int uzunluk) {\n    char *baslangic = dizi;\n    char *son = dizi + uzunluk - 1;\n    while (baslangic < son) {\n        char temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n\nint main() {\n    char dizi[] = \"merhaba\";\n    tersCevir(dizi, strlen(dizi));\n    printf(\"Ters: %s\", dizi);\n    return 0;\n}\n```\nBurada dizinin başlangıç ve son noktalarını doğru bir şekilde tanımlıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.259846"
  },
  {
    "question": "Dizinin sonuna yeni bir eleman eklemek istiyorum ama işaretçi aritmetiği ile bunu yaparken 'array index out of bounds' hatası alıyorum. Nasıl düzeltebilirim?",
    "answer": "Eğer dizi boyutunu aşmaya çalışıyorsanız bu hatayı alırsınız. Dinamik olarak bir dizi tanımlayıp gerektiği kadar bellek ayırmalısınız. Örneğin:\n\n```c\nint *dizi = malloc(5 * sizeof(int));\nif (dizi == NULL) { exit(1); }\nfor (int i = 0; i < 5; i++) {\n    dizi[i] = i;\n}\n\n// Yeni bir eleman eklemek için yeniden boyutlandırmalısınız\nint *yeniDizi = realloc(dizi, 6 * sizeof(int));\nif (yeniDizi == NULL) { free(dizi); exit(1); }\n// Yeni elemanı ekle\nnewDizi[5] = 10;\n```\nBu şekilde dinamik bellek yönetimi ile diziyi genişletebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.259894"
  },
  {
    "question": "Bir iki boyutlu dizi tanımladım ve satırları işaretçi aritmetiğiyle dolaşmaya çalışıyorum ama sonuçlar beklediğim gibi değil. Hata nerede?",
    "answer": "İki boyutlu diziler genellikle diziler içerisindeki diziler şeklinde tanımlanır. Pointer aritmetiği kullanırken her satırın boyutunu dikkate almanız gerekiyor. Örneğin:\n\n```c\nint dizi[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nint *p = &dizi[0][0];\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        printf(\"%d \", *(p + (i * 3) + j));\n    }\n}\n```\nBurada her satır için 3 eleman olduğuna dikkat etmelisiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.259943"
  },
  {
    "question": "Bir float dizisini işaretçi aritmetiği ile sumlamak istiyorum ama sonuç her zaman 0 çıkıyor. Hata ne olabilir?",
    "answer": "Muhtemelen toplam işlemini yaparken işaretçiyi doğru bir şekilde güncellemiyorsunuz. İşaretçiyi her döngüde artırmayı unutmamalısınız. Aşağıdaki gibi bir örnek inceleyin:\n\n```c\nfloat dizi[] = {1.5, 2.5, 3.5};\nfloat toplam = 0;\nfloat *p = dizi;\nfor (int i = 0; i < 3; i++) {\n    toplam += *(p + i);\n}\nprintf(\"Toplam: %f\", toplam);\n```\nBu şekilde işaretçiyi düzgün bir şekilde kullanarak doğru toplamı almış olursunuz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.259976"
  },
  {
    "question": "Bir stringi işaretçi ile kullanarak karakterlerini değiştirmeye çalışıyorum ama değişiklikler 'undefined behavior' yaratıyor. Neden?",
    "answer": "Eğer string sabit bir dizide tanımlanmışsa, onu değiştirmeye çalışmak 'undefined behavior' yaratır. `const` anahtar kelimesi kullanarak bu durumu engelleyebilirsiniz. Örneğin:\n\n```c\nconst char *str = \"merhaba\";\nchar *mutableStr = malloc(strlen(str) + 1);\nstrcpy(mutableStr, str);\nmutableStr[0] = 'M';\nprintf(\"Değiştirilmiş: %s\", mutableStr);\nfree(mutableStr);\n```\nBu şekilde değişiklik yapabileceğiniz bir dizi tanımlamış olursunuz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.260011"
  },
  {
    "question": "Bir tamsayı dizisi üzerinde pointer aritmetiği kullanarak elemanları sıralamak istiyorum ama sonuçlar beklemediğim gibi çıkıyor. Hata nerede?",
    "answer": "Sıralama algoritmasında işaretçi aritmetiğini doğru kullanmıyorsanız, yanlış elemanlar ile karşılaştırma yapıyor olabilirsiniz. Örnek olarak:\n\n```c\nvoid sirala(int *dizi, int uzunluk) {\n    for (int i = 0; i < uzunluk - 1; i++) {\n        for (int j = 0; j < uzunluk - i - 1; j++) {\n            if (*(dizi + j) > *(dizi + j + 1)) {\n                int temp = *(dizi + j);\n                *(dizi + j) = *(dizi + j + 1);\n                *(dizi + j + 1) = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 1, 4, 2, 8};\n    sirala(dizi, 5);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBurada işaretçi ile doğru karşılaştırma yaparak sıralama işlemini gerçekleştirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.260047"
  },
  {
    "question": "Bir işlevde işaretçi ile döngü kullanarak dizinin elemanlarını değiştirmeye çalışıyorum ama değişiklikler ana dizide yansımıyor. Neden?",
    "answer": "Eğer işlevde diziyi sadece işaretçi olarak geçiyorsanız, ama işlevde değişiklik yaparken yeni bir işaretçi tanımlıyorsanız, bu ana diziyi etkilemez. Orijinal işaretçiyi kullanmalısınız. Örneğin:\n\n```c\nvoid degistir(int *dizi, int uzunluk) {\n    for (int i = 0; i < uzunluk; i++) {\n        *(dizi + i) += 1;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3};\n    degistir(dizi, 3);\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu şekilde ana diziyi doğrudan etkileyebilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.260082"
  },
  {
    "question": "Bir struct dizisi tanımlayıp işaretçiler ile elemanlarına erişmeye çalışırken beklenmedik sonuçlar alıyorum. Hata nerede?",
    "answer": "Struct'ların boyutları, içerdikleri elemanların boyutlarına bağlıdır. İşaretçi aritmetiğini kullanırken struct boyutunu göz önünde bulundurmalısınız. Örneğin:\n\n```c\ntypedef struct {\n    int id;\n    char isim[20];\n} Kisi;\n\nKisi dizi[3] = {{1, \"Ali\"}, {2, \"Ayşe\"}, {3, \"Mehmet\"}};\nKisi *p = dizi;\nfor (int i = 0; i < 3; i++) {\n    printf(\"ID: %d, İsim: %s\\n\", (p + i)->id, (p + i)->isim);\n}\n```\nBurada struct'ların boyutunu doğru kullanarak işaretçi aritmetiği ile elemanlara erişim sağlayabilirsiniz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:12.260113"
  },
  {
    "question": "Aşağıdaki kodda, dizinin elemanlarına erişim sağlamakta bir hata var. Hatanın nerede olduğunu bul ve düzelt. Kod: int arr[5] = {0, 1, 2, 3, 4}; int *ptr = arr; printf('%d', *(ptr + 5));",
    "answer": "Hata, ptr + 5 ifadesinin dizinin sınırlarını aşmasından kaynaklanıyor. Çünkü arr dizisi 0'dan 4'e kadar olan indekslere sahip. Düzeltme için, printf('%d', *(ptr + 4)); şeklinde değiştirilmeli. Bu, son elemanı doğru şekilde yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.166784"
  },
  {
    "question": "Aşağıdaki kodda, iki farklı dizinin elemanlarını toplamak için pointer aritmetiği kullanılıyor. Ancak sonuç her zaman beklenenden küçük çıkıyor. Hatanın kaynağını bul ve düzelt. Kod: int arr1[3] = {1, 2, 3}; int arr2[3] = {4, 5, 6}; int *p1 = arr1; int *p2 = arr2; int sum = 0; for(int i = 0; i < 3; i++) { sum += *(p1 + i) + *(p2 + i); } printf('%d', sum);",
    "answer": "Kod doğru bir şekilde dizileri topluyor ancak toplamı iki dizinin toplamına eşit olarak çıkıyor. Toplamın iki katı çıkıyor. Düzeltmek için, sum değişkenini iki dizi için ayrı ayrı toplamamız gerekiyor. Yani sum += *(p1 + i); ve sum += *(p2 + i); şeklinde düzenlemek gerekecek.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.166912"
  },
  {
    "question": "Aşağıdaki kodda bir dizi üzerinde pointer ile geziniliyor, fakat program beklenmedik bir şekilde çalışıyor. Hatanın nerede olduğunu bul. Kod: int arr[4] = {10, 20, 30, 40}; int *ptr = arr; for(int i = 0; i <= 4; i++) { printf('%d', *(ptr + i)); }",
    "answer": "Hata, döngü koşulunun 'i <= 4' olmasından kaynaklanıyor. Bu, dizinin sınırlarını aşarak bellek hatasına yol açıyor. Düzeltmek için, döngü koşulunu 'i < 4' şeklinde değiştirmek gerekli.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.166987"
  },
  {
    "question": "Aşağıdaki kodda bellek yönetimi ile ilgili bir hata var. Hatanın nerede olduğunu bul ve düzelt. Kod: int *ptr = malloc(10 * sizeof(int)); for(int i = 0; i < 10; i++) { ptr[i] = i; } free(ptr); printf('%d', ptr[0]);",
    "answer": "Hata, ptr ile işaret edilen belleğin serbest bırakıldıktan sonra erişilmeye çalışılmasıdır. 'free(ptr);' çağrısından sonra ptr artık geçersiz bir gösterici. Düzeltmek için, printf çağrısını 'free' öncesine almak veya ptr'yi null yaparak erişmeye çalışmak daha güvenli.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167053"
  },
  {
    "question": "Aşağıdaki kodda bir dizi elemanını bir pointer aracılığıyla değiştirmeye çalışıyoruz, ancak beklenmedik sonuçlar alıyoruz. Hatanın kaynağını bul ve düzelt. Kod: void updateValue(int *p) { *p = 20; } int main() { int x = 10; updateValue(&x); printf('%d', x); }",
    "answer": "Kod doğru çalışmakta ancak herhangi bir hata yok. 'updateValue' fonksiyonu, x değişkeninin değerini 20 yapıyor. 'printf' doğru şekilde x'in 20 olarak yazdırılmasını sağlamalı. Ancak, eğer amaç x değerini değiştirmekse, her şey doğru.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167129"
  },
  {
    "question": "Aşağıdaki kodda, pointer aritmetiği ile bir dizi elemanını tersine çevirmek için bir fonksiyon yazılmış. Ancak sonuç beklenmedik. Hatanın nerede olduğunu bul ve düzelt. Kod: void reverseArray(int *arr, int size) { for(int i = 0; i < size / 2; i++) { int temp = *(arr + i); *(arr + i) = *(arr + size - i); *(arr + size - i) = temp; } }",
    "answer": "Hata, '*(arr + size - i)' ifadesinde 'size - i' yerine 'size - i - 1' kullanılmaması. Bu, dizinin son elemanını yazdırmak yerine dizinin boyutunu aşarak bellek hatasına yol açacaktır. Düzeltmek için, '*(arr + size - i - 1)' kullanılmalıdır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167226"
  },
  {
    "question": "Aşağıdaki kodda pointer ile gösterilen dizinin elemanları doğru bir şekilde yazdırılmıyor. Hatanın kaynağını bul ve düzelt. Kod: int arr[5] = {5, 10, 15, 20, 25}; int *p = arr; for(int i = 0; i < 5; i++) { printf('%d ', *(p + i + 1)); }",
    "answer": "Hata, '*(p + i + 1)' ifadesinin ilk elemanı atlayarak yazdırmasından kaynaklanıyor. Düzeltmek için '*(p + i)' olarak değiştirilmeli. Bu, dizinin her bir elemanını doğru sıralamada yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167298"
  },
  {
    "question": "Aşağıdaki kodda, bir dizinin son elemanına ulaşmaya çalışıyoruz fakat yanlış değer alıyoruz. Hatanın nerede olduğunu bul ve düzelt. Kod: int arr[4] = {2, 4, 6, 8}; int *ptr = arr; printf('%d', *(ptr + 4));",
    "answer": "Hata, dizinin boyutunun 4 olduğu ama son elemanının 3. indekste (0'dan başlandığı için) bulunmasından kaynaklanıyor. Düzeltmek için, printf('%d', *(ptr + 3)); şeklinde değiştirmek gerekecek.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167359"
  },
  {
    "question": "Aşağıdaki kodda, bir dizi üzerinde döngü ile ilerleniyor ama bir hata var. Hatanın nerede olduğunu bul ve düzelt. Kod: int arr[5] = {1, 2, 3, 4, 5}; int *p = arr; for(int i = 0; i < 6; i++) { printf('%d ', *(p + i)); }",
    "answer": "Hata, döngü koşulunun 6 olmasından kaynaklanıyor. Bu, dizinin sınırlarını aşıyor ve bellek hatalarına neden oluyor. Düzeltmek için döngü koşulunu 'i < 5' olarak değiştirmek gerekir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167428"
  },
  {
    "question": "Aşağıdaki kodda, iki pointer kullanarak bir dizinin elemanlarını kopyalamaya çalışıyoruz ama beklenmedik sonuçlar alıyoruz. Hatanın nerede olduğunu bul ve düzelt. Kod: int arr1[3] = {1, 2, 3}; int arr2[3]; int *p1 = arr1; int *p2 = arr2; for(int i = 0; i < 3; i++) { *(p2 + i) = *(p1 + i); } printf('%d', arr2[3]);",
    "answer": "Hata, arr2 dizisinin 3. indeksine erişmeye çalışmaktan kaynaklanıyor. arr2 dizisi 0'dan 2'ye kadar olan indekslere sahiptir. Düzeltmek için 'printf('%d', arr2[2]);' şeklinde değiştirilmeli.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:28.167533"
  },
  {
    "question": "C dilinde bir dizi tanımlayıp bu dizinin elemanlarına pointer ile erişebilir miyim?",
    "answer": "Evet, C dilinde bir diziyi tanımladıktan sonra, dizinin elemanlarına pointer aritmetiği kullanarak erişebilirsiniz. Örneğin:\n\n```c\nint dizi[] = {10, 20, 30, 40, 50};\nint *ptr = dizi;\n\nfor (int i = 0; i < 5; i++) {\n    printf(\"%d \\n\", *(ptr + i)); // Pointer aritmetiği kullanarak elemanlara erişiyoruz.\n}\n```\nBu kodda, 'ptr' pointer'ı dizinin ilk elemanını işaret ediyor ve '*(ptr + i)' ile dizinin her bir elemanına erişiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.511977"
  },
  {
    "question": "Pointer aritmetiği nedir ve neden kullanılır?",
    "answer": "Pointer aritmetiği, bir pointer değişkeninin adresini matematiksel işlemlerle değiştirmeye yarar. C dilinde dizilerle çalışırken oldukça kullanışlıdır. Örneğin:\n\n```c\nint sayilar[] = {1, 2, 3};\nint *ptr = sayilar;\nptr++; // ptr şimdi ikinci elemana işaret ediyor.\nprintf(\"%d\", *ptr); // Çıktı: 2\n```\nBu sayede dizinin elemanları arasında kolayca geçiş yapabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512013"
  },
  {
    "question": "Pointer ile bir dizi elemanını nasıl değiştirebilirim?",
    "answer": "Bir pointer kullanarak dizi elemanlarına erişip değerlerini değiştirebilirsiniz. Örneğin:\n\n```c\nint dizi[] = {1, 2, 3};\nint *ptr = dizi;\n*(ptr + 1) = 20; // İkinci elemana 20 değerini atıyoruz.\nprintf(\"%d\", dizi[1]); // Çıktı: 20\n```\nBu kodda, 'ptr + 1' ile dizinin ikinci elemanını işaret ediyor ve bu elemanın değerini değiştiriyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512042"
  },
  {
    "question": "Pointer ile dizinin sonuna nasıl ulaşabilirim?",
    "answer": "Diziye ait son elemana pointer ile ulaşmak için dizinin başlangıç adresine dizi uzunluğunu ekleyebilirsiniz. Örneğin:\n\n```c\nint dizi[] = {10, 20, 30, 40};\nint *ptr = dizi + (sizeof(dizi) / sizeof(dizi[0])) - 1; // Son elemana işaret ediyor.\nprintf(\"%d\", *ptr); // Çıktı: 40\n```\nBu kodda, dizi boyutunu kullanarak son elemanı işaret eden bir pointer elde ediyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512061"
  },
  {
    "question": "Pointer aritmetiğinde neden dizinin eleman sayısını bilmem gerekiyor?",
    "answer": "Pointer aritmetiği yaparken, dizinin eleman sayısını bilmek önemlidir çünkü pointer'ı geçerli bir aralıktan çıkmadan hareket ettirmek zorundayız. Örneğin:\n\n```c\nint dizi[5] = {1, 2, 3, 4, 5};\nint *ptr = dizi;\nfor (int i = 0; i < 5; i++) {\n    printf(\"%d \", *(ptr + i)); // 0'dan 4'e kadar geçerli elemanlara erişiyoruz.\n}\n```\nDizinin boyutunu bilmek, dizinin sınırlarını aşmamak için önemlidir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512083"
  },
  {
    "question": "Dizinin ortasındaki bir elemana pointer ile nasıl erişirim?",
    "answer": "Dizinin ortasındaki bir elemana erişmek için dizinin başlangıç adresine offset ekleyebilirsiniz. Örneğin:\n\n```c\nint dizi[] = {10, 20, 30, 40, 50};\nint *ptr = dizi + 2; // Ortadaki elemana işaret ediyor, 0'dan başlayarak.\nprintf(\"%d\", *ptr); // Çıktı: 30\n```\nBu örnekte, dizi başlangıcına 2 ekleyerek üçüncü elemana erişiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512105"
  },
  {
    "question": "Bir pointer'ı başka bir pointer ile nasıl kopyalarım?",
    "answer": "Bir pointer'ın değerini başka bir pointer'a atayarak kopyalayabilirsiniz. Örneğin:\n\n```c\nint dizi[] = {1, 2, 3};\nint *ptr1 = dizi;\nint *ptr2 = ptr1; // ptr2 şimdi ptr1 ile aynı adresi işaret ediyor.\nprintf(\"%d\", *ptr2); // Çıktı: 1\n```\nBurada, 'ptr1' ve 'ptr2' aynı dizinin ilk elemanını işaret eder.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512134"
  },
  {
    "question": "Pointer'lar ile iki dizi arasında nasıl döngü yapabilirim?",
    "answer": "İki dizi arasında döngü yaparken iki farklı pointer kullanarak her iki dizinin elemanlarına erişebilirsiniz. Örneğin:\n\n```c\nint dizi1[] = {1, 2, 3};\nint dizi2[] = {4, 5, 6};\nint *ptr1 = dizi1;\nint *ptr2 = dizi2;\n\nfor (int i = 0; i < 3; i++) {\n    printf(\"%d %d\\n\", *(ptr1 + i), *(ptr2 + i));\n}\n```\nBu kodda, iki dizi arasındaki elemanları yan yana yazdırıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512156"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizinin tersini nasıl yazdırabilirim?",
    "answer": "Pointer aritmetiği kullanarak bir diziyi ters yazdırmak için dizinin sonuna işaret eden bir pointer ile geriye doğru gidebilirsiniz. Örneğin:\n\n```c\nint dizi[] = {1, 2, 3, 4, 5};\nint *ptr = dizi + 4; // Son elemana işaret ediyor.\n\nfor (int i = 0; i < 5; i++) {\n    printf(\"%d \", *(ptr - i)); // Ters sırayla elemanlara erişiyoruz.\n}\n```\nBu kodda, dizinin sonundan başlayarak elemanları ters sırayla yazdırıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:41:49.512177"
  },
  {
    "question": "C dilinde bir tamsayı dizisi tanımlayıp, bir işlev ile dizinin elemanlarına pointer aritmetiği ile erişim nasıl yapılır?",
    "answer": "Diyelim ki bir tamsayı dizimiz var: 'int dizi[5] = {10, 20, 30, 40, 50};'. Pointer aritmetiği kullanarak, dizinin elemanlarına erişmek için bir pointer tanımlayabiliriz: 'int *ptr = dizi;'. Şimdi 'ptr[i]' ifadesi ile her bir elemana erişebiliriz. Örneğin, 'ptr[2]' ifadesi 30 değerini döndürecektir. Ayrıca '*(ptr + i)' ifadesi de aynı sonuca ulaşmamızı sağlar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.384768"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizi elemanlarının toplamını nasıl hesaplayabiliriz?",
    "answer": "Öncelikle bir tamsayı dizisi tanımlayalım: 'int dizi[4] = {1, 2, 3, 4};'. Bir pointer ile dizinin başlangıç adresine atıfta bulunabiliriz: 'int *ptr = dizi;'. Toplamı hesaplamak için bir döngü kullanabiliriz. 'int toplam = 0; for (int i = 0; i < 4; i++) toplam += *(ptr + i);' ifadesi ile tüm elemanları toplayarak toplam değişkeninde saklayabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.384830"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizi elemanlarını tersten nasıl yazdırabiliriz?",
    "answer": "Bir dizi tanımlayalım: 'int dizi[5] = {5, 4, 3, 2, 1};'. Bu dizinin sonuna ulaşmak için bir pointer tanımlayabiliriz: 'int *ptr = dizi + 4;'. Şimdi döngü içinde 'printf(\"%d \", *ptr); ptr--;' ifadesi ile dizinin elemanlarını tersten yazdırabiliriz. Döngü, 'ptr' pointeri sıfıra ulaşana kadar devam eder.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.384874"
  },
  {
    "question": "Dizi elemanlarına pointer aritmetiği ile erişerek, her elemanın karesini nasıl hesaplayabiliriz?",
    "answer": "Bir tamsayı dizisi tanımlayalım: 'int dizi[5] = {1, 2, 3, 4, 5};'. Pointer ile dizi üzerinde iterasyon yapabiliriz: 'int *ptr = dizi;'. Bir döngü ile her bir elemanın karesini alabiliriz: 'for(int i = 0; i < 5; i++) { *(ptr + i) = (*(ptr + i)) * (*(ptr + i)); }'. Bu işlem sonunda dizi elemanları kareleri ile güncellenir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.384923"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir iki boyutlu dizinin elemanlarına nasıl erişebiliriz?",
    "answer": "İki boyutlu bir dizi tanımlayalım: 'int dizi[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};'. Pointer aritmetiği kullanarak dizinin elemanlarına erişmek için 'int (*ptr)[3] = dizi;' şeklinde bir pointer tanımlayabiliriz. Bu durumda 'ptr[i][j]' ile elemanlara erişebiliriz. Örneğin 'printf(\"%d\", ptr[1][2]);' ifadesi 6 değerini yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.384978"
  },
  {
    "question": "Pointer aritmetiği ile bir dizideki maksimum elemanı nasıl bulabiliriz?",
    "answer": "Diyelim ki bir dizi tanımladık: 'int dizi[5] = {10, 20, 5, 16, 30};'. Bir pointer ile dizinin başına atıfta bulunabiliriz: 'int *ptr = dizi;'. Maksimum elemanı bulmak için bir değişken tanımlayıp, bir döngü ile karşılaştırmalar yapabiliriz. 'int max = *ptr; for(int i = 1; i < 5; i++) { if(*(ptr + i) > max) max = *(ptr + i); }'. Sonuçta 'max' değişkeni dizinin maksimum elemanını tutar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.385019"
  },
  {
    "question": "Pointer aritmetiği ile bir dizideki elemanları sıralamak için basit bir sıralama algoritması nasıl uygulanır?",
    "answer": "Örnek olarak bir tamsayı dizisi alalım: 'int dizi[5] = {5, 3, 1, 4, 2};'. Basit bir seçim sıralama algoritması kullanarak, pointer aritmetiği ile diziyi sıralayabiliriz. 'for(int i = 0; i < 5; i++) { int *min = ptr + i; for (int j = i + 1; j < 5; j++) { if (*(ptr + j) < *min) min = ptr + j; } int temp = *(ptr + i); *(ptr + i) = *min; *min = temp; }'. Bu yöntem ile diziyi sıralayabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.385068"
  },
  {
    "question": "Pointer aritmetiği ile iki dizi arasındaki ortak elemanların sayısını nasıl bulabiliriz?",
    "answer": "Örneğin, 'int dizi1[5] = {1, 2, 3, 4, 5};' ve 'int dizi2[5] = {4, 5, 6, 7, 8};' dizilerini tanımladık. Ortak elemanları bulmak için bir döngü ile iki diziyi karşılaştırabiliriz. 'int *ptr1 = dizi1; int *ptr2 = dizi2; int ortak_sayisi = 0; for(int i = 0; i < 5; i++) { for(int j = 0; j < 5; j++) { if (*(ptr1 + i) == *(ptr2 + j)) ortak_sayisi++; } }'. Sonuçta 'ortak_sayisi' değişkeni ortak elemanların sayısını tutar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.385113"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir diziyi döndürme (rotate) işlemi nasıl yapılır?",
    "answer": "Bir dizi tanımlayalım: 'int dizi[5] = {1, 2, 3, 4, 5};'. Dizi elemanlarını bir adım döndürmek için, önce son elemanı geçici bir değişkende saklayabiliriz. Ardından tüm diğer elemanları bir sonraki pozisyona kaydırabiliriz. 'int temp = *(dizi + 4); for(int i = 4; i > 0; i--) { *(dizi + i) = *(dizi + i - 1); } *(dizi + 0) = temp;'. Bu işlemler sonucunda dizi 5, 1, 2, 3, 4 şeklinde döner.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:21.385159"
  },
  {
    "question": "Bir dizi üzerinde pointer aritmetiği kullanarak nasıl gezilir?",
    "answer": "Diziler, bellekte ardışık bellek alanlarında saklanır. Örneğin, 'int arr[5] = {1, 2, 3, 4, 5};' tanımladıysak, dizinin ilk elemanını bir pointer ile şu şekilde gezebiliriz: 'int *ptr = arr; while (ptr < arr + 5) { printf('%d ', *ptr++); }'. Bu kod, dizinin tüm elemanlarını sırayla yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281257"
  },
  {
    "question": "Pointer aritmetiği ile iki dizinin toplamını nasıl hesaplayabiliriz?",
    "answer": "İki dizinin toplamını hesaplamak için, her iki dizinin elemanlarına aynı anda erişmek üzere bir döngü kullanabiliriz. Örneğin, 'int a[5] = {1, 2, 3, 4, 5}; int b[5] = {5, 4, 3, 2, 1}; int sum[5];' tanımlayıp, şu şekilde toplamını hesaplayabiliriz: 'int *p1 = a, *p2 = b, *pSum = sum; for (int i = 0; i < 5; i++) { *pSum++ = *p1++ + *p2++; }'. Bu kod, 'sum' dizisinde, 'a' ve 'b' dizilerinin elemanlarının toplamını saklar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281294"
  },
  {
    "question": "Pointer aritmetiği ile bir dizi elemanını geri almak mümkün müdür?",
    "answer": "Evet, pointer aritmetiği ile geri almak mümkündür. Örneğin, 'int arr[5] = {10, 20, 30, 40, 50};' tanımlayıp, dizi elemanlarını geriye doğru yazdırmak için 'int *ptr = arr + 4; for (int i = 0; i < 5; i++) { printf('%d ', *(ptr - i)); }' kullanabiliriz. Bu kod, dizinin sonundan başına doğru elemanları yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281319"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizinin maksimum değerini nasıl bulabiliriz?",
    "answer": "Maksimum değeri bulmak için, pointer aritmetiği ile dizi elemanlarını gezeriz. Örneğin, 'int arr[5] = {1, 2, 3, 4, 5}; int max = *arr;' diyerek başlayabiliriz. Ardından, 'for (int i = 1; i < 5; i++) { if (*(arr + i) > max) { max = *(arr + i); } }' ifadesi ile dizinin elemanlarını kontrol ederiz. Bu kod, dizideki en büyük değeri bulur.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281343"
  },
  {
    "question": "Pointer aritmetiği ile bir dizinin tersini nasıl alabiliriz?",
    "answer": "Dizinin tersini almak için, iki pointer kullanarak dizinin başından ve sonundan başlayarak değerleri değiştirebiliriz. 'int arr[5] = {1, 2, 3, 4, 5}; int *start = arr, *end = arr + 4;' tanımlayıp, while döngüsü ile 'while (start < end) { int temp = *start; *start++ = *end; *end-- = temp; }' kullanarak diziyi tersine çevirebiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281364"
  },
  {
    "question": "Pointer aritmetiği ile bir karakter dizisini ters çevirebilir miyiz?",
    "answer": "Evet, bir karakter dizisini ters çevirmek için aynı yöntemle bir baş ve bir son pointer kullanabiliriz. Örneğin, 'char str[] = 'hello';' diyelim. 'char *start = str, *end = str + strlen(str) - 1;' diyerek baş ve son pointer'ları belirleyip, 'while (start < end) { char temp = *start; *start++ = *end; *end-- = temp; }' ile diziyi tersine çevirebiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281386"
  },
  {
    "question": "Bir struct içindeki dizinin elemanlarına pointer aritmetiği ile nasıl erişebiliriz?",
    "answer": "Struct içinde bir dizi varsa, pointer aritmetiği ile dizi elemanlarına erişmek için struct pointer'ını kullanabiliriz. Örneğin, 'typedef struct { int arr[5]; } MyStruct; MyStruct s; s.arr[0] = 1; ...' diyelim, 'int *ptr = s.arr;' ile diziye erişip, 'for (int i = 0; i < 5; i++) { printf('%d ', *(ptr + i)); }' ile elemanlarına ulaşabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281411"
  },
  {
    "question": "Pointer aritmetiği kullanarak çok boyutlu dizilere nasıl erişebiliriz?",
    "answer": "Çok boyutlu dizilerde, her boyut için pointer aritmetiği kullanarak elemanlara ulaşabiliriz. Örneğin, 'int arr[3][3];' tanımlayıp, 'int *ptr = &arr[0][0];' ile dizinin başını gösterebiliriz. Elemanlara erişmek için '*(ptr + i * 3 + j)' ifadesini kullanarak, i satır ve j sütun indeksine ulaşabiliriz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281432"
  },
  {
    "question": "Pointer aritmetiği ile bellek yönetimi yaparken dikkat edilmesi gerekenler nelerdir?",
    "answer": "Pointer aritmetiği kullanırken bellek sınırlarına dikkat etmek çok önemlidir. Örneğin, bir dizinin sonuna erişim yaparken, pointer'ın dizinin sonunu aşmamasına dikkat edilmelidir. Ayrıca, serbest bırakılmamış bellek alanlarıyla çalışmak bellek sızıntılarına neden olabilir. Bu yüzden, her malloc sonrası free çağrısı yapmalıyız.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:42:42.281469"
  },
  {
    "question": "Bir tamsayı dizisinin elemanlarını toplamak için pointer aritmetiği kullanarak nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint toplam(int* dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği ile dizinin elemanlarına erişiyoruz\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = toplam(dizi, boyut);\n    printf(\"Toplam: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, verilen dizinin elemanlarını toplamak için pointer aritmetiği kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826637"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için pointer aritmetiği ile nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid ters_cevir(char* str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = *(str + i);\n        *(str + i) = *(str + (uzunluk - 1 - i));\n        *(str + (uzunluk - 1 - i)) = temp;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    ters_cevir(str);\n    printf(\"Ters çevrilmiş: %s\\n\", str);\n    return 0;\n}\n```\nBu kod, bir karakter dizisini pointer aritmetiği ile tersine çevirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826684"
  },
  {
    "question": "Bir dizinin elemanlarını pointer aritmetiği kullanarak sıralamak için nasıl bir algoritma yazabilirim?",
    "answer": "Aşağıdaki gibi basit bir sıralama algoritması (Bubble Sort) yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid sirala(int* dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - 1 - i; j++) {\n            if (*(dizi + j) > *(dizi + (j + 1))) {\n                int temp = *(dizi + j);\n                *(dizi + j) = *(dizi + (j + 1));\n                *(dizi + (j + 1)) = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 2, 9, 1, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    return 0;\n}\n```\nBu kod, bir diziyi pointer aritmetiği kullanarak sıralar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826714"
  },
  {
    "question": "Bir dizinin en büyük elemanını bulmak için pointer aritmetiği ile nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int* dizi, int boyut) {\n    int enBuyukEleman = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > enBuyukEleman) {\n            enBuyukEleman = *(dizi + i);\n        }\n    }\n    return enBuyukEleman;\n}\n\nint main() {\n    int dizi[] = {3, 5, 7, 2, 8};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int sonuc = enBuyuk(dizi, boyut);\n    printf(\"En büyük eleman: %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, bir dizinin en büyük elemanını pointer aritmetiği ile bulur.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826742"
  },
  {
    "question": "Bir dizinin elemanlarını iki katına çıkarmak için pointer aritmetiği kullanarak nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid ikiKatinaCikart(int* dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        *(dizi + i) *= 2; // Pointer aritmetiği ile elemanları güncelliyoruz\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    ikiKatinaCikart(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    return 0;\n}\n```\nBu kod, bir dizinin tüm elemanlarını iki katına çıkarmak için pointer aritmetiği kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826772"
  },
  {
    "question": "Dinamik olarak ayrılmış bir dizi kullanarak, dizinin elemanlarını kullanıcıdan almak için pointer aritmetiği ile nasıl bir uygulama yazabilirim?",
    "answer": "Aşağıdaki gibi bir uygulama yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int boyut;\n    printf(\"Dizinin boyutunu girin: \");\n    scanf(\"%d\", &boyut);\n    int* dizi = (int*)malloc(boyut * sizeof(int)); // Dinamik bellek ayırma\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Dizinin %d. elemanını girin: \", i + 1);\n        scanf(\"%d\", (dizi + i)); // Pointer aritmetiği ile elemanları alıyoruz\n    }\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i)); // Elemanları yazdırıyoruz\n    }\n    free(dizi); // Belleği serbest bırakıyoruz\n    return 0;\n}\n```\nBu kod, dinamik olarak bir dizi oluşturur ve kullanıcıdan eleman alır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826810"
  },
  {
    "question": "Bir tamsayı dizisinin ortalamasını hesaplamak için pointer aritmetiği ile nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nfloat ortalama(int* dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return (float)toplam / boyut; // Ortalama hesaplama\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    float sonuc = ortalama(dizi, boyut);\n    printf(\"Ortalama: %.2f\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, bir dizinin ortalamasını hesaplamak için pointer aritmetiği kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826839"
  },
  {
    "question": "Bir dizinin elemanlarını sıfırlamak için pointer aritmetiği ile nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid sifirla(int* dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        *(dizi + i) = 0; // Pointer aritmetiği ile elemanları sıfırlıyoruz\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sifirla(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i)); // Tüm elemanlar sıfır olmalı\n    }\n    return 0;\n}\n```\nBu kod, bir dizinin tüm elemanlarını sıfırlamak için pointer aritmetiği kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826865"
  },
  {
    "question": "Bir dizinin tüm elemanlarını ekrana yazdırmak için pointer aritmetiği ile nasıl bir fonksiyon yazabilirim?",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid yazdir(int* dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i)); // Pointer aritmetiği ile elemanları yazdırıyoruz\n    }\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    yazdir(dizi, boyut);\n    return 0;\n}\n```\nBu kod, bir dizinin tüm elemanlarını pointer aritmetiği kullanarak ekrana yazdırmak için bir fonksiyon kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:23.826901"
  },
  {
    "question": "Bir integer dizisinin elemanlarının toplamını hesaplayan bir fonksiyon yazın. Fonksiyonu pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği kullanarak dizi elemanlarına erişim\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Toplam: %d\\n\", toplam(dizi, boyut));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481248"
  },
  {
    "question": "Bir string dizisini ters çeviren bir fonksiyon yazın. Bu fonksiyonu pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    char *baslangic = str;\n    char *son = str + uzunluk - 1;\n    char temp;\n\n    while (baslangic < son) {\n        temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba Dünya\";\n    tersCevir(str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481297"
  },
  {
    "question": "Bir dizideki en büyük elemanı bulan bir fonksiyon yazın. Bu fonksiyonu pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int *dizi, int boyut) {\n    int max = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > max) {\n            max = *(dizi + i);\n        }\n    }\n    return max;\n}\n\nint main() {\n    int dizi[] = {3, 5, 1, 9, 7};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\\n\", enBuyuk(dizi, boyut));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481331"
  },
  {
    "question": "Bir dizideki tüm elemanları iki katına çıkaran bir fonksiyon yazın. Bu fonksiyonu pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nvoid ikiKatinaCikar(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        *(dizi + i) *= 2; // Elemanları iki katına çıkar\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    ikiKatinaCikar(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481376"
  },
  {
    "question": "Bir float dizisindeki elemanların ortalamasını hesaplayan bir fonksiyon yazın. Pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nfloat ortalama(float *dizi, int boyut) {\n    float toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return toplam / boyut; // Ortalama hesapla\n}\n\nint main() {\n    float dizi[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Ortalama: %.2f\\n\", ortalama(dizi, boyut));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481408"
  },
  {
    "question": "Bir dizinin elemanlarını sıralayan bir fonksiyon yazın. Pointer aritmetiği kullanarak implement edin (Bubble sort).",
    "answer": "#include <stdio.h>\n\nvoid sıralama(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (*(dizi + j) > *(dizi + j + 1)) {\n                int temp = *(dizi + j);\n                *(dizi + j) = *(dizi + j + 1);\n                *(dizi + j + 1) = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 1, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sıralama(dizi, boyut);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481440"
  },
  {
    "question": "Bir dizideki tüm elemanları pozitif mi negatif mi kontrol eden bir fonksiyon yazın. Pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nvoid kontrolEt(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) >= 0) {\n            printf(\"%d: Pozitif\\n\", *(dizi + i));\n        } else {\n            printf(\"%d: Negatif\\n\", *(dizi + i));\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {-3, 5, -2, 7, 0};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    kontrolEt(dizi, boyut);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481481"
  },
  {
    "question": "Bir integer dizisindeki çift sayıları bulup yeni bir diziye atan bir fonksiyon yazın. Pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nvoid ciftSayilariBul(int *dizi, int boyut, int *ciftDizi, int *ciftBoyut) {\n    *ciftBoyut = 0; // Çift sayı sayısını sıfırla\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            *(ciftDizi + (*ciftBoyut)++) = *(dizi + i); // Çift sayıları yeni diziye ekle\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int ciftDizi[boyut];\n    int ciftBoyut;\n    ciftSayilariBul(dizi, boyut, ciftDizi, &ciftBoyut);\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < ciftBoyut; i++) {\n        printf(\"%d \", *(ciftDizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481547"
  },
  {
    "question": "Bir dizinin ilk N elemanını bir başka diziye kopyalayan bir fonksiyon yazın. Pointer aritmetiği kullanarak implement edin.",
    "answer": "#include <stdio.h>\n\nvoid kopyala(int *kaynak, int *hedef, int N) {\n    for (int i = 0; i < N; i++) {\n        *(hedef + i) = *(kaynak + i); // Elemanları kopyala\n    }\n}\n\nint main() {\n    int kaynak[] = {10, 20, 30, 40, 50};\n    int N = 3;\n    int hedef[N];\n    kopyala(kaynak, hedef, N);\n    printf(\"Kopyalanan dizi: \");\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", *(hedef + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:43:40.481598"
  },
  {
    "question": "Bir dizi içinde en büyük elemanı bulmak için pointer aritmetiği kullanarak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint enBuyukEleman(int *dizi, int boyut) {\n    int *max = dizi; // İlk elemanı max olarak atıyoruz\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > *max) {\n            max = dizi + i; // Yeni max adresini güncelliyoruz\n        }\n    }\n    return *max; // En büyük elemanı döndürüyoruz\n}\n\nint main() {\n    int dizi[] = {3, 5, 2, 8, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"En büyük eleman: %d\\n\", enBuyukEleman(dizi, boyut));\n    return 0;\n}\n// Bu örnekte, pointer aritmetiği kullanarak dizinin elemanlarına erişiyoruz ve en büyük elemanı buluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.905888"
  },
  {
    "question": "Bir karakter dizisini tersine çevirmek için pointer aritmetiği kullanarak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid tersCevir(char *str) {\n    char *baslangic = str;\n    char *son = str;\n    while (*son) {\n        son++; // Son karakterin bir sonrasına gidiyoruz\n    }\n    son--;\n\n    while (baslangic < son) {\n        char temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    tersCevir(str);\n    printf(\"Ters çevrilen: %s\\n\", str);\n    return 0;\n}\n// Bu örnekte, pointer aritmetiği ile dizinin başını ve sonunu işaret ederek karakterleri yer değiştiriyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.905944"
  },
  {
    "question": "Bir tam sayı dizisinin toplamını pointer aritmetiği ile hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği ile dizi elemanlarına erişim\n    }\n    return toplam;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Toplam: %d\\n\", toplam(dizi, boyut));\n    return 0;\n}\n// Bu örnekte, pointer aritmetiği kullanarak dizinin elemanlarını topluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.905971"
  },
  {
    "question": "Bir dizi elemanlarının ortalamasını hesaplamak için pointer aritmetiği kullanarak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\ndouble ortalama(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return (double)toplam / boyut;\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Ortalama: %.2f\\n\", ortalama(dizi, boyut));\n    return 0;\n}\n// Bu örnekte, pointer aritmetiği ile dizinin elemanlarını topluyor ve ortalamasını hesaplıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.905999"
  },
  {
    "question": "Pointer aritmetiği kullanarak iki diziyi birleştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid birleştir(int *dizi1, int boyut1, int *dizi2, int boyut2, int *sonuc) {\n    for (int i = 0; i < boyut1; i++) {\n        *(sonuc + i) = *(dizi1 + i); // İlk diziyi kopyala\n    }\n    for (int i = 0; i < boyut2; i++) {\n        *(sonuc + boyut1 + i) = *(dizi2 + i); // İkinci diziyi kopyala\n    }\n}\n\nint main() {\n    int dizi1[] = {1, 2, 3};\n    int dizi2[] = {4, 5, 6};\n    int boyut1 = sizeof(dizi1) / sizeof(dizi1[0]);\n    int boyut2 = sizeof(dizi2) / sizeof(dizi2[0]);\n    int sonuc[boyut1 + boyut2];\n    birleştir(dizi1, boyut1, dizi2, boyut2, sonuc);\n    printf(\"Birleşik dizi: \");\n    for (int i = 0; i < boyut1 + boyut2; i++) {\n        printf(\"%d \", *(sonuc + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu örnekte, iki tam sayı dizisini birleştiriyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.906022"
  },
  {
    "question": "Bir tam sayı dizisindeki negatif sayıları pozitif yapmak için pointer aritmetiği ile bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid negatifleriPozitifYap(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) < 0) {\n            *(dizi + i) = -*(dizi + i); // Negatif sayıları pozitif yap\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {-1, 2, -3, 4, -5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    negatifleriPozitifYap(dizi, boyut);\n    printf(\"Dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu örnekte, negatif sayıları pozitif hale getiriyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.906052"
  },
  {
    "question": "Bir dizinin her elemanının karesini almak için pointer aritmetiği ile bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid kareleriniAl(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        *(dizi + i) = (*(dizi + i)) * (*(dizi + i)); // Pointer aritmetiği ile karesini al\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    kareleriniAl(dizi, boyut);\n    printf(\"Kareler: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu örnekte, dizinin her elemanının karesini alıp diziyi güncelliyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.906078"
  },
  {
    "question": "Bir dizinin elemanlarını sıralamak için pointer aritmetiği ile bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = i + 1; j < boyut; j++) {\n            if (*(dizi + i) > *(dizi + j)) {\n                int temp = *(dizi + i);\n                *(dizi + i) = *(dizi + j);\n                *(dizi + j) = temp; // Pointer aritmetiği ile elemanları yer değiştir\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 2, 9, 1, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", *(dizi + i));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu örnekte, pointer aritmetiği ile basit bir sıralama algoritması (bubble sort) uyguluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.906112"
  },
  {
    "question": "Bir dizi içindeki çift sayıları bulmak için pointer aritmetiği kullanarak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid ciftSayilariBul(int *dizi, int boyut) {\n    printf(\"Çift sayılar: \");\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            printf(\"%d \", *(dizi + i)); // Pointer aritmetiği ile çift sayıları kontrol et\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    ciftSayilariBul(dizi, boyut);\n    return 0;\n}\n// Bu örnekte, dizinin elemanlarını kontrol ederek çift sayıları buluyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:03.906139"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını pointer aritmetiği kullanarak nasıl hesaplayabilirim?",
    "answer": "Diziye pointer ile erişerek toplamı hesaplamak için aşağıdaki gibi bir kod kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int *ptr = dizi;\n    int toplam = 0;\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(ptr + i);\n    }\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kodda, dizinin her elemanına pointer aritmetiği ile erişerek toplamı hesaplıyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346599"
  },
  {
    "question": "Bir dizi elemanlarını tersine çevirmek için pointer aritmetiği kullanarak nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizi elemanlarını tersine çevirmek için şu şekilde bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid tersCevir(int *dizi, int boyut) {\n    int *baslangic = dizi;\n    int *son = dizi + boyut - 1;\n    while (baslangic < son) {\n        int temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    tersCevir(dizi, boyut);\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, dizinin başına ve sonuna iki ayrı pointer yerleştirerek elemanları yer değiştirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346666"
  },
  {
    "question": "Pointer aritmetiği ile bir dizinin en büyük elemanını nasıl bulabilirim?",
    "answer": "Dizinin en büyük elemanını bulmak için aşağıdaki gibi bir kod yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[] = {3, 1, 4, 1, 5, 9, 2};\n    int *ptr = dizi;\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int enBuyuk = *ptr;\n\n    for (int i = 1; i < boyut; i++) {\n        if (*(ptr + i) > enBuyuk) {\n            enBuyuk = *(ptr + i);\n        }\n    }\n\n    printf(\"En büyük eleman: %d\\n\", enBuyuk);\n    return 0;\n}\n```\nBu kod, dizinin elemanlarını pointer aritmetiği ile kontrol ederek en büyük değeri bulur.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346708"
  },
  {
    "question": "Pointer aritmetiği kullanarak iki dizinin elemanlarını nasıl birleştirebilirim?",
    "answer": "İki diziyi birleştirmek için aşağıdaki gibi bir kod yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid birleştir(int *dizi1, int boyut1, int *dizi2, int boyut2, int *birlesikDizi) {\n    int i;\n    for (i = 0; i < boyut1; i++) {\n        *(birlesikDizi + i) = *(dizi1 + i);\n    }\n    for (int j = 0; j < boyut2; j++) {\n        *(birlesikDizi + i + j) = *(dizi2 + j);\n    }\n}\n\nint main() {\n    int dizi1[] = {1, 2, 3};\n    int dizi2[] = {4, 5, 6};\n    int boyut1 = sizeof(dizi1) / sizeof(dizi1[0]);\n    int boyut2 = sizeof(dizi2) / sizeof(dizi2[0]);\n    int birlesikDizi[boyut1 + boyut2];\n\n    birleştir(dizi1, boyut1, dizi2, boyut2, birlesikDizi);\n\n    for (int i = 0; i < (boyut1 + boyut2); i++) {\n        printf(\"%d \", birlesikDizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBurada, iki dizinin elemanlarını birleştirerek yeni bir dizi oluşturuyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346750"
  },
  {
    "question": "Pointer aritmetiği ile bir dizinin ortalamasını nasıl hesaplayabilirim?",
    "answer": "Dizinin ortalamasını hesaplamak için aşağıdaki fonksiyonu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nfloat ortalama(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i);\n    }\n    return (float)toplam / boyut;\n}\n\nint main() {\n    int dizi[] = {2, 4, 6, 8, 10};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Ortalama: %.2f\\n\", ortalama(dizi, boyut));\n    return 0;\n}\n```\nBu kod, dizinin elemanlarını pointer aritmetiği ile toplayarak ortalamayı hesaplar.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346789"
  },
  {
    "question": "Pointer aritmetiği ile bir dizi içerisindeki belirli bir değerin kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Belirli bir değerin kaç kez geçtiğini bulmak için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint say(int *dizi, int boyut, int deger) {\n    int sayac = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) == deger) {\n            sayac++;\n        }\n    }\n    return sayac;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 2, 4, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    int deger = 2;\n    printf(\"%d sayısı dizide %d kez geçiyor.\\n\", deger, say(dizi, boyut, deger));\n    return 0;\n}\n```\nBu kod, dizideki belirli bir değerin kaç kez geçtiğini bulmak için pointer aritmetiğinden faydalanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346842"
  },
  {
    "question": "Pointer aritmetiği ile bir dizi elemanını değiştirmek için nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizi elemanını değiştirmek için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid elemanDegistir(int *dizi, int indeks, int yeniDeger) {\n    *(dizi + indeks) = yeniDeger;\n}\n\nint main() {\n    int dizi[] = {10, 20, 30, 40, 50};\n    int indeks = 2;\n    int yeniDeger = 99;\n    elemanDegistir(dizi, indeks, yeniDeger);\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, belirtilen indeksteki dizi elemanını değiştirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346897"
  },
  {
    "question": "Pointer aritmetiği ile çok boyutlu bir dizinin elemanlarına nasıl erişebilirim?",
    "answer": "Çok boyutlu bir diziye pointer aritmetiği ile erişme örneği:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int dizi[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int *ptr = &dizi[0][0];\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", *(ptr + i * 3 + j));\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\nBu kod, iki boyutlu dizinin elemanlarına tek boyutlu bir dizi gibi erişerek yazdırır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346940"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir diziyi sıralamak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Diziyi sıralamak için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid sirala(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (*(dizi + j) > *(dizi + j + 1)) {\n                int temp = *(dizi + j);\n                *(dizi + j) = *(dizi + j + 1);\n                *(dizi + j + 1) = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 6, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut);\n\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kod, bubble sort algoritması ile diziyi sıralamak için pointer aritmetiği kullanır.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:44:48.346985"
  },
  {
    "question": "Bir dizinin toplamını hesaplayan bir fonksiyona pointer aritmetiği ile nasıl erişebiliriz?",
    "answer": "Dizinin toplamını hesaplamak için bir pointer kullanabiliriz. Aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nint toplam(int *dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += *(dizi + i); // Pointer aritmetiği ile erişim\n    }\n    return toplam;\n}\n```\nBu fonksiyonda, `dizi + i` ifadesi ile dizinin her bir elemanına pointer aritmetiği kullanarak erişiyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.749980"
  },
  {
    "question": "Bir dizi üzerinde iki farklı pointer kullanarak elemanları nasıl değiştirebiliriz?",
    "answer": "İki pointer kullanarak dizinin elemanlarını değiştirmek için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nvoid degistir(int *p1, int *p2) {\n    int temp = *p1;\n    *p1 = *p2;\n    *p2 = temp;\n}\n```\nBu fonksiyon, iki pointerın işaret ettiği değerleri değiştirir. Pointerlar dizinin elemanlarını işaret ediyorsa, bu elemanlar arasında bir swap işlemi gerçekleştirir.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750023"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizinin tersini nasıl alabiliriz?",
    "answer": "Dizinin tersini almak için iki pointer kullanabiliriz. Aşağıdaki örnekte, bir dizinin elemanlarını tersine çeviriyoruz:\n\n```c\nvoid tersCevir(int *dizi, int boyut) {\n    int *baslangic = dizi;\n    int *son = dizi + boyut - 1;\n    while (baslangic < son) {\n        int temp = *baslangic;\n        *baslangic = *son;\n        *son = temp;\n        baslangic++;\n        son--;\n    }\n}\n```\nBurada, `baslangic` pointerı dizinin ilk elemanını, `son` pointerı ise son elemanını işaret eder.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750047"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplamak için pointer aritmetiği kullanabilir miyim? Nasıl?",
    "answer": "Evet, pointer aritmetiği ile bir stringin uzunluğunu hesaplayabiliriz. Aşağıdaki örnekte, bir stringin uzunluğunu bulmak için bir fonksiyon yazıyoruz:\n\n```c\nint stringUzunlugu(char *str) {\n    char *p = str;\n    while (*p != '\\0') {\n        p++;\n    }\n    return p - str; // Pointer aritmetiği ile uzunluk hesaplama\n}\n```\nBu fonksiyonda, `p` pointerı stringin sonuna kadar ilerliyor ve sonrasında başlangıç noktasına göre farkı alarak uzunluğu döndürüyoruz.",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750073"
  },
  {
    "question": "Dinamik olarak tahsis edilen bir dizi üzerinde pointer aritmetiği kullanarak elemanları nasıl baştan sona gezebiliriz?",
    "answer": "Dinamik olarak tahsis edilen bir dizi üzerinde pointer aritmetiği kullanarak elemanlara erişmek için aşağıdaki gibi bir kod yazabiliriz:\n\n```c\nint *dizi = (int*)malloc(boyut * sizeof(int));\n// Diziye eleman ekle\nfor (int i = 0; i < boyut; i++) {\n    *(dizi + i) = i * 2; // Elemanları atama\n}\n// Elemanları yazdır\nfor (int i = 0; i < boyut; i++) {\n    printf(\"%d \", *(dizi + i));\n}\nfree(dizi);\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750105"
  },
  {
    "question": "Pointer aritmetiği ile bir çok boyutlu diziye nasıl erişim sağlayabilirim?",
    "answer": "Çok boyutlu dizilere erişim için pointer aritmetiği kullanarak aşağıdaki gibi bir kod yazabiliriz:\n\n```c\n#define SATIR 3\n#define SUTUN 4\nint dizi[SATIR][SUTUN];\n\nfor (int i = 0; i < SATIR; i++) {\n    for (int j = 0; j < SUTUN; j++) {\n        *(*(dizi + i) + j) = i + j; // Pointer aritmetiği ile erişim\n    }\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750129"
  },
  {
    "question": "Bir dizi elemanlarının maksimumunu bulmak için pointer aritmetiği nasıl kullanılabilir?",
    "answer": "Maksimum elemanı bulmak için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nint maksimum(int *dizi, int boyut) {\n    int max = *dizi;\n    for (int i = 1; i < boyut; i++) {\n        if (*(dizi + i) > max) {\n            max = *(dizi + i);\n        }\n    }\n    return max;\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750154"
  },
  {
    "question": "Bir diziyi sıralamak için pointer aritmetiği kullanabilir miyiz? Bir örnek ver.",
    "answer": "Evet, pointer aritmetiği ile bir diziyi sıralamak için aşağıdaki gibi bir seçim sıralama algoritması yazabiliriz:\n\n```c\nvoid selectionSort(int *dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (*(dizi + j) < *(dizi + minIndex)) {\n                minIndex = j;\n            }\n        }\n        if (minIndex != i) {\n            int temp = *(dizi + i);\n            *(dizi + i) = *(dizi + minIndex);\n            *(dizi + minIndex) = temp;\n        }\n    }\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750180"
  },
  {
    "question": "Pointer aritmetiği kullanarak bir dizinin elemanlarını çift veya tek olduğu durumuna göre nasıl ayırabilirim?",
    "answer": "Dizinin elemanlarını çift ve tek olarak ayırmak için aşağıdaki gibi bir örnek yazabiliriz:\n\n```c\nvoid ayir(int *dizi, int boyut, int **ciftler, int *ciftSayisi, int **tekler, int *tekSayisi) {\n    *ciftSayisi = 0;\n    *tekSayisi = 0;\n    for (int i = 0; i < boyut; i++) {\n        if (*(dizi + i) % 2 == 0) {\n            (*ciftler)[(*ciftSayisi)++] = *(dizi + i);\n        } else {\n            (*tekler)[(*tekSayisi)++] = *(dizi + i);\n        }\n    }\n}\n```",
    "category": "pointers_memory",
    "topic": "pointer_arithmetic",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Pointer aritmetiği",
    "timestamp": "2025-06-01T15:45:11.750209"
  },
  {
    "question": "Bir fonksiyon işaretçisi tanımlamak için eksik kodu tamamlayın. Fonksiyon, iki tam sayıyı alacak ve bunların toplamını dönecek.",
    "answer": "#include <stdio.h>\n\nint topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int (*fonksiyonPtr)(int, int) = topla; // Fonksiyon işaretçisini tanımlıyoruz.\n    int sonuc = fonksiyonPtr(3, 5); // Fonksiyonu çağırıyoruz.\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037341"
  },
  {
    "question": "Aşağıdaki eksik kodda, bir dizi fonksiyon işaretçilerini tanımlayın ve her birini çağırarak sonucu yazdırın. Fonksiyonlar: çıkartma ve çarpma.",
    "answer": "#include <stdio.h>\n\nint cikart(int a, int b) {\n    return a - b;\n}\n\nint carp(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    int (*fonksiyonlar[2])(int, int) = {cikart, carp}; // Fonksiyon işaretçileri dizisi.\n    int sonuc1 = fonksiyonlar[0](10, 3); // Çıkartma çağrısı\n    int sonuc2 = fonksiyonlar[1](4, 5); // Çarpma çağrısı\n    printf(\"Çıkartma Sonucu: %d\\n\", sonuc1);\n    printf(\"Çarpma Sonucu: %d\\n\", sonuc2);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037396"
  },
  {
    "question": "Bir dizideki elemanların toplamını hesaplamak için bir fonksiyon işaretçisi kullanarak bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint toplam(int dizi[], int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    return toplam;\n}\n\nint main() {\n    int (*fonksiyonPtr)(int[], int) = toplam; // Fonksiyon işaretçisini tanımlıyoruz.\n    int dizi[] = {1, 2, 3, 4, 5};\n    int sonuc = fonksiyonPtr(dizi, 5); // Fonksiyonu çağırıyoruz.\n    printf(\"Dizinin toplamı: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037431"
  },
  {
    "question": "Bir diziden en büyük sayıyı bulmak için bir fonksiyon işaretçisi kullanarak bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[], int boyut) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (dizi[i] > max) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int (*fonksiyonPtr)(int[], int) = enBuyuk; // Fonksiyon işaretçisini tanımlıyoruz.\n    int dizi[] = {3, 5, 2, 8, 1};\n    int sonuc = fonksiyonPtr(dizi, 5); // Fonksiyonu çağırıyoruz.\n    printf(\"En büyük sayı: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037465"
  },
  {
    "question": "Bir fonksiyon işaretçisini kullanarak, verilmiş bir sayının karesini hesaplayan bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint kareAl(int a) {\n    return a * a;\n}\n\nint main() {\n    int (*fonksiyonPtr)(int) = kareAl; // Fonksiyon işaretçisini tanımlıyoruz.\n    int sayi = 4;\n    int sonuc = fonksiyonPtr(sayi); // Fonksiyonu çağırıyoruz.\n    printf(\"Kare: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037498"
  },
  {
    "question": "Bir işaretçi kullanarak, verilen iki sayının maksimumunu bulan bir fonksiyon yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint maksimum(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int (*fonksiyonPtr)(int, int) = maksimum; // Fonksiyon işaretçisini tanımlıyoruz.\n    int sonuc = fonksiyonPtr(7, 12); // Fonksiyonu çağırıyoruz.\n    printf(\"Maksimum: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037544"
  },
  {
    "question": "Verilen iki sayının ortalamasını hesaplayan bir fonksiyon yazın ve bir fonksiyon işaretçisi kullanarak sonucu döndürün. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nfloat ortalama(float a, float b) {\n    return (a + b) / 2;\n}\n\nint main() {\n    float (*fonksiyonPtr)(float, float) = ortalama; // Fonksiyon işaretçisini tanımlıyoruz.\n    float sonuc = fonksiyonPtr(5.0, 15.0); // Fonksiyonu çağırıyoruz.\n    printf(\"Ortalama: %.2f\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037581"
  },
  {
    "question": "İki sayının birbirine bölünmesini sağlayan bir fonksiyon yazın. Bu fonksiyonu bir işaretçi ile çağırarak sonucu gösterin.",
    "answer": "#include <stdio.h>\n\nfloat bol(float a, float b) {\n    if (b == 0) {\n        printf(\"Bölme hatası!\\n\");\n        return 0;\n    }\n    return a / b;\n}\n\nint main() {\n    float (*fonksiyonPtr)(float, float) = bol; // Fonksiyon işaretçisini tanımlıyoruz.\n    float sonuc = fonksiyonPtr(10.0, 2.0); // Fonksiyonu çağırıyoruz.\n    printf(\"Sonuç: %.2f\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037616"
  },
  {
    "question": "Bir karakter dizisini tersine çeviren bir fonksiyon yazın ve bu fonksiyonu bir işaretçi ile çağırın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char* str) {\n    int uzunluk = strlen(str);\n    for (int i = 0; i < uzunluk / 2; i++) {\n        char temp = str[i];\n        str[i] = str[uzunluk - i - 1];\n        str[uzunluk - i - 1] = temp;\n    }\n}\n\nint main() {\n    void (*fonksiyonPtr)(char*) = tersCevir; // Fonksiyon işaretçisini tanımlıyoruz.\n    char str[] = \"Merhaba\";\n    fonksiyonPtr(str); // Fonksiyonu çağırıyoruz.\n    printf(\"Ters hali: %s\\n\", str);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:45:31.037650"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayarak iki tamsayıyı toplayan bir fonksiyon işaretçisi oluşturun.",
    "answer": "#include <stdio.h>\n\n// İki tamsayıyı toplayan fonksiyon\nint topla(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    // Fonksiyon işaretçisini tanımlıyoruz\n    int (*islem)(int, int);\n    // Fonksiyon işaretçisini topla fonksiyonuna atıyoruz\n    islem = topla;\n    int sonuc = islem(5, 3); // 5 ve 3'ü topluyoruz\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873214"
  },
  {
    "question": "Aşağıdaki fonksiyon işaretçisinin kullanımı ile bir dizi elemanlarını çarpan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\n// İki tamsayıyı çarpan fonksiyon\nint carp(int a, int b) {\n    return a * b;\n}\n\nvoid diziHesapla(int (*islem)(int, int), int dizi[], int boyut) {\n    int sonuc = 1;\n    for (int i = 0; i < boyut; i++) {\n        sonuc = islem(sonuc, dizi[i]);\n    }\n    printf(\"Çarpım Sonucu: %d\\n\", sonuc);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4};\n    diziHesapla(carp, dizi, 4);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873258"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayarak birden fazla matematiksel işlem gerçekleştiren bir yapı oluşturun.",
    "answer": "#include <stdio.h>\n\n// Toplama fonksiyonu\nint toplama(int a, int b) { return a + b; }\n// Çıkarma fonksiyonu\nint cikarma(int a, int b) { return a - b; }\n// Çarpma fonksiyonu\nint carpma(int a, int b) { return a * b; }\n\nint main() {\n    int (*islemler[3])(int, int) = {toplama, cikarma, carpma};\n    int a = 10, b = 5;\n    printf(\"Toplama: %d\\n\", islemler[0](a, b));\n    printf(\"Çıkarma: %d\\n\", islemler[1](a, b));\n    printf(\"Çarpma: %d\\n\", islemler[2](a, b));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873291"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısımları tamamlayarak, kullanıcının girdiği iki sayının maksimumunu bulan bir fonksiyon işaretçisi oluşturun.",
    "answer": "#include <stdio.h>\n\n// Maksimumu bulan fonksiyon\nint maksimum(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int (*islem)(int, int);\n    islem = maksimum;\n    int a, b;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    printf(\"Maksimum: %d\\n\", islem(a, b));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873327"
  },
  {
    "question": "Aşağıdaki kodda eksik kısımları tamamlayarak bir dizi içindeki elemanlar üzerinde bir işlemi gerçekleştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\n// Elemanları iki katına çıkaran fonksiyon\nvoid ikiKatinaCikar(int *dizi, int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        dizi[i] *= 2;\n    }\n}\n\nvoid diziIslem(int (*islem)(int*, int), int *dizi, int boyut) {\n    islem(dizi, boyut);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4};\n    diziIslem(ikiKatinaCikar, dizi, 4);\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873360"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayarak bir karakter dizisi üzerinde işlem yapan bir fonksiyon işaretçisi oluşturun.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\n// Karakter dizisini ters çeviren fonksiyon\nvoid tersCevir(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nvoid diziIslem(void (*islem)(char*), char *str) {\n    islem(str);\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    diziIslem(tersCevir, str);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873392"
  },
  {
    "question": "Aşağıdaki kodda eksik kısmı tamamlayarak, iki farklı matematiksel işlem için fonksiyon işaretçilerini kullanan bir yapı oluşturun.",
    "answer": "#include <stdio.h>\n\n// Toplama fonksiyonu\nint toplama(int x, int y) { return x + y; }\n// Çıkarma fonksiyonu\nint cikarma(int x, int y) { return x - y; }\n\nvoid hesapla(int (*islem)(int, int), int x, int y) {\n    printf(\"Sonuç: %d\\n\", islem(x, y));\n}\n\nint main() {\n    hesapla(toplama, 10, 5);\n    hesapla(cikarma, 10, 5);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873426"
  },
  {
    "question": "Aşağıdaki kodu tamamlayarak bir dizinin elemanlarını sıralayan bir fonksiyon tanımlayın ve fonksiyon işaretçisi kullanarak bu fonksiyonu çağırın.",
    "answer": "#include <stdio.h>\n\n// İki tamsayıyı karşılaştıran fonksiyon\nint kucuktenBuyuge(int a, int b) {\n    return a - b;\n}\n\nvoid siralama(int dizi[], int boyut, int (*karsilastir)(int, int)) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = i + 1; j < boyut; j++) {\n            if (karsilastir(dizi[i], dizi[j]) > 0) {\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {4, 2, 3, 1};\n    siralama(dizi, 4, kucuktenBuyuge);\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873485"
  },
  {
    "question": "Aşağıdaki kodda eksik kısımları tamamlayarak bir fonksiyon işaretçisi ile faktöriyel hesaplayan bir yapı oluşturun.",
    "answer": "#include <stdio.h>\n\n// Faktöriyel hesaplayan fonksiyon\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int (*islem)(int);\n    islem = faktoriyel;\n    int n;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Faktöriyel: %d\\n\", islem(n));\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:04.873540"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. Bu program bir dizi üzerindeki işlemleri fonksiyon işaretçileri ile gerçekleştirecek. `int performOperation(int a, int b, int (*operation)(int, int))` fonksiyonunu tamamlayın.",
    "answer": "```c\n#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}\n\nint performOperation(int a, int b, int (*operation)(int, int)) {\n    return operation(a, b);\n}\n\nint main() {\n    int x = 5, y = 3;\n    printf(\"Toplama: %d\\n\", performOperation(x, y, add));\n    printf(\"Çıkarma: %d\\n\", performOperation(x, y, subtract));\n    return 0;\n}\n``` Bu kodda, `performOperation` fonksiyonu, iki tam sayı ve bir fonksiyon işaretçisi alarak belirtilen işlemi gerçekleştiriyor. `add` ve `subtract` fonksiyonları da temel matematiksel işlemleri tanımlıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883234"
  },
  {
    "question": "Aşağıdaki eksik `calculator` fonksiyonunu tamamlayın. Bu fonksiyon, verilen iki tamsayıyı belirtilen işlemle hesaplayacak (toplama, çıkarma, çarpma veya bölme). İşlem türü, bir fonksiyon işaretçisi ile geçilecek.",
    "answer": "```c\n#include <stdio.h>\n\nint multiply(int a, int b) {\n    return a * b;\n}\n\nint divide(int a, int b) {\n    if (b != 0) return a / b;\n    else return 0; // Hata durumu\n}\n\nint calculator(int a, int b, int (*operation)(int, int)) {\n    return operation(a, b);\n}\n\nint main() {\n    printf(\"Çarpma: %d\\n\", calculator(10, 5, multiply));\n    printf(\"Bölme: %d\\n\", calculator(10, 2, divide));\n    return 0;\n}\n``` Bu kod, matematiksel işlemleri fonksiyon işaretçileri aracılığıyla gerçekleştiriyor. `calculator` fonksiyonu, bir işlem fonksiyonu alarak iki sayıyı hesaplıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883307"
  },
  {
    "question": "Aşağıdaki kodda eksik `applyFunction` fonksiyonunu tamamlayın. Bu fonksiyon, verilen bir dizi ve fonksiyon işaretçisi ile belirtilen işlemi dizinin her elemanına uygulamalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid square(int *n) {\n    *n = (*n) * (*n);\n}\n\nvoid applyFunction(int *arr, int length, void (*func)(int *)) {\n    for(int i = 0; i < length; i++) {\n        func(&arr[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4};\n    int length = sizeof(numbers) / sizeof(numbers[0]);\n    applyFunction(numbers, length, square);\n    for(int i = 0; i < length; i++) {\n        printf(\"%d \", numbers[i]); // 1 4 9 16\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` Bu kodda, `applyFunction` fonksiyonu, her elemanı `square` fonksiyonu ile işleyerek dizinin elemanlarını karelerine dönüştürüyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883354"
  },
  {
    "question": "Aşağıdaki kodda eksik `findMax` fonksiyonunu tamamlayın. Bu fonksiyon, verilen bir dizi ve bir karşılaştırma fonksiyonu ile dizinin en büyük elemanını bulmalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nint compare(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint findMax(int *arr, int length, int (*compareFunc)(int, int)) {\n    int max = arr[0];\n    for (int i = 1; i < length; i++) {\n        max = compareFunc(max, arr[i]);\n    }\n    return max;\n}\n\nint main() {\n    int numbers[] = {3, 5, 2, 8, 1};\n    int max = findMax(numbers, 5, compare);\n    printf(\"En büyük sayı: %d\\n\", max); // 8\n    return 0;\n}\n``` Bu kodda, `findMax` fonksiyonu, verilen dizideki en büyük elemanı bulmak için bir karşılaştırma fonksiyonu kullanıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883397"
  },
  {
    "question": "Aşağıdaki kodda eksik `stringManipulator` fonksiyonunu tamamlayın. Bu fonksiyon, verilen bir dizi üzerinde belirtilen işlemi gerçekleştirmelidir (örneğin, tersten yazma).",
    "answer": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverse(char *str) {\n    int n = strlen(str);\n    for(int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nvoid stringManipulator(char *str, void (*manipulate)(char *)) {\n    manipulate(str);\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    stringManipulator(str, reverse);\n    printf(\"Ters çevrilmiş: %s\\n\", str); // abahreM\n    return 0;\n}\n``` Bu kod, `stringManipulator` fonksiyonu kullanarak verilen bir diziyi ters çeviriyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883439"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın. `processData` fonksiyonu, verilen bir dizi ve işlem fonksiyonu ile dizideki her elemanı işleme tabi tutmalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid increment(int *n) {\n    (*n)++;\n}\n\nvoid processData(int *arr, int length, void (*operation)(int *)) {\n    for (int i = 0; i < length; i++) {\n        operation(&arr[i]);\n    }\n}\n\nint main() {\n    int data[] = {1, 2, 3, 4};\n    int length = sizeof(data) / sizeof(data[0]);\n    processData(data, length, increment);\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", data[i]); // 2 3 4 5\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` Bu kodda, `processData` fonksiyonu, her elemanı `increment` fonksiyonu ile işleyerek dizinin elemanlarını bir artırıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883481"
  },
  {
    "question": "Aşağıdaki eksik `executeOperation` fonksiyonunu tamamlayın. Bu fonksiyon, belirtilen işlem türüne göre iki sayıyı işleyecek (topla, çıkar) ve sonucu dönecektir.",
    "answer": "```c\n#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}\n}\n\nint executeOperation(int a, int b, char operation) {\n    int (*func)(int, int);\n    if (operation == '+') {\n        func = add;\n    } else if (operation == '-') {\n        func = subtract;\n    }\n    return func(a, b);\n}\n\nint main() {\n    printf(\"Toplama: %d\\n\", executeOperation(7, 3, '+')); // 10\n    printf(\"Çıkarma: %d\\n\", executeOperation(7, 3, '-')); // 4\n    return 0;\n}\n``` Bu kod, işlem türüne göre uygun fonksiyon işaretçisini atayarak belirtilen işlemi gerçekleştiriyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883539"
  },
  {
    "question": "Aşağıdaki kodda eksik `filter` fonksiyonunu tamamlayın. Bu fonksiyon, verilen bir dizi ve bir filtre fonksiyonu ile dizi elemanlarını filtrelemelidir.",
    "answer": "```c\n#include <stdio.h>\n\nint isEven(int n) {\n    return n % 2 == 0;\n}\n\nvoid filter(int *arr, int length, int (*filterFunc)(int), int *result, int *resultLength) {\n    for (int i = 0; i < length; i++) {\n        if (filterFunc(arr[i])) {\n            result[(*resultLength)++] = arr[i];\n        }\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5, 6};\n    int length = sizeof(numbers) / sizeof(numbers[0]);\n    int result[6];\n    int resultLength = 0;\n    filter(numbers, length, isEven, result, &resultLength);\n    for (int i = 0; i < resultLength; i++) {\n        printf(\"%d \", result[i]); // 2 4 6\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` Bu kod, `filter` fonksiyonu ile verilen dizideki çift sayıları ayıklıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883578"
  },
  {
    "question": "Aşağıdaki kodda eksik `apply` fonksiyonunu tamamlayın. Bu fonksiyon, bir dizi üzerindeki her eleman için verilen fonksiyonu uygulamalıdır.",
    "answer": "```c\n#include <stdio.h>\n\nvoid doubleValue(int *n) {\n    *n *= 2;\n}\n\nvoid apply(int *arr, int length, void (*func)(int *)) {\n    for (int i = 0; i < length; i++) {\n        func(&arr[i]);\n    }\n}\n\nint main() {\n    int values[] = {1, 2, 3, 4};\n    int length = sizeof(values) / sizeof(values[0]);\n    apply(values, length, doubleValue);\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", values[i]); // 2 4 6 8\n    }\n    printf(\"\\n\");\n    return 0;\n}\n``` Bu kodda, `apply` fonksiyonu, verilen bir dizi üzerindeki her eleman için belirtilen işlemi gerçekleştiren bir fonksiyonu çağırıyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:46:40.883620"
  },
  {
    "question": "Function pointer kullanarak iki sayının toplamını hesaplamak istiyorum. Ancak kodda bir hata var. Kodun içeriği şöyle: `int (*func_ptr)(int, int); func_ptr = &topla; int sonuc = func_ptr(3, 5);` `topla` fonksiyonu tanımlandı ancak nasıl? Hata nerede?",
    "answer": "Hata, `topla` fonksiyonunun tanımlanmaması. Öncelikle `topla` fonksiyonunu tanımlamalısınız. Örnek: `int topla(int a, int b) { return a + b; }` Bu fonksiyonu tanımladıktan sonra kod çalışacaktır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.218537"
  },
  {
    "question": "Aşağıdaki kodda 'divide' fonksiyonu bir işlev işaretçisi olarak atanmış ama çağrılmıyor. Hatanın nedeni nedir? `double (*func_ptr)(double, double); func_ptr = divide; double result = func_ptr;`",
    "answer": "Hata, `func_ptr`'ın bir işlev işaretçisi olarak atanmış olmasına rağmen çağrılmaması. `result`'ı hesaplamak için fonksiyonu çağırmalısınız: `double result = func_ptr(10.0, 2.0);`",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.218654"
  },
  {
    "question": "Fonksiyon işaretçileri ile bir dizi üzerinde işlem yapmak istiyorum ama sonuç beklediğim gibi çıkmıyor. Kod şu şekilde: `void (*func[2])(int); func[0] = ekrana_bas; func[1] = ekrana_yaz; func[0](5);` ekrana_bas'ı tanımlamadım. Ne yapmalıyım?",
    "answer": "Hata, `ekrana_bas` fonksiyonunun tanımlanmamış olması. Öncelikle `void ekrana_bas(int a) { printf(\"%d\\n\", a); }` şeklinde fonksiyonu tanımlamalısınız. Bu şekilde `func[0]`'ı kullanmak mümkün olacaktır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.218781"
  },
  {
    "question": "Aşağıdaki kodda bir işlev işaretçisi kullanarak sıralama yapmak istiyorum ama dizinin sıralanması başarısız. Kod şu: `void (*sortFunc)(int*, int); sortFunc = bubbleSort; sortFunc(dizi, 5);` `bubbleSort` fonksiyonunu nasıl tanımlamalıyım?",
    "answer": "Hata, `bubbleSort` fonksiyonunun yanlış tanımlanması veya eksik olması olabilir. Doğru tanım şöyle olmalı: `void bubbleSort(int* dizi, int boyut) { ... }` Bu fonksiyon diziyi doğru şekilde almalı ve sıralamalıdır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.218891"
  },
  {
    "question": "Fonksiyon işaretçileri ile bir hesap makinesi yapmak istiyorum ama iki sayının çarpımını hesaplayan işlev işaretçisini atarken hata alıyorum. Kod şu: `int (*calculator)(int, int); calculator = multiply; int sonuc = calculator(4, 5);` Ama multiply tanımlı değil. Ne yapmalıyım?",
    "answer": "Hata, `multiply` fonksiyonunun tanımlanmaması. Öncelikle `int multiply(int a, int b) { return a * b; }` şeklinde fonksiyonu tanımlayıp, ardından kullanmalısınız.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219016"
  },
  {
    "question": "Aşağıdaki kodda işlev işaretçisi ile iki farklı fonksiyonu çağırmak istiyorum ama hiçbiri çalışmıyor. `void (*func_ptr)(); func_ptr = fonksiyon1; func_ptr(); func_ptr = fonksiyon2;` fonksiyonlar tanımlı değil. Ne yapmalıyım?",
    "answer": "Hata, `fonksiyon1` ve `fonksiyon2`'nin tanımlanmamış olması. Öncelikle bu fonksiyonları tanımlamalısınız. Örnek: `void fonksiyon1() { printf(\"Fonksiyon 1 çalıştı\\n\"); }` ve `void fonksiyon2() { printf(\"Fonksiyon 2 çalıştı\\n\"); }`",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219122"
  },
  {
    "question": "Dizi içindeki fonksiyon işaretçilerini kullanarak bir metin işleme uygulaması yapmak istiyorum ama sonuçlar beklediğim gibi çıkmıyor. Kod: `void (*textFunc[2])(); textFunc[0] = metin_kucult; textFunc[1] = metin_buyut; textFunc[0](metin);` Hata nerede?",
    "answer": "Hata, `metin_kucult` ve `metin_buyut` fonksiyonlarının tanımlanmamasından kaynaklanıyor. Bu fonksiyonları doğru bir şekilde tanımlamanız gerekiyor. Örneğin: `void metin_kucult(char* metin) { ... }` ve `void metin_buyut(char* metin) { ... }`",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219232"
  },
  {
    "question": "İşlev işaretçileri ile iki farklı matematiksel işlem yapmak istiyorum fakat çağırdığımda hata alıyorum. Kod: `int (*operation)(int, int); operation = islem; int sonuc = operation(5, 10);` islem tanımlı değil. Hata nasıl düzeltilir?",
    "answer": "Hata, `islem` fonksiyonunun tanımlanmaması. Öncelikle `int islem(int a, int b) { return a + b; }` şeklinde bir fonksiyon tanımlamalısınız. Böylece çalışma sırasında hata almazsınız.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219334"
  },
  {
    "question": "Fonksiyon işaretçileri ile bir dizi üzerinde işlem yapmak istiyorum ama sonuçlar doğru gelmiyor. Kod: `void (*func_ptr[3])(int); func_ptr[0] = fonksiyonA; func_ptr[1] = fonksiyonB; func_ptr[2] = fonksiyonC; func_ptr[0](10);` fonksiyonlar tanımlı değil. Ne yapmalıyım?",
    "answer": "Hata, `fonksiyonA`, `fonksiyonB` ve `fonksiyonC`'nin tanımlanmaması. Öncelikle bu fonksiyonları tanımlamalısınız. Örneğin: `void fonksiyonA(int a) { printf(\"Fonksiyon A: %d\\n\", a); }` ve diğer fonksiyonlar benzer şekilde tanımlanmalı.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219464"
  },
  {
    "question": "Fonksiyon işaretçileri ile bir karakter dizisinde işlem yapmak istiyorum ama dizinin uzunluğunu hesapladığımda hata alıyorum. Kod: `int (*lengthFunc)(char*); lengthFunc = uzunlukHesapla; int uzunluk = lengthFunc(dizi);` uzunlukHesapla tanımlı değil. Hata nasıl düzeltilir?",
    "answer": "Hata, `uzunlukHesapla` fonksiyonunun tanımlanmaması. Öncelikle `int uzunlukHesapla(char* dizi) { return strlen(dizi); }` şeklinde bir fonksiyon tanımlamalısınız. Böylece dizinin uzunluğunu doğru şekilde hesaplayabilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:03.219590"
  },
  {
    "question": "Bir function pointer'ı tanımladıktan sonra işlevini çağırmak için nasıl kullanılır?",
    "answer": "Function pointer'ı tanımladıktan sonra, işlevi çağırmak için pointer'ı işlevin adı gibi kullanmalısınız. Örneğin:\n\n```c\n#include <stdio.h>\n\nvoid selamla() {\n    printf(\"Merhaba, dünya!\\n\");\n}\n\nint main() {\n    void (*fonksiyonPtr)() = selamla;\n    fonksiyonPtr(); // selamla() işlevini çağırıyor\n    return 0;\n}\n``` \nBurada, `selamla` işlevinin adresi `fonksiyonPtr`'a atanır ve daha sonra bu pointer kullanılarak işlev çağrılır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962783"
  },
  {
    "question": "Function pointer kullanırken yanlış bir işlev türüyle nasıl hata alırsınız?",
    "answer": "Eğer bir function pointer'ı yanlış türde bir işleve atanırsa, bu derleyici hata mesajlarına yol açabilir. Örneğin:\n\n```c\nvoid fonksiyon() {}\nint main() {\n    void (*ptr)() = (int (*)())fonksiyon; // Hatalı atama\n    return 0;\n}\n``` \nBurada `ptr` int döndüren bir işlev olarak tanımlanmıştır, oysa `fonksiyon` void döndürmektedir. Bu durumda belirsiz davranışa yol açabilir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962823"
  },
  {
    "question": "Bir function pointer'ı bir dizi elemanı olarak nasıl kullanabilirsiniz?",
    "answer": "Function pointer'ları bir dizi içinde saklamak, farklı işlevleri dinamik olarak çağırmak için kullanılabilir. Örneğin:\n\n```c\n#include <stdio.h>\n\nvoid a() { printf(\"A\\n\"); }\nvoid b() { printf(\"B\\n\"); }\n\nint main() {\n    void (*fonksiyonlar[2])() = {a, b};\n    for (int i = 0; i < 2; i++) {\n        fonksiyonlar[i](); // A ve B'yi sırasıyla çağırır\n    }\n    return 0;\n}\n``` \nBurada, `fonksiyonlar` dizisi iki işlev pointer'ı içermektedir ve bir döngü ile işlevler çağrılmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962856"
  },
  {
    "question": "Neden bir function pointer'ı null değerine ayarlamak iyi bir uygulamadır?",
    "answer": "Function pointer'ları null değerine ayarlamak, belirli bir işlevin atanmadığını belirtmek için iyi bir uygulamadır. Bu, programın ilerleyen bölümlerinde çağrılmaya çalışıldığında beklenmedik hataların önüne geçer. Örneğin:\n\n```c\n#include <stdio.h>\n\nvoid (*fonksiyonPtr)() = NULL;\n\nint main() {\n    if (fonksiyonPtr != NULL) {\n        fonksiyonPtr(); // Null kontrolü\n    } else {\n        printf(\"Fonksiyon atanmadı.\\n\");\n    }\n    return 0;\n}\n``` \nBurada, `fonksiyonPtr` null olduğu için çağrılmadan önce kontrol ediliyor.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962882"
  },
  {
    "question": "Function pointer'ları kullanarak bir matematiksel işlemler menüsü nasıl oluşturabilirsiniz?",
    "answer": "Çeşitli matematiksel işlevleri çağırmak için function pointer'ları kullanarak bir menü oluşturabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) { return a + b; }\nint cikarma(int a, int b) { return a - b; }\n\nint main() {\n    int (*islemler[2])(int, int) = {toplama, cikarma};\n    int sonuc = islemler[0](5, 3); // Toplama işlemi\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n``` \nBurada, `islemler` dizisi iki farklı matematiksel işlemi içermektedir, ve belirtilen indekse göre işlev çağrılmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962908"
  },
  {
    "question": "C dilinde bir function pointer'ı bir başka function pointer'a nasıl atarsınız?",
    "answer": "Bir function pointer'ı diğerine atamak mümkündür. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid merhaba() { printf(\"Merhaba!\\n\"); }\n\nint main() {\n    void (*ptr1)() = merhaba;\n    void (**ptr2)() = &ptr1;\n    (*ptr2)(); // merhaba() işlevini çağırır\n    return 0;\n}\n``` \nBurada `ptr1`, `ptr2` aracılığıyla çağrılmaktadır. İkinci pointer, ilk pointer'ın adresini tutar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962937"
  },
  {
    "question": "Bir işlevde function pointer'ı parametre olarak nasıl geçirebilirsiniz?",
    "answer": "Function pointer'ları işlev parametreleri olarak geçilebilir. Bu, işlevin farklı işlevleri çağırmasına olanak tanır. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid islemYap(int (*ilkIslem)(int, int), int a, int b) {\n    printf(\"Sonuç: %d\\n\", ilkIslem(a, b));\n}\n\nint toplama(int x, int y) { return x + y; }\n\nint main() {\n    islemYap(toplama, 5, 3); // Toplama işlevini geçiriyoruz\n    return 0;\n}\n``` \nBurada `islemYap` işlevi, bir işlev pointer'ı ve iki tam sayı alır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962961"
  },
  {
    "question": "Function pointer kullanarak bir dizi üzerinde işlem yapmanın avantajları nelerdir?",
    "answer": "Function pointer kullanarak bir dizi üzerinde işlem yapmak, esneklik sağlar. Örneğin, farklı işlevleri dinamik olarak çağırabiliriz. Bu, kodun tekrar kullanılabilirliğini artırır ve bakımı kolaylaştırır:\n\n```c\n#include <stdio.h>\n\nvoid karesiniAl(int x) { printf(\"%d\\n\", x * x); }\nvoid kupunuAl(int x) { printf(\"%d\\n\", x * x * x); }\n\nint main() {\n    void (*fonksiyonlar[2])(int) = {karesiniAl, kupunuAl};\n    for (int i = 0; i < 2; i++) {\n        fonksiyonlar[i](5); // 5'in karesi ve küpü\n    }\n    return 0;\n}\n``` \nBu örnekte, iki farklı işlevi çağırarak her biri için farklı işlemler yapılmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.962987"
  },
  {
    "question": "Function pointer'lar ile callback mekanizmasını nasıl uygulayabilirsiniz?",
    "answer": "Callback mekanizması, bir işlevin başka bir işlevi parametre olarak alması durumunda kullanılır. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid callbackFonksiyonu(int x) {\n    printf(\"Callback: %d\\n\", x);\n}\n\nvoid anaFonksiyon(void (*cb)(int), int deger) {\n    cb(deger); // Callback işlevini çağır\n}\n\nint main() {\n    anaFonksiyon(callbackFonksiyonu, 10);\n    return 0;\n}\n``` \nBurada `anaFonksiyon`, `callbackFonksiyonu`'nu parametre olarak alır ve çağırır, bu da callback mekanizmasının bir örneğidir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.963009"
  },
  {
    "question": "Function pointer'lar ve struct'lar nasıl bir arada kullanılabilir?",
    "answer": "Struct'lar içinde function pointer'lar tanımlamak, daha karmaşık veri yapıları oluşturmanıza olanak tanır. Örnek:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*yazdir)();\n} Yazici;\n\nvoid merhaba() { printf(\"Merhaba!\\n\"); }\n\nint main() {\n    Yazici y;\n    y.yazdir = merhaba;\n    y.yazdir(); // Merhaba işlevini çağır\n    return 0;\n}\n``` \nBurada, `Yazici` adında bir struct tanımlanmış ve içinde bir function pointer bulunmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:47:33.963033"
  },
  {
    "question": "Bir function pointer'ın doğru bir şekilde tanımlanıp kullanılmadığı bir durumda oluşan hatayı düzeltin. Kod: void (*funcPtr)(); funcPtr();",
    "answer": "Hata, 'funcPtr' işaretçisinin henüz herhangi bir fonksiyonu işaret etmemesidir. İlk önce bir fonksiyona atanması gerekir. Düzeltmek için öncelikle bir fonksiyon tanımlayıp, ardından işaretçiyi o fonksiyona atayın. Örneğin:\n\nvoid myFunction() { printf(\"Hello, World!\\n\"); }\nvoid (*funcPtr)() = myFunction; funcPtr();",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.087766"
  },
  {
    "question": "Fonksiyon işaretçisinin yanlış bir türdeki fonksiyona atandığı bir durumu düzeltin. Kod: void myFunc(int a) {} void (*funcPtr)() = myFunc; funcPtr();",
    "answer": "Hata, 'myFunc' fonksiyonu bir int parametre alırken, 'funcPtr' işaretçisi parametresiz bir fonksiyona işaret ediyor. Bunu düzeltmek için işaretçiyi uygun türde fonksiyona atamak gerekir. Örneğin:\n\nvoid myFunc(int a) { printf(\"Value: %d\\n\", a); }\nvoid (*funcPtr)(int) = myFunc; funcPtr(5);",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.087829"
  },
  {
    "question": "Bir fonksiyon işaretçisini kullanarak bir dizi üzerinde işlem yapmak istiyorsanız ancak işaretçinin dizinin elemanlarını işaret etmediği bir kodda hata alıyorsunuz. Düzeltin. Kod: void processArray(int *arr) {} void (*funcPtr)(int *) = processArray; funcPtr();",
    "answer": "Hata, 'processArray' fonksiyonuna geçirilmesi gereken dizi işaretçisinin verilmemesidir. Düzeltmek için bir dizi tanımlayıp, işaretçiyi bu dizi ile çağırmalısınız. Örneğin:\n\nvoid processArray(int *arr) { for(int i = 0; i < 5; i++) printf(\"%d \", arr[i]); }\nint main() { int arr[5] = {1, 2, 3, 4, 5}; funcPtr(arr); }",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.087901"
  },
  {
    "question": "Bir fonksiyon işaretçisini birden fazla fonksiyona atamak istediğinizde, tür uyumsuzluğu hatası alıyorsunuz. Düzeltin. Kod: void funcA() {} void funcB() {} void (*funcPtr)() = funcA; funcPtr = funcB;",
    "answer": "Bu kod doğru çalışır çünkü her iki fonksiyon da aynı türdedir. Ancak, işaretçiyi yanlış bir şekilde kullanmaya çalışırsanız hata alırsınız. Bu durumda, işaretçinin her iki fonksiyonu da işaret edebilmesi için türlerinin aynı olduğundan emin olun. Eğer türler farklıysa, her iki fonksiyonu da aynı türde işaret eden bir işaretçi tanımlayın.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.087975"
  },
  {
    "question": "Fonksiyon işaretçisinin bir dizi elemanı olarak kullanıldığı bir durumda, işaretçinin adresinin yanlış alındığı bir hata var. Düzeltin. Kod: void myFunc() {} void (*funcArr[3])() = {myFunc}; funcArr[0];",
    "answer": "Bu kodda, 'funcArr' dizisi oluşturulmuş ancak sadece ilk eleman atanmış. Düzeltmek için dizinin diğer elemanlarını da tanımlayın. Örneğin:\n\nvoid myFuncA() { printf(\"A\\n\"); }\nvoid myFuncB() { printf(\"B\\n\"); }\nvoid (*funcArr[3])() = {myFuncA, myFuncB, NULL}; funcArr[0]();",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088031"
  },
  {
    "question": "Bir fonksiyon işaretçisinden dönen bir fonksiyonu çağırmak istediğinizde, dönüş değerini yanlış kullandığınız bir örnek var. Düzeltin. Kod: int myFunc() { return 5; } int (*funcPtr)() = myFunc; int result = funcPtr(); printf(\"Result: %d\\n\", result);",
    "answer": "Kod doğru çalışıyor. Ancak, eğer işaretçiyi yanlış kullanarak dönüş değerini kaybederseniz hata alabilirsiniz. Düzeltmek için 'result' değişkeni ile işaretçiyi çağırdıktan sonra dönüş değerini kullanmalısınız. Yukarıdaki kod doğru. Eğer işaretçi NULL olsaydı, kontrol ekleyerek bu durumu düzeltmelisiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088102"
  },
  {
    "question": "Fonksiyon işaretçisinin bir yapı içinde depolandığı bir senaryoda adresin yanlış alındığı bir hata var. Düzeltin. Kod: struct FuncHolder { void (*funcPtr)(); }; struct FuncHolder holder; holder.funcPtr = NULL; holder.funcPtr();",
    "answer": "Burada 'holder.funcPtr' için NULL atanmış ve bu nedenle çağrıldığında hata alırsınız. Düzeltmek için önce bir fonksiyon atayın. Örneğin:\n\nvoid myFunction() { printf(\"Function called!\\n\"); }\nstruct FuncHolder holder; holder.funcPtr = myFunction; holder.funcPtr();",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088164"
  },
  {
    "question": "Fonksiyon işaretçisinin kullanımında, yerel bir değişkenin ömrü sona erdiğinde oluşan hatayı düzeltin. Kod: void createFuncPtr() { void myFunc() { printf(\"Hi!\\n\"); } void (*funcPtr)() = myFunc; } funcPtr();",
    "answer": "Bu kodda 'myFunc' yerel bir fonksiyon olduğu için 'funcPtr' döndüğünde geçersiz olur. Düzeltmek için 'myFunc' fonksiyonunu dışarıda tanımlayın. Örneğin:\n\nvoid myFunc() { printf(\"Hi!\\n\"); }\nvoid (*funcPtr)() = myFunc; funcPtr();",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088224"
  },
  {
    "question": "Bir fonksiyon işaretçisini farklı türdeki parametrelerle kullanmaya çalıştığınızda hata alıyorsunuz. Düzeltin. Kod: void myFunc(char *str) { printf(\"%s\\n\", str); } void (*funcPtr)() = myFunc; funcPtr(\"Hello\");",
    "answer": "Hata, 'funcPtr' işaretçisinin parameatre türü ile uyuşmamasıdır. Düzeltmek için işaretçiyi doğru tanımlayın. Örneğin:\n\nvoid myFunc(char *str) { printf(\"%s\\n\", str); }\nvoid (*funcPtr)(char *) = myFunc; funcPtr(\"Hello\");",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088282"
  },
  {
    "question": "Bir dizi içinde fonksiyon işaretçilerini kullanarak çağırma yaparken, işaretçilerin yanlış dizinlere erişim sağladığı bir hata ile karşılaşıyorsunuz. Düzeltin. Kod: void func1() { printf(\"Func1\\n\"); } void func2() { printf(\"Func2\\n\"); } void (*funcArr[2])() = {func1, func2}; funcArr[2]();",
    "answer": "Hata, dizinin sınırlarının dışına erişilmesidir. Dizi 2 elemanlı olduğu için son eleman 1'dir. Düzeltmek için doğru dizinleri kullanmalısınız. Örneğin:\n\nvoid (*funcArr[2])() = {func1, func2}; funcArr[0](); funcArr[1]();",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:00.088360"
  },
  {
    "question": "Function pointer nedir?",
    "answer": "Function pointer, bir fonksiyonun adresini tutabilen bir işaretçidir. C dilinde fonksiyonlar, bellekte bir adresle temsil edilir ve bu adresi saklamak için pointerlar kullanılır. Bu sayede, bir fonksiyonu dinamik olarak çağırabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942297"
  },
  {
    "question": "Function pointer'ları nasıl tanımlarız?",
    "answer": "Function pointer tanımlarken, öncelikle fonksiyonun dönüş tipi ve parametre tipi belirtilmelidir. Örneğin, int döndüren ve iki int parametre alan bir fonksiyon pointer'ı şöyle tanımlanır: 'int (*funcPtr)(int, int);'. Burada 'funcPtr', fonksiyonun adresini tutacak olan pointer'dır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942335"
  },
  {
    "question": "Function pointer'ları nasıl kullanılır?",
    "answer": "Function pointer kullanmak için önce bir fonksiyona işaret eden bir pointer oluşturmalıyız. Örneğin, 'funcPtr = &topla;' şeklinde, 'topla' fonksiyonunun adresini aldığımızda, 'funcPtr(3, 4);' ile bu fonksiyonu çağırabiliriz. Burada '3' ve '4' toplama işlemi için parametrelerdir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942352"
  },
  {
    "question": "Function pointer'ların avantajları nelerdir?",
    "answer": "Function pointer'lar, kodu daha esnek hale getirir. Örneğin, bir işlevi değiştirmek veya belirli bir fonksiyonu dinamik olarak seçmek için kullanabilirsiniz. Ayrıca, callback fonksiyonları ve olay yönlendirmeleri gibi senaryolar için idealdirler.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942370"
  },
  {
    "question": "Fonksiyon pointer'ları ile callback fonksiyonu nasıl oluşturulur?",
    "answer": "Callback fonksiyonu oluşturmak için bir fonksiyon pointer'ı tanımlayıp, bu pointer'ı bir başka fonksiyona parametre olarak geçebilirsiniz. Örneğin, 'void islemYap(int a, int b, int (*func)(int, int))' şeklinde bir fonksiyon oluşturup, 'func' ile farklı işlemlerin gerçekleştirilmesini sağlayabilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942393"
  },
  {
    "question": "Bir dizi içinde function pointer nasıl tanımlanır?",
    "answer": "Bir dizi içinde function pointer tanımlamak için, öncelikle function pointer türünü belirleyip ardından bir dizi oluşturmalısınız. Örneğin, 'int (*funcArray[3])(int, int);' şeklinde tanımlayıp, daha sonra bu diziye farklı fonksiyonların adreslerini atayabilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942413"
  },
  {
    "question": "Function pointer'lar ile matematiksel işlemler nasıl yapılır?",
    "answer": "Matematiksel işlemleri function pointer ile yapmak için, her bir işlemi gerçekleştiren fonksiyonlar tanımlayıp, bu fonksiyonları bir pointer dizisine atayabilirsiniz. Örneğin, toplama, çıkarma, çarpma ve bölme işlemleri için ayrı fonksiyonlar oluşturup, ihtiyaca göre bu fonksiyonları çağırabilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942437"
  },
  {
    "question": "Function pointer kullanarak bir seçim menüsü nasıl oluşturulur?",
    "answer": "Seçim menüsü oluşturmak için, her bir seçeneği temsil eden fonksiyonları tanımlayıp, bu fonksiyonların adreslerini bir array'e yerleştirebilirsiniz. Kullanıcıdan seçim alıp, ilgili fonksiyon pointer'ını çağırarak menü işlemlerini gerçekleştirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942458"
  },
  {
    "question": "Function pointer ile dinamik bellek yönetimi nasıl yapılır?",
    "answer": "Fonksiyon pointer kullanarak dinamik bellek yönetimi gerçekleştirmek için, bellek alanı tahsis eden bir fonksiyon tanımlayıp, ardından bu fonksiyonun adresini bir pointer'a atayabilirsiniz. Bu sayede, bellek tahsisini dinamik olarak kontrol edebilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942486"
  },
  {
    "question": "Function pointer ile çoklu fonksiyon çağrısı nasıl yapılır?",
    "answer": "Çoklu fonksiyon çağrısı yapmak için bir fonksiyon pointer dizisi oluşturup, her bir elemana farklı fonksiyon adreslerini atayabilirsiniz. Daha sonra döngü kullanarak bu dizideki tüm fonksiyonları çağırabilirsiniz, bu sayede kod tekrarı önlenmiş olur.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942531"
  },
  {
    "question": "Function pointer'lar ile hata ayıklama işlemleri nasıl yapılır?",
    "answer": "Hata ayıklama işlemleri için, fonksiyon pointer kullanarak hata kontrol fonksiyonları tanımlayabilirsiniz. Örneğin, bir işlem sonrası hata kontrolü yapmak için 'void (*hataKontrol)(int)' şeklinde bir fonksiyon pointer'ı oluşturup, bu pointer ile hata kontrol fonksiyonunu dinamik olarak çağırabilirsiniz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:13.942555"
  },
  {
    "question": "Fonksiyon işaretçileri (function pointers) nedir ve ne amaçla kullanılır?",
    "answer": "Fonksiyon işaretçileri, C dilinde bir fonksiyonu işaret eden değişkenlerdir. Bu işaretçi sayesinde fonksiyonları dinamik olarak çağırabiliriz. Örneğin, bir dizi içinde farklı fonksiyonları saklayarak, ihtiyaç duyduğumuzda bu fonksiyonları çağırabiliriz. Bu özellik, özellikle callback fonksiyonlarında ve fonksiyon tabanlı programlamada oldukça yararlıdır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906291"
  },
  {
    "question": "Function pointer nasıl tanımlanır ve kullanılır?",
    "answer": "Function pointer tanımlamak için, işaretçi değişkeninin tipini ve fonksiyonun tipini belirtmemiz gerekiyor. Örneğin, int tipinde bir fonksiyon işaretçisi tanımlamak için: 'int (*funcPtr)(int, int);'. Daha sonra bu işaretçiyi bir fonksiyona atayarak kullanabiliriz. Örnek: 'funcPtr = toplama;'. Kullanım: 'int sonuc = funcPtr(3, 4);'.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906341"
  },
  {
    "question": "Bir dizi içerisindeki fonksiyon işaretçilerini nasıl kullanabiliriz?",
    "answer": "Fonksiyon işaretçilerini bir dizi içinde kullanarak, birden fazla işlemi dinamik olarak çağırabiliriz. Örneğin, bir dizi içerisinde toplama ve çıkarma fonksiyonlarını saklayabiliriz. Aşağıdaki örnekte, fonksiyon işaretçilerini kullanarak dinamik bir hesaplama yapıyoruz: \n\n```c\ntypedef int (*operation)(int, int);\noperation ops[2];\nops[0] = toplama;\nops[1] = cikarma;\nint sonuc = ops[0](3, 4); // toplama\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906380"
  },
  {
    "question": "Callback fonksiyonları ve function pointerlar arasındaki ilişki nedir?",
    "answer": "Callback fonksiyonları, bir fonksiyonun parametre olarak başka bir fonksiyonu almasıdır. Function pointerlar bu fonksiyonları temsil etmek için kullanılır. Örneğin, bir sıralama fonksiyonu, elemanları nasıl sıralayacağına dair bir fonksiyon işaretçisi alabilir. Bu sayede farklı sıralama algoritmaları arasında geçiş yapabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906418"
  },
  {
    "question": "Fonksiyon işaretçileri ile uygulama modülerliğini nasıl artırabiliriz?",
    "answer": "Fonksiyon işaretçileri, uygulama içinde modülerliği artırarak, kodun okunabilirliğini ve bakımını kolaylaştırır. Örneğin, bir uygulamada kullanıcıdan gelen verilere göre farklı işlem yapan fonksiyonlar varsa, bu fonksiyonları işaretçi dizisi ile yönetebiliriz. Böylece yeni fonksiyonlar eklemek çok kolay hale gelir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906454"
  },
  {
    "question": "Fonksiyon işaretçileri kullanarak bir hesap makinesi uygulaması nasıl yapılır?",
    "answer": "Fonksiyon işaretçileri ile basit bir hesap makinesi uygulaması yapabiliriz. İşte adım adım bir örnek:\n\n```c\n#include <stdio.h>\n\nint toplama(int a, int b) { return a + b; }\nint cikarma(int a, int b) { return a - b; }\n\nint main() {\n    int (*hesapla)(int, int);\n    hesapla = toplama;\n    printf(\"Toplama: %d\\n\", hesapla(5, 3));\n    hesapla = cikarma;\n    printf(\"Çıkarma: %d\\n\", hesapla(5, 3));\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906495"
  },
  {
    "question": "Fonksiyon işaretçileri kullanarak dinamik bir dizinin elemanlarını nasıl işleyebiliriz?",
    "answer": "Fonksiyon işaretçileri ile dinamik diziler üzerinde işlem yaparak daha esnek bir yapı oluşturabiliriz. Örneğin, bir dizi oluşturup bu dizi üzerinde farklı fonksiyonlar ile işlem yapabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid elemanYaz(int *dizi, int boyut) {\n    for(int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int *dizi = malloc(5 * sizeof(int));\n    for(int i = 0; i < 5; i++) {\n        dizi[i] = i + 1;\n    }\n    void (*fonksiyon)(int*, int);\n    fonksiyon = elemanYaz;\n    fonksiyon(dizi, 5);\n    free(dizi);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906553"
  },
  {
    "question": "C dilinde bir fonksiyonun geri dönüş değerini, işaretçi ile nasıl değiştirebiliriz?",
    "answer": "Fonksiyon işaretçileri kullanarak, bir fonksiyonu çağırdıktan sonra geri dönüş değerini değiştirmek mümkündür. Bunu yapmak için, fonksiyonun geri dönüş değerini bir işaretçi aracılığıyla iletebiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n\nvoid ikiKat(int sayi, int *sonuc) {\n    *sonuc = sayi * 2;\n}\n\nint main() {\n    int sonuc;\n    ikiKat(5, &sonuc);\n    printf(\"Sonuç: %d\\n\", sonuc);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906598"
  },
  {
    "question": "Fonksiyon işaretçilerini kullanarak bir dizi üzerinde sıralama işlemi nasıl yapılabilir?",
    "answer": "Fonksiyon işaretçileri ile sıralama algoritmalarını dinamik olarak uygulayabiliriz. Örneğin, bir dizi üzerinde sıralama işlemi yapmak için iki farklı sıralama fonksiyonu tanımlayıp, bir işaretçi ile hangisini kullanacağımıza karar verebiliriz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int *dizi, int boyut) {\n    // Seçim sıralama algoritması\n}\nvoid bubbleSort(int *dizi, int boyut) {\n    // Kabarcık sıralama algoritması\n}\n\nvoid sirala(int *dizi, int boyut, void (*siralama)(int*, int)) {\n    siralama(dizi, boyut);\n}\n\nint main() {\n    int dizi[] = {5, 2, 9, 1, 5};\n    int boyut = 5;\n    sirala(dizi, boyut, selectionSort);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906640"
  },
  {
    "question": "Function pointer'lar ile çoklu işlem yaparken dikkat edilmesi gereken noktalar nelerdir?",
    "answer": "Function pointer'lar kullanırken dikkat edilmesi gereken en önemli noktalar, işaretçilerin doğru tipteki fonksiyonlara atanması ve işaretçinin NULL olup olmadığını kontrol etmektir. Ayrıca, işaretçi ile çağırılacak fonksiyonu çağırmadan önce işaretçinin geçerli bir adres gösterdiğinden emin olmamız gerekir. Aksi takdirde program hatası alabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:48:43.906686"
  },
  {
    "question": "Function pointer nedir ve nasıl kullanılır?",
    "answer": "Function pointer, bir fonksiyonun adresini tutan bir işaretçidir. Örneğin, bir fonksiyonu bir değişken gibi kullanmak istediğimizde function pointer kullanabiliriz. Fonksiyonun adresini elde etmek için fonksiyonun ismini kullanırız. Örnek: \n\n```c\n#include <stdio.h>\n\nvoid selamla() {\n    printf(\"Merhaba!\\n\");\n}\n\nint main() {\n    void (*func_ptr)(); // Function pointer tanımlama\n    func_ptr = selamla; // Function pointer'a fonksiyon atama\n    func_ptr(); // Fonksiyonu çağırma\n    return 0;\n}\n```\nBu kodda `func_ptr` bir function pointer'dır ve `selamla` fonksiyonunu çağırmak için kullanılır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062140"
  },
  {
    "question": "Function pointer kullanarak bir dizi içinde farklı fonksiyonlar çağırabilir miyim?",
    "answer": "Evet, function pointer kullanarak bir dizi içinde farklı fonksiyonları saklayabilir ve çağırabilirsiniz. Aşağıdaki örnekte, farklı matematiksel fonksiyonları bir array içinde saklıyoruz:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\nint main() {\n    int (*func_ptr[2])(int, int); // Fonksiyon pointer dizisi\n    func_ptr[0] = topla; // 1. fonksiyon\n    func_ptr[1] = carp;  // 2. fonksiyon\n    printf(\"Toplama: %d\\n\", func_ptr[0](3, 4)); // Çıktı: 7\n    printf(\"Çarpma: %d\\n\", func_ptr[1](3, 4)); // Çıktı: 12\n    return 0;\n}\n```\nBu örnekte, `func_ptr` dizisi toplama ve çarpma fonksiyonlarını içerir. İlgili fonksiyonlar, diziden çağrılarak kullanılır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062182"
  },
  {
    "question": "Fonksiyon pointer'ları ile callback mekanizması nasıl oluşturabilirim?",
    "answer": "Callback, bir fonksiyonun başka bir fonksiyona argüman olarak geçilmesiyle elde edilir. Aşağıdaki örnekte, bir işlem fonksiyonuna callback olarak bir fonksiyon gönderiyoruz:\n\n```c\n#include <stdio.h>\n\nvoid islem(int a, int b, int (*fonk)(int, int)) {\n    printf(\"Sonuç: %d\\n\", fonk(a, b));\n}\n\nint topla(int a, int b) { return a + b; }\n\nint main() {\n    islem(5, 3, topla); // Callback olarak toplama fonksiyonunu geçiriyoruz.\n    return 0;\n}\n```\nBurada `islem` fonksiyonu, hangi işlemi yapacağına `fonk` parametresi aracılığıyla karar verir. Bu şekilde farklı işlemler için aynı fonksiyonu kullanabiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062208"
  },
  {
    "question": "Fonksiyon pointer'ları ile dinamik bir dizi oluşturabilir miyim?",
    "answer": "Evet, dinamik olarak oluşturulmuş bir dizi içinde fonksiyon pointer'ları saklayabiliriz. Aşağıdaki örnekte, kullanıcıdan alınan sayıya göre fonksiyon pointer dizisi oluşturuluyor:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\nint main() {\n    int n;\n    printf(\"Kaç fonksiyon gireceksiniz? \");\n    scanf(\"%d\", &n);\n    int (*func_ptr[n])(int, int); // Dinamik fonksiyon pointer dizisi\n    func_ptr[0] = topla;\n    func_ptr[1] = carp;\n    printf(\"Toplama: %d\\n\", func_ptr[0](5, 10));\n    printf(\"Çarpma: %d\\n\", func_ptr[1](5, 10));\n    return 0;\n}\n```\nBu örnek, kullanıcının belirlediği sayıda fonksiyon pointer saklamaya olanak tanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062230"
  },
  {
    "question": "C dilinde yüksek dereceli fonksiyonlar (higher-order functions) nasıl uygulanır?",
    "answer": "Yüksek dereceli fonksiyonlar, başka bir fonksiyonu parametre olarak alan veya bir fonksiyonu döndüren fonksiyonlardır. Aşağıdaki örnek, bir fonksiyonu döndüren bir fonksiyonu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint (*fonksiyonSec(int secim))(int, int) {\n    if (secim == 1) return topla;\n    else return carp;\n}\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\nint main() {\n    int (*secilen_fonk)(int, int);\n    secilen_fonk = fonksiyonSec(1); // Toplama fonksiyonunu al\n    printf(\"Sonuç: %d\\n\", secilen_fonk(5, 3));\n    return 0;\n}\n```\nBu örnekte `fonksiyonSec`, seçim parametresine göre uygun fonksiyonu döndürür.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062257"
  },
  {
    "question": "C dilinde fonksiyon pointer'ları ile hata yönetimi nasıl yapılır?",
    "answer": "Fonksiyon pointer'ları, hata yönetimi yaparken belirli bir hata durumunda alternatif bir fonksiyon çağırmak için kullanılabilir. Aşağıdaki örnek, hata durumu için bir hata fonksiyonu kullanmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid hataMesaji() {\n    printf(\"Bir hata oluştu!\\n\");\n}\n\nvoid fonksiyon(int a, void (*hata_fonk)()) {\n    if (a < 0) {\n        hata_fonk(); // Hata fonksiyonunu çağır\n    } else {\n        printf(\"Değer: %d\\n\", a);\n    }\n}\n\nint main() {\n    fonksiyon(-1, hataMesaji); // Hata durumunda çağırılır\n    return 0;\n}\n```\nBu örnekte, `fonksiyon` negatif bir değer aldığında hata mesajı fonksiyonunu çağırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062281"
  },
  {
    "question": "Fonksiyon pointer'ları ile çoklu işlemler nasıl gerçekleştirilir?",
    "answer": "Fonksiyon pointer'ları ile çoklu işlemleri tek bir fonksiyonda birleştirmek mümkündür. Aşağıda, işlemlerin bir dizide saklanarak dinamik olarak seçilmesi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\nvoid islemYap(int a, int b, int (*func_ptr[])(int, int), int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        printf(\"Sonuç %d: %d\\n\", i + 1, func_ptr[i](a, b));\n    }\n}\n\nint main() {\n    int (*func_ptr[])(int, int) = {topla, carp};\n    islemYap(3, 4, func_ptr, 2); // İki işlemi de yap\n    return 0;\n}\n```\nBu örnekte, `islemYap` fonksiyonu, fonksiyon pointer dizisi aracılığıyla her iki işlemi de gerçekleştirir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062302"
  },
  {
    "question": "C dilinde fonksiyon pointer'ları ile veri yapıları nasıl yönetilir?",
    "answer": "Fonksiyon pointer'ları, veri yapıları içinde fonksiyonları saklamak için kullanılabilir. Örneğin, bir `struct` içinde fonksiyon pointer tanımlayarak veri yapısına fonksiyon ekleyebiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    int (*islem)(int, int);\n} VeriYapisi;\n\nint topla(int a, int b) { return a + b; }\n\nint main() {\n    VeriYapisi v;\n    v.islem = topla; // Fonksiyon pointer atama\n    printf(\"Sonuç: %d\\n\", v.islem(2, 3)); // Fonksiyonu kullanma\n    return 0;\n}\n```\nBu örnekte, `VeriYapisi` içinde bir fonksiyon pointer'ı saklanmakta ve kullanılmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062325"
  },
  {
    "question": "Fonksiyon pointer'ları ile event-driven programlama nasıl yapılır?",
    "answer": "Event-driven programlama, olayları dinlemek ve bunlara tepki vermek üzerine kuruludur. Fonksiyon pointer'ları, olaylara karşılık gelen fonksiyonları saklamak için kullanılabilir. Aşağıdaki örnekte bir olay sistemi tasarlanmıştır:\n\n```c\n#include <stdio.h>\n\nvoid olayA() { printf(\"Olay A gerçekleşti!\\n\"); }\nvoid olayB() { printf(\"Olay B gerçekleşti!\\n\"); }\n\ntypedef void (*OlayFonksiyonu)();\n\nvoid olayYonetici(OlayFonksiyonu olay) {\n    olay(); // Olay fonksiyonunu çağır\n}\n\nint main() {\n    olayYonetici(olayA); // Olay A'yı yönet\n    olayYonetici(olayB); // Olay B'yi yönet\n    return 0;\n}\n```\nBu örnekte, `olayYonetici` fonksiyonu, geçilen olay fonksiyonunu çağırır ve bu şekilde olaylara tepki verir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:49:17.062348"
  },
  {
    "question": "C dilinde iki sayıyı toplayan bir fonksiyon tanımlayın ve bu fonksiyonu bir function pointer kullanarak çağırın.",
    "answer": "Öncelikle, iki sayıyı toplayan bir fonksiyon tanımlayalım:\n\n```c\nint topla(int a, int b) {\n    return a + b;\n}\n```\nDaha sonra, bu fonksiyonu çağırmak için bir function pointer tanımlayalım:\n\n```c\nint (*islem)(int, int);\n\nislem = topla;\nint sonuc = islem(5, 3);\nprintf(\"Sonuç: %d\\n\", sonuc);\n```\nBurada 'islem' adında bir function pointer tanımlıyoruz ve 'topla' fonksiyonuna atıyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470076"
  },
  {
    "question": "Bir dizi üzerinde işlem yapmak için function pointerları nasıl kullanabilirsiniz? Örnek bir uygulama gösterin.",
    "answer": "Bir dizi elemanlarını üç farklı şekilde işlemek için üç fonksiyon tanımlayalım: toplama, çarpma ve çıkarma. \n\n```c\nvoid diziIsle(int *dizi, int boyut, int (*islem)(int, int)) {\n    int sonuc = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        sonuc = islem(sonuc, dizi[i]);\n    }\n    printf(\"Sonuç: %d\\n\", sonuc);\n}\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\nint cikart(int a, int b) { return a - b; }\n```\nDaha sonra bu fonksiyonu şu şekilde çağırabiliriz:\n\n```c\nint dizi[] = {1, 2, 3, 4};\ndiziIsle(dizi, 4, topla);\ndiziIsle(dizi, 4, carp);\ndiziIsle(dizi, 4, cikart);\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470124"
  },
  {
    "question": "Bir string üzerinde işlem yapan bir function pointer örneği oluşturun. Örneğin, bir string'in uzunluğunu hesaplayın.",
    "answer": "String uzunluğunu hesaplamak için bir fonksiyon tanımlayalım:\n\n```c\nint stringUzunlugu(char *str) {\n    int uzunluk = 0;\n    while (*str++) uzunluk++;\n    return uzunluk;\n}\n```\nFonksiyon pointer ile bu fonksiyonu çağırmak için:\n\n```c\nint (*islem)(char*);\nislem = stringUzunlugu;\nchar myString[] = \"Merhaba!\";\nprintf(\"Uzunluk: %d\\n\", islem(myString));\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470160"
  },
  {
    "question": "Bir hesap makinesi uygulaması için toplama, çıkarma, çarpma ve bölme işlemlerini yapan fonksiyonları ve bunları işlemek için function pointerları kullanın.",
    "answer": "Öncelikle dört işlem için fonksiyonları tanımlayalım:\n\n```c\nint toplama(int a, int b) { return a + b; }\nint cikarma(int a, int b) { return a - b; }\nint carpma(int a, int b) { return a * b; }\nint bolme(int a, int b) { return a / b; }\n```\nSonra bir function pointer dizisi oluşturalım:\n\n```c\nint (*islemler[4])(int, int) = {toplama, cikarma, carpma, bolme};\nchar *isimler[4] = {\"Toplama\", \"Çıkarma\", \"Çarpma\", \"Bölme\"};\nfor (int i = 0; i < 4; i++) {\n    printf(\"%s: %d\\n\", isimler[i], islemler[i](10, 5));\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470217"
  },
  {
    "question": "Bir C programında, kullanıcıdan girilen iki rakamı işlemek için function pointer kullanan bir örnek yazın.",
    "answer": "Kullanıcıdan iki rakam alalım ve bunları işlemek için bir function pointer kullanalım:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\nint main() {\n    int a, b;\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n\n    int (*islem)(int, int);\n    islem = topla;\n    printf(\"Toplam: %d\\n\", islem(a, b));\n    islem = carp;\n    printf(\"Çarpım: %d\\n\", islem(a, b));\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470251"
  },
  {
    "question": "Basit bir dizi sıralama algoritması (selection sort) için fonksiyon pointer kullanarak nasıl bir çözüm üretebilirsiniz?",
    "answer": "Selection sort algoritmasını yazalım ve sıralama işlemi için fonksiyon pointer kullanalım:\n\n```c\nvoid selectionSort(int *dizi, int boyut, int (*kriter)(int, int)) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (kriter(dizi[j], dizi[minIndex]) < 0) {\n                minIndex = j;\n            }\n        }\n        int temp = dizi[i];\n        dizi[i] = dizi[minIndex];\n        dizi[minIndex] = temp;\n    }\n}\n\nint buyuktenKucuge(int a, int b) { return b - a; }\n\nint main() {\n    int dizi[] = {64, 25, 12, 22, 11};\n    selectionSort(dizi, 5, buyuktenKucuge);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470285"
  },
  {
    "question": "Yardımcı fonksiyonlar kullanarak bir dizinin maksimum elemanını bulmak için bir function pointer örneği oluşturun.",
    "answer": "Bir dizinin maksimum elemanını bulmak için bir fonksiyon tanımlayalım:\n\n```c\nint maksimumBul(int *dizi, int boyut, int (*kriter)(int, int)) {\n    int max = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        if (kriter(dizi[i], max) > 0) {\n            max = dizi[i];\n        }\n    }\n    return max;\n}\n\nint buyuktenKucuge(int a, int b) { return a - b; }\n\nint main() {\n    int dizi[] = {5, 8, 1, 3, 9};\n    int max = maksimumBul(dizi, 5, buyuktenKucuge);\n    printf(\"Maksimum: %d\\n\", max);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470315"
  },
  {
    "question": "Bir dizi elemanlarını belirli bir işleme sokmak için bir function pointer kullanarak bir örnek oluşturun.",
    "answer": "Bir dizi elemanlarını her birine belirli bir işlem uygulayarak güncelleyelim:\n\n```c\nvoid diziGuncelle(int *dizi, int boyut, void (*islem)(int*)) {\n    for (int i = 0; i < boyut; i++) {\n        islem(&dizi[i]);\n    }\n}\n\nvoid ikiKatina(int *sayi) {\n    *sayi *= 2;\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4};\n    diziGuncelle(dizi, 4, ikiKatina);\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470345"
  },
  {
    "question": "Bir kullanıcıdan alınan sayıyı işlemek için function pointer kullanarak bir örnek yazın.",
    "answer": "Kullanıcıdan bir sayı alıp, bu sayı üzerinde farklı işlemler yapalım:\n\n```c\n#include <stdio.h>\n\nint karesi(int sayi) { return sayi * sayi; }\nint kupu(int sayi) { return sayi * sayi * sayi; }\n\nint main() {\n    int sayi;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &sayi);\n\n    int (*islem)(int);\n    islem = karesi;\n    printf(\"Kare: %d\\n\", islem(sayi));\n    islem = kupu;\n    printf(\"Küp: %d\\n\", islem(sayi));\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:01.470374"
  },
  {
    "question": "Bir dizideki elemanları sıralamak için farklı sıralama algoritmalarını kullanmak istiyorum. Bunu function pointerlar ile nasıl yaparım?",
    "answer": "Function pointerlar kullanarak, farklı sıralama algoritmalarını tanımlayabilir ve bunları bir dizi üzerinde uygulayabilirsiniz. Öncelikle, sıralama fonksiyonlarınızı tanımlayın. Örneğin, 'bubbleSort' ve 'quickSort' fonksiyonları. Ardından, bu fonksiyonların pointerlarını tutacak bir değişken tanımlayın. Kullanıcıdan hangi sıralama yöntemini kullanmak istediğini alarak, ilgili fonksiyonu çağırabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    // Bubble sort implementasyonu\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    // Quick sort implementasyonu\n}\n\nvoid sortArray(int arr[], int n, void (*sortFunc)(int[], int)) {\n    sortFunc(arr, n);\n}\n\nint main() {\n    int arr[] = {5, 2, 9, 1, 5, 6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    // Kullanıcıdan sıralama seçeneği al\n    void (*sortFunc)(int[], int);\n    sortFunc = bubbleSort; // veya quickSort\n\n    sortArray(arr, n, sortFunc);\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810280"
  },
  {
    "question": "Bir matematik kütüphanesi oluşturmak istiyorum. Farklı matematiksel işlemleri (toplama, çıkarma, çarpma) function pointerlar ile nasıl gerçekleştirebilirim?",
    "answer": "Matematiksel işlemleri gerçekleştirmek için function pointerlar kullanarak farklı fonksiyonlar tanımlayabilirsiniz. Ayrıca, bu fonksiyonları bir array içinde tutarak işlemleri kolayca çağırabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nint add(int a, int b) { return a + b; }\nint subtract(int a, int b) { return a - b; }\nint multiply(int a, int b) { return a * b; }\n\nint main() {\n    int (*operations[3])(int, int) = {add, subtract, multiply};\n    int a = 5, b = 3;\n    for (int i = 0; i < 3; i++) {\n        printf(\"Sonuç: %d\\n\", operations[i](a, b));\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810338"
  },
  {
    "question": "Bir oyun uygulaması geliştiriyorum. Oyun içindeki karakterlerin farklı eylemlerini function pointerlar kullanarak nasıl yönetebilirim?",
    "answer": "Her karakter için farklı eylemleri temsil eden fonksiyonları tanımlayarak ve bunları function pointerlarla ilişkilendirerek, karakterlerin eylemlerini dinamik olarak değiştirebilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid jump() { printf(\"Karakter zıplıyor!\\n\"); }\nvoid run() { printf(\"Karakter koşuyor!\\n\"); }\nvoid attack() { printf(\"Karakter saldırıyor!\\n\"); }\n\nint main() {\n    void (*action)();\n    action = jump;\n    action(); // Karakter zıplıyor!\n    action = run;\n    action(); // Karakter koşuyor!\n    action = attack;\n    action(); // Karakter saldırıyor!\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810371"
  },
  {
    "question": "Bir kullanıcı arayüzü uygulaması geliştiriyorum. Kullanıcının seçimine göre farklı buton işlevlerini function pointerlar ile nasıl uygulayabilirim?",
    "answer": "Kullanıcının seçimine göre buton fonksiyonlarını dinamik olarak değiştirmek için function pointerlar kullanabilirsiniz. Her buton için ilgili fonksiyonu tanımlayıp bir array içinde tutarak, kullanıcının seçimine göre çağırabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid onClick1() { printf(\"Buton 1 tıklandı!\\n\"); }\nvoid onClick2() { printf(\"Buton 2 tıklandı!\\n\"); }\n\nint main() {\n    void (*buttons[2])() = {onClick1, onClick2};\n    int choice;\n    printf(\"1 veya 2 seçin: \");\n    scanf(\"%d\", &choice);\n    if (choice >= 1 && choice <= 2) {\n        buttons[choice - 1]();\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810411"
  },
  {
    "question": "Bir oyun programında düşman davranışlarını yönetmek için function pointerlar kullanarak nasıl bir yapı oluşturabilirim?",
    "answer": "Düşman davranışlarını yönetmek için her düşmanın farklı davranışlarını temsil eden fonksiyonlar oluşturun ve bunları bir yapı içinde function pointer olarak saklayın. Örnek:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*move)();\n    void (*attack)();\n} Enemy;\n\nvoid enemyMove() { printf(\"Düşman hareket ediyor!\\n\"); }\nvoid enemyAttack() { printf(\"Düşman saldırıyor!\\n\"); }\n\nint main() {\n    Enemy enemy;\n    enemy.move = enemyMove;\n    enemy.attack = enemyAttack;\n    enemy.move(); // Düşman hareket ediyor!\n    enemy.attack(); // Düşman saldırıyor!\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810455"
  },
  {
    "question": "Bir araç sınıfı oluşturdum, aracın farklı hızlanma yöntemlerini function pointerlar ile nasıl uygulayabilirim?",
    "answer": "Araç sınıfında farklı hızlanma yöntemlerini temsil eden fonksiyonlar tanımlayarak, bu fonksiyonları function pointerlar ile ilişkilendirebilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid speedUp() { printf(\"Araç hızlanıyor!\\n\"); }\nvoid turboBoost() { printf(\"Araç turbo ile hızlanıyor!\\n\"); }\n\nint main() {\n    void (*acceleration)(void);\n    acceleration = speedUp;\n    acceleration(); // Araç hızlanıyor!\n    acceleration = turboBoost;\n    acceleration(); // Araç turbo ile hızlanıyor!\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810492"
  },
  {
    "question": "Bir oyun geliştirmek istiyorum ve her seviyenin tamamlanma durumunu işlemek için function pointerlar kullanarak nasıl bir yapı oluşturabilirim?",
    "answer": "Her seviyenin tamamlanma durumunu işlemek için, seviyeleri temsil eden fonksiyonları ve her seviyenin tamamlandığında çağırılacak fonksiyonları kullanabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid level1Completed() { printf(\"Seviye 1 tamamlandı!\\n\"); }\nvoid level2Completed() { printf(\"Seviye 2 tamamlandı!\\n\"); }\n\nint main() {\n    void (*levelComplete[2])() = {level1Completed, level2Completed};\n    for (int i = 0; i < 2; i++) {\n        levelComplete[i]();\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810541"
  },
  {
    "question": "Farklı dosya işlemlerini gerçekleştirmek istiyorum (okuma, yazma) ve bu işlemleri function pointerlar ile nasıl yapabilirim?",
    "answer": "Dosya işlemleri için farklı fonksiyonlar tanımlayıp, bu fonksiyonları function pointerlar ile yönetebilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid readFile() { printf(\"Dosya okundu!\\n\"); }\nvoid writeFile() { printf(\"Dosyaya yazıldı!\\n\"); }\n\nint main() {\n    void (*fileOperations[2])() = {readFile, writeFile};\n    for (int i = 0; i < 2; i++) {\n        fileOperations[i]();\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810575"
  },
  {
    "question": "Bir hesap makinesi uygulaması geliştiriyorum. Kullanıcının seçimine göre işlemleri function pointerlar ile nasıl yapabilirim?",
    "answer": "Hesap makinesi uygulamanızda, kullanıcının seçimine göre işlem fonksiyonlarını function pointerlar ile çağırabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nint add(int a, int b) { return a + b; }\nint subtract(int a, int b) { return a - b; }\nint multiply(int a, int b) { return a * b; }\nint divide(int a, int b) { return a / b; }\n\nint main() {\n    int (*operations[4])(int, int) = {add, subtract, multiply, divide};\n    int choice, a, b;\n    printf(\"1: Topla, 2: Çıkar, 3: Çarp, 4: Böl: \");\n    scanf(\"%d\", &choice);\n    printf(\"İki sayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    if (choice >= 1 && choice <= 4) {\n        printf(\"Sonuç: %d\\n\", operations[choice - 1](a, b));\n    }\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:50:36.810606"
  },
  {
    "question": "C dilinde bir dizi üzerinde işlem yapmak için fonksiyon işaretçilerini nasıl kullanabilirim?",
    "answer": "Fonksiyon işaretçileri, dinamik olarak hangi fonksiyonun çağrılacağını belirlemek için idealdir. Örneğin, bir dizi üzerinde toplama ve çarpma işlemleri yapacak bir program yazalım:\n\n```c\n#include <stdio.h>\n\n// İşlem fonksiyonları\nint topla(int a, int b) { return a + b; }\nint carp(int a, int b) { return a * b; }\n\n// İşlem seçici fonksiyonu\nvoid islemYap(int (*islem)(int, int), int a, int b) {\n    printf(\"Sonuç: %d\\n\", islem(a, b));\n}\n\nint main() {\n    int a = 5, b = 3;\n    islemYap(topla, a, b);  // Toplama işlemi\n    islemYap(carp, a, b);   // Çarpma işlemi\n    return 0;\n}\n```\nBu örnekte, `islemYap` fonksiyonu, hangi işlemin yapılacağını belirlemek için bir fonksiyon işaretçisi alır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769624"
  },
  {
    "question": "Fonksiyon işaretçilerini kullanarak bir sıralama algoritması nasıl yazabilirim?",
    "answer": "Fonksiyon işaretçileri kullanarak farklı sıralama algoritmalarını dinamik olarak seçebiliriz. Aşağıdaki örnekte, bir diziyi sıralamak için fonksiyon işaretçisi kullanarak hem 'bubblesort' hem de 'selectionsort' uygulayacağız:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n}\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int minIdx = i;\n        for (int j = i+1; j < n; j++)\n            if (arr[j] < arr[minIdx])\n                minIdx = j;\n        int temp = arr[minIdx];\n        arr[minIdx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nvoid siralamaYap(void (*siralama)(int[], int), int arr[], int n) {\n    siralama(arr, n);\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    siralamaYap(bubbleSort, arr, n); // Bubblesort ile sıralama\n    // veya\n    //siralamaYap(selectionSort, arr, n); // Selectionsort ile sıralama\n\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu örnek, `siralamaYap` fonksiyonuyla dinamik olarak sıralama algoritmasını seçmemizi sağlar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769684"
  },
  {
    "question": "Fonksiyon işaretçilerini kullanarak bir olasılık fonksiyonu nasıl uygulayabilirim?",
    "answer": "Bir olasılık fonksiyonu uygulamak için farklı olasılık dağılımlarını temsil eden fonksiyonlar tanımlayabilir ve bunları fonksiyon işaretçileri kullanarak çağırabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\ndouble normalDağılım(double mean, double stddev) {\n    double u = (double)rand() / RAND_MAX;\n    double v = (double)rand() / RAND_MAX;\n    return mean + stddev * sqrt(-2.0 * log(u)) * cos(2.0 * M_PI * v);\n}\n\ndouble uniformDağılım(double min, double max) {\n    return min + (rand() / (RAND_MAX / (max - min)));\n}\n\nvoid olasılıkUygula(double (*dağılım)(double, double), double param1, double param2) {\n    printf(\"Olasılık sonucu: %f\\n\", dağılım(param1, param2));\n}\n\nint main() {\n    srand(time(NULL)); // Rastgele sayı üreteciyi başlat\n    olasılıkUygula(normalDağılım, 0.0, 1.0); // Normal dağılım\n    olasılıkUygula(uniformDağılım, 1.0, 10.0); // Uniform dağılım\n    return 0;\n}\n```\nBu örnekte, `olasılıkUygula` fonksiyonu, hangi dağılımın kullanılacağını belirler.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769709"
  },
  {
    "question": "C dilinde callback fonksiyonları nasıl implement edebilirim?",
    "answer": "Callback fonksiyonları, bir fonksiyona parametre olarak başka bir fonksiyon vermek için kullanılır. Bu sayede, belirtilen bir olay gerçekleştiğinde belirli bir fonksiyon çağrılabilir. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid selamVer() {\n    printf(\"Merhaba!\\n\");\n}\n\nvoid işlemiGerçekle(int n, void (*callback)()) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d. işlem yapılıyor...\\n\", i+1);\n        callback(); // Callback fonksiyonu çağır\n    }\n}\n\nint main() {\n    işlemiGerçekle(3, selamVer); // selamVer fonksiyonunu callback olarak geçiriyoruz\n    return 0;\n}\n```\nBu örnekte, `işlemiGerçekle` fonksiyonu, belirtilen sayıda işlemi gerçekleştirdikten sonra callback olarak verilen `selamVer` fonksiyonunu çağırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769731"
  },
  {
    "question": "C dilinde bir hesap makinesi uygulaması için fonksiyon işaretçilerini nasıl kullanabilirim?",
    "answer": "Hesap makinesi işlemlerini fonksiyon işaretçileri ile dinamik olarak yönetmek için aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint topla(int a, int b) { return a + b; }\nint cikar(int a, int b) { return a - b; }\nint carp(int a, int b) { return a * b; }\nint bol(int a, int b) { return a / b; }\n\nvoid hesapla(int (*islem)(int, int), int a, int b) {\n    printf(\"Sonuç: %d\\n\", islem(a, b));\n}\n\nint main() {\n    int a = 10, b = 5;\n    hesapla(topla, a, b);\n    hesapla(cikar, a, b);\n    hesapla(carp, a, b);\n    hesapla(bol, a, b);\n    return 0;\n}\n```\nBurada, `hesapla` fonksiyonu, dinamik olarak hangi işlemin yapılacağını belirlemek için bir fonksiyon işaretçisi kullanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769757"
  },
  {
    "question": "Bir yapı içerisinde fonksiyon işaretçilerini nasıl kullanabilirim?",
    "answer": "Bir yapı içinde fonksiyon işaretçileri kullanarak, o yapının belirli işlevselliğini artırabiliriz. Aşağıdaki örnekte bir yapı oluşturup, fonksiyon işaretçilerini nasıl kullanacağımızı görebiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n    void (*yazdır)(int, int);\n} Nokta;\n\nvoid noktaYazdır(int x, int y) {\n    printf(\"Nokta: (%d, %d)\\n\", x, y);\n}\n\nint main() {\n    Nokta n;\n    n.x = 5;\n    n.y = 10;\n    n.yazdır = noktaYazdır;\n    n.yazdır(n.x, n.y); // Noktayı yazdır\n    return 0;\n}\n```\nBu örnekte, `Nokta` yapısı bir fonksiyon işaretçisi içerir ve bu işaretçi aracılığıyla `yazdır` fonksiyonu çağrılır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769780"
  },
  {
    "question": "C dilinde bir dizi üzerinde belirli bir koşula göre elemanları filtrelemek için fonksiyon işaretçilerini nasıl kullanabilirim?",
    "answer": "Bir diziyi filtreleme işlemi için koşul belirleyen bir fonksiyon yazabiliriz. Bu koşulu kontrol eden fonksiyonu fonksiyon işaretçisi ile geçebiliriz. Aşağıda bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint filtrele(int n) { return n % 2 == 0; } // Çift sayı kontrolü\n\nvoid diziFiltrele(int arr[], int size, int (*kosul)(int)) {\n    printf(\"Filtrelenmiş dizi: \");\n    for (int i = 0; i < size; i++) {\n        if (kosul(arr[i])) {\n            printf(\"%d \", arr[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    diziFiltrele(arr, size, filtrele); // Çift sayıları filtrele\n    return 0;\n}\n```\nBu örnekte, `diziFiltrele` fonksiyonu, koşul fonksiyonu olarak `filtrele` fonksiyonunu alarak dizinin elemanlarını filtreler.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769815"
  },
  {
    "question": "C dilinde bir oyun içinde yapay zeka hareketlerini belirlemek için fonksiyon işaretçilerini nasıl kullanabilirim?",
    "answer": "Oyun içindeki yapay zeka karakterlerinin hareketlerini dinamik olarak belirlemek için fonksiyon işaretçilerini kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid hareketEt() {\n    printf(\"Karakter hareket ediyor!\\n\");\n}\nvoid saldır() {\n    printf(\"Karakter saldırıyor!\\n\");\n}\n\ntypedef struct {\n    void (*hareket)();\n} Karakter;\n\nint main() {\n    Karakter a;\n    a.hareket = hareketEt;\n    a.hareket(); // Karakterin hareket etmesini sağla\n\n    a.hareket = saldır;\n    a.hareket(); // Karakterin saldırmasını sağla\n    return 0;\n}\n```\nBu örnekte, `Karakter` yapısı içindeki `hareket` fonksiyon işaretçisi ile karakterin dinamik olarak farklı hareketlerini kontrol edebiliriz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769845"
  },
  {
    "question": "C dilinde bir hata ayıklama sistemi için fonksiyon işaretçileri ile nasıl bir yapı oluşturabilirim?",
    "answer": "Hata ayıklama işlemlerini fonksiyon işaretçileri ile yöneterek daha esnek bir hata işleme sistemi oluşturabiliriz. Aşağıdaki örnek, hata ayıklama fonksiyonlarının nasıl kullanılacağını göstermektedir:\n\n```c\n#include <stdio.h>\n\nvoid hataYakala() {\n    printf(\"Hata yakalandı!\\n\");\n}\n\nvoid hataGider(int (*hataFonksiyonu)()) {\n    printf(\"Hata gideriliyor...\\n\");\n    hataFonksiyonu(); // Hata fonksiyonunu çağır\n}\n\nint main() {\n    hataGider(hataYakala); // Hata yakala fonksiyonunu geçiriyoruz\n    return 0;\n}\n```\nBu örnekte, `hataGider` fonksiyonu, hata oluştuğunda çağrılacak olan fonksiyonu fonksiyon işaretçisi ile alır ve belirtilen işlemi gerçekleştirir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:51:18.769881"
  },
  {
    "question": "Bir dizi üzerinde farklı matematiksel işlemler gerçekleştiren bir fonksiyon oluştururken, function pointer kullanmanın avantajları nelerdir?",
    "answer": "Function pointer kullanarak, aynı dizi üzerinde toplama, çıkarma, çarpma gibi farklı işlemler gerçekleştirebiliriz. Bu sayede kodun esnekliği artar. Örneğin, bir dizi üzerinde işlem yapan bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nvoid toplama(int* dizi, int boyut) {\n    int toplam = 0;\n    for (int i = 0; i < boyut; i++) {\n        toplam += dizi[i];\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n}\n\nvoid cikarma(int* dizi, int boyut) {\n    int sonuc = dizi[0];\n    for (int i = 1; i < boyut; i++) {\n        sonuc -= dizi[i];\n    }\n    printf(\"Sonuç: %d\\n\", sonuc);\n}\n\nvoid hesapla(int* dizi, int boyut, void (*islem)(int*, int)) {\n    islem(dizi, boyut);\n}\n\nint main() {\n    int dizi[] = {10, 20, 30};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    hesapla(dizi, boyut, toplama);\n    hesapla(dizi, boyut, cikarma);\n    return 0;\n}\n```\nBu kodda, `hesapla` fonksiyonu, hangi matematiksel işlemin yapılacağını belirlemek için function pointer kullanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185110"
  },
  {
    "question": "Function pointer kullanarak bir callback mekanizması nasıl oluşturulur?",
    "answer": "Callback mekanizması, bir fonksiyonun başka bir fonksiyonun parametresi olarak geçmesini sağlar. Örneğin, bir dizideki her bir öğe için belirli bir işlemi uygulamak üzere bir callback fonksiyonu yazalım:\n\n```c\n#include <stdio.h>\n\nvoid elemanIsle(int eleman, void (*callback)(int)) {\n    callback(eleman);\n}\n\nvoid yazdir(int sayi) {\n    printf(\"Eleman: %d\\n\", sayi);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    for (int i = 0; i < boyut; i++) {\n        elemanIsle(dizi[i], yazdir);\n    }\n    return 0;\n}\n```\nBu kodda, `elemanIsle` fonksiyonu, her eleman için `yazdir` fonksiyonunu çağırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185167"
  },
  {
    "question": "Birden fazla function pointer kullanarak bir yapı içerisinde farklı işlemler tanımlamak nasıl yapılır?",
    "answer": "Bir yapı içerisinde farklı işlemler tanımlamak için function pointerları yapının bir parçası olarak kullanabiliriz. Örneğin, farklı matematiksel işlemleri tutan bir yapı oluşturalım:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*topla)(int, int);\n    void (*cikar)(int, int);\n} IslemYapisi;\n\nvoid toplama(int a, int b) {\n    printf(\"Toplama: %d\\n\", a + b);\n}\n\nvoid cikarma(int a, int b) {\n    printf(\"Çıkarma: %d\\n\", a - b);\n}\n\nint main() {\n    IslemYapisi islem;\n    islem.topla = toplama;\n    islem.cikar = cikarma;\n    islem.topla(5, 3);\n    islem.cikar(5, 3);\n    return 0;\n}\n```\nBu örnekte, `IslemYapisi` yapısı, toplama ve çıkarma işlemleri için iki farklı function pointer içerir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185225"
  },
  {
    "question": "Function pointer kullanılarak bir dizi içinde sıralama algoritması nasıl uygulanır?",
    "answer": "Function pointer kullanarak bir sıralama algoritması uygulamak, farklı sıralama yöntemleri arasında geçiş yapmamıza olanak tanır. Örneğin, bir diziyi artan veya azalan sırada sıralamak için:\n\n```c\n#include <stdio.h>\n\nvoid artan(int* a, int* b) {\n    int temp;\n    if (*a > *b) {\n        temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n}\n\nvoid azalan(int* a, int* b) {\n    int temp;\n    if (*a < *b) {\n        temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n}\n\nvoid sirala(int* dizi, int boyut, void (*kriter)(int*, int*)) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            kriter(&dizi[j], &dizi[j + 1]);\n        }\n    }\n}\n\nint main() {\n    int dizi[] = {5, 3, 8, 1, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut, artan);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kodda, `sirala` fonksiyonu sıralama kriterini belirlemek için function pointer kullanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185252"
  },
  {
    "question": "Function pointer ile bir yapıya dinamik olarak fonksiyon atamak hangi senaryolar için faydalı olabilir?",
    "answer": "Function pointer kullanarak bir yapıya dinamik olarak fonksiyon atamak, özellikle plugin mimarileri veya oyun motorları gibi dinamik sistemlerde faydalıdır. Örneğin, bir oyun karakterinin davranışlarını tanımlayan bir yapı oluşturalım:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*hareket)();\n    void (*saldir)();\n} Karakter;\n\nvoid karakterHareketi() {\n    printf(\"Karakter hareket ediyor!\\n\");\n}\n\nvoid karakterSaldir() {\n    printf(\"Karakter saldırıyor!\\n\");\n}\n\nint main() {\n    Karakter karakter;\n    karakter.hareket = karakterHareketi;\n    karakter.saldir = karakterSaldir;\n    karakter.hareket();\n    karakter.saldir();\n    return 0;\n}\n```\nBu örnekte, karakter davranışları dinamik olarak atanır ve çağrılır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185281"
  },
  {
    "question": "Function pointer ile bir hata işleme mekanizması nasıl oluşturabiliriz?",
    "answer": "Hata işleme mekanizması için function pointer kullanarak, her hata türü için farklı işleme fonksiyonları tanımlayabiliriz. Örneğin, basit bir hata işleme yapısı oluşturalım:\n\n```c\n#include <stdio.h>\n\ntypedef void (*HataIslemeFonk)(const char*);\n\nvoid hataYazdir(const char* mesaj) {\n    printf(\"Hata: %s\\n\", mesaj);\n}\n\nvoid hataGizle(const char* mesaj) {\n    // Hata mesajı gizleniyor\n}\n\nvoid islemYap(HataIslemeFonk hataFonk) {\n    // Bir hata oluştu\n    hataFonk(\"Bir hata meydana geldi!\");\n}\n\nint main() {\n    islemYap(hataYazdir);\n    islemYap(hataGizle);\n    return 0;\n}\n```\nBu kodda, `islemYap` fonksiyonu, hata durumunda belirtilen fonksiyonu çağırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185312"
  },
  {
    "question": "Bir yapı içerisinde function pointerları kullanarak bir oyun durumunu nasıl modelleyebiliriz?",
    "answer": "Bir oyun durumu modellemek için, her duruma karşılık gelen fonksiyonlar tanımlayıp bunları bir yapı içerisinde function pointer olarak saklayabiliriz. Örneğin, bir basit oyun durumu oluşturalım:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    void (*basla)();\n    void (*duraklat)();\n    void (*bitir)();\n} OyunDurumu;\n\nvoid oyunBasla() {\n    printf(\"Oyun başladı!\\n\");\n}\n\nvoid oyunDuraklat() {\n    printf(\"Oyun duraklatıldı!\\n\");\n}\n\nvoid oyunBitir() {\n    printf(\"Oyun bitti!\\n\");\n}\n\nint main() {\n    OyunDurumu oyun;\n    oyun.basla = oyunBasla;\n    oyun.duraklat = oyunDuraklat;\n    oyun.bitir = oyunBitir;\n    oyun.basla();\n    oyun.duraklat();\n    oyun.bitir();\n    return 0;\n}\n```\nBu kodda, oyun durumları için fonksiyonlar tanımlanmış ve bir yapı içerisinde kullanılmıştır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185339"
  },
  {
    "question": "Function pointer kullanarak bir event sistemi nasıl tasarlanabilir?",
    "answer": "Event sistemi tasarlarken, event'lerin tetiklenmesi ve dinlenmesi için function pointer kullanabiliriz. Örneğin, bir basit event sistemi oluşturalım:\n\n```c\n#include <stdio.h>\n\ntypedef void (*EventHandler)(int);\n\ntypedef struct {\n    EventHandler event;\n} Event;\n\nvoid onEvent(int id) {\n    printf(\"Event tetiklendi: %d\\n\", id);\n}\n\nint main() {\n    Event e;\n    e.event = onEvent;\n    // Event'i tetikle\n    e.event(1);\n    return 0;\n}\n```\nBu kodda, bir event nesnesi tanımlanmış ve event tetiklendiğinde çağrılacak fonksiyon belirlenmiştir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185361"
  },
  {
    "question": "Function pointer'lar ile bir dizi üzerinde farklı sıralama algoritmalarını nasıl değiştirebiliriz?",
    "answer": "Farklı sıralama algoritmalarını değiştirmek için function pointer kullanabiliriz. Örneğin, bir dizi üzerinde hem seçim sıralama hem de kabarcık sıralama algoritmalarını uygulayalım:\n\n```c\n#include <stdio.h>\n\nvoid secimSirala(int* dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < boyut; j++) {\n            if (dizi[j] < dizi[minIdx]) {\n                minIdx = j;\n            }\n        }\n        int temp = dizi[i];\n        dizi[i] = dizi[minIdx];\n        dizi[minIdx] = temp;\n    }\n}\n\nvoid kabarcikSirala(int* dizi, int boyut) {\n    for (int i = 0; i < boyut - 1; i++) {\n        for (int j = 0; j < boyut - i - 1; j++) {\n            if (dizi[j] > dizi[j + 1]) {\n                int temp = dizi[j];\n                dizi[j] = dizi[j + 1];\n                dizi[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid sirala(int* dizi, int boyut, void (*siralama)(int*, int)) {\n    siralama(dizi, boyut);\n}\n\nint main() {\n    int dizi[] = {5, 2, 9, 1, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut, secimSirala);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu örnekte, `sirala` fonksiyonu sıralama algoritmasını belirlemek için function pointer kullanmaktadır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:13.185390"
  },
  {
    "question": "Function pointerları kullanarak dinamik bir hesap makinesi uygulaması nasıl yazılır?",
    "answer": "Dinamik bir hesap makinesi yaparken, farklı işleçler için fonksiyon pointerlar kullanabiliriz. Örneğin, toplama, çıkarma, çarpma ve bölme işlemlerini gerçekleştiren fonksiyonlar tanımlayıp, bunları bir dizi içinde tutabiliriz. Kullanıcıdan işlem seçimini alarak doğru fonksiyonu çağırabiliriz.\n\n```c\n#include <stdio.h>\n\n// Fonksiyon prototipleri\nint toplama(int a, int b) { return a + b; }\nint cikarma(int a, int b) { return a - b; }\nint carpma(int a, int b) { return a * b; }\nint bolme(int a, int b) { return a / b; }\n\nint main() {\n    int (*islemler[4])(int, int) = {toplama, cikarma, carpma, bolme};\n    int a = 10, b = 5, secim;\n    printf(\"Bir işlem seçin: 0-toplama, 1-çıkarma, 2-çarpma, 3-bölme: \");\n    scanf(\"%d\", &secim);\n    if (secim >= 0 && secim < 4) {\n        printf(\"Sonuç: %d\\n\", islemler[secim](a, b));\n    } else {\n        printf(\"Geçersiz seçim!\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, işlemleri temsil eden fonksiyon pointerlar bir diziye yerleştirilmiştir. Kullanıcıdan alınan seçimle ilgili fonksiyonun çağrılması sağlanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886464"
  },
  {
    "question": "Bir yapı içerisinde fonksiyon pointerları nasıl kullanılabilir?",
    "answer": "Bir yapı içerisinde fonksiyon pointerları kullanarak, nesne yönelimli programlama yaklaşımını C'de simüle edebiliriz. Aşağıdaki örnekte, bir şekil yapısı tanımlıyoruz ve bu yapıya alan ve çevre hesaplama fonksiyonlarını ekliyoruz.\n\n```c\n#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double (*alan)(double);\n    double (*cevre)(double);\n} Sekil;\n\ndouble daire_alan(double r) { return M_PI * r * r; }\ndouble daire_cevre(double r) { return 2 * M_PI * r; }\n\nint main() {\n    Sekil daire;\n    daire.alan = daire_alan;\n    daire.cevre = daire_cevre;\n    double yaricap = 5.0;\n    printf(\"Dairenin alanı: %f\\n\", daire.alan(yaricap));\n    printf(\"Dairenin çevresi: %f\\n\", daire.cevre(yaricap));\n    return 0;\n}\n```\nBu yapı sayesinde, farklı şekiller için farklı hesaplama fonksiyonları ekleyerek, kodun genişletilebilirliğini artırmış oluruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886503"
  },
  {
    "question": "Bir dizi elemanlarına uygulanan bir fonksiyon pointerı kullanarak filtreleme işlemi nasıl yapılabilir?",
    "answer": "Filtreleme işlemi için, belirli bir koşulu sağlayan elemanları seçmek amacıyla fonksiyon pointerları kullanabiliriz. Bu örnekte, bir tamsayı dizisinde çift sayıları filtreleyeceğiz.\n\n```c\n#include <stdio.h>\n\nint filtrele(int (*kosul)(int), int dizi[], int boyut) {\n    for (int i = 0; i < boyut; i++) {\n        if (kosul(dizi[i])) {\n            printf(\"%d \", dizi[i]);\n        }\n    }\n}\n\nint cift_mi(int sayi) { return sayi % 2 == 0; }\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5, 6};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Çift sayılar: \");\n    filtrele(cift_mi, dizi, boyut);\n    return 0;\n}\n```\nBu kodda, bir dizi üzerinde belirli bir koşulu kontrol eden fonksiyon pointerı kullanarak elemanları filtrelemiş oluyoruz.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886552"
  },
  {
    "question": "Fonksiyon pointerları ile olay tabanlı programlama nasıl yapılabilir?",
    "answer": "Olay tabanlı programlama yaparken, olaylara karşılık gelen fonksiyonları çağırmak için fonksiyon pointerları kullanabiliriz. Aşağıdaki örnekte, tuş olaylarını simüle eden bir program yazdık.\n\n```c\n#include <stdio.h>\n\nvoid tusA() { printf(\"Tuşa A basıldı!\\n\"); }\nvoid tusB() { printf(\"Tuşa B basıldı!\\n\"); }\n\nint main() {\n    void (*tuslar[2])() = {tusA, tusB};\n    int tus;\n    printf(\"Bir tuş seçin (0-A, 1-B): \");\n    scanf(\"%d\", &tus);\n    if (tus >= 0 && tus < 2) {\n        tuslar[tus]();\n    } else {\n        printf(\"Geçersiz tuş!\\n\");\n    }\n    return 0;\n}\n```\nBu örnek, belirli tuşlara karşılık gelen fonksiyonların çağrılmasını sağlar. Kullanıcı girişine bağlı olarak farklı olaylar tetiklenebilir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886576"
  },
  {
    "question": "Fonksiyon pointerları ile dönüşüm işlemleri nasıl optimize edilebilir?",
    "answer": "Fonksiyon pointerları kullanarak dönüştürme işlemleri için optimize edilmiş bir yapı oluşturabiliriz. Örneğin, farklı veri tiplerini bir formata dönüştüren fonksiyonlar tanımlayıp, bunları tek bir fonksiyonla yönetebiliriz.\n\n```c\n#include <stdio.h>\n\ntypedef void (*donustur_func)(void*);\n\ndvoid int_to_string(void* data) { printf(\"String: %d\\n\", *(int*)data); }\ndvoid double_to_string(void* data) { printf(\"String: %f\\n\", *(double*)data); }\n\nvoid donustur(donustur_func f, void* data) {\n    f(data);\n}\n\nint main() {\n    int a = 10;\n    double b = 5.5;\n    donustur(int_to_string, &a);\n    donustur(double_to_string, &b);\n    return 0;\n}\n```\nBu yapıyla, dönüşüm işlemlerini tek bir fonksiyon üzerinden yönetmek, kodun daha düzenli ve genişletilebilir olmasını sağlar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886598"
  },
  {
    "question": "Bir nesne havuzunda fonksiyon pointerları ile kaynak yönetimi nasıl yapılır?",
    "answer": "Kaynak yönetimi için fonksiyon pointerları ile bir nesne havuzu oluşturabiliriz. Aşağıdaki örnekte, bellek yönetimi için allocate ve deallocate işlemlerini fonksiyon pointerları ile yönetiyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef void* (*allocate_func)(size_t);\ntypedef void (*deallocate_func)(void*);\n\nvoid* my_alloc(size_t size) { return malloc(size); }\nvoid my_free(void* ptr) { free(ptr); }\n\nvoid kaynak_yonet(allocate_func alloc, deallocate_func dealloc) {\n    int* ptr = (int*)alloc(sizeof(int));\n    *ptr = 42;\n    printf(\"Değer: %d\\n\", *ptr);\n    dealloc(ptr);\n}\n\nint main() {\n    kaynak_yonet(my_alloc, my_free);\n    return 0;\n}\n```\nBu kod, kaynak yönetimini fonksiyon pointerları aracılığıyla daha esnek hale getirir ve farklı bellek yönetimi stratejilerine kolayca geçiş yapmamıza olanak tanır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886623"
  },
  {
    "question": "Bir olay dinleyici sistemi yaratırken fonksiyon pointerları nasıl kullanılır?",
    "answer": "Olay dinleyici sistemi kurarken, olayları dinlemek ve yanıt vermek için fonksiyon pointerları kullanabiliriz. Aşağıdaki örnekte, bir basit buton sistemi kurarak farklı olaylara tepki veren dinleyiciler oluşturuyoruz.\n\n```c\n#include <stdio.h>\n\nvoid buton_tiklandi() { printf(\"Butona tıklandı!\\n\"); }\nvoid buton_uzaklastirildi() { printf(\"Buton uzaklaştırıldı!\\n\"); }\n\ntypedef void (*event_listener)();\n\nevent_listener dinleyiciler[2];\n\nvoid olay_yerine_getir(int olay) {\n    dinleyiciler[olay]();\n}\n\nint main() {\n    dinleyiciler[0] = buton_tiklandi;\n    dinleyiciler[1] = buton_uzaklastirildi;\n    olay_yerine_getir(0); // Butona tıklandı\n    olay_yerine_getir(1); // Buton uzaklaştırıldı\n    return 0;\n}\n```\nBu sistem, olay dinleyicilerini yönetmeyi ve yeni olay işleyicileri eklemeyi kolaylaştırır.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886647"
  },
  {
    "question": "Bir dizi üzerinde sıralama işlemi yaparken fonksiyon pointerları nasıl kullanılabilir?",
    "answer": "Sıralama işlemi için fonksiyon pointerları kullanarak, farklı sıralama algoritmalarını dinamik olarak değiştirebiliriz. Aşağıdaki örnekte, bir tamsayı dizisini sıralamak için bir karşılaştırma fonksiyonu kullanıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint kucuktenBuyuge(const void* a, const void* b) { return (*(int*)a - *(int*)b); }\nvoid sirala(int dizi[], int boyut, int (*karsilastir)(const void*, const void*)) {\n    qsort(dizi, boyut, sizeof(int), karsilastir);\n}\n\nint main() {\n    int dizi[] = {5, 3, 4, 1, 2};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    sirala(dizi, boyut, kucuktenBuyuge);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu kodda, qsort fonksiyonu ile sıralama işlemi gerçekleştirilir ve fonksiyon pointerı ile karşılaştırma kriteri dinamik olarak belirlenir.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886680"
  },
  {
    "question": "Bir çok işlevsel programlama modelinde fonksiyon pointerları ile nasıl etki sağlanır?",
    "answer": "Fonksiyonel programlama modelinde, fonksiyon pointerları kullanarak yüksek dereceli fonksiyonlar oluşturabiliriz. Örneğin, bir dizi elemanlarına bir fonksiyonu uygulamak için aşağıdaki gibi bir yapı kurabiliriz.\n\n```c\n#include <stdio.h>\n\nvoid uygulama(int dizi[], int boyut, void (*fonksiyon)(int*)) {\n    for (int i = 0; i < boyut; i++) {\n        fonksiyon(&dizi[i]);\n    }\n}\n\nvoid karesiniAl(int* sayi) { *sayi = (*sayi) * (*sayi); }\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    uygulama(dizi, boyut, karesiniAl);\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    return 0;\n}\n```\nBu yapı, dizinin her bir elemanına fonksiyonu uygulayarak işlevselliği artırır ve kodun daha modüler olmasını sağlar.",
    "category": "pointers_memory",
    "topic": "function_pointers",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Function pointerlar",
    "timestamp": "2025-06-01T15:52:59.886708"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını düzeltin: \n\n#include <stdio.h>\n\nint main() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 10;\n    printf(\"Değer: %d\\n\", *ptr);\n    return 0;\n}",
    "answer": "Kodda malloc ile ayrılan bellek için bir free çağrısı eksik. Belleği serbest bırakmak için aşağıdaki gibi kodu düzeltebiliriz:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 10;\n    printf(\"Değer: %d\\n\", *ptr);\n    free(ptr); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.620526"
  },
  {
    "question": "Aşağıdaki kodu düzeltin. malloc ile ayrılan bellek serbest bırakılmıyor. \n\n#include <stdio.h>\n\nvoid createArray() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    for (int i = 0; i < 10; i++) {\n        arr[i] = i;\n    }\n}\n\nint main() {\n    createArray();\n    return 0;\n}",
    "answer": "createArray fonksiyonunda malloc ile ayrılan bellek için free çağrısı eksik. Aşağıdaki gibi düzeltebiliriz:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    for (int i = 0; i < 10; i++) {\n        arr[i] = i;\n    }\n    free(arr); // Belleği serbest bırakıyoruz\n}\n\nint main() {\n    createArray();\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.620640"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısını önlemek için ne yapmalıyız? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *data;\n    for (int i = 0; i < 5; i++) {\n        data = (int *)malloc(sizeof(int));\n        *data = i * 10;\n    }\n    return 0;\n}",
    "answer": "Her döngüde malloc çağrısı yapılıp bellekte yer açılıyor ama serbest bırakılmıyor. Her malloc'dan sonra free çağrılmalı. Düzeltilmiş kod:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *data;\n    for (int i = 0; i < 5; i++) {\n        data = (int *)malloc(sizeof(int));\n        *data = i * 10;\n        free(data); // Her seferinde belleği serbest bırakıyoruz\n    }\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.620723"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısını önlemek için yapılması gerekenler nelerdir? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* getString() {\n    char *str = (char *)malloc(20 * sizeof(char));\n    return str;\n}\n\nint main() {\n    char *myString = getString();\n    sprintf(myString, \"Merhaba, dünya!\");\n    printf(\"%s\\n\", myString);\n    return 0;\n}",
    "answer": "getString fonksiyonunda malloc ile ayrılan bellek serbest bırakılmıyor. main fonksiyonunda myString'den sonra free çağrılmalı:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* getString() {\n    char *str = (char *)malloc(20 * sizeof(char));\n    return str;\n}\n\nint main() {\n    char *myString = getString();\n    sprintf(myString, \"Merhaba, dünya!\");\n    printf(\"%s\\n\", myString);\n    free(myString); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.620816"
  },
  {
    "question": "Aşağıdaki C kodunu inceleyin. Bellek sızıntısını düzeltin. \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    for (int i = 0; i < 5; i++) {\n        arr[i] = i * 2;\n    }\n    // Belleği serbest bırakmayı unuttuk\n    return 0;\n}",
    "answer": "Kodda malloc ile ayrılan bellek için free çağrısı eksik. Aşağıdaki gibi düzeltebiliriz:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    for (int i = 0; i < 5; i++) {\n        arr[i] = i * 2;\n    }\n    free(arr); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.620896"
  },
  {
    "question": "Aşağıdaki kodda bir bellek sızıntısı var. Düzeltin. \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint* allocate_memory() {\n    int *ptr = (int *)malloc(10 * sizeof(int));\n    return ptr;\n}\n\nint main() {\n    int *data;\n    data = allocate_memory();\n    // Belleği serbest bırakmayı unuttuk\n    return 0;\n}",
    "answer": "allocate_memory fonksiyonu ile ayrılan bellek için main fonksiyonunda free çağrılması gerekiyor. Aşağıdaki gibi düzeltebiliriz:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint* allocate_memory() {\n    int *ptr = (int *)malloc(10 * sizeof(int));\n    return ptr;\n}\n\nint main() {\n    int *data;\n    data = allocate_memory();\n    free(data); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.621005"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısı oluşuyor. Nasıl düzeltebiliriz? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createBuffer() {\n    char *buffer = (char *)malloc(256);\n    // Belleği serbest bırakmayı unuttuk\n}\n\nint main() {\n    createBuffer();\n    return 0;\n}",
    "answer": "createBuffer fonksiyonunda malloc ile ayrılan bellek için free çağrısı eksik. Buffer oluşturulduktan sonra serbest bırakılmalı. Düzeltilmiş hali:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid createBuffer() {\n    char *buffer = (char *)malloc(256);\n    // İşlemler burada yapılabilir\n    free(buffer); // Belleği serbest bırakıyoruz\n}\n\nint main() {\n    createBuffer();\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.621073"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını düzeltin. \n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid processArray(int size) {\n    int *array = (int *)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        array[i] = i;\n    }\n    // Belleği serbest bırakmayı unuttuk\n}\n\nint main() {\n    processArray(100);\n    return 0;\n}",
    "answer": "processArray fonksiyonunda malloc ile ayrılan bellek için free çağrısı eksik. Aşağıdaki gibi düzeltilebilir:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid processArray(int size) {\n    int *array = (int *)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        array[i] = i;\n    }\n    free(array); // Belleği serbest bırakıyoruz\n}\n\nint main() {\n    processArray(100);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.621159"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısı var. Düzeltin. \n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* allocateString() {\n    char *str = (char *)malloc(50);\n    return str;\n}\n\nint main() {\n    char *myString = allocateString();\n    sprintf(myString, \"Hello, World!\");\n    // Belleği serbest bırakmayı unuttuk\n    return 0;\n}",
    "answer": "allocateString fonksiyonu ile ayrılan bellek için main fonksiyonunda free çağrılması gerekiyor. Düzeltme şu şekilde olmalı:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* allocateString() {\n    char *str = (char *)malloc(50);\n    return str;\n}\n\nint main() {\n    char *myString = allocateString();\n    sprintf(myString, \"Hello, World!\");\n    free(myString); // Belleği serbest bırakıyoruz\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:53:33.621240"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını düzeltin. Kod eksik ve bellek sızıntısı yaratabilir.",
    "answer": "Kodun amacı bir dizi oluşturmak ve elemanlarına değer atamak. Ancak dinamik bellek tahsisi yapıldıktan sonra, belleğin serbest bırakılması unutulmuş. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* dizi = (int*)malloc(10 * sizeof(int));\n    if (dizi == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    for (int i = 0; i < 10; i++) {\n        dizi[i] = i;\n    }\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    free(dizi); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\nBurada, `free(dizi);` satırı eklenerek bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176769"
  },
  {
    "question": "Aşağıdaki C kodunda bellek sızıntısını düzeltin. Kodda bir dizi oluşturulmuş ancak serbest bırakılmamış.",
    "answer": "Kodda dinamik olarak bir dizi oluşturulmuş ancak sonrasında serbest bırakılması unutulmuş. İşte düzeltilmiş şekli:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid diziOlustur() {\n    int* dizi = (int*)malloc(5 * sizeof(int));\n    if (dizi == NULL) {\n        return; // Bellek tahsisi başarısız\n    }\n    for (int i = 0; i < 5; i++) {\n        dizi[i] = i * 2;\n    }\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    free(dizi); // Bellek serbest bırakılıyor\n}\n\nint main() {\n    diziOlustur();\n    return 0;\n}\n```\nBurada `free(dizi);` eklenerek bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176826"
  },
  {
    "question": "Aşağıdaki C kodunu düzeltin; belleği serbest bırakmıyor ve bu bir bellek sızıntısına neden oluyor.",
    "answer": "Kodda bir karakter dizisi dinamik olarak tahsis edilmiş fakat sonrasında serbest bırakılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char* metin = (char*)malloc(20 * sizeof(char));\n    if (metin == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    strcpy(metin, \"Merhaba Dünya!\");\n    printf(\"%s\\n\", metin);\n    free(metin); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\n`free(metin);` ile dinamik olarak tahsis edilen bellek serbest bırakılmıştır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176858"
  },
  {
    "question": "Aşağıdaki kodda bir bellek sızıntısı meydana geliyor. Düzeltin.",
    "answer": "Kodda bir yapı için dinamik bellek tahsisi yapılmış, ancak serbest bırakılması unutulmuş. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int numara;\n    char isim[50];\n} Kisi;\n\nint main() {\n    Kisi* kisi = (Kisi*)malloc(sizeof(Kisi));\n    if (kisi == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    kisi->numara = 123;\n    strcpy(kisi->isim, \"Ahmet\");\n    printf(\"Numara: %d, İsim: %s\\n\", kisi->numara, kisi->isim);\n    free(kisi); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\n`free(kisi);` ile bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176881"
  },
  {
    "question": "Aşağıdaki C kodu bellek sızıntısına neden oluyor. Kodun düzeltilmiş halini verin.",
    "answer": "Kodda bir dizi için bellek tahsis edildi ancak `free` çağrısı yapılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* dizi = (int*)malloc(10 * sizeof(int));\n    if (dizi == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    for (int i = 0; i < 10; i++) {\n        dizi[i] = i + 1;\n    }\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    free(dizi); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\n`free(dizi);` eklenerek bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176915"
  },
  {
    "question": "Dinamik oluşturulan bir yapının bellek serbest bırakılmasını unutmuş bir kodu düzeltin.",
    "answer": "Kodda yapı için dinamik bellek tahsisi yapılmış ancak serbest bırakılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a;\n    float b;\n} Veri;\n\nint main() {\n    Veri* veri = (Veri*)malloc(sizeof(Veri));\n    if (veri == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    veri->a = 5;\n    veri->b = 3.14;\n    printf(\"A: %d, B: %.2f\\n\", veri->a, veri->b);\n    free(veri); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\n`free(veri);` ile bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176942"
  },
  {
    "question": "Aşağıdaki kodu düzeltin; bellek sızıntısı var ve bu kod çalıştırıldığında hatalı sonuç veriyor.",
    "answer": "Kodda bir dizi için dinamik bellek tahsisi yapılmış ancak serbest bırakılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid toplam() {\n    int* dizi = (int*)malloc(5 * sizeof(int));\n    if (dizi == NULL) {\n        return; // Bellek tahsisi başarısız\n    }\n    for (int i = 0; i < 5; i++) {\n        dizi[i] = i + 1;\n    }\n    int toplam = 0;\n    for (int i = 0; i < 5; i++) {\n        toplam += dizi[i];\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    free(dizi); // Bellek serbest bırakılıyor\n}\n\nint main() {\n    toplam();\n    return 0;\n}\n```\nKodda `free(dizi);` eklenerek bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176971"
  },
  {
    "question": "Aşağıdaki kodda bellek sızıntısı var. Bu kodu düzeltin.",
    "answer": "Kodda bir karakter dizisine dinamik bellek tahsisi yapılmış fakat serbest bırakılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char* mesaj = (char*)malloc(50 * sizeof(char));\n    if (mesaj == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    strcpy(mesaj, \"Bellek sızıntısı önlenmeli\");\n    printf(\"Mesaj: %s\\n\", mesaj);\n    free(mesaj); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\n`free(mesaj);` ile bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.176994"
  },
  {
    "question": "Aşağıdaki kodda yapılar için bellek sızıntısı var. Düzeltin.",
    "answer": "Kodda bir yapı için dinamik bellek tahsisi yapıldıktan sonra serbest bırakılmamış. İşte düzeltilmiş hali:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[30];\n} Ogrenci;\n\nint main() {\n    Ogrenci* ogrenci = (Ogrenci*)malloc(sizeof(Ogrenci));\n    if (ogrenci == NULL) {\n        return 1; // Bellek tahsisi başarısız\n    }\n    ogrenci->id = 1;\n    strcpy(ogrenci->name, \"Ali\");\n    printf(\"ID: %d, İsim: %s\\n\", ogrenci->id, ogrenci->name);\n    free(ogrenci); // Bellek serbest bırakılıyor\n    return 0;\n}\n```\nYukarıdaki kodda `free(ogrenci);` ile bellek sızıntısı önlenmiştir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:54:12.177016"
  },
  {
    "question": "Bir dinamik dizi oluşturduktan sonra belleği serbest bırakmayı unuttuğumda ne olur?",
    "answer": "Dinamik olarak oluşturulan dizi için `malloc` veya `calloc` fonksiyonu kullanıldığında, bu bellekte ayrılan alan serbest bırakılmazsa, bellekte sızıntı oluşur. Bu, programın çalıştığı sürece kullanılamayan bellek alanlarının birikmesine neden olur. Örneğin:\n\n```c\nint *arr = (int*)malloc(10 * sizeof(int));\n// İşlemler...\n// free(arr); // Belleği serbest bırakmayı unuttuk!\n```\n\nBu durumda, `free(arr);` satırı eklenerek belleğin serbest bırakılması gerekir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106035"
  },
  {
    "question": "Birden fazla `malloc` çağrısı yapıp her birine karşılık gelen `free` çağrısını unuttuğumda ne olur?",
    "answer": "Her `malloc` çağrısı için bir `free` çağrısı yapılmadığında, her çağrıda ayrılan bellek alanı serbest bırakılmaz. Bu da programın çalıştığı süre boyunca bellekte gereksiz yere alan kaplamaya devam eder. Örneğin:\n\n```c\nchar *str1 = (char*)malloc(20 * sizeof(char));\nchar *str2 = (char*)malloc(30 * sizeof(char));\n// free(str1); // str1 için belleği serbest bırakmayı unuttuk\n// free(str2); // str2 için belleği serbest bırakmayı unuttuk\n```\n\nHer iki değişken için de `free` çağrısı yapılmadığında, bellekte sızıntı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106102"
  },
  {
    "question": "Bağlantılı bir liste oluşturup node'ları silmeyi unuttuğumda ne olur?",
    "answer": "Bağlantılı listelerde her bir düğüm için dinamik bellek kullanılır. Eğer düğümleri serbest bırakmayı unuturken listeyi temizlemeye çalışırsanız, her düğüm için tahsis edilen bellek serbest bırakılmadığı için bir bellek sızıntısı yaşarsınız. Örnek:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode *head = (Node*)malloc(sizeof(Node));\n// Düğümleri ekledik... \n// Belleği serbest bırakmayı unuttuk!\n```\n\nListe düğümlerinin serbest bırakılması gerekir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106131"
  },
  {
    "question": "Fonksiyon içinde dinamik bellek ayırıp dışarıda `free` etmemek ne anlama gelir?",
    "answer": "Eğer bir fonksiyon içinde dinamik bellek ayırıp bu belleği dışarıda serbest bırakmayı unutursanız, bellekte sızıntı oluşur. Bu durum, özellikle belleği ayıran fonksiyonun geri dönen işaretçiyi çağıran fonksiyona iletmediği durumlarda sık görülür. Örneğin:\n\n```c\nint* allocateMemory() {\n    int *ptr = (int*)malloc(sizeof(int));\n    return ptr;\n}\n\nint main() {\n    int *num = allocateMemory();\n    // free(num); // Unutuldu\n}\n```\n\nBurada `free(num);` satırı eklenmelidir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106162"
  },
  {
    "question": "Bir `struct` içinde dinamik bellek kullanırken serbest bırakmayı unuttuğumda ne olur?",
    "answer": "Eğer bir `struct` içinde dinamik bellek ayırırsanız ve bu belleği serbest bırakmayı unutursanız, `struct` içindeki tüm dinamik alanlar için bellek sızıntısı oluşur. Örneğin:\n\n```c\ntypedef struct {\n    char *name;\n} Person;\n\nPerson *p = (Person*)malloc(sizeof(Person));\n// p->name = (char*)malloc(50 * sizeof(char));\n// free(p->name); // Unutuldu\n// free(p); // Unutuldu\n```\n\nHem `p->name` hem de `p` için `free` çağrıları yapılmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106193"
  },
  {
    "question": "Bir programda `calloc` kullanıp serbest bırakmayı unuttuğumda ne olur?",
    "answer": "Dinamik bellek ayırmak için `calloc` kullanıldığında, bu belleği serbest bırakmak zorunludur. Aksi takdirde, programın çalışma süresi boyunca bellek sızıntısı oluşur. Örnek:\n\n```c\nint *arr = (int*)calloc(5, sizeof(int));\n// İşlemler...\n// free(arr); // Burada serbest bırakmayı unuttuk!\n```\n\n`free(arr);` satırı eklenmelidir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106220"
  },
  {
    "question": "Bir belleği serbest bırakırken iki kez `free` yaparsam ne olur?",
    "answer": "Bir bellek alanını iki kez `free` etmeye çalıştığınızda, programda tanımsız bir davranış (undefined behavior) meydana gelir. Bu, belleği bozuk hale getirebilir ve programın çökmesine neden olabilir. Örnek:\n\n```c\nint *arr = (int*)malloc(10 * sizeof(int));\nfree(arr);\nfree(arr); // İkinci kez serbest bırakmaya çalışıyoruz, bu hatalıdır.\n```\n\nBu durumda, ikinci `free(arr);` satırı kaldırılmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106248"
  },
  {
    "question": "Statik bir değişken kullanıp onun için dinamik bellek ayırdığımda ne olur?",
    "answer": "Statik değişkenler programın ömrü boyunca varlığını korurken, dinamik olarak ayrılan bellek için serbest bırakma işlemi yapılmazsa sızıntı oluşur. Örneğin:\n\n```c\nstatic int *ptr;\nptr = (int*)malloc(sizeof(int));\n// free(ptr); // Unutuldu\n```\n\n`free(ptr);` satırı eklenmelidir, aksi takdirde bellekte sızıntı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106276"
  },
  {
    "question": "Bir işaretçiyi başka bir işaretçiye atadığımda bellek sızıntısı oluşur mu?",
    "answer": "Evet, eğer işaretçiyi başka bir işaretçiye atarsanız ve önceden tahsis edilen belleği serbest bırakmazsanız, bu durumda bellekte sızıntı meydana gelir. Örnek:\n\n```c\nint *ptr1 = (int*)malloc(sizeof(int));\nint *ptr2 = ptr1;\n// free(ptr1); // Serbest bırakmayı unuttuk\n// ptr1 = NULL; // ptr1 NULL yapıldıktan sonra ptr2 hala belleği tutuyor\n```\n\nBurada `free(ptr1);` çağrısını ekleyerek sızıntı önlenmelidir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106302"
  },
  {
    "question": "Bir döngü içinde dinamik bellek ayırırken her döngüde `free` etmezsem ne olur?",
    "answer": "Bir döngü içinde her döngüde dinamik bellek ayırıp serbest bırakmayı unutursanız, her döngüde yeni bir bellek alanı ayrılacak ancak önceki alan serbest bırakılmadığı için bellekte sızıntı oluşacaktır. Örnek:\n\n```c\nfor (int i = 0; i < 5; i++) {\n    int *arr = (int*)malloc(10 * sizeof(int));\n    // Belleği serbest bırakmayı unuttuk!\n}\n```\n\nBurada her döngüde `free(arr);` satırı eklenmeli ve döngü tamamlandıktan sonra tüm belleğin serbest bırakılması sağlanmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:09.106333"
  },
  {
    "question": "Bir dinamik bellek alanı ayırdım ama serbest bırakmayı unuttum. Ne gibi problemlerle karşılaşabilirim ve nasıl düzeltebilirim?",
    "answer": "Dinamik bellek ayırma işlemi (örneğin, malloc) kullanıldığında, bellek sızıntıları oluşabilir. Eğer belleği serbest bırakmazsanız, programın çalışma süresi boyunca ayrılan bellek kullanılmamış halde kalır. Bu, uzun süreli çalışan programlar için toplam bellek kullanımını artırarak sonunda sistemin bellek havuzunu tüketmesine neden olabilir. Çözüm, kullanılan her dinamik bellek alanını (örneğin, free ile) uygun bir yerde serbest bırakmaktır. Örneğin: int *ptr = malloc(sizeof(int)); // Kullanım... free(ptr);",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.268953"
  },
  {
    "question": "Bir linked list yapısı kullanıyorum ve düğümleri ekleyip çıkarırken bellek sızıntısı oluşuyor. Neden olabilir?",
    "answer": "Linked list yapısında düğümleri eklerken yeni bellek alanı ayırıyorsanız, düğümü sildikten sonra bu belleği serbest bırakmazsanız bellek sızıntısı oluşur. Her düğüm silindiğinde, o düğüme ait bellek alanını free ile serbest bırakmalısınız. Örneğin: 'Node* temp = head; head = head->next; free(temp);' Bu şekilde, silinen düğümün belleği temizlenmiş olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269001"
  },
  {
    "question": "Bir fonksiyon içinde yerel bir dizi tanımladım ve daha sonra bu diziyi başka bir fonksiyona ilettim. Bu durumda bellek sızıntısı oluşur mu?",
    "answer": "Yerel diziler, fonksiyon sona erdiğinde otomatik olarak yok edilir, bu yüzden bellek sızıntısı oluşmaz. Ancak, eğer dinamik olarak bir dizi oluşturuyor ve bu bellek alanını serbest bırakmayı unutuyorsanız, sızıntı olabilir. Dikkatli olmak için her dinamik dizi için bir free çağrısı yapmalısınız: 'int* arr = malloc(size * sizeof(int)); // Kullanım... free(arr);'",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269041"
  },
  {
    "question": "Bir nesne örneğini paylaşmak için bir işlev kullanıyorum, ancak her nesne oluşturulduğunda bellek sızıntısı yaşıyorum. Neden?",
    "answer": "Eğer nesne örneğini bir yerde paylaşırken, o nesneyi serbest bırakmazsanız bellek sızıntısı yaşarsınız. Paylaşılan nesneye erişim sağlandığında, nesneyi serbest bırakmamış olmanız mümkündür. Bu yüzden, nesneyi kullandıktan sonra her yerde free ile serbest bırakıldığından emin olun. Ayrıca, paylaşılan nesne için akıllı işaretçiler kullanmak, bellek yönetiminde yardım edebilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269076"
  },
  {
    "question": "Bir döngü içinde dinamik bellek ayırma işlemi yaparsam bellek sızıntısına yol açar mı?",
    "answer": "Evet, döngü içinde her iterasyonda yeni bellek alanı ayırıyorsanız ve bunları uygun şekilde serbest bırakmazsanız, bellek sızıntısı oluşur. Her döngüde ayırdığınız belleği kullanmayı bitirdikten sonra free ile serbest bırakmalısınız. Örneğin: 'for(int i = 0; i < n; i++) { int* arr = malloc(size); // Kullanım... free(arr); }'",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269105"
  },
  {
    "question": "Bir kütüphane işlevi çağırdıktan sonra bellek sızıntısı ile karşılaştım. Bu durumda ne yapmalıyım?",
    "answer": "Kütüphane işlevleri genellikle belgeleri ve kaynakları yönetir, ancak eğer işlev içerisine dinamik bellek ayırma işlemi yapıyorsa, döndürülen nesneleri serbest bırakmayı unutmamalısınız. Kütüphane belgelerini kontrol ederek, döndürülen nesnelerin nasıl yönetileceği hakkında bilgi edinin. İşlev sonrası serbest bırakmayı unutmayın, örneğin: 'FreeLibraryObject(object);'",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269135"
  },
  {
    "question": "Bir dizi oluşturup bu diziyi bir başka yapıya kopyaladım. Kopyalama işlemini yaptıktan sonra orijinal diziyi serbest bıraktım. Hala bellek sızıntısı yaşıyorum. Neden?",
    "answer": "Eğer kopyalama işlemi sırasında kullanmakta olduğunuz bellek alanı, yeni bir bellek bloğuna işaret etmiyorsa ve orijinal diziyi serbest bıraktıysanız, kopyalanan yapı içindeki bellek hala işaret edilmiyor olabilir. Bu durumda, her iki yapıyı da yönetebilmek için uygun serbest bırakma işlemlerini uyguladığınızdan emin olun. Örneğin: 'int* newArray = malloc(size); memcpy(newArray, oldArray, size); free(oldArray);'",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269178"
  },
  {
    "question": "Bir global değişken üzerinde dinamik bellek kullanımı yaptım. Bunun bellek yönetiminde nasıl bir etkisi olur?",
    "answer": "Global değişkenler programın ömrü boyunca bellek alanında kalır. Eğer bu global değişken üzerinde dinamik bellek ayırıyorsanız ve serbest bırakmayı unutur veya doğru bir şekilde yönetmezseniz, bellek sızıntısı ortaya çıkabilir. Global değişkenin bellek alanını serbest bırakmayı unutmamak için programın sonlarında uygun free çağrılarını kullanmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269210"
  },
  {
    "question": "Bir struct içinde dinamik olarak ayrılan bir diziye sahip olduğumda, bu struct'ı serbest bırakırken dikkat etmem gerekenler nelerdir?",
    "answer": "Struct içinde dinamik olarak ayrılan bir dizi olduğunda, önce dizinin belleğini serbest bırakmanız gerekmektedir. Ardından struct'ın kendisini de free ile serbest bırakmalısınız. Aksi takdirde, dizinin belleği sızıntı yapar. Örnek: 'free(myStruct->array); free(myStruct);'",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269246"
  },
  {
    "question": "Bir fonksiyon içinde dinamik bellek ayırıp, bu belleği başka bir fonksiyona ilettim. Belleği serbest bırakmayı unuttum. Ne yapmalıyım?",
    "answer": "Eğer dinamik bellek ayırma işlemini bir fonksiyonda yaptıysanız ve bu belleği başka bir fonksiyona ilettiyseniz, bu fonksiyonu çağırmadan sonra serbest bırakmayı unutmamalısınız. Belleği kimin serbest bırakacağını belirlemeli ve bellek yönetimine dikkat etmelisiniz. Örneğin, belleği alan fonksiyon, kullanımı tamamladıktan hemen sonra free çağrısını yapmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:55:33.269282"
  },
  {
    "question": "Dinamik olarak tahsis edilmiş bir dizinin belleği serbest bırakılmadığında ne olur?",
    "answer": "Eğer dinamik olarak tahsis edilmiş bir diziye bellekte yer ayırdıysanız ve daha sonra bu belleği serbest bırakmazsanız, bellekte sızıntı oluşur. Bu, uygulamanızın çalıştığı süre boyunca her seferinde daha fazla bellek kullanmasına neden olur ve sonunda belleği tükenmesine yol açabilir. Örneğin:\n\n```c\nint *arr = malloc(sizeof(int) * 10);\n// Kod burada...\n// free(arr); // Bu satırı unutursanız bellek sızıntısı oluşur.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486738"
  },
  {
    "question": "Bir yapı içinde bir işaretçi tutuluyorsa ve yapı serbest bırakılmadan önce işaretçinin belleği serbest bırakılırsa ne olur?",
    "answer": "Bir yapı içinde bir işaretçi varsa ve bu işaretçi için tahsis edilen bellek serbest bırakılırsa, yapı serbest bırakıldığında işaretçiye işaret eden belleğe erişim yapılmaya çalışılırsa tanımsız davranış oluşur. Bu durum, 'dangling pointer' (sarkık işaretçi) hatasına neden olur. Örneğin:\n\n```c\ntypedef struct {\n    int *data;\n} MyStruct;\n\nMyStruct *s = malloc(sizeof(MyStruct));\ns->data = malloc(sizeof(int));\nfree(s->data); // Burada işaretçi serbest bırakılıyor, s->data geçersiz hale geliyor.\nfree(s); // Bu noktada s->data'ya erişim hatalı olur.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486792"
  },
  {
    "question": "Bir döngü içinde sürekli yeni bellek tahsis etmek ve serbest bırakmamak neye yol açar?",
    "answer": "Eğer bir döngü içinde sürekli olarak yeni bellek tahsis ediyorsanız ancak bu belleği serbest bırakmıyorsanız, zamanla belleğiniz dolacak ve 'Out of Memory' hatası alabilirsiniz. Bu genellikle  belleğin dinamik olarak yönetildiği uygulamalarda sık görülen bir durumdur. Örneğin:\n\n```c\nfor (int i = 0; i < 1000; i++) {\n    int *p = malloc(sizeof(int)); // Bellek tahsis ediliyor ama serbest bırakılmıyor\n}\n// Bu döngü, bellek sızıntısına yol açar.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486825"
  },
  {
    "question": "Bir fonksiyonda tahsis edilmiş belleği başka bir fonksiyona geçirirken neye dikkat etmeliyiz?",
    "answer": "Bir fonksiyonda tahsis edilen belleği başka bir fonksiyona geçirirken, fonksiyonların belleği nasıl yöneteceğine dikkat etmelisiniz. Eğer geçirdiğiniz fonksiyon belleği serbest bırakmazsa ve kullanmadığınız belleği serbest bırakıyorsanız bellek sızıntısı veya çift serbest bırakma hatası yaşayabilirsiniz. Örneğin:\n\n```c\nvoid process(int *p) {\n    // Belleği serbest bırakmıyorsak dikkat etmeliyiz\n}\n\nint *arr = malloc(sizeof(int) * 5);\nprocess(arr); // arr burada serbest bırakılmıyor, sızıntı oluşur.\nfree(arr);\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486854"
  },
  {
    "question": "Global değişkenler dinamik bellek tahsisini nasıl etkiler?",
    "answer": "Global değişkenler, dinamik bellek tahsisi sırasında bellek sızıntılarına neden olabilir çünkü global değişkenler programın yaşam döngüsü boyunca varlıklarını sürdürecek ve eğer dinamik olarak tahsis ettiğiniz belleği unuttuysanız, programınızdan çıkana dek o bellek kaybolmuş olacaktır. Örneğin:\n\n```c\nint *globalPtr;\nvoid allocate() {\n    globalPtr = malloc(100);\n}\n// allocate() çağrıldıktan sonra, globalPtr serbest bırakılmazsa bellek sızıntısı oluşur.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486875"
  },
  {
    "question": "Belleği serbest bırakmayı unuttuğunuzda, programın performansı üzerinde ne gibi etkiler olur?",
    "answer": "Belleği serbest bırakmayı unuttuğunuzda programınızın performansı zamanla düşebilir. Sistem belleği doldukça, işletim sistemi belleği yönetmekte zorlanabilir ve swap alanı kullanmaya başlayabilir. Bu da programın yavaşlamasına neden olur. Örneğin:\n\n```c\nfor (int i = 0; i < 1000000; i++) {\n    char *buffer = malloc(1024);\n    // Belleği serbest bırakmıyorsanız, her döngüde bellek tüketimi artar.\n}\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486903"
  },
  {
    "question": "C dilindeki 'calloc' ve 'malloc' arasındaki fark nedir ve bellek sızıntısını nasıl etkiler?",
    "answer": "'calloc', tahsis edilen belleği sıfırlarken, 'malloc' sadece bellek ayırır. 'calloc' kullanarak tahsis edilen belleği unuttuğunuzda bellek sızıntısı oluşur, ancak belleği sıfırladığınız için bellek sızıntısının etkisi daha az hissedilebilir. Örneğin:\n\n```c\nint *arr = (int *)calloc(10, sizeof(int));\n// free(arr); çağrısını unutursanız, bellek sızıntısı oluşur, ancak içerikler sıfırdır.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486933"
  },
  {
    "question": "Dizilerin başlangıç adresini başka bir işaretçiye atamak bellek sızıntısına neden olur mu?",
    "answer": "Evet, dizinin başlangıç adresini başka bir işaretçiye atarken, eğer ilk işaretçiyi serbest bırakmazsanız bellek sızıntısı oluşur. Bu durumda ilk işaretçi, tahsis edilen belleği kaybedecek ve belleği serbest bırakmayı beceremeyeceksiniz. Örneğin:\n\n```c\nint *array1 = malloc(sizeof(int) * 5);\nint *array2 = array1; // array1 belleği kaybeder\n// free(array1); // Bu satır bellek sızıntısına yol açar.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486960"
  },
  {
    "question": "C dilinde bir işaretçinin yanlış bir şekilde kullanılması sonucu bellek sızıntısı nasıl oluşur?",
    "answer": "Eğer bir işaretçi tahsis edilen belleğe işaret ediyorsa ama başka bir bellek tahsisi yapıldığında işaretçi önceki belleği kaybederse, bu bellek sızıntısına yol açar. Örneğin:\n\n```c\nchar *str = malloc(20);\nstr = malloc(30); // Önceki belleği kaybettiniz, bellek sızıntısı oluşur.\nfree(str); // Bu, ilk malloc'u serbest bırakmaz.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:13.486987"
  },
  {
    "question": "Bellek sızıntısı nedir?",
    "answer": "Bellek sızıntısı, bir programın, artık kullanılmayan bellek alanlarını serbest bırakmaması durumudur. Bu, zamanla bellek kullanımının artmasına ve sistemin yavaşlamasına neden olabilir. Örneğin, dinamik olarak ayırdığımız bir bellek bloğunu serbest bırakmazsak, bu bellek bloğu bir daha kullanılamaz ve sistemde gereksiz yere yer kaplamaya devam eder.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.471943"
  },
  {
    "question": "C dilinde bellek sızıntısı nasıl oluşur?",
    "answer": "C dilinde bellek sızıntısı, genellikle malloc() gibi fonksiyonlar kullanılarak bellek ayrıldıktan sonra bu bellek bloğunun free() fonksiyonu ile serbest bırakılmaması nedeniyle oluşur. Örneğin, bir diziyi dinamik olarak ayırdık ve daha sonra onun için bir free() çağrısı yapmadık. Bu durumda, o bellek alanı bir daha kullanılamaz ve bellek sızıntısı meydana gelir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.471980"
  },
  {
    "question": "Bellek sızıntısını nasıl tespit edebilirim?",
    "answer": "Bellek sızıntılarını tespit etmek için çeşitli araçlar ve kütüphaneler kullanılabilir. Örneğin, Valgrind gibi bir araç kullanarak programınızı çalıştırabilir ve bellek sızıntılarını raporlayabilirsiniz. Bu tür araçlar, hangi bellek bloklarının serbest bırakılmadığını ve hangi fonksiyonların bu blokları ayırdığını gösterir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.471999"
  },
  {
    "question": "Bellek sızıntısını önlemek için hangi iyi uygulamaları takip etmeliyim?",
    "answer": "Bellek sızıntılarını önlemek için bazı iyi uygulamalar şunlardır: Dinamik bellek ayırma işlemlerinizin hemen ardından free() çağrısını yapmak, bellek ayırdığınız yerleri takip etmek için bir veri yapısı kullanmak ve fonksiyonlar arasında bellek kullanan değişkenleri dikkatli yönetmektir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472025"
  },
  {
    "question": "malloc ve free fonksiyonları arasındaki ilişki nedir?",
    "answer": "malloc(), programda ihtiyaç duyulan bellek miktarını dinamik olarak ayırırken, free() bu bellek alanını serbest bırakmak için kullanılır. Eğer malloc() ile ayırdığınız belleği free() ile serbest bırakmazsanız bellek sızıntısı oluşur. Bu nedenle, her malloc() çağrısının bir karşılık free() çağrısı olmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472046"
  },
  {
    "question": "Bir fonksiyonda dinamik bellek kullanırken dikkat etmem gerekenler nelerdir?",
    "answer": "Bir fonksiyonda dinamik bellek kullanırken, bellek ayırma işlemlerinden sonra mutlaka bu bellek bloğunu serbest bırakmayı unutmayın. Ayrıca, aynı bellek bloğunu birden fazla kez free() çağrısı yapmaktan kaçının, çünkü bu durum programın çökmesine neden olabilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472069"
  },
  {
    "question": "C dilinde dizi kullanırken bellek sızıntısı nasıl önlenir?",
    "answer": "C dilinde dizi kullanırken, dinamik dizi oluşturuyorsanız, bu diziyi malloc() ile ayırdıktan sonra kullanmayı ve işiniz bittiğinde free() ile serbest bırakmayı unutmayın. Örneğin, int* dizi = (int*)malloc(10 * sizeof(int)); kodunu kullandıysanız, dizi ile işiniz bittiğinde free(dizi); çağrısını yapmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472091"
  },
  {
    "question": "Bellek sızıntısı olan bir kod parçası örneği verebilir misin?",
    "answer": "Tabii ki. Aşağıdaki örnekte, dinamik olarak bir dizi ayırdık ancak serbest bırakmayı unuttuk: \n\n```c\nint* dizi = (int*)malloc(5 * sizeof(int));\nfor (int i = 0; i < 5; i++) {\n    dizi[i] = i;\n}\n// Burada free(dizi); çağrısı yok, bu bir bellek sızıntısıdır.\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472113"
  },
  {
    "question": "Dinamik bellek ayırma işlemi sonrası hatalar nasıl giderilir?",
    "answer": "Dinamik bellek ayırma işlemi sonrası hataları gidermek için öncelikle kodu dikkatli bir şekilde gözden geçirip tüm malloc() çağrılarının karşısında free() çağrısının yapıldığından emin olmalısınız. Ayrıca, bellek kullanımını izlemek için Valgrind gibi araçlar kullanarak potansiyel sızıntıları tespit edebilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472134"
  },
  {
    "question": "Bir bellek sızıntısını düzeltmek için hangi adımları izlemeliyim?",
    "answer": "Bir bellek sızıntısını düzeltmek için öncelikle sızıntının kaynağını bulmalısınız. Bunun için bir bellek analiz aracı kullanabilir ve hangi alanların serbest bırakılmadığını tespit edebilirsiniz. Sonrasında ilgili free() çağrılarını ekleyerek sızıntıyı ortadan kaldırmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472155"
  },
  {
    "question": "Bellek sızıntısı yazılım geliştirme sürecinde ne gibi sorunlar yaratır?",
    "answer": "Bellek sızıntıları, yazılım geliştirme sürecinde performans sorunlarına neden olabilir. Uygulama zamanla yavaşlayabilir veya sistemin bellek kapasitesini aşarak çökmesine yol açabilir. Bu nedenle, bellek yönetimine dikkat etmek, yazılım kalitesini artırmak açısından kritik öneme sahiptir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:56:37.472178"
  },
  {
    "question": "Bellek sızıntısı nedir ve neden oluşur?",
    "answer": "Bellek sızıntısı, bir programın dinamik bellek alanında gereksiz yere bellek tahsis etmesi ancak bu belleği serbest bırakmaması durumudur. Genellikle, bir işlev içinde bellek tahsis edildiğinde ve o bellek alanı kullanılmadığında serbest bırakılmadığında meydana gelir. Bu durum, zamanla bellek kullanımının artmasına ve sistemin yavaşlamasına veya çökmesine neden olabilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930658"
  },
  {
    "question": "C dilinde bellek sızıntılarını nasıl tespit edebilirim?",
    "answer": "Bellek sızıntılarını tespit etmek için `valgrind` gibi araçlar kullanabilirsiniz. Valgrind, programınızın bellek kullanımını izler ve serbest bırakılmayan bellek blokları hakkında rapor verir. Programınızı bu araçla çalıştırarak, hangi bellek bloklarının sızıntıya neden olduğunu kolaylıkla görebilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930708"
  },
  {
    "question": "Aşağıdaki kodda bir bellek sızıntısı var mı? Nasıl düzeltebiliriz?\n\n```c\nint* allocate_memory() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int *data = allocate_memory();\n    // Bellek serbest bırakılmıyor\n    return 0;\n}\n```",
    "answer": "Evet, bu kodda bir bellek sızıntısı vardır. `malloc` fonksiyonu ile bellek tahsis ediliyor, ancak `free` fonksiyonu ile bu bellek serbest bırakılmıyor. Bu durumu düzeltmek için `main` fonksiyonunda `free(data);` eklemeliyiz. Güncellenmiş kod:\n\n```c\nint* allocate_memory() {\n    int *arr = (int *)malloc(10 * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int *data = allocate_memory();\n    free(data); // Bellek serbest bırakılıyor\n    return 0;\n}\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930793"
  },
  {
    "question": "Neden `malloc` ile tahsis edilen bellek `free` ile serbest bırakılmalıdır?",
    "answer": "`malloc` fonksiyonu kullanıldığında, işletim sistemi tarafından belirli bir bellek alanı tahsis edilir. Bu bellek, programın çalışması sırasında kullanılabilir. Ancak, program sona erdiğinde veya belleğe ihtiyaç kalmadığında bu bellek alanının geri verilmesi gereklidir. Eğer serbest bırakılmazsa, sistemde kullanılabilir bellek miktarı azalacak ve zamanla bellek sızıntısı oluşacaktır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930822"
  },
  {
    "question": "Bir işlevin içinde tahsis edilen belleği nasıl yönetebilirim?",
    "answer": "Bir işlev içinde tahsis edilen belleği yönetmek için, tahsis edilen belleğin alanını işlevin dışına taşımak, yani dışarıda `free` edilmesi için pointer döndürmek en iyi yoldur. Özellikle, işlev sonunda belleği serbest bırakmak için çağıran kodun sorumluluğuna bırakırsak bellek sızıntılarını önlemiş oluruz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930853"
  },
  {
    "question": "Kodda bellek sızıntısını önlemek için hangi iyi uygulamalar vardır?",
    "answer": "Bellek sızıntısını önlemek için birkaç iyi uygulama vardır: 1. Her `malloc` çağrısını bir `free` çağrısı ile eşleştirin. 2. Bellek tahsisi sonrası işlev içinde veya dışında dereferencing yapmadan önce NULL kontrolü yapın. 3. Bellek tahsis edilen işlevlerde, kullanılmayan bellekleri serbest bırakmayı unutmamak için `try...catch` yapıları kullanın. 4. Kullanım bitiminde belleği serbest bırakmayı otomatik hale getiren veri yapıları kullanın.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930878"
  },
  {
    "question": "C dilinde çok boyutlu dizilerde bellek sızıntısı nasıl oluşabilir?",
    "answer": "C dilinde çok boyutlu diziler dinamik olarak tahsis edilirse, her bir boyut için ayrı ayrı `malloc` çağrısı yapılması gerekebilir. Eğer bu dizilerin bellek alanı serbest bırakılmazsa, her bir `malloc` çağrısı bellek sızıntısına neden olur. Örneğin:\n\n```c\nint **arr;\narr = malloc(3 * sizeof(int *));\nfor (int i = 0; i < 3; i++) {\n    arr[i] = malloc(4 * sizeof(int));\n}\n// Burada serbest bırakma işlemi yok\n```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930901"
  },
  {
    "question": "Belirli bir süre sonra kullanılmayan bellek bloklarını nasıl serbest bırakabilirim?",
    "answer": "Bu tip sorunları önlemek için bellek yönetimi stratejileri kullanabilirsiniz. Örneğin, bellek havuzları (memory pools) oluşturmak, belirli bir süre kullanılmayan bellek bloklarını otomatik olarak serbest bırakmanıza yardımcı olabilir. Ayrıca, belirli bir zaman diliminde kullanılmayan bellek alanını kontrol eden bir yöneticiyi entegre ederek, bu alanı yönlendirebilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930926"
  },
  {
    "question": "C dilinde döngüler içinde bellek tahsisi yapmanın riskleri nelerdir?",
    "answer": "Döngüler içinde bellek tahsisi yapmak, her döngü döndüğünde yeni bir bellek bloğu tahsis ettiği için bellek sızıntısına yol açabilir. Eğer her döngüde tahsis edilen bellek dışında serbest bırakılmıyorsa, kullanılmayan bellek miktarı zamanla artar. Bu durumu önlemek için, her tahsis işleminden sonra uygun şekilde `free` çağrısı yapmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930948"
  },
  {
    "question": "C dilinde bellek sızıntılarını önlemek için en iyi alternatifler nelerdir?",
    "answer": "Bellek sızıntılarını önlemek için önerilen en iyi alternatifler arasında akıllı pointerlar (Smart Pointers) kullanmak, otomatik bellek yönetimi sağlayan kütüphaneler kullanmak (örneğin, C++ için std::unique_ptr veya std::shared_ptr) ve bellek havuzları oluşturmak yer alır. Bu yöntemler, bellek yönetimini kolaylaştırır ve sızıntı olasılığını azaltır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:02.930971"
  },
  {
    "question": "Dinamik bellek tahsisi nasıl yapılır ve bellek sızıntısına neden olabilecek durumlar nelerdir?",
    "answer": "Dinamik bellek tahsisi, C dilinde 'malloc', 'calloc' veya 'realloc' gibi fonksiyonlar kullanılarak yapılır. Bellek sızıntıları, tahsis edilen belleğin serbest bırakılmaması durumunda ortaya çıkar. Örneğin, bir dizi oluşturup, ardından serbest bırakmadan farklı bir diziye geçiş yaparsanız, önceki bellek bloğu kaybolur ve bu bir bellek sızıntısına yol açar. Örnek: 'int *arr = malloc(10 * sizeof(int));' sonrası 'free(arr);' çağrısı yapılmazsa, bellek sızıntısı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503160"
  },
  {
    "question": "Bir yapı (struct) içinde dinamik bellek tahsisi yaparken dikkat edilmesi gerekenler nelerdir?",
    "answer": "Bir yapı içinde dinamik bellek tahsisi yaparken, yapının her örneği için tahsis edilen belleği serbest bırakmak önemlidir. Örneğin, bir 'Node' yapısında veri ve bir sonraki düğüm için bellek tahsis ediyorsanız, 'Node' yapısının her bir örneği için 'free' çağrısını yapmalısınız. Aksi halde, her 'Node' için tahsis edilen bellek sızıntısı olacaktır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503204"
  },
  {
    "question": "C dilinde bir fonksiyon içinde dinamik bellek tahsis ettiğimde, bu belleği nasıl yönetmeliyim?",
    "answer": "Fonksiyon içinde dinamik bellek tahsis ettiğinizde, belleği serbest bırakma sorumluluğu, bu belleği alan fonksiyona aittir. Eğer fonksiyon bir işlevsellik sunuyorsa ve bellek alanını döndürüyor ise, dönen bellek alanının serbest bırakılması gerektiğini dokümante etmelisiniz. Örneğin, 'char* create_buffer(size_t size) { char* buf = malloc(size); return buf; }' fonksiyonundan dönen 'buf' belleği, çağıran fonksiyonda 'free(buf);' ile serbest bırakılmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503235"
  },
  {
    "question": "C dilinde bir döngü içinde sürekli olarak bellek tahsisi yapmak ne gibi sorunlar yaratır?",
    "answer": "Döngü içinde sürekli bellek tahsisi yapmak, her döngü iterasyonunda yeni bellek blokları ayırır, ancak bunların serbest bırakılmaması durumunda bellek sızıntısına yol açar. Örneğin, 'for (int i = 0; i < 10; i++) { int* ptr = malloc(sizeof(int)); }' yazdığınızda, her 'malloc' çağrısı için bir bellek bloğu tahsis edilir, ama bunları serbest bırakmadıysanız, sızıntı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503263"
  },
  {
    "question": "Bellek sızıntılarını tespit etmek için hangi araçları kullanabilirim?",
    "answer": "Bellek sızıntılarını tespit etmek için 'Valgrind', 'AddressSanitizer' ve 'Electric Fence' gibi araçlar kullanılabilir. Valgrind, bellek kullanımını izleyerek sızıntıları ve hataları raporlar. Örneğin, Valgrind kullanarak bir programı çalıştırdığınızda, 'valgrind ./my_program' komutunu vererek bellek sızıntılarını görebilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503285"
  },
  {
    "question": "Birden fazla iş parçacığı (thread) ile çalışırken bellek sızıntılarını nasıl önleyebilirim?",
    "answer": "Birden fazla iş parçacığı ile çalışırken, her iş parçacığının kendi bellek alanını yönetmesi önemlidir. İş parçacıkları arasında veri paylaşımında dikkatli olmalısınız. Mutex'ler veya semaforlar kullanarak, bellek tahsisi ve serbest bırakma işlemlerini senkronize etmelisiniz. Örneğin, bir iş parçacığı bir bellek bloğunu tahsis edip kullanırken, diğer iş parçacığının o bloğu serbest bırakmadığından emin olmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503314"
  },
  {
    "question": "C dilinde, bir bellek bloğunun yeniden tahsis edilmesi (realloc) sırasında sızıntılardan nasıl kaçınılır?",
    "answer": "Realloc kullanırken, bellek bloğunun yeniden tahsis edilmesi durumunda eski bellek bloğunun kaybolmaması için dikkatli olunmalıdır. Örneğin, 'int* arr = malloc(10 * sizeof(int));' ifadesi ile bellek tahsis ettikten sonra, 'int* new_arr = realloc(arr, 20 * sizeof(int));' kullandığınızda, 'arr' değişkenine atama yapmadan önce 'new_arr' kontrol edilmelidir. Eğer 'realloc' başarısız olursa, 'arr' belleği kaybolur ve sızıntı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503373"
  },
  {
    "question": "Fonksiyonlar arasında bellek sızıntısı olasılığını azaltmak için tasarımda ne tür önlemler alınabilir?",
    "answer": "Fonksiyonlar arasında bellek sızıntısı olasılığını azaltmak için 'RAII' (Resource Acquisition Is Initialization) prensibini veya akıllı işaretçileri (smart pointers) kullanabilirsiniz. Dinamik belleği yöneten bir yapı oluşturarak, fonksiyonlar yalnızca yapı üzerinden bellekle etkileşimde bulunur ve serbest bırakma işlemleri yapı tarafından otomatik olarak yönetilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503403"
  },
  {
    "question": "Yardımcı fonksiyonlar kullanarak bellek sızıntılarını nasıl önleyebilirim?",
    "answer": "Yardımcı fonksiyonlar oluşturarak bellek sızıntılarını önleyebilirsiniz. Örneğin, 'create_array' fonksiyonu belleği tahsis ederken, 'destroy_array' fonksiyonu belleği serbest bırakma işlevini üstlenebilir. Bu şekilde, bellek yönetimini merkezi bir yere taşıyarak sızıntıların önlenmesine yardımcı olabilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503426"
  },
  {
    "question": "C dilinde, bir dizinin elemanlarını dinamik olarak tahsis ederken nelere dikkat edilmelidir?",
    "answer": "Bir dizinin elemanlarını dinamik olarak tahsis ederken, her bir elemanın serbest bırakılmasını sağlamak önemlidir. Eğer diziyi dinamik olarak tahsis ettiyseniz, tüm elemanların serbest bırakılması gerektiğinden, belleği yönetmek için bir döngü kullanmalısınız. Örneğin: 'int *arr = malloc(size * sizeof(int));' sonrası 'for (int i = 0; i < size; i++) free(arr[i]); free(arr);' ile belleği doğru şekilde serbest bırakmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:18.503452"
  },
  {
    "question": "Dinamik bir dizi oluşturmak için gerekli olan kodu yaz ve bellek sızıntısını önlemek için gerekli önlemleri al.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr;\n    int n;\n    printf(\"Dizinin boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    // Bellek ayırma\n    arr = (int *)malloc(n * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n\n    // Dizi elemanlarını doldurma\n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n\n    // Dizi elemanlarını yazdırma\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    // Belleği serbest bırakma\n    free(arr);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467572"
  },
  {
    "question": "Bir yapıyı dinamik olarak oluştur ve bellek sızıntısını önlemek için nasıl bir çözüm uygularsın?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Student;\n\nint main() {\n    Student *student = (Student *)malloc(sizeof(Student));\n    if (student == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n\n    // Öğrenci bilgilerini alma\n    student->id = 1;\n    snprintf(student->name, sizeof(student->name), \"John Doe\");\n\n    // Öğrenci bilgisini yazdırma\n    printf(\"ID: %d, Name: %s\\n\", student->id, student->name);\n\n    // Belleği serbest bırakma\n    free(student);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467617"
  },
  {
    "question": "Bir linked list oluştur ve her düğüm için dinamik bellek ayırırken sızıntıyı önle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nvoid freeList(Node* head) {\n    Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n\nint main() {\n    Node* head = (Node*)malloc(sizeof(Node));\n    if (head == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    head->data = 1;\n    head->next = NULL;\n\n    // Listeyi serbest bırakma\n    freeList(head);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467646"
  },
  {
    "question": "Bir metin dosyasını okuyan bir program yaz ve bellek sızıntısını nasıl önlersin?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    char *buffer = (char *)malloc(100 * sizeof(char));\n    if (buffer == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        fclose(file);\n        return 1;\n    }\n\n    while (fgets(buffer, 100, file)) {\n        printf(\"%s\", buffer);\n    }\n\n    // Belleği serbest bırakma\n    free(buffer);\n    fclose(file);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467672"
  },
  {
    "question": "Bir dizi içerisindeki en büyük sayıyı bul ve bellek sızıntısını önlemek için dikkat edilmesi gerekenleri belirt.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    printf(\"Dizinin boyutunu girin: \");\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    if (arr == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Dizi elemanını girin: \");\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    printf(\"En büyük sayı: %d\\n\", max);\n\n    // Belleği serbest bırakma\n    free(arr);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467711"
  },
  {
    "question": "Pointer kullanarak bir integer değerini dinamik olarak ayır ve serbest bırak.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr = (int *)malloc(sizeof(int));\n    if (ptr == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    *ptr = 10;\n    printf(\"Değer: %d\\n\", *ptr);\n\n    // Belleği serbest bırakma\n    free(ptr);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467738"
  },
  {
    "question": "Bir karakter dizisini dinamik olarak oluştur ve bellek sızıntısını önlemek için neler yapmalısın?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *str = (char *)malloc(100 * sizeof(char));\n    if (str == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return 1;\n    }\n    snprintf(str, 100, \"Merhaba Dünya!\");\n    printf(\"String: %s\\n\", str);\n\n    // Belleği serbest bırakma\n    free(str);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467768"
  },
  {
    "question": "Aynı anda birden fazla dinamik bellek ayırma işlemi yap ve bunları dikkatli bir şekilde serbest bırak.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr1 = (int *)malloc(10 * sizeof(int));\n    int *arr2 = (int *)malloc(20 * sizeof(int));\n\n    if (arr1 == NULL || arr2 == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        free(arr1);\n        free(arr2);\n        return 1;\n    }\n\n    // İşlemler\n\n    // Belleği serbest bırakma\n    free(arr1);\n    free(arr2);\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467799"
  },
  {
    "question": "Bir fonksiyon çağrısı içinde dinamik bellek ayır ve çağrı sonrasında bellek sızıntısının önlenmesi için ne yapmalısın?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid allocateMemory() {\n    int *ptr = (int *)malloc(sizeof(int));\n    if (ptr == NULL) {\n        printf(\"Bellek ayırma hatası!\");\n        return;\n    }\n    *ptr = 42;\n    printf(\"Fonksiyon içindeki değer: %d\\n\", *ptr);\n    // Belleği serbest bırakma\n    free(ptr);\n}\n\nint main() {\n    allocateMemory();\n    return 0;\n}",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:57:54.467833"
  },
  {
    "question": "Dinamik bellek tahsisi yaptıktan sonra, belleği serbest bırakmazsanız ne olur?",
    "answer": "Dinamik bellek tahsisi yapıldığında, bu bellek alanı heap üzerinde ayrılır. Eğer bu bellek alanı kullanılmadıktan sonra serbest bırakılmazsa, programın yaşam süresi boyunca bu bellek alanı kullanılamaz hale gelir ve bu duruma bellek sızıntısı denir. Sonuç olarak, program uzun süre çalışıyorsa, yeterli bellek kalmayabilir ve bu durum performans düşüklüğüne ya da çökme gibi sorunlara yol açabilir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446475"
  },
  {
    "question": "Bir yapının içinde dinamik olarak tahsis edilmiş alan varsa, bunu nasıl serbest bırakmalıyız?",
    "answer": "Eğer bir yapı içinde dinamik olarak tahsis edilmiş alan varsa, yapının serbest bırakılmadan önce bu alanların serbest bırakılması gerekir. Örneğin, bir yapı tanımlayalım: 'typedef struct { int *data; } MyStruct;'. Bu durumda 'MyStruct' türünden bir değişken oluşturduktan sonra 'data' alanına bellek tahsis ettiğimizde, 'free(myStruct.data);' ile bu belleği serbest bırakmayı unutmamalıyız. Aksi takdirde bellek sızıntısı oluşur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446546"
  },
  {
    "question": "Bellek sızıntılarını tespit etmek için hangi araçları kullanabilirsiniz?",
    "answer": "Bellek sızıntılarını tespit etmek için kullanılan bazı popüler araçlar arasında Valgrind, AddressSanitizer ve LeakSanitizer bulunmaktadır. Örneğin, Valgrind kullanarak bir programı çalıştırdığınızda, bellek sızıntılarını tespit edebilir ve hangi hatalı noktaların sızıntıya sebep olduğunu görebilirsiniz. Bu araçlar, bellek yönetimi ile ilgili sorunları bulmanıza yardımcı olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446572"
  },
  {
    "question": "Bir fonksiyondan döndürdüğünüz bir işaretçi için bellek yönetimini nasıl sağlamalısınız?",
    "answer": "Eğer bir fonksiyondan dinamik olarak tahsis edilmiş bir işaretçi döndürecekseniz, bu işaretçinin belleğini kullanan kod parçasının bu belleği serbest bırakması gerektiğini açıkça belirtmelisiniz. Örneğin: 'int* createArray(int size) { int* arr = malloc(size * sizeof(int)); return arr; }'. Bu durumda, 'createArray' fonksiyonunun döndürdüğü işaretçi ile oluşturulan dizinin kullanıldığı yerde 'free(arr);' ile belleğin serbest bırakıldığından emin olmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446601"
  },
  {
    "question": "Birden fazla yerden aynı bellek alanına erişim olursa, bellek sızıntısı nasıl oluşur?",
    "answer": "Eğer bir bellek alanı birden fazla yerden serbest bırakılmaya çalışılırsa, bu durum 'double free' hatasına neden olabilir. Bu tür hatalar, belleğin yanlış bir şekilde yönetilmesine yol açarak potansiyel bellek sızıntılarına neden olabilir. Örneğin, bir işaretçinin birden fazla yerde 'free' komutu ile serbest bırakılması durumu, bellek sızıntısı ve çökme gibi sorunlara yol açabilir. Bu yüzden, bir işaretçiyi yalnızca bir kez serbest bırakmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446629"
  },
  {
    "question": "Bir diziye dinamik bellek tahsis ettikten sonra, elemanlarını nasıl kontrol edersiniz?",
    "answer": "Dinamik olarak tahsis edilmiş bir dizinin elemanlarını kontrol etmek için, dizinin işaretçisini kullanarak her bir elemanı gözden geçirebiliriz. Örneğin: 'int* arr = malloc(size * sizeof(int));' ile bir dizi oluşturduysak, 'for (int i = 0; i < size; i++) { printf(\"%d\", arr[i]); }' kullanarak dizinin elemanlarını kontrol edebiliriz. Unutmayın ki diziyi kullandıktan sonra 'free(arr);' ile belleği serbest bırakmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446656"
  },
  {
    "question": "Kapsayıcı yapılar (struct, union) kullanırken bellek yönetimini nasıl sağlamalısınız?",
    "answer": "Kapsayıcı yapılar kullanırken, içlerinde dinamik bellek tahsisi yapılmış alanlar varsa, yapının serbest bırakılmadan önce her iç alanın da serbest bırakılması gerekir. Örneğin: 'typedef struct { char *name; int *ages; } People;'. Bu durumda, 'People' yapısının 'name' ve 'ages' alanlarına bellek tahsis ettiğimizde, 'free(people.name); free(people.ages);' ile bu alanları serbest bırakmayı unutmamalıyız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446683"
  },
  {
    "question": "C dilinde çok boyutlu dizileri dinamik olarak nasıl tahsis edersiniz?",
    "answer": "C dilinde çok boyutlu dizileri dinamik olarak tahsis etmek için, işaretçilerin işaretçi dizisi kullanabiliriz. Örneğin, 'int** matrix = malloc(rows * sizeof(int*));' ile satır sayısını tahsis ettikten sonra, her satır için ayrı ayrı bellek tahsis etmeliyiz: 'for (int i = 0; i < rows; i++) { matrix[i] = malloc(cols * sizeof(int)); }'. Kullanım tamamlandığında, her satır ve ardından ana dizi serbest bırakılmalıdır: 'for (int i = 0; i < rows; i++) { free(matrix[i]); } free(matrix);'.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446708"
  },
  {
    "question": "Bellek sızıntılarını önlemek için hangi iyi uygulamaları takip etmelisiniz?",
    "answer": "Bellek sızıntılarını önlemek için bazı iyi uygulamalar şunlardır: 1) Bellek tahsis ettikten sonra, her zaman serbest bırakmayı unutmayın; 2) İşaretçileri NULL yaparak işaretçilerin çift serbest bırakılmalarını önleyin; 3) Dinamik bellek tahsisi yapmadan önce gereken bellek miktarını dikkatlice hesaplayın. 4) Bellek yönetimi için akıllı işaretçiler (C dilinde nadir, ama C++) kullanmayı düşünün.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446732"
  },
  {
    "question": "C dilinde bellek sızıntılarını önlemek için nasıl bir hata kontrolü yapmalısınız?",
    "answer": "Bellek sızıntılarını önlemek için, her dinamik bellek tahsisi işleminden sonra, tahsisin başarılı olup olmadığını kontrol etmelisiniz. Örneğin: 'int* arr = malloc(size * sizeof(int));' satırında, 'if (arr == NULL) { printf(\"Bellek tahsisi başarısız!\"); exit(1); }' ile bellek tahsisinin başarılı olup olmadığını kontrol edebilirsiniz. Bu, bellek yönetimini daha güvenli hale getirir ve sızıntıları önlemeye yardımcı olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:20.446757"
  },
  {
    "question": "C dilinde dinamik bellek tahsisi yaparken bellek sızıntısını önlemek için hangi önlemleri almalıyız?",
    "answer": "Dinamik bellek tahsisi yaparken (örneğin, malloc, calloc, realloc kullanarak) her tahsisten sonra allocated belleği serbest bırakmayı unutmamak önemlidir. Aksi takdirde, belleği kullandıktan sonra serbest bırakmadığınızda bellek sızıntıları oluşur. Özellikle, fonksiyonlar içinde belleği tahsis edip, çıkışta serbest bırakmamayı önlemek için gerekli kontrolleri yapmalısınız. Tüm bellek tahsis işlemlerine karşılık gelen free() çağrıları yapılmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229724"
  },
  {
    "question": "Bir yapı (struct) okuma ve yazma işlemleri yapan bir fonksiyonda bellek sızıntısı nasıl oluşabilir ve nasıl önlenir?",
    "answer": "Yapılar üzerinde dinamik bellek tahsisi yapılırken, yapı içerisindeki her işaretçinin doğru bir şekilde yönetilmesi gerekir. Örneğin, bir yapının içindeki işaretçi bir başka dinamik belleğe işaret ediyorsa, bu belleği serbest bırakmadan yapıyı serbest bırakmak bellek sızıntısına yol açar. Bu durumu önlemek için, yapıyı kullanmadan önce içindeki tüm işaretçilerin serbest bırakıldığından emin olunmalı ve yapının serbest bırakılmadan önce işaretçilerin NULL olarak ayarlanması sağlanmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229783"
  },
  {
    "question": "C dilinde Linked List yapısında bellek sızıntılarını nasıl tespit edip giderebiliriz?",
    "answer": "Linked List yapısında her düğüm için dinamik bellek tahsisi yapıldığında, düğümler arasındaki bağlantıları kaybetmemek önemlidir. Her düğümü serbest bırakmadan önce, bir önceki düğümden gelen bağlantıyı takip etmek gerekir. Ayrıca, tüm düğümler serbest bırakılmadan önce listenin başına geri dönülmeli ve her düğüm için free() çağrısı yapılmalıdır. Bellek sızıntılarını tespit etmek için ayrıca 'valgrind' gibi araçlar kullanarak uygulamanın çalışma süresinde bellek kullanımını izlemek faydalı olacaktır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229810"
  },
  {
    "question": "C dilinde, bir fonksiyon içinde dinamik olarak tahsis ettiğiniz belleği nasıl güvenli bir şekilde serbest bırakabilirsiniz?",
    "answer": "Fonksiyon içinde tahsis edilen belleği serbest bırakmak için, tahsis edilen bellek adresini global veya statik bir işaretçiye atamak ve fonksiyon çıkmadan önce bu işaretçiyi 'free()' ile serbest bırakmak gerekir. Ayrıca, işaretçiyi serbest bıraktıktan sonra NULL yaparak, ileride bu işaretçiye erişim hatalarını önleyebilirsiniz. Fonksiyon bitiminde, belleği kullanmadığınızdan emin olmak için bu teknikleri kullanmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229852"
  },
  {
    "question": "Hatalı bellek erişimi nedir ve bellek sızıntıları ile nasıl bir ilişkisi vardır?",
    "answer": "Hatalı bellek erişimi, programın tahsis edilmemiş bellek alanlarına erişmeye çalıştığında veya serbest bırakılmış belleğe erişmeye çalıştığında ortaya çıkar. Bu durum, bellek sızıntılarına sebep olabileceği gibi programın çökmesine de yol açabilir. Bellek yönetiminin dikkatle yapılması, tahsis edilen alanların doğru bir şekilde kullanılmasını ve sonlandırılmasını sağlayarak bu tür hataların önlenmesine yardımcı olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229880"
  },
  {
    "question": "C dilinde bellek sızıntılarını önlemek için akıllı işaretçiler (smart pointers) kullanabilir miyiz? Nasıl?",
    "answer": "C dilinde doğrudan akıllı işaretçi kavramı yoktur, ancak benzer bir işlevselliği sağlamak için yapılar ve fonksiyonlar kullanarak kendi akıllı işaretçi benzeri yapılarınızı oluşturabilirsiniz. Örneğin, bir yapı oluşturarak, bu yapının içinde hem işaretçi hem de bu işaretçiyi serbest bırakacak bir fonksiyon tanımlayabilirsiniz. Bu yapı ile belleği otomatik olarak yöneterek sızıntıları azaltabilirsiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229912"
  },
  {
    "question": "C dilinde bir dizi üzerinde bellek sızıntısı oluşturacak bir örnek senaryo paylaşır mısınız?",
    "answer": "Bir dizi üzerinde bellek sızıntısı oluşturacak bir senaryo, dinamik bir diziye veri eklerken her seferinde yeni bir dizi tahsis etmek ve eski diziyi serbest bırakmamaktır. Örneğin: 'array = malloc(sizeof(int) * newSize);' çağrısı yapılırken, eski 'array' işaretçisi unutulursa ve yeni tahsis edilen bellek için eski bellek serbest bırakılmazsa, bellek sızıntısı oluşur. Her yeni dizi tahsisi öncesinde eski işaretçinin 'free()' ile serbest bırakılması şarttır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229940"
  },
  {
    "question": "C dilinde bir dosyadan okunan veriler için bellek yönetimi yaparken hangi yöntemleri kullanmalıyız?",
    "answer": "Bir dosyadan okunan verileri dinamik olarak belleğe alırken, her okunan veri için bellek tahsisi yapıyorsanız, okunan verilerin işlenmesi bittikten sonra her bir veriyi serbest bırakmayı unutmayın. Örneğin, okunan her satır için 'malloc' kullanarak yer tahsis ediyorsanız, dosya okuma işleminin sonunda her bir buffer belleği 'free()' ile serbest bırakılmalıdır. Ayrıca, dikkatlice bellek tahsisi ve serbest bırakma işlemlerini takip etmek, sızıntıları önlemek açısından önemlidir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229968"
  },
  {
    "question": "C dilinde çok boyutlu dizilerde bellek sızıntısını nasıl önleyebiliriz?",
    "answer": "Çok boyutlu dizilerde bellek yönetimi yaparken her boyut için ayrı ayrı dinamik bellek tahsisi yapılır. Her bir boyut için tahsis edilen bellek, kullanımdan sonra serbest bırakılmalıdır. Örneğin, 'int** array = malloc(sizeof(int*) * rows);' ile tahsis edilen her 'int*' işaretçisi için serbest bırakma yapılmalı ve en son ana dizinin belleği serbest bırakılmalıdır. Ayrıca, her boyut için tahsis edilen belleğin NULL kontrolü yapılmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.229991"
  },
  {
    "question": "C dilinde bir kütüphane geliştirirken kullanıcıların bellek sızıntısı yapmaması için hangi yöntemleri önerirsiniz?",
    "answer": "Bir kütüphane geliştirirken, kullanıcıların bellek sızıntısı yapmamalarını sağlamak için API'nizde bellek tahsisi ve serbest bırakma işlemlerinin düzenli bir şekilde yapılmasını belirten net dökümantasyon sağlamalısınız. Ayrıca, kütüphane içerisinde otomatik bellek yönetimi yapacak fonksiyonlar oluşturarak, bellek tahsisinden sonra otomatik olarak belleği serbest bırakacak yapılar kullanabilirsiniz. Kullanıcıların bellek yönetimini kolaylaştırmak için örnek kodlar ve kullanım yönergeleri de sağlanmalıdır.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:58:45.230023"
  },
  {
    "question": "Bir dinamik bellek tahsisi yapıldıktan sonra, serbest bırakılmadığı için bellek sızıntısı oluşuyor. Aşağıdaki kodda bu sorun nasıl çözülebilir? \n\n```c\nint* allocateArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* myArray = allocateArray(10);\n    // buraya kadar her şey normal, fakat myArray kullanılmadı ve serbest bırakılmadı.\n    return 0;\n}```",
    "answer": "Bellek sızıntısını önlemek için dinamik olarak tahsis edilen bellek serbest bırakılmalıdır. Yukarıdaki kodda `free(myArray);` ifadesi eklenmelidir. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\nint* allocateArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* myArray = allocateArray(10);\n    // myArray kullanıldıktan sonra serbest bırakılmalıdır.\n    free(myArray);\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.947836"
  },
  {
    "question": "Fonksiyon içinde oluşturulan bir diziye bellek tahsis ediliyor fakat bu bellek ana fonksiyonda serbest bırakılmıyor. Nasıl düzeltilebilir? \n\n```c\nvoid createBuffer(char** buffer) {\n    *buffer = (char*)malloc(256);\n}\n\nint main() {\n    char* myBuffer = NULL;\n    createBuffer(&myBuffer);\n    // Bellek serbest bırakılmıyor.\n    return 0;\n}```",
    "answer": "Ana fonksiyonda `myBuffer` kullanıldıktan sonra serbest bırakılmalıdır. Kod aşağıdaki gibi düzeltilmelidir:\n\n```c\nvoid createBuffer(char** buffer) {\n    *buffer = (char*)malloc(256);\n}\n\nint main() {\n    char* myBuffer = NULL;\n    createBuffer(&myBuffer);\n    // myBuffer kullanıldıktan sonra serbest bırakılmalıdır.\n    free(myBuffer);\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.947951"
  },
  {
    "question": "Bir linked list yapısında her düğüm için dinamik bellek tahsis ediliyor fakat temizleme fonksiyonu eksik. Aşağıdaki kodda bellek sızıntısı nasıl önlenebilir? \n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    Node* head = createNode(1);\n    head->next = createNode(2);\n    // Temizleme işlemi yok.\n    return 0;\n}```",
    "answer": "Linked list temizleme fonksiyonu eklenerek bellek sızıntısı önlenebilir. Bu fonksiyon tüm düğümleri serbest bırakmalıdır. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\nvoid freeList(Node* head) {\n    Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n\nint main() {\n    Node* head = createNode(1);\n    head->next = createNode(2);\n    freeList(head); // Temizleme işlemi burada yapılıyor.\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948084"
  },
  {
    "question": "Bir dizi için bellek tahsis ediliyor fakat hatalı bir şekilde serbest bırakılıyor. Bu bellek sızıntısını nasıl önleyebilirim? \n\n```c\nint* allocateIntArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* myArray = allocateIntArray(5);\n    // Bellek yanlış bir şekilde serbest bırakılıyor.\n    free(&myArray);\n    return 0;\n}```",
    "answer": "Belleği serbest bırakırken işaretçi değişkeninin kendisini değil, gösterdiği adresi kullanmalısınız. `free(myArray);` olarak değiştirilmelidir. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\nint* allocateIntArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* myArray = allocateIntArray(5);\n    free(myArray); // Doğru serbest bırakma işlemi\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948180"
  },
  {
    "question": "Çok katmanlı bir programda bir nesne dizisi dinamik olarak tahsis ediliyor fakat ana fonksiyonda serbest bırakılmıyor. Aşağıdaki kodda ilgili bellek sızıntısı nasıl giderilir? \n\n```c\ntypedef struct Object {\n    int id;\n} Object;\n\nObject* createObjects(int count) {\n    return (Object*)malloc(count * sizeof(Object));\n}\n\nint main() {\n    Object* objects = createObjects(10);\n    // Bellek serbest bırakılmıyor.\n    return 0;\n}```",
    "answer": "Ana fonksiyonda `objects` kullanıldıktan sonra serbest bırakılmalıdır. Kod aşağıdaki gibi düzeltilmelidir:\n\n```c\ntypedef struct Object {\n    int id;\n} Object;\n\nObject* createObjects(int count) {\n    return (Object*)malloc(count * sizeof(Object));\n}\n\nint main() {\n    Object* objects = createObjects(10);\n    // Kullanımdan sonra bellek serbest bırakılmalıdır.\n    free(objects);\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948280"
  },
  {
    "question": "Aynı bellek alanı birden fazla kez tahsis ediliyor ama sadece bir kez serbest bırakılıyor. Bu durumda bellek sızıntısı nasıl oluşuyor? \n\n```c\nint* allocateMemory() {\n    int* p = (int*)malloc(sizeof(int));\n    return p;\n}\n\nint main() {\n    int* ptr1 = allocateMemory();\n    int* ptr2 = allocateMemory();\n    // ptr1 ve ptr2 için ayrı ayrı bellek serbest bırakılmıyor.\n    free(ptr1);\n    return 0;\n}```",
    "answer": "Her tahsis edilen bellek için serbest bırakma işlemi yapılmalıdır. `free(ptr2);` ifadesi eklenmelidir. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\nint* allocateMemory() {\n    int* p = (int*)malloc(sizeof(int));\n    return p;\n}\n\nint main() {\n    int* ptr1 = allocateMemory();\n    int* ptr2 = allocateMemory();\n    free(ptr1);\n    free(ptr2); // Her iki bellek alanı da serbest bırakılıyor.\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948389"
  },
  {
    "question": "Bir fonksiyonda bellek tahsisi yapıldıktan sonra bu bellek serbest bırakılmıyor. Çözümü nedir? \n\n```c\nvoid function() {\n    int* data = (int*)malloc(100);\n    // Bellek kullanılmıyor ve serbest bırakılmıyor.\n}\n\nint main() {\n    function();\n    return 0;\n}```",
    "answer": "Fonksiyonun içinde tahsis edilen bellek dışarıdan erişilemiyor, bu yüzden serbest bırakma işlemi dışarıda yapılamaz. Bu durumda bellek serbest bırakma işlemi fonksiyon içinde gerçekleştirilmelidir. Aşağıda düzeltilmiş hali:\n\n```c\nvoid function() {\n    int* data = (int*)malloc(100);\n    // Bellek kullanıldı ve şimdi serbest bırakılıyor.\n    free(data);\n}\n\nint main() {\n    function();\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948457"
  },
  {
    "question": "Bir nesne dizisi oluşturuluyor fakat serbest bırakılmıyor. Aşağıdaki kodda bellek sızıntısını nasıl önleyebilirim? \n\n```c\ntypedef struct Point {\n    int x, y;\n} Point;\n\nPoint* createPoints(int count) {\n    return (Point*)malloc(count * sizeof(Point));\n}\n\nint main() {\n    Point* points = createPoints(10);\n    // Serbest bırakılmıyor.\n    return 0;\n}```",
    "answer": "Ana fonksiyonda `points` kullanıldıktan sonra serbest bırakılmalıdır. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\ntypedef struct Point {\n    int x, y;\n} Point;\n\nPoint* createPoints(int count) {\n    return (Point*)malloc(count * sizeof(Point));\n}\n\nint main() {\n    Point* points = createPoints(10);\n    free(points); // Bellek burada serbest bırakılıyor.\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948556"
  },
  {
    "question": "Dinamik oluşturulan bir dizide bellek sızıntısı meydana geliyor. Aşağıdaki kodda bunu düzeltmek için ne yapmalıyım? \n\n```c\nint* allocateDynamicArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* dynamicArray = allocateDynamicArray(5);\n    // Serbest bırakılmıyor.\n    return 0;\n}```",
    "answer": "Ana fonksiyonda `dynamicArray` kullanıldıktan sonra `free(dynamicArray);` ifadesi eklenmelidir. Aşağıda düzeltilmiş hali verilmiştir:\n\n```c\nint* allocateDynamicArray(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    return arr;\n}\n\nint main() {\n    int* dynamicArray = allocateDynamicArray(5);\n    free(dynamicArray); // Bellek burada serbest bırakılıyor.\n    return 0;\n}```",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:20.948641"
  },
  {
    "question": "Bir işlev içinde malloc ile ayrılan bellek, işlevin sonunda neden serbest bırakılmıyor?",
    "answer": "Eğer bir işlev içinde malloc ile bellek ayırıyorsanız, işlevin sonunda, o bellek alanını serbest bırakmayı unutursanız bellek sızıntısına yol açarsınız. Örneğin:\n\n```c\nvoid create_array(int size) {\n    int *arr = malloc(size * sizeof(int));\n    // İşlemler...\n    // free(arr); // Bu satır eksik olduğunda bellek sızar.\n}\n```\nYukarıdaki kodda `arr` için ayrılan bellek serbest bırakılmadığı için her çağrıldığında bellek sızıntısı yaşayacağız. Çözüm, işlevin sonunda `free(arr);` çağrısını eklemektir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688224"
  },
  {
    "question": "Birden fazla nesne için bellek ayırdığınızda, bellek sızıntısını nasıl önlersiniz?",
    "answer": "Birden fazla nesne için bellek ayırdığınızda, her nesne için ayrı ayrı serbest bırakmalısınız. Örneğin:\n\n```c\nvoid create_structs(int count) {\n    MyStruct *array = malloc(count * sizeof(MyStruct));\n    for (int i = 0; i < count; i++) {\n        array[i] = create_struct(); // Farz edelim ki create_struct da bellek ayırıyor.\n    }\n    // free(array); // Sonsuz döngüye neden olabilir.\n}\n```\nEğer `create_struct()` içinde bellek ayrılıyorsa, her bir nesne için `free` çağrılması gerektiğini unutmamalıyız. Her yapıyı serbest bırakmayı unutmayın.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688267"
  },
  {
    "question": "Bir diziyi serbest bırakırken nasıl doğru kullanmalısınız?",
    "answer": "Diziyi serbest bırakırken, dizinin elemanlarının da serbest bırakılması gerekebilir. Örneğin:\n\n```c\ntypedef struct {\n    char *name;\n} Person;\n\nvoid create_persons(int count) {\n    Person *people = malloc(count * sizeof(Person));\n    for (int i = 0; i < count; i++) {\n        people[i].name = malloc(50); // Her kişi için bellek ayırıyoruz.\n    }\n    // İşlemler...\n    // free(people); // Bu tek başına yeterli değil.\n}\n```\n`people` dizisini serbest bırakmadan önce, her bir `name` için de `free(people[i].name);` çağrısını yapmalıyız. Aksi halde bellek sızıntısı olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688295"
  },
  {
    "question": "Global veya statik değişkenlerde bellek sızıntısını nasıl önleyebilirsiniz?",
    "answer": "Global veya statik değişkenler için bellek sızıntısı genellikle ufak tefek hatalardan kaynaklanır. Örneğin:\n\n```c\nint *global_array;\nvoid allocate_global_array(int size) {\n    global_array = malloc(size * sizeof(int));\n}\n```\nBurada `global_array` için bellek ayrılıyor ama program sonunda `free(global_array);` çağrısını unutursak bellek sızıntısı oluşur. Statik değişkenlerin ömrü boyunca bellek serbest bırakılmadığında bu durumu göz önünde bulundurmalıyız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688319"
  },
  {
    "question": "Kütüphanelerden veya API'lerden dönen bellek izinlerinin yönetimi nasıl olmalıdır?",
    "answer": "Kütüphanelerden veya API'lerden dönen bellek izinleri, genellikle kullanıcı tarafından serbest bırakılması gerektiğini unutmamak önemlidir. Örneğin:\n\n```c\nchar *data = library_function(); // Kütüphaneden dönen bellek\n// Kullanım...\n// free(data); // Kütüphanenin gereksinimlerine göre bu satır önemlidir.\n```\nAPI dökümantasyonunu kontrol ederek, döndürülen bellek için serbest bırakma gerekliliğini bilmelisiniz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688345"
  },
  {
    "question": "Bellek sızıntılarına karşı en iyi uygulamalar nelerdir?",
    "answer": "Bellek sızıntılarını önlemek için bazı en iyi uygulamalar:\n1. Her malloc kullanımı için bir free çağrısı yapılmalı.\n2. Yapıların içindeki dinamik bellek alanlarını serbest bırakmayı unutmamalıyız.\n3. Programınızın yaşam döngüsü boyunca tüm bellek ayrımlarını takip edin.\n4. Memory management tools (valgrind gibi) kullanarak bellek sızıntıları tespit edin.\n5. Akıllı işaretçiler veya bellek havuzları gibi daha güvenli bellek yönetim teknikleri kullanmayı düşünün.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688366"
  },
  {
    "question": "Bir işlev içinde bir struct'a bellek ayırdıktan sonra, bu struct'ı nasıl doğru bir şekilde serbest bırakırsınız?",
    "answer": "Struct içerisine bellek ayırdıysanız, struct'ın kendisini serbest bırakmadan önce içindeki dinamik bellek alanlarını serbest bırakmalısınız:\n\n```c\ntypedef struct {\n    int *data;\n} MyStruct;\n\nvoid create_struct() {\n    MyStruct *s = malloc(sizeof(MyStruct));\n    s->data = malloc(sizeof(int) * 10);\n    // Kullanım...\n    free(s->data); // Öncelikle içerik serbest\n    free(s); // Sonra struct'ı serbest bırakın.\n}\n```\nBurada `s->data`'yı serbest bırakmadan önce, `s`'yi serbest bırakmak bellekte sızıntıya neden olur.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688401"
  },
  {
    "question": "Bir bellek havuzuyla çalışırken bellek sızıntılarını nasıl yönetirsiniz?",
    "answer": "Bellek havuzları, bellek tahsisini ve serbest bırakılmasını yönetmek için kullanılabilir. Ancak bellek havuzları kullanılırken, her tahsis edilen nesnenin sonunda serbest bırakılması önemlidir:\n\n```c\ntypedef struct {\n    char *pool;\n} MemoryPool;\n\nvoid init_pool(MemoryPool *mp, size_t size) {\n    mp->pool = malloc(size);\n    // Belirli bir mekanizma ile bellek tahsisi yapmalıyız.\n}\n\nvoid free_pool(MemoryPool *mp) {\n    free(mp->pool); // Havuzun serbest bırakılması\n}\n```\nBellek havuzunu kullanmayla ilgili döngülerde, havuzdan alınan her nesnenin sonunda `free` ile serbest bırakıldığından emin olmalısınız.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688424"
  },
  {
    "question": "C dilinde döngüler içinde bellek ayırmanın riskleri nelerdir?",
    "answer": "Döngüler içinde bellek ayırmak, her döngüde yeni bellek tahsis edileceğinden bellek sızıntısına yol açabilir. Örneğin:\n\n```c\nvoid allocate_in_loop(int iterations) {\n    for (int i = 0; i < iterations; i++) {\n        int *ptr = malloc(sizeof(int));\n        // İşlemler...\n        // free(ptr); // Bu satır unutulursa sızıntı olur.\n    }\n}\n```\nHer iterasyonda bellek serbest bırakılmazsa, her döngüde yeni bellek ayrılacağı için sızıntı olacaktır. Çözüm, her döngüde `free` çağrısını eklemektir.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688446"
  },
  {
    "question": "Dinamik dizilerde bellek sızıntısını nasıl önleyebilirsiniz?",
    "answer": "Dinamik dizilerde, boyut değiştirme işlemleri sırasında eski dizinin belleğini serbest bırakmayı unutursanız bellek sızıntısına yol açar:\n\n```c\nint *resize_array(int *old_array, int new_size) {\n    int *new_array = malloc(new_size * sizeof(int));\n    memcpy(new_array, old_array, sizeof(int) * old_size);\n    free(old_array); // Eski diziyi serbest bırakmayı unutmayın.\n    return new_array;\n}\n```\n`old_array`'ı serbest bırakmazsak bellek sızıntısı meydana gelir. Bu yüzden her boyut değiştirme işleminde eski belleği serbest bırakmayı ihmal etmemeliyiz.",
    "category": "pointers_memory",
    "topic": "memory_leaks",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bellek sızıntıları",
    "timestamp": "2025-06-01T15:59:47.688465"
  },
  {
    "question": "Bir bağlı liste yapısı oluşturmak için gerekli yapı tanımını yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n// Bağlı liste düğümü tanımı\nstruct Node {\n    int data; // Düğümde depolanan veri\n    struct Node* next; // Bir sonraki düğümü işaret eden gösterici\n};\n\n// Yeni bir düğüm oluşturma fonksiyonu\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858679"
  },
  {
    "question": "Bağlı listeye yeni bir düğüm eklemek için bir fonksiyon yaz.",
    "answer": "void append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = createNode(new_data);\n    struct Node* last = *head_ref;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858720"
  },
  {
    "question": "Bağlı listeyi ekrana yazdırmak için bir fonksiyon tanımla.",
    "answer": "void printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n    printf(\"\\n\");\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858743"
  },
  {
    "question": "Bağlı listenin başına bir düğüm eklemek için bir fonksiyon yaz.",
    "answer": "void push(struct Node** head_ref, int new_data) {\n    struct Node* new_node = createNode(new_data);\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858765"
  },
  {
    "question": "Bağlı listede bir düğümü silmek için bir fonksiyon yaz.",
    "answer": "void deleteNode(struct Node** head_ref, int key) {\n    struct Node* temp = *head_ref, *prev = NULL;\n\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next; // Baş düğüm siliniyorsa\n        free(temp);\n        return;\n    }\n\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return; // Anahtar bulunamadı\n\n    prev->next = temp->next; // Düğümü sil\n    free(temp);\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858787"
  },
  {
    "question": "Bağlı listede belirli bir değeri bulmak için bir fonksiyon yaz.",
    "answer": "struct Node* search(struct Node* head, int key) {\n    struct Node* current = head; // Başlangıçta baş düğümü\n    while (current != NULL) {\n        if (current->data == key) {\n            return current; // Düğüm bulundu\n        }\n        current = current->next;\n    }\n    return NULL; // Düğüm bulunamadı\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858810"
  },
  {
    "question": "Bağlı listenin uzunluğunu hesaplamak için bir fonksiyon yaz.",
    "answer": "int getLength(struct Node* head) {\n    int count = 0;\n    struct Node* current = head;\n    while (current != NULL) {\n        count++;\n        current = current->next;\n    }\n    return count;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858830"
  },
  {
    "question": "Bağlı listeyi tersine çevirmek için bir fonksiyon yaz.",
    "answer": "void reverse(struct Node** head_ref) {\n    struct Node* prev = NULL;\n    struct Node* current = *head_ref;\n    struct Node* next = NULL;\n\n    while (current != NULL) {\n        next = current->next; // Bir sonraki düğümü kaydet\n        current->next = prev; // Önceki düğümü göster\n        prev = current; // Önceki düğümü güncelle\n        current = next; // Geçerli düğümü güncelle\n    }\n    *head_ref = prev; // Yeni baş düğümü güncelle\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858849"
  },
  {
    "question": "Bağlı listede döngü olup olmadığını kontrol etmek için bir fonksiyon yaz.",
    "answer": "int hasCycle(struct Node* head) {\n    struct Node* slow = head;\n    struct Node* fast = head;\n\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next; // Bir adım ilerle\n        fast = fast->next->next; // İki adım ilerle\n        if (slow == fast) {\n            return 1; // Döngü var\n        }\n    }\n    return 0; // Döngü yok\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858874"
  },
  {
    "question": "Bir bağlı listeyi sıralamak için bir fonksiyon yaz.",
    "answer": "void sortList(struct Node** head_ref) {\n    struct Node* current = *head_ref;\n    struct Node* index = NULL;\n    int temp;\n    if (head_ref == NULL) return;\n    while (current != NULL) {\n        index = current->next;\n        while (index != NULL) {\n            if (current->data > index->data) {\n                temp = current->data;\n                current->data = index->data;\n                index->data = temp;\n            }\n            index = index->next;\n        }\n        current = current->next;\n    }\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:06.858894"
  },
  {
    "question": "Aşağıdaki kodda, bir bağlı listeye eleman eklemek için eksik olan kısmı tamamlayın. Listeye bir tamsayı eklenmesi gerekiyor. Kodun başlangıcı var: \n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid append(struct Node** head_ref, int new_data) {\n    // Buraya kod yazın\n}",
    "answer": "Kodun eksik kısmını tamamlayarak, yeni bir düğüm oluşturup listeye ekleyebiliriz. Kod şu şekilde olmalıdır:\n\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); // Yeni düğüm oluştur\n    struct Node* last = *head_ref;  // Listeyi taramak için geçici bir gösterici\n    new_node->data = new_data; // Yeni düğümün verisini ayarla\n    new_node->next = NULL; // Yeni düğümün son olduğunu belirt\n\n    if (*head_ref == NULL) { // Eğer liste boşsa\n        *head_ref = new_node; // Yeni düğümü baş olarak ayarla\n        return;\n    }\n\n    while (last->next != NULL) // Son düğümü bul\n        last = last->next;\n\n    last->next = new_node; // Son düğümün next'ine yeni düğümü ata\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393325"
  },
  {
    "question": "Bir bağlı listenin tüm elemanlarını yazdırmak için eksik olan kodu tamamlayın. Başlangıç olarak şu kod verildi: \n\nvoid printList(struct Node* node) {\n    // Buraya kod yazın\n}",
    "answer": "Bağlı listenin elemanlarını yazdırmak için düğümleri gezmeli ve her birinin verisini ekrana yazdırmalıyız. Kod şu şekilde olmalıdır:\n\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data); // Düğümün verisini yazdır\n        node = node->next; // Sonraki düğüme geç\n    }\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393434"
  },
  {
    "question": "Verilen bağlı listeden bir elemanı silmek için eksik olan kodu tamamlayın. Başlangıç kodu: \n\nvoid deleteNode(struct Node** head_ref, int key) {\n    // Buraya kod yazın\n}",
    "answer": "Bir elemanı silmek için, düğümü bulmalı ve bağlantıları ayarlamalıyız. Kod şöyle olmalıdır:\n\nvoid deleteNode(struct Node** head_ref, int key) {\n    struct Node* temp = *head_ref, *prev = NULL;\n\n    if (temp != NULL && temp->data == key) { // Baş düğüm silinirse\n        *head_ref = temp->next; // Baş düğümü güncelle\n        free(temp); // Belleği serbest bırak\n        return;\n    }\n\n    while (temp != NULL && temp->data != key) { // Düğümü bul\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return; // Düğüm bulunamadı\n\n    prev->next = temp->next; // Düğümü bağlantıdan çıkar\n    free(temp); // Belleği serbest bırak\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393665"
  },
  {
    "question": "Bağlı listenin sonuna eleman eklemek için kullanılan append fonksiyonunu baştan yazın. Kod başlangıcı: \n\nvoid append(struct Node** head_ref, int new_data) {\n    // Buraya kod yazın\n}",
    "answer": "Yeni bir düğüm eklerken, önce yeni düğümü oluşturmalı ve ardından listenin sonuna eklemeliyiz. Kod şöyle olmalıdır:\n\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    last->next = new_node;\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393758"
  },
  {
    "question": "Bağlı listeden belirli bir konumdaki (n. düğüm) elemanı silmek için eksik olan kodu tamamlayın. Başlangıç kodu şu şekilde:\n\nvoid deleteNodeAtPosition(struct Node** head_ref, int position) {\n    // Buraya kod yazın\n}",
    "answer": "Bir düğümü silmek için, silinecek düğüme kadar ilerlemeli ve bağlantıları ayarlamalıyız. Kod şöyle olmalıdır:\n\nvoid deleteNodeAtPosition(struct Node** head_ref, int position) {\n    if (*head_ref == NULL) return;\n\n    struct Node* temp = *head_ref;\n\n    if (position == 0) { // Baş düğüm silinirse\n        *head_ref = temp->next; // Baş düğümü güncelle\n        free(temp);\n        return;\n    }\n\n    for (int i = 0; temp != NULL && i < position - 1; i++)\n        temp = temp->next;\n\n    if (temp == NULL || temp->next == NULL) return; // Pozisyon geçersizse\n\n    struct Node* next = temp->next->next;\n    free(temp->next); // Silinecek düğümü serbest bırak\n    temp->next = next; // Bağlantıları ayarla\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393875"
  },
  {
    "question": "Bir bağlı listenin ortasına eleman eklemek için eksik olan kısmı tamamlayın. Başlangıç kodu şu şekilde:\n\nvoid insertAfter(struct Node* prev_node, int new_data) {\n    // Buraya kod yazın\n}",
    "answer": "Orta noktada yeni bir düğüm eklemek için, önce yeni düğümü oluşturmalı ve ardından önceki düğümün bağlantısını değiştirmeliyiz. Kod şöyle olmalıdır:\n\nvoid insertAfter(struct Node* prev_node, int new_data) {\n    if (prev_node == NULL) return; // Eğer önceki düğüm NULL ise geri dön\n\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); // Yeni düğüm oluştur\n    new_node->data = new_data; // Yeni düğümün verisini ayarla\n\n    new_node->next = prev_node->next; // Yeni düğümün next değerini ayarla\n    prev_node->next = new_node; // Önceki düğümün next'ini yeni düğüme ayarla\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.393966"
  },
  {
    "question": "Bağlı listede belirli bir elemanın olup olmadığını kontrol etmek için eksik olan kodu tamamlayın. Başlangıç kodu şu şekilde:\n\nint search(struct Node* head, int key) {\n    // Buraya kod yazın\n}",
    "answer": "Bir elemanın varlığını kontrol etmek için, düğümleri gezip belirtilen anahtar değerine eşit olup olmadığını kontrol etmeliyiz. Kod şöyle olmalıdır:\n\nint search(struct Node* head, int key) {\n    struct Node* current = head; // Başlangıç düğümünü al\n    while (current != NULL) {\n        if (current->data == key) return 1; // Eleman bulundu\n        current = current->next; // Sonraki düğüme geç\n    }\n    return 0; // Eleman bulunamadı\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.394063"
  },
  {
    "question": "Bağlı listeyi tersine çevirmek için eksik olan kodu tamamlayın. Başlangıç kodu şu şekilde:\n\nvoid reverse(struct Node** head_ref) {\n    // Buraya kod yazın\n}",
    "answer": "Bağlı listeyi tersine çevirmek için üç değişken kullanarak düğümleri gezmeliyiz. Kod şöyle olmalıdır:\n\nvoid reverse(struct Node** head_ref) {\n    struct Node* prev = NULL;\n    struct Node* current = *head_ref;\n    struct Node* next = NULL;\n\n    while (current != NULL) {\n        next = current->next; // Sonraki düğümü kaydet\n        current->next = prev; // Mevcut düğümün önceki bağlantısını ayarla\n        prev = current; // Önceki düğümü güncelle\n        current = next; // Mevcut düğümü güncelle\n    }\n    *head_ref = prev; // Yeni baş düğümü ayarla\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.394144"
  },
  {
    "question": "Bir bağlı listeyi birleştirerek iki ayrı listeyi tek bir liste haline getirmek için eksik olan kodu tamamlayın. Başlangıç kodu şu şekilde:\n\nvoid mergeLists(struct Node** head1, struct Node** head2) {\n    // Buraya kod yazın\n}",
    "answer": "İki listeyi birleştirmek için, birinci listenin sonunu ikinci listenin başına bağlayacağız. Kod şöyle olmalıdır:\n\nvoid mergeLists(struct Node** head1, struct Node** head2) {\n    if (*head1 == NULL) { // Eğer baş1 boşsa\n        *head1 = *head2; // Baş1'i baş2 olarak ayarla\n        return;\n    }\n    struct Node* last = *head1; // Baş1'deki son düğümü bul\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = *head2; // Baş1'in sonuna baş2'yi ekle\n}",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:00:39.394261"
  },
  {
    "question": "Tek yönlü bir bağlı liste tanımlayın ve listeye eleman eklemek için bir fonksiyon yazın.",
    "answer": "İlk olarak, bağlı listemizi temsil etmek için bir yapı tanımlamamız gerekiyor. Sonrasında, eleman eklemek için bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid append(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = new_node;\n}\n\nint main() {\n    struct Node* head = NULL;\n    append(&head, 10);\n    append(&head, 20);\n    return 0;\n}\n```\nBu kodda, `Node` yapısı verileri ve bir sonraki düğümün adresini tutar. `append` fonksiyonu, listeye yeni eleman ekler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061455"
  },
  {
    "question": "İki yönlü bağlı listeden tüm elemanları silen bir fonksiyon yazın.",
    "answer": "İki yönlü bağlı liste için bir yapı tanımlayıp, tüm elemanları silen bir fonksiyon oluşturalım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\nvoid deleteList(struct Node** head_ref) {\n    struct Node* current = *head_ref;\n    struct Node* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    *head_ref = NULL;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Liste oluşturma ve ekleme işlemleri burada...\n    deleteList(&head);\n    return 0;\n}\n```\nBu `deleteList` fonksiyonu, bağlı listedeki tüm düğümleri serbest bırakır ve liste başını NULL yapar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061496"
  },
  {
    "question": "Bir bağlı listenin ortasına bir eleman ekleyen bir fonksiyon geliştirin.",
    "answer": "Bağlı listeye eleman eklemek için öncelikle liste uzunluğunu hesaplayabiliriz. Ardından ortada bir eleman eklemek için:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid insertAtMiddle(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    struct Node* slow = *head_ref;\n    struct Node* fast = *head_ref;\n\n    while (fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n\n    new_node->next = slow;\n    // Bulunan yeri bulup, yeni düğümü ekle\n    struct Node* temp = *head_ref;\n    while (temp->next != slow) {\n        temp = temp->next;\n    }\n    temp->next = new_node;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    insertAtMiddle(&head, 15);\n    return 0;\n}\n```\nBu fonksiyon, listenin ortasına belirtilen veriyi ekler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061540"
  },
  {
    "question": "Bağlı listedeki bir elemanı silen bir fonksiyon yazın. Elemanı değeriyle bulabilmeli.",
    "answer": "Belirli bir değere sahip düğümü silmek için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid deleteNode(struct Node** head_ref, int key) {\n    struct Node* temp = *head_ref, *prev = NULL;\n\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next;\n        free(temp);\n        return;\n    }\n\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return;\n\n    prev->next = temp->next;\n    free(temp);\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    deleteNode(&head, 20);\n    return 0;\n}\n```\nBu fonksiyon, verilen değere sahip düğümü bulup siler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061569"
  },
  {
    "question": "Bağlı listeyi tersine çeviren bir fonksiyon yazın.",
    "answer": "Bağlı listeyi tersine çevirmek için aşağıdaki fonksiyonu kullanabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid reverse(struct Node** head_ref) {\n    struct Node* prev = NULL;\n    struct Node* current = *head_ref;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    *head_ref = prev;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    reverse(&head);\n    return 0;\n}\n```\nBu fonksiyon, bağlı listedeki düğümlerin bağlantı yönlerini tersine çevirir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061589"
  },
  {
    "question": "Bir bağlı listenin döngü içerip içermediğini kontrol eden bir fonksiyon yazın.",
    "answer": "Döngü kontrolü için Floyd'un tortoise and hare algoritmasını kullanabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nint hasCycle(struct Node* head) {\n    struct Node *slow = head, *fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    if (hasCycle(head)) {\n        printf(\"Liste döngü içeriyor.\");\n    } else {\n        printf(\"Liste döngü içermiyor.\");\n    }\n    return 0;\n}\n```\nBu fonksiyon, bağlı listenin döngü içerip içermediğini kontrol eder.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061614"
  },
  {
    "question": "Bir bağlı listeyi sıralayan bir fonksiyon yazın. Sıralama için 'insertion sort' algoritmasını kullanın.",
    "answer": "Bağlı listeyi sıralamak için aşağıdaki gibi bir 'insertion sort' fonksiyonu yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid sortedInsert(struct Node** head_ref, struct Node* new_node) {\n    struct Node* current;\n    if (*head_ref == NULL || (*head_ref)->data >= new_node->data) {\n        new_node->next = *head_ref;\n        *head_ref = new_node;\n    } else {\n        current = *head_ref;\n        while (current->next != NULL && current->next->data < new_node->data) {\n            current = current->next;\n        }\n        new_node->next = current->next;\n        current->next = new_node;\n    }\n}\n\nvoid insertionSort(struct Node** head_ref) {\n    struct Node* sorted = NULL;\n    struct Node* current = *head_ref;\n    while (current != NULL) {\n        struct Node* next = current->next;\n        sortedInsert(&sorted, current);\n        current = next;\n    }\n    *head_ref = sorted;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    insertionSort(&head);\n    return 0;\n}\n```\nBu fonksiyon, bağlı listedeki elemanları sıralar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061655"
  },
  {
    "question": "Bağlı liste içerisinde belirli bir aralıkta elemanları içeren alt listeyi çıkaran bir fonksiyon yazın.",
    "answer": "Alt listeyi çıkarmak için aşağıdaki şekilde bir fonksiyon geliştirebiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* extractSubList(struct Node* head, int start, int end) {\n    struct Node* current = head;\n    struct Node* sublist_head = NULL;\n    struct Node* sublist_tail = NULL;\n    int index = 0;\n\n    while (current != NULL) {\n        if (index >= start && index <= end) {\n            struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n            new_node->data = current->data;\n            new_node->next = NULL;\n            if (sublist_head == NULL) {\n                sublist_head = new_node;\n                sublist_tail = new_node;\n            } else {\n                sublist_tail->next = new_node;\n                sublist_tail = new_node;\n            }\n        }\n        current = current->next;\n        index++;\n    }\n    return sublist_head;\n}\n\nint main() {\n    struct Node* head = NULL;\n    // Listeye eleman ekleme işlemleri burada...\n    struct Node* sublist = extractSubList(head, 1, 3);\n    return 0;\n}\n```\nBu fonksiyon, belirtilen başlangıç ve bitiş indeksleri arasında bulunan elemanları içeren bir alt liste oluşturur.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:01:48.061683"
  },
  {
    "question": "Bağlı listeyi tersine çeviren bir fonksiyonda, tüm düğümler sıfırdan başladığında sonucun neden boş olduğunu açıkla.",
    "answer": "Tersine çevirme işlemi sırasında düğümlerin bağlantılarını kaybetmiş olabilirsin. Düğüm bağlantılarını güncellerken geçici bir değişken kullanmadıysan, düğümler arasında kaybolmalar olabilir. Örneğin, şu şekilde düzeltebilirsin:\n\n```c\nvoid tersineCevir(struct Node** baslangic) {\n    struct Node* onceki = NULL;\n    struct Node* simdiki = *baslangic;\n    struct Node* sonraki;\n    while (simdiki != NULL) {\n        sonraki = simdiki->next;\n        simdiki->next = onceki;\n        onceki = simdiki;\n        simdiki = sonraki;\n    }\n    *baslangic = onceki;\n}\n```\nBu düzeltme ile, her düğümün bağlantısını doğru bir şekilde güncelliyorsun.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.569887"
  },
  {
    "question": "Bağlı listeye eleman eklerken, her zaman eklenen elemanın null olup olmadığını kontrol etmemek neden hatalara yol açar?",
    "answer": "Eğer bir eleman null olarak eklenirse, listenin yapısı bozulur ve bu durum ileride listeyi kullanmaya çalışırken erişim hatalarına yol açabilir. Örneğin, şu şekilde kontrol ekleyebilirsin:\n\n```c\nvoid ekle(struct Node** baslangic, int veri) {\n    if (veri == NULL) return; // Null kontrolü\n    struct Node* yeni = (struct Node*)malloc(sizeof(struct Node));\n    yeni->veri = veri;\n    yeni->next = *baslangic;\n    *baslangic = yeni;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.569966"
  },
  {
    "question": "Bağlı listeyi silerken, sadece baş düğümün silinmesi yeterli midir? Neden?",
    "answer": "Hayır, sadece baş düğümü silmek yeterli değildir. Eğer baş düğümü silersen, listenin geri kalanı kaybolur. Tüm düğümleri silmek için bir döngü kullanarak her bir düğümü tek tek serbest bırakman gerekiyor:\n\n```c\nvoid sil(struct Node** baslangic) {\n    struct Node* simdiki = *baslangic;\n    struct Node* sonraki;\n    while (simdiki != NULL) {\n        sonraki = simdiki->next;\n        free(simdiki);\n        simdiki = sonraki;\n    }\n    *baslangic = NULL;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570012"
  },
  {
    "question": "Bağlı listeye eleman ekleme sırasında yanlış sırayla güncelleme yapmak, listenin yapısını nasıl etkiler?",
    "answer": "Eğer düğüm bağlantılarını yanlış sırayla güncellersen, listenin düzeni bozulur. Örneğin, yeni düğümü bağlamadan önce mevcut bağlantıyı güncellersen, kaybolur. Doğru sıralama şu şekildedir:\n\n```c\nvoid ekleSonuna(struct Node** baslangic, int veri) {\n    struct Node* yeni = (struct Node*)malloc(sizeof(struct Node));\n    yeni->veri = veri;\n    yeni->next = NULL;\n    if (*baslangic == NULL) {\n        *baslangic = yeni;\n        return;\n    }\n    struct Node* son = *baslangic;\n    while (son->next != NULL) {\n        son = son->next;\n    }\n    son->next = yeni;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570065"
  },
  {
    "question": "Bağlı liste uygulamanızda bellek sızıntısı yaşanıyorsa, bu sorunu nasıl çözebilirsin?",
    "answer": "Bellek sızıntısı, allocated belleklerin serbest bırakılmaması nedeniyle oluşur. Listenin her düğümünü silerken, her düğüm için 'free()' fonksiyonunu kullanmalısın. Örneğin:\n\n```c\nvoid sil(struct Node** baslangic) {\n    struct Node* simdiki = *baslangic;\n    while (simdiki != NULL) {\n        struct Node* sonraki = simdiki->next;\n        free(simdiki);\n        simdiki = sonraki;\n    }\n    *baslangic = NULL;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570112"
  },
  {
    "question": "Bağlı listede döngü olup olmadığını kontrol etmediysen, bu ne tür hatalara yol açabilir?",
    "answer": "Döngü kontrolü yapmadığın takdirde sonsuz döngüye girebilir ve programın yanıt vermemeye başlayabilir. Bu nedenle, döngü kontrolü için Floyd’un Tortoise ve Hare algoritmasını kullanabilirsin:\n\n```c\nint donguKontrol(struct Node* baslangic) {\n    struct Node* tortoise = baslangic;\n    struct Node* hare = baslangic;\n    while (hare != NULL && hare->next != NULL) {\n        tortoise = tortoise->next;\n        hare = hare->next->next;\n        if (tortoise == hare) {\n            return 1; // Döngü var\n        }\n    }\n    return 0; // Döngü yok\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570162"
  },
  {
    "question": "Bağlı liste elemanlarını sıralarken, sıralama algoritını hangi durumda yanlış uygulamak sonuçları etkiler?",
    "answer": "Sıralama algoritını yanlış uygulamak, listenin düğümlerinin ilişkisini bozabilir. Örneğin, bir düğümün 'next' bağlantısını yanlış güncellersen, kaybolur. Doğru şekilde bir sıralama algoritması uygulamak için, her düğümün değerini karşılaştırmalı ve doğru sırayla yerleştirmelisin:\n\n```c\nvoid sirala(struct Node** baslangic) {\n    // Basit bir seçme sıralama örneği\n    struct Node* i, *j;\n    int temp;\n    for (i = *baslangic; i != NULL; i = i->next) {\n        for (j = i->next; j != NULL; j = j->next) {\n            if (i->veri > j->veri) {\n                temp = i->veri;\n                i->veri = j->veri;\n                j->veri = temp;\n            }\n        }\n    }\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570213"
  },
  {
    "question": "Bağlı liste üzerinde bir elemanı ararken, arama işleminin optimize edilmesi gerektiğini belirten bir senaryo örneğini açıkla.",
    "answer": "Eğer bağlı listende sık sık arama yapıyorsan, her seferinde baştan başlayarak arama yapmak verimlilik açısından sıkıntılıdır. Bu durumu optimize etmek için, önceden bir indeks yapısı oluşturabilirsin veya elemanları sıralayarak arama algoritmalarını (örn. ikili arama) kullanabilirsin. Bunu şu şekilde uygulayabilirsin:\n\n```c\nstruct Node* arama(struct Node* baslangic, int hedef) {\n    while (baslangic != NULL) {\n        if (baslangic->veri == hedef) {\n            return baslangic;\n        }\n        baslangic = baslangic->next;\n    }\n    return NULL; // Bulunamadı\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570273"
  },
  {
    "question": "Bağlı listede eleman silerken, silinen elemanın üstündeki elemanın bağlantısını güncellemeyi unuttuğunda ne olur?",
    "answer": "Eğer silinen elemanın üstündeki düğümün bağlantısını güncellemezsen, silinen elemandan sonraki düğüme erişim kaybolur ve bellek sızıntısı yaşanır. Bu durumu düzeltmek için, silme işleminde bağlantıyı güncellemeyi unutmamalısın:\n\n```c\nvoid sil(struct Node** baslangic, int veri) {\n    struct Node* simdiki = *baslangic;\n    struct Node* onceki = NULL;\n    while (simdiki != NULL && simdiki->veri != veri) {\n        onceki = simdiki;\n        simdiki = simdiki->next;\n    }\n    if (simdiki == NULL) return; // Bulunamadı\n    if (onceki == NULL) {\n        *baslangic = simdiki->next; // Baş düğüm siliniyor\n    } else {\n        onceki->next = simdiki->next; // Bağlantıyı güncelle\n    }\n    free(simdiki);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:02:55.570328"
  },
  {
    "question": "Bağlı liste nedir?",
    "answer": "Bağlı liste, verileri depolamak için kullanılan bir veri yapısıdır. Her bir elemanı, kendisinden sonraki elemanın adresini tutan bir düğüm (node) olarak temsil edilir. Bağlı listeler, dinamik bellek yönetimi sayesinde eleman ekleme ve silme işlemlerinde verimlidir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471279"
  },
  {
    "question": "Bağlı liste ile dizi arasındaki temel farklar nelerdir?",
    "answer": "Diziler, sabit boyutlu bir yapı iken bağlı listeler dinamik bir yapıdır. Dizilerde elemanlara erişim O(1) karmaşıklıkla sağlanırken, bağlı listelerde O(n) karmaşıklıkla erişim sağlanır. Ayrıca, diziler bitişik bellek alanı kullanırken, bağlı listeler düğümler arasında bellek alanı dağıtır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471333"
  },
  {
    "question": "Bağlı liste nasıl tanımlanır?",
    "answer": "Bağlı listeyi C dilinde tanımlamak için önce bir düğüm yapısı oluşturmalıyız. Örneğin: \n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n``` Bu yapı, her bir düğümün veri alanını ve bir sonraki düğümün adresini tutar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471364"
  },
  {
    "question": "Bağlı listeye eleman ekleme işlemi nasıl yapılır?",
    "answer": "Bağlı listeye eleman eklemek için önce yeni bir düğüm oluşturmalıyız. Yeni düğümü eklemek istediğimiz konuma göre (baş, ortada veya sonda) işlemleri gerçekleştirebiliriz. Örneğin, başa eleman eklemek için şu adımları izleriz:\n```c\nNode* newNode = (Node*)malloc(sizeof(Node));\nnewNode->data = 10;\nnewNode->next = head;\nhead = newNode;\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471398"
  },
  {
    "question": "Bağlı listeden eleman silme işlemi nasıl yapılır?",
    "answer": "Bağlı listeden eleman silmek için, silmek istediğimiz düğümün öncesindeki düğümü bulmamız gerekmektedir. Önce ilgili düğümü buluruz, sonra öncesindeki düğümün next işaretçisini silinecek düğümün next işaretçisine güncelleriz. Örnek:\n```c\nNode* current = head;\nNode* previous = NULL;\nwhile (current != NULL && current->data != value) {\n    previous = current;\n    current = current->next;\n}\nif (previous != NULL) {\n    previous->next = current->next;\n}\nfree(current);\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471431"
  },
  {
    "question": "Bağlı listeyi nasıl görüntüleyebilirim?",
    "answer": "Bağlı listeyi görüntülemek için, listenin başına gidip her düğümün verisini ekrana yazdırmak için bir döngü kullanabiliriz. Örnek:\n```c\nNode* current = head;\nwhile (current != NULL) {\n    printf(\"%d \", current->data);\n    current = current->next;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471458"
  },
  {
    "question": "Bağlı listeyi nasıl tersine çevirebilirim?",
    "answer": "Bağlı listeyi tersine çevirmek için üç işaretçi kullanarak (previous, current, next) döngü içinde ilerleyeceğiz. Her adımda current'in next işaretçisini previous'e yönlendireceğiz. Örnek:\n```c\nNode* previous = NULL;\nNode* current = head;\nNode* next;\nwhile (current != NULL) {\n    next = current->next;\n    current->next = previous;\n    previous = current;\n    current = next;\n}\nhead = previous;\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471488"
  },
  {
    "question": "Bağlı listede arama işlemi nasıl yapılır?",
    "answer": "Bağlı listede arama işlemi, listenin başından başlayarak her düğümün verisini kontrol ederek gerçekleştirilir. Belirli bir değeri bulana kadar her düğümü kontrol ederiz. Örnek:\n```c\nNode* current = head;\nbool found = false;\nwhile (current != NULL) {\n    if (current->data == value) {\n        found = true;\n        break;\n    }\n    current = current->next;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471548"
  },
  {
    "question": "Bağlı listenin sonuna eleman eklemek için hangi yöntemleri kullanabilirim?",
    "answer": "Bağlı listenin sonuna eleman eklemek için, öncelikle listenin başına gidip son düğümü bulmalıyız. Son düğümün next işaretçisini yeni düğüme yönlendirmeliyiz. Örnek:\n```c\nNode* newNode = (Node*)malloc(sizeof(Node));\nnewNode->data = 20;\nnewNode->next = NULL;\nif (head == NULL) {\n    head = newNode;\n} else {\n    Node* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471589"
  },
  {
    "question": "Bağlı listenin bellek salınımı nasıl yapılır?",
    "answer": "Bağlı listenin bellek salınımı için, her düğüme gidip bellekteki alanı serbest bırakmalıyız. Bu işlem, tüm düğümler için yapılmalıdır. Örnek:\n```c\nNode* current = head;\nNode* next;\nwhile (current != NULL) {\n    next = current->next;\n    free(current);\n    current = next;\n}\nhead = NULL;\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:03:56.471621"
  },
  {
    "question": "Bağlı liste nedir ve neden kullanılır?",
    "answer": "Bağlı liste, elemanların (düğümlerin) birbirine referanslarla bağlı olduğu bir veri yapısıdır. Her düğüm, veri ve bir sonraki düğümü işaret eden bir işaretçi (pointer) içerir. Bağlı listeler, dinamik bellek yönetimi sağlar, yani eleman ekleyip çıkarırken bellek yeniden tahsis edilmesine gerek kalmaz. Dizi gibi statik yapılar yerine kullanılır çünkü boyutları esnektir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418527"
  },
  {
    "question": "Tek yönlü bağlı liste ile iki yönlü bağlı liste arasındaki fark nedir?",
    "answer": "Tek yönlü bağlı listede her düğüm, sadece bir sonraki düğüme işaret eden bir işaretçi taşır. İki yönlü bağlı listede ise her düğüm hem bir sonraki hem de bir önceki düğüme işaret eden işaretçiler taşır. İki yönlü bağlı listeler, geri dönme işlemleri yapılması gereken durumlarda daha kullanışlıdır, ancak bu fazladan bellek kullanımı gerektirir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418570"
  },
  {
    "question": "Bağlı listelerde eleman eklemek için hangi yöntemleri kullanabiliriz?",
    "answer": "Bağlı listelere eleman eklemek için birkaç yöntem vardır: 1) Listenin başına eklemek: yeni düğüm oluşturulur ve baş göstericisi güncellenir. 2) Listenin sonuna eklemek: mevcut son düğüm bulunur ve onun sonuna yeni düğüm eklenir. 3) Belirli bir konuma eklemek: belirtilen konumda düğüm oluşturulur ve ilgili işaretçiler güncellenir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418593"
  },
  {
    "question": "Bağlı listelerde bir eleman silmek için gerekli adımlar nelerdir?",
    "answer": "Eleman silmek için önce silinecek düğüm bulunur. Eğer düğüm başta ise baş gösterici güncellenir, eğer ortada veya sonda ise, önceki düğümün sonraki işaretçisi güncellenir. Son olarak, silinen düğümün bellek alanı serbest bırakılır. Bu işlem sırasında, silinecek düğümün işaretçilerine dikkat edilmelidir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418617"
  },
  {
    "question": "Bağlı listelerde döngü nasıl tespit edilir?",
    "answer": "Bağlı listelerde döngü tespit etmek için Floyd'un döngü tespit algoritması (slow and fast pointer) kullanılabilir. Burada, bir işaretçi (slow) bir adım, diğeri (fast) iki adım ilerler. Eğer bu iki işaretçi bir noktada kesişirse, listede bir döngü vardır. Aksi takdirde, listede bir döngü yoktur.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418635"
  },
  {
    "question": "Bağlı listelerde elemanları ters çevirmek için hangi algoritmayı kullanabiliriz?",
    "answer": "Bağlı listelerde elemanları ters çevirmek için iteratif veya rekürsif yöntemler kullanılabilir. İteratif yöntem, üç işaretçi (önceki, mevcut, sonraki) kullanarak her düğümün yönünü tersine çevirir. Rekürsif yöntem ise, listenin sonuna kadar ilerleyip dönerken her düğümün yönünü değiştirir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418669"
  },
  {
    "question": "Bağlı listelerdeki tüm elemanları nasıl görüntüleyebiliriz?",
    "answer": "Bağlı listedeki tüm elemanları görüntülemek için bir döngü kullanabiliriz. Başlangıçta baş göstericisine gidilir ve her düğümün verisi ekrana yazdırılır. Sonrasında, sonraki düğüme geçmek için işaretçi güncellenir. Bu işlem, son düğümün sonraki işaretçisi NULL olduğunda sona erer.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418691"
  },
  {
    "question": "Bağlı listeye veri ekleme ve silme işlemlerinin zaman karmaşıklığı nedir?",
    "answer": "Bağlı listelerde veri ekleme ve silme işlemleri genellikle O(1) zaman karmaşıklığına sahiptir, eğer baş veya son düğüme ekleme/ silme yapılıyorsa. Ancak belirli bir konuma ekleme veya silme işlemi O(n) zaman alır, çünkü ilgili düğüme ulaşmak için listenin başından itibaren iterasyon yapmak gerekir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418715"
  },
  {
    "question": "Bağlı listelerde bellek sızıntısını önlemek için neler yapmalıyız?",
    "answer": "Bellek sızıntısını önlemek için, düğümler silinmeden önce işaretçilerin güncellenmesine dikkat edilmelidir. Silinen düğümlerin bellek alanı serbest bırakılmalı ve silme işlemi sırasında geçici değişkenler kullanılmalıdır. Ayrıca, program sonunda tüm düğümlerin serbest bırakılması için bir 'clear' fonksiyonu yazılabilir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418736"
  },
  {
    "question": "Bağlı listelerde birden fazla veri türünü saklamak mümkün mü?",
    "answer": "Evet, bağlı listelerde birden fazla veri türünü saklamak mümkündür. Bunun için, bir yapı (struct) tanımlanabilir ve bu yapının içinde farklı veri türleri yer alabilir. Örneğin, bir düğüm yapısında hem tamsayı hem de karakter dizisi saklayabiliriz. Bu sayede listede karmaşık veri yapıları oluşturulabilir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:17.418759"
  },
  {
    "question": "Bağlı liste nedir ve diğer veri yapılarından farkları nelerdir?",
    "answer": "Bağlı liste, elemanların birbirine referanslarla bağlı olduğu bir veri yapısıdır. Diğer veri yapılarından en belirgin farkı, dinamik boyutlandırma yeteneğidir. Dizi gibi sabit boyutlu değildir; eleman ekleyip çıkarmak işlemleri daha kolaydır. Ancak, erişim süreleri dizilere göre daha uzundur çünkü elemanlara sırayla ulaşmak gerekir. Bağlı listeler kendi içinde tek yönlü ve iki yönlü olarak ayrılır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643763"
  },
  {
    "question": "Tek yönlü bağlı liste nasıl tanımlanır ve örnek bir C kodu ile gösteriniz.",
    "answer": "Tek yönlü bağlı liste, her düğümün bir verisi ve bir sonraki düğümün adresini içerdiği bir yapıdır. Aşağıda basit bir tanım ve ekleme işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid append(Node** head, int data) {\n    Node* newNode = createNode(data);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    Node* temp = *head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643819"
  },
  {
    "question": "Bir bağlı listede düğüm silme işlemi nasıl yapılır?",
    "answer": "Düğüm silme işlemi, silinecek düğümün bir önceki düğümüne erişimi gerektirir. Aşağıda, belirli bir değeri bulup silen bir fonksiyon örneği verilmiştir:\n\n```c\nvoid deleteNode(Node** head, int key) {\n    Node* temp = *head;\n    Node* prev = NULL;\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    prev->next = temp->next;\n    free(temp);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643844"
  },
  {
    "question": "İki yönlü bağlı liste nedir ve nasıl tanımlanır?",
    "answer": "İki yönlü bağlı liste, her düğümün hem bir sonraki hem de bir önceki düğümün adresini tuttuğu bir veri yapısıdır. Aşağıda bir iki yönlü bağlı listenin tanımını ve düğüm ekleme işlemini gösteren bir örnek verilmiştir:\n\n```c\ntypedef struct DNode {\n    int data;\n    struct DNode* next;\n    struct DNode* prev;\n} DNode;\n\nDNode* createDNode(int data) {\n    DNode* newNode = (DNode*)malloc(sizeof(DNode));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\n    return newNode;\n}\n\nvoid appendDNode(DNode** head, int data) {\n    DNode* newNode = createDNode(data);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    DNode* temp = *head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n    newNode->prev = temp;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643877"
  },
  {
    "question": "Bağlı listelerin bellek yönetimi açısından avantajları ve dezavantajları nelerdir?",
    "answer": "Bağlı listelerin en büyük avantajı, dinamik bellek kullanımıdır; bu sayede eleman ekleme ve çıkarma işlemleri kolayca yapılabilir. Ancak, dezavantajları arasında bellek parçalanması ve elemanlara erişim süresinin uzun olması gelmektedir. Ayrıca, her düğüm için ek bellek kullanılması gerektiğinden, dizilere göre daha fazla hafıza tüketebilirler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643903"
  },
  {
    "question": "Bağlı listeyi tersine çevirmek için hangi algoritmayı kullanmalıyız?",
    "answer": "Bağlı listeyi tersine çevirmek için üç adet işaretçi kullanarak (önceki, mevcut ve sonraki düğüm) iteratif bir yaklaşım benimseyebiliriz. Aşağıda bu işlemi gerçekleştiren bir fonksiyon örneği verilmiştir:\n\n```c\nvoid reverseList(Node** head) {\n    Node* prev = NULL;\n    Node* current = *head;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    *head = prev;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643925"
  },
  {
    "question": "Bağlı listelerde döngü tespiti için hangi algoritmalar kullanılabilir?",
    "answer": "Bağlı listelerde döngü tespiti için en yaygın kullanılan algoritmalardan biri Floyd'un döngü tespit algoritmasıdır. İki işaretçi kullanarak (yavaş ve hızlı) listeyi tarar. Eğer hızlı işaretçi yavaş işaretçiyi yakalarsa, liste döngü içeriyor demektir. Aşağıda basit bir uygulamayı görebilirsiniz:\n\n```c\nint detectCycle(Node* head) {\n    Node *slow = head, *fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return 1; // Döngü var\n    }\n    return 0; // Döngü yok\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643947"
  },
  {
    "question": "Bağlı liste ile yığın (stack) nasıl oluşturulur ve temel işlemleri nelerdir?",
    "answer": "Bir bağlı liste kullanarak yığın oluşturmak için, listeye eleman eklemek (push) ve eleman çıkarmak (pop) işlemlerini gerçekleştirebiliriz. Aşağıda yığın işlemlerini gerçekleştiren bir örnek verilmiştir:\n\n```c\nvoid push(Node** top, int data) {\n    Node* newNode = createNode(data);\n    newNode->next = *top;\n    *top = newNode;\n}\n\nint pop(Node** top) {\n    if (*top == NULL) return -1; // Yığın boş\n    Node* temp = *top;\n    *top = (*top)->next;\n    int popped = temp->data;\n    free(temp);\n    return popped;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643975"
  },
  {
    "question": "Bağlı listelerde sıralama algoritması nasıl uygulanır?",
    "answer": "Bağlı listelerde sıralama işlemi için genellikle 'Merge Sort' kullanılır. Bu algoritma, bağlı listeyi ikiye bölüp her iki parçayı ayrı ayrı sıralar ve ardından birleştirir. Aşağıda bu işlemi gerçekleştiren bir örnek verilmiştir:\n\n```c\nNode* sortedMerge(Node* a, Node* b) {\n    if (!a) return b;\n    if (!b) return a;\n    Node* result;\n    if (a->data <= b->data) {\n        result = a;\n        result->next = sortedMerge(a->next, b);\n    } else {\n        result = b;\n        result->next = sortedMerge(a, b->next);\n    }\n    return result;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:04:53.643994"
  },
  {
    "question": "Tek yönlü bağlı liste nasıl oluşturulur?",
    "answer": "Tek yönlü bağlı liste, her bir düğümün bir veri ve bir sonraki düğümün adresini sakladığı bir veri yapısıdır. İşte basit bir uygulama:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516230"
  },
  {
    "question": "Bağlı listeye yeni bir düğüm nasıl eklenir?",
    "answer": "Bağlı listeye düğüm eklemek için yeni bir düğüm oluşturup, bu düğümü listenin başına veya sonuna ekleyebiliriz. İşte başa ekleme örneği:\n\n```c\nvoid insertAtBeginning(struct Node** head, int newData) {\n    struct Node* newNode = createNode(newData);\n    newNode->next = *head;\n    *head = newNode;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516282"
  },
  {
    "question": "Bağlı listeden bir düğüm nasıl silinir?",
    "answer": "Bağlı listeden düğüm silmek için, silinmek istenen düğümün referansını bulmalı ve önceki düğümün next işaretçisini güncellemelisiniz. İşte örnek:\n\n```c\nvoid deleteNode(struct Node** head, int key) {\n    struct Node* temp = *head, *prev = NULL;\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    prev->next = temp->next;\n    free(temp);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516313"
  },
  {
    "question": "Bağlı listenin elemanlarını nasıl yazdırırız?",
    "answer": "Bağlı listedeki elemanları yazdırmak için bir döngü kullanarak listenin tüm düğümlerine erişebiliriz. İşte bir yazdırma fonksiyonu:\n\n```c\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516344"
  },
  {
    "question": "Bağlı listenin uzunluğunu nasıl hesaplarız?",
    "answer": "Bağlı listenin uzunluğunu hesaplamak için tüm düğümleri gezip bir sayaç kullanabiliriz. İşte bir örnek:\n\n```c\nint getCount(struct Node* head) {\n    int count = 0;\n    struct Node* current = head;\n    while (current != NULL) {\n        count++;\n        current = current->next;\n    }\n    return count;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516374"
  },
  {
    "question": "Bağlı listeyi nasıl ters çevirebiliriz?",
    "answer": "Bağlı listeyi ters çevirmek için üç işaretçi kullanarak düğümlerin yönünü değiştirebiliriz. İşte bir örnek:\n\n```c\nvoid reverse(struct Node** head) {\n    struct Node* prev = NULL;\n    struct Node* current = *head;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    *head = prev;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516404"
  },
  {
    "question": "İki bağlı listeyi nasıl birleştiririz?",
    "answer": "İki bağlı listeyi birleştirmek için bir listeyi diğerinin sonuna ekleyebiliriz. İşte bir örnek:\n\n```c\nvoid concatenate(struct Node** first, struct Node* second) {\n    if (*first == NULL) {\n        *first = second;\n        return;\n    }\n    struct Node* temp = *first;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    temp->next = second;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516434"
  },
  {
    "question": "Bağlı listede belirli bir değeri aramak için nasıl bir fonksiyon yazılır?",
    "answer": "Bağlı listede belirli bir değeri aramak için her düğümün değerini kontrol eden bir fonksiyon yazabiliriz. İşte örnek:\n\n```c\nstruct Node* search(struct Node* head, int key) {\n    struct Node* current = head;\n    while (current != NULL) {\n        if (current->data == key) return current;\n        current = current->next;\n    }\n    return NULL;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516478"
  },
  {
    "question": "Bağlı listede döngü olup olmadığını nasıl kontrol ederiz?",
    "answer": "Bağlı listede döngü olup olmadığını kontrol etmek için Floyd’un döngü tespit algoritmasını kullanabiliriz. İşte örnek:\n\n```c\nint hasCycle(struct Node* head) {\n    struct Node *slow = head, *fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516532"
  },
  {
    "question": "Bağlı listeyi nasıl serbest bırakırız?",
    "answer": "Bağlı listeyi serbest bırakmak için tüm düğümleri gezip her birini tek tek serbest bırakmalıyız. İşte bir örnek:\n\n```c\nvoid freeList(struct Node* head) {\n    struct Node* current = head;\n    struct Node* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:23.516562"
  },
  {
    "question": "Tek yönlü bağlı listeyi nasıl oluşturabilirim?",
    "answer": "Öncelikle bir düğüm yapısı (node) tanımlamalıyız. Aşağıda bir düğüm ve bir bağlı liste yapısını nasıl oluşturabileceğinizi gösteren örnek bir kod bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    Node* head = createNode(10);\n    head->next = createNode(20);\n    head->next->next = createNode(30);\n    return 0;\n}\n```\nBu kodda, '10', '20' ve '30' verileri içeren bir bağlı liste oluşturuyoruz.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352195"
  },
  {
    "question": "Bağlı listeden düğüm nasıl silinir?",
    "answer": "Bağlı listeden düğüm silmek için önce silmek istediğimiz düğümün yerini bulmalıyız. İşte belirli bir değere sahip düğümü silen bir fonksiyon:\n\n```c\nvoid deleteNode(Node** head_ref, int key) {\n    Node* temp = *head_ref, *prev = NULL;\n    if (temp != NULL && temp->data == key) {\n        *head_ref = temp->next;\n        free(temp);\n        return;\n    }\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    prev->next = temp->next;\n    free(temp);\n}\n```\nBu fonksiyon, belirtilen anahtara (key) sahip düğümü listeden siler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352259"
  },
  {
    "question": "Bağlı listenin elemanlarını nasıl yazdırabilirim?",
    "answer": "Bağlı listedeki tüm elemanları yazdırmak için, listenin başından başlayarak son düğüme kadar ilerlemeniz gerekiyor. Aşağıda bir yazdırma fonksiyonu örneği:\n\n```c\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d \", node->data);\n        node = node->next;\n    }\n}\n```\nBu fonksiyon, bağlı listedeki tüm verileri sırayla konsola yazdırır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352291"
  },
  {
    "question": "Bağlı listedeki düğümlerin sayısını nasıl bulabilirim?",
    "answer": "Bağlı listedeki düğüm sayısını bulmak için bir sayaç kullanarak listenin sonuna kadar ilerlememiz gerekiyor. İşte bir örnek:\n\n```c\nint countNodes(Node* head) {\n    int count = 0;\n    while (head != NULL) {\n        count++;\n        head = head->next;\n    }\n    return count;\n}\n```\nBu fonksiyon, bağlı listedeki düğümlerin sayısını döndürür.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352325"
  },
  {
    "question": "Bağlı listede bir düğümün yerini nasıl bulabilirim?",
    "answer": "Bağlı listede belirli bir değere sahip düğümün pozisyonunu bulmak için bir arama fonksiyonu kullanabiliriz. İşte bir örnek:\n\n```c\nint search(Node* head, int key) {\n    int position = 0;\n    while (head != NULL) {\n        if (head->data == key)\n            return position;\n        head = head->next;\n        position++;\n    }\n    return -1; // Bulunamadı\n}\n```\nBu fonksiyon, verilen anahtarın bulunduğu pozisyonu döndürür.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352359"
  },
  {
    "question": "Bağlı listeyi ters çevirmek için nasıl bir algoritma kullanabilirim?",
    "answer": "Bağlı listeyi ters çevirmek için, önce her düğümün yönünü değiştirmemiz gerekir. İşte bunu yapan bir fonksiyon:\n\n```c\nvoid reverse(Node** head_ref) {\n    Node* prev = NULL;\n    Node* current = *head_ref;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    *head_ref = prev;\n}\n```\nBu fonksiyon, verilen bağlı listeyi tersine çevirir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352399"
  },
  {
    "question": "Bir bağlı listenin döngü içerip içermediğini nasıl kontrol edebilirim?",
    "answer": "Bağlı listede döngü olup olmadığını kontrol etmek için Floyd'un döngü tespiti algoritmasını kullanabiliriz. İşte bir örnek:\n\n```c\nint hasCycle(Node* head) {\n    Node* slow = head;\n    Node* fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast)\n            return 1; // Döngü var\n    }\n    return 0; // Döngü yok\n}\n```\nBu fonksiyon, listenin döngü içerip içermediğini döndürür.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352440"
  },
  {
    "question": "Bağlı bir listenin ortasındaki düğümü bulmak için ne yapmalıyım?",
    "answer": "Bağlı listenin ortasındaki düğümü bulmak için yine Floyd'un algoritmasını kullanabiliriz. İşte bir örnek:\n\n```c\nNode* findMiddle(Node* head) {\n    Node* slow = head;\n    Node* fast = head;\n    if (head != NULL) {\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n    }\n    return slow; // Ortadaki düğüm\n}\n```\nBu fonksiyon, bağlı listenin ortasındaki düğümü döndürür.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:05:48.352478"
  },
  {
    "question": "Tek yönlü bağlı liste yapısını nasıl tanımlarsınız ve temel işlemleri (ekleme, silme, arama) nasıl gerçekleştirirsiniz?",
    "answer": "Tek yönlü bağlı liste, her bir düğümün bir veri (data) ve bir sonraki düğümün adresini (next) içerdiği bir veri yapısıdır. İşte basit bir tanım ve temel işlemler:  \n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nNode* head = NULL;  // Liste başlangıcını tutar\n\n// Ekleme işlemi\nvoid insert(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = head;\n    head = newNode;\n}\n\n// Silme işlemi\nvoid delete(int value) {\n    Node* temp = head;\n    Node* prev = NULL;\n    while (temp != NULL && temp->data != value) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;  // değer bulunamazsa\n    if (prev == NULL) head = temp->next;  // ilk eleman silinirse\n    else prev->next = temp->next;\n    free(temp);\n}\n\n// Arama işlemi\nNode* search(int value) {\n    Node* current = head;\n    while (current != NULL) {\n        if (current->data == value) return current;\n        current = current->next;\n    }\n    return NULL;  // bulunamazsa\n}\n```\nBu kod, temel bir ekleme, silme ve arama fonksiyonlarıyla birlikte bir bağlı liste yapısını tanımlar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106034"
  },
  {
    "question": "Çift yönlü bağlı liste nedir ve bu yapıyı nasıl tanımlayıp kullanabilirsiniz?",
    "answer": "Çift yönlü bağlı liste, her düğümün bir veri (data), bir sonraki düğümün adresi (next) ve bir önceki düğümün adresini (prev) içerdiği bir veri yapısıdır. Aşağıda bir çift yönlü bağlı liste yapısının tanımı ve bazı temel işlemler verilmiştir:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n} Node;\n\nNode* head = NULL;\n\n// Ekleme işlemi\nvoid insert(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = head;\n    newNode->prev = NULL;\n    if (head != NULL) head->prev = newNode;\n    head = newNode;\n}\n\n// Silme işlemi\nvoid delete(int value) {\n    Node* temp = head;\n    while (temp != NULL && temp->data != value) {\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    if (temp->prev != NULL) temp->prev->next = temp->next;\n    if (temp->next != NULL) temp->next->prev = temp->prev;\n    if (temp == head) head = temp->next;\n    free(temp);\n}\n```\nBu yapı, listeyi iki yönlü dolaşma imkanı sağlar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106076"
  },
  {
    "question": "Bağlı listeyi tersine çevirme işlemini nasıl gerçekleştirirsiniz?",
    "answer": "Bir bağlı listeyi tersine çevirmek için düğümlerin yönlerini değiştirmemiz gerekiyor. İşte bu işlemi gerçekleştiren bir fonksiyon:\n\n```c\nvoid reverse() {\n    Node* current = head;\n    Node* prev = NULL;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;  // bir sonraki düğümü kaydet\n        current->next = prev;  // yön değiştir\n        prev = current;        // bir önceki düğümü güncelle\n        current = next;\n    }\n    head = prev;  // başı güncelle\n}\n```\nBu fonksiyon, listeyi tersine çevirir ve baş düğümü güncelleyerek yeni başı gösterir.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106100"
  },
  {
    "question": "Bağlı listeye sıralı ekleme işlemi nasıl gerçekleştirilir?",
    "answer": "Bağlı listeye sıralı ekleme, yeni bir düğüm eklerken mevcut düğümlerin sırasına dikkat edilerek yapılır. İşte sıralı ekleme fonksiyonu:\n\n```c\nvoid sortedInsert(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    if (head == NULL || head->data >= value) {\n        newNode->next = head;\n        head = newNode;\n        return;\n    }\n    Node* current = head;\n    while (current->next != NULL && current->next->data < value) {\n        current = current->next;\n    }\n    newNode->next = current->next;\n    current->next = newNode;\n}\n```\nBu fonksiyon, bağlı listeyi sıralı bir şekilde tutar ve yeni bir eleman eklerken uygun yeri bulur.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106120"
  },
  {
    "question": "Bir bağlı listede döngü olup olmadığını nasıl kontrol edersiniz?",
    "answer": "Bir bağlı listede döngü olup olmadığını kontrol etmek için Floyd'un döngü tespit algoritması kullanılabilir. İşte bu algoritmanın C dilindeki uygulanışı:\n\n```c\nint hasCycle() {\n    Node* slow = head;\n    Node* fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;  // bir adım\n        fast = fast->next->next;  // iki adım\n        if (slow == fast) return 1;  // döngü var\n    }\n    return 0;  // döngü yok\n}\n```\nBu fonksiyon, iki işaretçi kullanarak döngü olup olmadığını tespit eder.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106144"
  },
  {
    "question": "Bağlı listeden belirli bir aralıktaki elemanları silme işlemini nasıl yaparsınız?",
    "answer": "Bağlı listeden, belirli bir aralıkta bulunan düğümleri silmek için geçerli düğümü kontrol ederek işlemi gerçekleştirebiliriz. İşte bir örnek:\n\n```c\nvoid deleteInRange(int start, int end) {\n    Node* current = head;\n    Node* prev = NULL;\n    while (current != NULL) {\n        if (current->data >= start && current->data <= end) {\n            Node* temp = current;\n            if (prev != NULL) prev->next = current->next;\n            else head = current->next;\n            current = current->next;\n            free(temp);\n        } else {\n            prev = current;\n            current = current->next;\n        }\n    }\n}\n```\nBu fonksiyon, verilen aralıktaki elemanları siler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106169"
  },
  {
    "question": "Bağlı listeyi bir diziye dönüştürmek için hangi adımları izleyebilirsiniz?",
    "answer": "Bağlı listeyi bir diziye dönüştürmek için önce listeyi dolaşmalı ve her elemanı diziye eklemeliyiz. İşte bir örnek:\n\n```c\nvoid toArray(int* arr, int size) {\n    Node* current = head;\n    for (int i = 0; i < size; i++) {\n        if (current != NULL) {\n            arr[i] = current->data;\n            current = current->next;\n        } else {\n            break;\n        }\n    }\n}\n```\nBu fonksiyon, bağlı listedeki elemanları bir diziye kopyalar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106192"
  },
  {
    "question": "Çift yönlü bağlı listede, bir elemanın öncesindeki elemanı nasıl bulursunuz?",
    "answer": "Çift yönlü bağlı liste kullanıyorsanız, her düğümün 'prev' işaretçisi, bir önceki düğümün adresini tutar. Aşağıdaki fonksiyon, belirli bir elemanın öncesindeki elemanı bulur:\n\n```c\nNode* getPrevious(Node* node) {\n    if (node != NULL) {\n        return node->prev;\n    }\n    return NULL;  // Eğer düğüm NULL ise, öncesi yoktur\n}\n```\nBu fonksiyon, mevcut bir düğüm verildiğinde, o düğümün öncesindeki düğümü döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106217"
  },
  {
    "question": "Bağlı listede tüm elemanların toplamını hesaplamak için bir fonksiyon yazın.",
    "answer": "Tüm bağlı liste elemanlarının toplamını hesaplamak için, listeyi dolaşarak her elemanın değerini bir değişkene ekleyebiliriz. İşte bir örnek:\n\n```c\nint sumList() {\n    int sum = 0;\n    Node* current = head;\n    while (current != NULL) {\n        sum += current->data;\n        current = current->next;\n    }\n    return sum;\n}\n```\nBu fonksiyon, tüm bağlı liste elemanlarının toplamını döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:22.106241"
  },
  {
    "question": "Bağlı listeyi tersine çevirmek için hangi algoritmayı kullanmalıyım?",
    "answer": "Bağlı listeyi tersine çevirmek için iki işaretçi (pointer) kullanarak bir döngü oluşturabiliriz. İlk önce, mevcut düğümün bir öncekine işaret etmesi için üç değişken kullanmalıyız: önceki, mevcut ve sonraki. Mevcut düğümü tersine çevirdikten sonra, önceki düğümü güncelleyerek döngüyü devam ettiririz. Bu yöntem O(n) zaman ve O(1) alan karmaşıklığına sahiptir. Örnek kod:\n\n```c\nNode* reverseList(Node* head) {\n    Node* prev = NULL;\n    Node* current = head;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\nBu kod, bağlı listeyi tersine çevirir ve yeni baş düğümünü döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785808"
  },
  {
    "question": "Bağlı listede döngü olup olmadığını nasıl tespit edebilirim?",
    "answer": "Döngü tespit etmek için Floyd'un Tortoise ve Hare algoritmasını kullanabiliriz. Bu algoritma, iki işaretçi kullanarak listede bir döngü olup olmadığını kontrol eder. Hızlı işaretçi (hare) her iki adımda bir ilerlerken, yavaş işaretçi (tortoise) bir adımda bir ilerler. Eğer döngü varsa, bu iki işaretçi bir noktada kesişecektir. İşte örnek kod:\n\n```c\nint hasCycle(Node* head) {\n    if (head == NULL) return 0;\n    Node* slow = head;\n    Node* fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n```\nBu kod, döngü varsa 1, yoksa 0 döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785855"
  },
  {
    "question": "Bağlı listenin ortasındaki düğümü nasıl bulabilirim?",
    "answer": "Yine Floyd'un Tortoise ve Hare algoritmasını kullanarak, bir işaretçiyi iki adımda bir ve diğerini bir adımda bir ilerleterek bağlı listenin ortasındaki düğümü bulabiliriz. İşte örnek kod:\n\n```c\nNode* findMiddle(Node* head) {\n    if (head == NULL) return NULL;\n    Node* slow = head;\n    Node* fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    return slow;\n}\n```\nBu kod, baş düğümden başlayarak ortadaki düğümü döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785884"
  },
  {
    "question": "Bağlı listeyi bir diziye dönüştürmek için en verimli yöntem nedir?",
    "answer": "Bağlı listeyi bir diziye dönüştürmek için bağlı listenin tüm düğümlerini gezip, her bir düğümün verisini bir diziye kopyalayabiliriz. Bu işlem O(n) zaman karmaşıklığına sahiptir. Ancak dizi boyutunu önceden bilmek mümkün değilse, dinamik bir dizi (örneğin, malloc ile) kullanmamız gerekecektir. Örnek kod:\n\n```c\nint* listToArray(Node* head, int* size) {\n    Node* current = head;\n    int count = 0;\n    while (current != NULL) {\n        count++;\n        current = current->next;\n    }\n    *size = count;\n    int* arr = (int*)malloc(count * sizeof(int));\n    current = head;\n    for (int i = 0; i < count; i++) {\n        arr[i] = current->data;\n        current = current->next;\n    }\n    return arr;\n}\n```\nBu kod, bağlı listeyi bir diziye dönüştürür ve dizinin boyutunu geri döner.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785909"
  },
  {
    "question": "Bağlı listedeki bir düğümü silmek için hangi adımları izlemeliyim?",
    "answer": "Bağlı listedeki bir düğümü silerken, silinecek düğümün öncesindeki düğümü bulmalıyız. Önceki düğümün 'next' işaretçisini, silinecek düğümün 'next' işaretçisine ayarlamalıyız. Ayrıca, bellek sızıntısı olmaması için silinecek düğümü serbest bırakmalıyız. Örnek kod:\n\n```c\nvoid deleteNode(Node** head, int key) {\n    Node* temp = *head;\n    Node* prev = NULL;\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    prev->next = temp->next;\n    free(temp);\n}\n```\nBu kod, verilen anahtar ile eşleşen düğümü siler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785931"
  },
  {
    "question": "Bir bağlı listenin kopyasını nasıl oluşturabilirim?",
    "answer": "Bağlı listenin kopyasını oluşturmak için her bir düğümün verisini okuyup yeni bir düğüm oluşturabiliriz. Yeni düğümler, orijinal listenin düğümleriyle aynı sırada yerleştirilmelidir. O(n) zaman karmaşıklığına sahiptir. Örnek kod:\n\n```c\nNode* copyList(Node* head) {\n    if (head == NULL) return NULL;\n    Node* newHead = NULL;\n    Node* tail = NULL;\n    Node* current = head;\n    while (current != NULL) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = current->data;\n        newNode->next = NULL;\n        if (newHead == NULL) {\n            newHead = newNode;\n            tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n        current = current->next;\n    }\n    return newHead;\n}\n```\nBu kod, verilen bağlı listenin bir kopyasını oluşturur.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785951"
  },
  {
    "question": "Bağlı listenin tüm elemanlarını nasıl yazdırabilirim?",
    "answer": "Bağlı listenin tüm elemanlarını yazdırmak için basit bir döngü ile her bir düğümün verisini ekrana yazdırabiliriz. O(n) zaman karmaşıklığına sahiptir. Örnek kod:\n\n```c\nvoid printList(Node* head) {\n    Node* current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n```\nBu kod, verilen bağlı listedeki tüm elemanları yazdırır.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785969"
  },
  {
    "question": "Bağlı listenin sonuna nasıl düğüm eklerim?",
    "answer": "Bağlı listenin sonuna düğüm eklemek için, önce listeyi dolaşarak son düğümü bulmalıyız. Son düğümü bulduktan sonra, onun 'next' işaretçisini yeni düğüme yönlendirebiliriz. O(1) zaman karmaşıklığına sahiptir. Örnek kod:\n\n```c\nvoid append(Node** head, int newData) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    Node* last = *head;\n    newNode->data = newData;\n    newNode->next = NULL;\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = newNode;\n}\n```\nBu kod, verilen bağlı listenin sonuna yeni bir düğüm ekler.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.785987"
  },
  {
    "question": "Bağlı listeyi sıralamak için hangi yöntemleri kullanabilirim?",
    "answer": "Bağlı listeyi sıralamak için çeşitli algoritmalar kullanabiliriz. En yaygın yöntemler arasında 'Merge Sort' ve 'Quick Sort' bulunmaktadır. Merge Sort, bağlı listelerde daha iyi performans gösterir çünkü O(n log n) zaman karmaşıklığına sahiptir. İşte Merge Sort algoritmasının örnek kodu:\n\n```c\nNode* merge(Node* first, Node* second) {\n    if (!first) return second;\n    if (!second) return first;\n    if (first->data < second->data) {\n        first->next = merge(first->next, second);\n        return first;\n    } else {\n        second->next = merge(first, second->next);\n        return second;\n    }\n}\nNode* mergeSort(Node* head) {\n    if (!head || !head->next) return head;\n    Node* middle = findMiddle(head);\n    Node* nextOfMiddle = middle->next;\n    middle->next = NULL;\n    Node* left = mergeSort(head);\n    Node* right = mergeSort(nextOfMiddle);\n    return merge(left, right);\n}\n```\nBu kod, bağlı listeyi Merge Sort ile sıralar.",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:06:55.786007"
  },
  {
    "question": "Dairesel bağlı listeyi nasıl implement edebilirim? Performans açısından en iyi yöntemi nedir?",
    "answer": "Dairesel bağlı liste, son elemanın bir sonraki işaretçisinin baş elemanı işaret ettiği bir yapıdadır. Bunun için, her düğümde bir işaretçi (next) ve eğer gerekli ise bir önceki işaretçi (prev) tutabiliriz. Dairesel bağlı listede en iyi performansı elde etmek için, baş düğüm ve son düğüm referanslarını saklamalıyız. Bu sayede ekleme, silme ve arama işlemlerini O(1) sürede gerçekleştirebiliriz. Aşağıda basit bir örnek verilmiştir:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct CircularLinkedList {\n    Node* head;\n} CircularLinkedList;\n\nvoid addNode(CircularLinkedList* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    if (list->head == NULL) {\n        list->head = newNode;\n        newNode->next = newNode;  // kendisine işaret eder\n    } else {\n        Node* temp = list->head;\n        while (temp->next != list->head) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n        newNode->next = list->head;\n    }\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396418"
  },
  {
    "question": "Bir bağlı listeden belirli bir değeri nasıl sileceğim? En kötü durum performansı nedir?",
    "answer": "Bağlı listeden belirli bir değeri silmek için, silinecek düğümün referansını bulmalıyız. İlk önce listeyi dolaşarak aradığımız değeri buluyoruz. Eğer bulursak, düğümün bir önceki düğümünün next işaretçisini silinecek düğümün next işaretçisine yönlendirmeliyiz. Bu işlem O(n) zaman alır, çünkü en kötü durumda listeyi tamamen dolaşmamız gerekebilir. Örnek: \n\n```c\nvoid deleteNode(LinkedList* list, int value) {\n    Node* current = list->head;\n    Node* prev = NULL;\n    do {\n        if (current->data == value) {\n            if (prev == NULL) {\n                // İlk düğüm siliniyor\n                Node* temp = list->head;\n                while (temp->next != list->head) {\n                    temp = temp->next;\n                }\n                list->head = current->next;\n                temp->next = list->head;\n                free(current);\n                return;\n            } else {\n                prev->next = current->next;\n                free(current);\n                return;\n            }\n        }\n        prev = current;\n        current = current->next;\n    } while (current != list->head);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396465"
  },
  {
    "question": "Bir bağlı listeyi nasıl tersine çevirebilirim? Hangi yöntemler daha etkilidir?",
    "answer": "Bir bağlı listeyi tersine çevirmek için, mevcut düğümlerin işaretçilerini güncellememiz gerekir. Burada, bir geçici düğüm tutarak mevcut düğümün next işaretçisini bir önceki düğüme yönlendirebiliriz. Bu işlem O(n) zaman alır. Aşağıda bir örnek verilmiştir:\n\n```c\nvoid reverseList(LinkedList* list) {\n    Node* prev = NULL;\n    Node* current = list->head;\n    Node* next = NULL;\n    do {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    } while (current != list->head);\n    list->head->next = prev; // baş düğümün işaretçisi\n    list->head = prev; // yeni baş düğüm\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396494"
  },
  {
    "question": "Bağlı listede döngü olup olmadığını nasıl kontrol edebilirim? Hangi algoritm daha etkilidir?",
    "answer": "Bağlı listede döngü olup olmadığını kontrol etmek için Floyd'ın döngü algılama algoritmasını kullanabiliriz. Bu algoritma, iki işaretçi (tortoise ve hare) kullanarak çalışır. Bir işaretçi (hare) iki adım ileri, diğeri (tortoise) bir adım ileri gider. Eğer bir döngü varsa, bu iki işaretçi bir noktada buluşacaktır. Bu algoritmanın O(n) zaman ve O(1) alan karmaşıklığı vardır:\n\n```c\nint hasCycle(LinkedList* list) {\n    Node* slow = list->head;\n    Node* fast = list->head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return 1; // döngü var\n        }\n    }\n    return 0; // döngü yok\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396544"
  },
  {
    "question": "Bağlı listeyi bir diziye dönüştürmenin en etkili yolu nedir?",
    "answer": "Bağlı listeyi bir diziye dönüştürmek için, listenin uzunluğunu bilmemiz gerekir. Öncelikle listeyi dolaşarak düğüm sayısını bulmak ve ardından dinamik bir dizi oluşturmak gerekir. Bu işlem O(n) zaman alır:\n\n```c\nint* linkedListToArray(LinkedList* list, int* size) {\n    int count = 0;\n    Node* current = list->head;\n    do {\n        count++;\n        current = current->next;\n    } while (current != list->head);\n\n    *size = count;\n    int* array = (int*)malloc(count * sizeof(int));\n    current = list->head;\n    for (int i = 0; i < count; i++) {\n        array[i] = current->data;\n        current = current->next;\n    }\n    return array;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396568"
  },
  {
    "question": "Bir bağlı listenin ortasındaki düğümü nasıl bulabilirim? Performansı nasıl optimize edebilirim?",
    "answer": "Bir bağlı listenin ortasındaki düğümü bulmak için hız ve yavaş işaretçi yöntemini kullanabiliriz. Hızlı işaretçi her iki adımda bir ilerlerken yavaş işaretçi bir adımda ilerler. Listeyi bu şekilde dolaşarak, yavaş işaretçi ortayı gösterecektir. Bu algoritmanın O(n) zaman ve O(1) alan karmaşıklığı vardır:\n\n```c\nNode* findMiddle(LinkedList* list) {\n    Node* slow = list->head;\n    Node* fast = list->head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    return slow; // ortadaki düğüm\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396601"
  },
  {
    "question": "Bir bağlı listeyi belirli bir pozisyondan nasıl bölerim? İki ayrı listeye ayırmanın en iyi yolu nedir?",
    "answer": "Bir bağlı listeyi belirli bir pozisyondan bölerken, istenen pozisyondaki düğümü bulmalı ve bu düğümü iki ayrı listeye ayırmalıyız. Öncelikle listeyi dolaşarak istenen pozisyona ulaşıyor ve sonra iki yeni liste oluşturuyoruz. Bu işlem O(n) zaman alır:\n\n```c\nvoid splitList(LinkedList* list, int position, LinkedList* list1, LinkedList* list2) {\n    Node* current = list->head;\n    int count = 0;\n    do {\n        if (count == position - 1) {\n            list1->head = list->head;\n            list2->head = current->next;\n            current->next = list1->head;\n            return;\n        }\n        count++;\n        current = current->next;\n    } while (current != list->head);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396639"
  },
  {
    "question": "Bir bağlı listeyi bir başka bağlı listenin sonuna nasıl ekleyebilirim? Performans açısından dikkat edilmesi gereken noktalar nelerdir?",
    "answer": "Bir bağlı listeyi başka bir bağlı listenin sonuna eklemek için, ilk listenin son düğümünü bulmalı ve onu ikinci listenin başına yönlendirmeliyiz. Bu işlem O(n) zaman alır, çünkü birinci listenin sonuna ulaşmamız gerekir:\n\n```c\nvoid appendList(LinkedList* list1, LinkedList* list2) {\n    if (list1->head == NULL) {\n        list1->head = list2->head;\n        return;\n    }\n    Node* temp = list1->head;\n    while (temp->next != list1->head) {\n        temp = temp->next;\n    }\n    temp->next = list2->head;\n    Node* last = list2->head;\n    while (last->next != list2->head) {\n        last = last->next;\n    }\n    last->next = list1->head;\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396680"
  },
  {
    "question": "Bağlı listede birden fazla elemanı nasıl silerim? Performans açısından önerileriniz var mı?",
    "answer": "Birden fazla elemanı silmek için, listeyi dolaşarak silinecek elemanları belirlemeliyiz. Her eleman için silme işlemini yapmalıyız. Ancak, silme işlemi sırasında bir sonraki düğüme geçmek için dikkatli olmalıyız. Bu işlem O(n) zaman alır, çünkü tüm elemanları kontrol etmemiz gerekir. Aşağıda örnek verilmiştir:\n\n```c\nvoid deleteMultipleNodes(LinkedList* list, int* values, int size) {\n    Node* current = list->head;\n    Node* prev = NULL;\n    do {\n        for (int i = 0; i < size; i++) {\n            if (current->data == values[i]) {\n                if (prev == NULL) {\n                    Node* temp = list->head;\n                    while (temp->next != list->head) {\n                        temp = temp->next;\n                    }\n                    list->head = current->next;\n                    temp->next = list->head;\n                    free(current);\n                    current = list->head;\n                    break;\n                } else {\n                    prev->next = current->next;\n                    free(current);\n                    current = prev->next;\n                    break;\n                }\n            }\n        }\n        if (current != NULL) {\n            prev = current;\n            current = current->next;\n        }\n    } while (current != list->head);\n}\n```",
    "category": "data_structures",
    "topic": "linked_lists",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bağlı listeler",
    "timestamp": "2025-06-01T16:07:49.396710"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için bir stack kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nvoid push(int value) {\n    if (top >= MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = value;\n}\n\nint pop() {\n    if (top < 0) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return stack[top--];\n}\n\nint factorial(int n) {\n    if (n == 0) return 1;\n    push(n);\n    int result = 1;\n    while (top != -1) {\n        int val = pop();\n        result *= val;\n        if (val > 1) push(val - 1);\n    }\n    return result;\n}\n\nint main() {\n    int number;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &number);\n    printf(\"%d sayısının faktöriyeli: %d\\n\", number, factorial(number));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868226"
  },
  {
    "question": "Bir dizi elemanını tersine çevirmek için bir queue kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint queue[MAX];\nint front = -1, rear = -1;\n\nvoid enqueue(int value) {\n    if (rear >= MAX - 1) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (front == -1) front = 0;\n    queue[++rear] = value;\n}\n\nint dequeue() {\n    if (front == -1 || front > rear) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return queue[front++];\n}\n\nvoid reverseArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        enqueue(arr[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        arr[i] = dequeue();\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, n);\n    printf(\"Ters çevrilmiş dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868271"
  },
  {
    "question": "Bir palindrom kontrolü yapmak için bir stack kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 100\n\nchar stack[MAX];\nint top = -1;\n\nvoid push(char c) {\n    if (top >= MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = c;\n}\n\nchar pop() {\n    if (top < 0) {\n        printf(\"Stack boş!\\n\");\n        return '\\0';\n    }\n    return stack[top--];\n}\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        push(str[i]);\n    }\n    for (int i = 0; i < len; i++) {\n        if (pop() != str[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char str[MAX];\n    printf(\"Bir kelime girin: \");\n    scanf(\"%s\", str);\n    if (isPalindrome(str)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868296"
  },
  {
    "question": "Bir sayılar dizisinin en büyük elemanını bulmak için bir queue kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint queue[MAX];\nint front = -1, rear = -1;\n\nvoid enqueue(int value) {\n    if (rear >= MAX - 1) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (front == -1) front = 0;\n    queue[++rear] = value;\n}\n\nint dequeue() {\n    if (front == -1 || front > rear) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return queue[front++];\n}\n\nint maxInQueue() {\n    int max = -1;\n    while (front <= rear) {\n        int val = dequeue();\n        if (val > max) max = val;\n    }\n    return max;\n}\n\nint main() {\n    enqueue(10);\n    enqueue(25);\n    enqueue(5);\n    enqueue(40);\n    printf(\"En büyük eleman: %d\\n\", maxInQueue());\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868325"
  },
  {
    "question": "Kullanıcının girdiği sayıların toplamını hesaplamak için bir stack kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nvoid push(int value) {\n    if (top >= MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = value;\n}\n\nint pop() {\n    if (top < 0) {\n        printf(\"Stack boş!\\n\");\n        return 0;\n    }\n    return stack[top--];\n}\n\nint sumNumbers(int n) {\n    for (int i = 0; i < n; i++) {\n        int num;\n        printf(\"Bir sayı girin: \");\n        scanf(\"%d\", &num);\n        push(num);\n    }\n    int sum = 0;\n    while (top != -1) {\n        sum += pop();\n    }\n    return sum;\n}\n\nint main() {\n    int count;\n    printf(\"Kaç sayı gireceksiniz: \");\n    scanf(\"%d\", &count);\n    printf(\"Toplam: %d\\n\", sumNumbers(count));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868353"
  },
  {
    "question": "Bir dizinin elemanlarını sıralamak için bir queue kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint queue[MAX];\nint front = -1, rear = -1;\n\nvoid enqueue(int value) {\n    if (rear >= MAX - 1) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (front == -1) front = 0;\n    queue[++rear] = value;\n}\n\nint dequeue() {\n    if (front == -1 || front > rear) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return queue[front++];\n}\n\nvoid sortQueue(int n) {\n    for (int i = 0; i < n; i++) {\n        enqueue(rand() % 100);\n    }\n    // Sıralama işlemi\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (queue[i] > queue[j]) {\n                int temp = queue[i];\n                queue[i] = queue[j];\n                queue[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int n = 5;\n    sortQueue(n);\n    printf(\"Sıralanmış kuyruk:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", queue[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868378"
  },
  {
    "question": "Bir iş listesi uygulaması için bir stack kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nchar *stack[MAX];\nint top = -1;\n\nvoid push(char *task) {\n    if (top >= MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = task;\n}\n\nchar* pop() {\n    if (top < 0) {\n        printf(\"Stack boş!\\n\");\n        return NULL;\n    }\n    return stack[top--];\n}\n\nvoid printTasks() {\n    printf(\"Görevler:\\n\");\n    for (int i = top; i >= 0; i--) {\n        printf(\"%s\\n\", stack[i]);\n    }\n}\n\nint main() {\n    push(\"Görev 1\");\n    push(\"Görev 2\");\n    push(\"Görev 3\");\n    printTasks();\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868403"
  },
  {
    "question": "Bir stringin kelimelerini ters çevirmek için bir queue kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 100\n\nchar queue[MAX][MAX];\nint front = -1, rear = -1;\n\nvoid enqueue(char *word) {\n    if (rear >= MAX - 1) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (front == -1) front = 0;\n    strcpy(queue[++rear], word);\n}\n\nchar* dequeue() {\n    if (front == -1 || front > rear) {\n        printf(\"Queue boş!\\n\");\n        return NULL;\n    }\n    return queue[front++];\n}\n\nvoid reverseWords(char *str) {\n    char *token = strtok(str, \" \");\n    while (token != NULL) {\n        enqueue(token);\n        token = strtok(NULL, \" \");\n    }\n    while (front <= rear) {\n        printf(\"%s \", dequeue());\n    }\n}\n\nint main() {\n    char str[MAX];\n    printf(\"Bir cümle girin: \");\n    fgets(str, MAX, stdin);\n    reverseWords(str);\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868428"
  },
  {
    "question": "Bir matematik ifadesini değerlendirmek için bir stack kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nvoid push(int value) {\n    if (top >= MAX - 1) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    stack[++top] = value;\n}\n\nint pop() {\n    if (top < 0) {\n        printf(\"Stack boş!\\n\");\n        return 0;\n    }\n    return stack[top--];\n}\n\nint evaluateExpression(char *expr) {\n    for (int i = 0; expr[i] != '\\0'; i++) {\n        if (isdigit(expr[i])) {\n            push(expr[i] - '0');\n        } else {\n            int op2 = pop();\n            int op1 = pop();\n            switch (expr[i]) {\n                case '+': push(op1 + op2); break;\n                case '-': push(op1 - op2); break;\n                case '*': push(op1 * op2); break;\n                case '/': push(op1 / op2); break;\n            }\n        }\n    }\n    return pop();\n}\n\nint main() {\n    char expr[MAX];\n    printf(\"Bir matematik ifadesi girin (ör: 23+5*): \");\n    scanf(\"%s\", expr);\n    printf(\"Sonuç: %d\\n\", evaluateExpression(expr));\n    return 0;\n}",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:08:49.868452"
  },
  {
    "question": "Aşağıdaki kodda bir Stack veri yapısı tanımlanmıştır. eksik olan push fonksiyonunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nvoid push(Stack *s, int value) {\n    if (isFull(s)) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    s->items[++(s->top)] = value;\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    push(&s, 10);\n    push(&s, 20);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir Stack yapısı oluşturur ve push fonksiyonu ile yeni elemanlar ekler. Stack doluysa kullanıcıya mesaj verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806425"
  },
  {
    "question": "Aşağıdaki kodda bir Queue veri yapısı tanımlanmıştır. eksik olan enqueue fonksiyonunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initialize(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue *q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue *q, int value) {\n    if (isFull(q)) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->rear = (q->rear + 1) % MAX;\n    q->items[q->rear] = value;\n}\n\nint main() {\n    Queue q;\n    initialize(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir Queue yapısı oluşturur ve enqueue fonksiyonu ile yeni elemanlar ekler. Queue doluysa kullanıcya mesaj verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806472"
  },
  {
    "question": "Aşağıdaki kodda Stack veri yapısının pop işlemi eksik. Bu işlemi tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nint pop(Stack *s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[(s->top)--];\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    s.items[++(s.top)] = 10;\n    int value = pop(&s);\n    printf(\"Çıkarılan değer: %d\\n\", value);\n    return 0;\n}\n\n// Açıklama: Bu kod, bir Stack yapısından eleman çıkartma işlemi (pop) gerçekleştirir. Stack boşsa kullanıcıya uyarı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806499"
  },
  {
    "question": "Aşağıdaki kodda Queue veri yapısının dequeue işlemi eksik. Bu işlemi tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initialize(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nint dequeue(Queue *q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    int item = q->items[q->front];\n    if (q->front == q->rear) {\n        q->front = q->rear = -1; // Tek eleman silindi\n    } else {\n        q->front = (q->front + 1) % MAX;\n    }\n    return item;\n}\n\nint main() {\n    Queue q;\n    initialize(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    int value = dequeue(&q);\n    printf(\"Çıkarılan değer: %d\\n\", value);\n    return 0;\n}\n\n// Açıklama: Bu kod, Queue'dan eleman çıkarma (dequeue) işlemini gerçekleştirir. Queue boşsa kullanıcıya uyarı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806540"
  },
  {
    "question": "Aşağıdaki kodda Stack veri yapısında en üstteki elemanı görüntülemek için gereken fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nint peek(Stack *s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[s->top];\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printf(\"En üstteki değer: %d\\n\", peek(&s));\n    return 0;\n}\n\n// Açıklama: Bu kod, Stack'in en üstteki elemanını görebilmek için bir peek fonksiyonu ekler. Stack boşsa kullanıcıya uyarı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806570"
  },
  {
    "question": "Aşağıdaki kodda Queue veri yapısında ilk eklenen elemanı görüntülemek için gereken fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initialize(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == -1;\n}\n\nint front(Queue *q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return q->items[q->front];\n}\n\nint main() {\n    Queue q;\n    initialize(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    printf(\"İlk eklenen değer: %d\\n\", front(&q));\n    return 0;\n}\n\n// Açıklama: Bu kod, Queue'daki ilk eklenen elemanı görebilmek için bir front fonksiyonu ekler. Queue boşsa kullanıcıya uyarı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806599"
  },
  {
    "question": "Aşağıdaki kodda bir Stack veri yapısının boyutunu kontrol eden bir fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint getSize(Stack *s) {\n    return s->top + 1;\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printf(\"Stack boyutu: %d\\n\", getSize(&s));\n    return 0;\n}\n\n// Açıklama: Bu kod, Stack yapısının mevcut boyutunu döndürmek için bir getSize fonksiyonu ekler. Stack'teki eleman sayısını verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806626"
  },
  {
    "question": "Aşağıdaki kodda bir Queue veri yapısının boyutunu kontrol eden bir fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initialize(Queue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint getSize(Queue *q) {\n    if (isEmpty(q)) return 0;\n    if (q->rear >= q->front) {\n        return q->rear - q->front + 1;\n    }\n    return MAX - q->front + q->rear + 1;\n}\n\nint main() {\n    Queue q;\n    initialize(&q);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    printf(\"Queue boyutu: %d\\n\", getSize(&q));\n    return 0;\n}\n\n// Açıklama: Bu kod, Queue yapısının mevcut boyutunu döndürmek için bir getSize fonksiyonu ekler. Queue'daki eleman sayısını verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806651"
  },
  {
    "question": "Aşağıdaki kodda Stack veri yapısındaki tüm elemanları yazdıran bir fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nvoid printStack(Stack *s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return;\n    }\n    for (int i = s->top; i >= 0; i--) {\n        printf(\"%d \", s->items[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Stack s;\n    initialize(&s);\n    push(&s, 10);\n    push(&s, 20);\n    printStack(&s);\n    return 0;\n}\n\n// Açıklama: Bu kod, Stack'teki tüm elemanları yazdırmak için bir printStack fonksiyonu ekler. Stack boşsa kullanıcıya uyarı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:09:32.806676"
  },
  {
    "question": "Aşağıdaki kodda bir stack yapısı tanımlanmış. Ancak push ve pop fonksiyonları eksik. Bu fonksiyonları tamamla ve açıklamalar ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Stack {\n    int top;\n    int items[MAX];\n};\n\nvoid initStack(struct Stack* s) {\n    s->top = -1;\n}\n\nint isFull(struct Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(struct Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(struct Stack* s, int item) {\n    if (isFull(s)) {\n        printf(\"Stack dolu!\\n\");\n        return;\n    }\n    s->items[++(s->top)] = item;\n}\n\nint pop(struct Stack* s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[(s->top)--];\n}\n\n// Açıklama: Bu kodda basit bir stack yapısı oluşturulmuştur. push() fonksiyonu, verilen öğeyi stack'in en üstüne eklerken; pop() fonksiyonu ise en üstteki öğeyi çıkartır. Stack dolu veya boş olduğunda ise uygun hata mesajları verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192283"
  },
  {
    "question": "Bir queue yapısı tanımlanmış, ancak enqueue ve dequeue fonksiyonları eksik. Bu fonksiyonları tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Queue {\n    int front, rear;\n    int items[MAX];\n};\n\nvoid initQueue(struct Queue* q) {\n    q->front = 0;\n    q->rear = -1;\n}\n\nint isFull(struct Queue* q) {\n    return q->rear == MAX - 1;\n}\n\nint isEmpty(struct Queue* q) {\n    return q->front > q->rear;\n}\n\nvoid enqueue(struct Queue* q, int item) {\n    if (isFull(q)) {\n        printf(\"Queue dolu!\\n\");\n        return;\n    }\n    q->items[++(q->rear)] = item;\n}\n\nint dequeue(struct Queue* q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return q->items[(q->front)++];\n}\n\n// Açıklama: Bu kodda temel bir queue yapısı oluşturulmuştur. enqueue() fonksiyonu, öğeyi sıranın arkasına eklerken; dequeue() fonksiyonu sıranın önünden bir öğeyi çıkartır. Queue dolu veya boş olduğunda uygun hata mesajları gösterir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192333"
  },
  {
    "question": "Aşağıdaki kod bir stack yapısı üzerinde işlem yapıyor. Ancak en üstteki öğeyi görmek için bir fonksiyon eksik. O fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Stack {\n    int top;\n    int items[MAX];\n};\n\nvoid initStack(struct Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(struct Stack* s) {\n    return s->top == -1;\n}\n\nint peek(struct Stack* s) {\n    if (isEmpty(s)) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[s->top];\n}\n\n// Açıklama: peek() fonksiyonu, stack'in en üstündeki öğeyi döndürür. Eğer stack boşsa, uygun bir hata mesajı verir. Bu fonksiyon, öğeyi stack'ten çıkarmadan sadece gözlemlemek için kullanılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192378"
  },
  {
    "question": "Verilen kodda bir queue yapısı var, ancak tüm öğeleri ekrana yazdırmak için bir fonksiyon eksik. O fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Queue {\n    int front, rear;\n    int items[MAX];\n};\n\nvoid initQueue(struct Queue* q) {\n    q->front = 0;\n    q->rear = -1;\n}\n\nint isEmpty(struct Queue* q) {\n    return q->front > q->rear;\n}\n\nvoid displayQueue(struct Queue* q) {\n    if (isEmpty(q)) {\n        printf(\"Queue boş!\\n\");\n        return;\n    }\n    for (int i = q->front; i <= q->rear; i++) {\n        printf(\"%d \", q->items[i]);\n    }\n    printf(\"\\n\");\n}\n\n// Açıklama: displayQueue() fonksiyonu, queue'nun tüm öğelerini ekrana yazdırır. Eğer queue boşsa, uygun bir hata mesajı verir. Bu, queue'nun içerdiği verileri gözlemlemek için kullanışlıdır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192418"
  },
  {
    "question": "Aşağıdaki stack yapısında en son eklenen öğeyi çıkartma işlemi eksik. Bu fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Stack {\n    int top;\n    int items[MAX];\n};\n\nvoid initStack(struct Stack* s) {\n    s->top = -1;\n}\n\nint pop(struct Stack* s) {\n    if (s->top == -1) {\n        printf(\"Stack boş!\\n\");\n        return -1;\n    }\n    return s->items[s->top--];\n}\n\n// Açıklama: pop() fonksiyonu, stack'in en üstündeki öğeyi çıkartır ve döndürür. Eğer stack boşsa, uygun bir hata mesajı verir. Bu işlem, LIFO (Last In First Out) prensibi ile çalışır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192450"
  },
  {
    "question": "Bir queue yapısı tanımlandığında, ilk öğenin hangi sırada verileceğini gösteren bir fonksiyon eksik. Bu fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Queue {\n    int front, rear;\n    int items[MAX];\n};\n\nvoid initQueue(struct Queue* q) {\n    q->front = 0;\n    q->rear = -1;\n}\n\nint front(struct Queue* q) {\n    if (q->front > q->rear) {\n        printf(\"Queue boş!\\n\");\n        return -1;\n    }\n    return q->items[q->front];\n}\n\n// Açıklama: front() fonksiyonu, queue'nun en önündeki öğeyi döndürür. Eğer queue boşsa, uygun bir hata mesajı verir. Bu metod, sıranın önündeki öğeyi görebilmek için kullanılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192488"
  },
  {
    "question": "Aşağıdaki kodda bir stack yapısı var ve stack'in durumunu kontrol eden bir fonksiyon eksik. Bu fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Stack {\n    int top;\n    int items[MAX];\n};\n\nvoid initStack(struct Stack* s) {\n    s->top = -1;\n}\n\nvoid stackStatus(struct Stack* s) {\n    if (s->top == -1) {\n        printf(\"Stack boş!\\n\");\n    } else {\n        printf(\"Stack'te %d öğe var.\\n\", s->top + 1);\n    }\n}\n\n// Açıklama: stackStatus() fonksiyonu, stack'in durumunu kontrol eder ve içerdiği öğe sayısını ekrana yazdırır. Eğer stack boşsa, uygun bir mesaj verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192540"
  },
  {
    "question": "Bir queue yapısında öğeleri ekleme ve çıkarma işlemlerinin durumunu göstermek için bir fonksiyon eksik. Bu fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Queue {\n    int front, rear;\n    int items[MAX];\n};\n\nvoid initQueue(struct Queue* q) {\n    q->front = 0;\n    q->rear = -1;\n}\n\nvoid queueStatus(struct Queue* q) {\n    if (q->front > q->rear) {\n        printf(\"Queue boş!\\n\");\n    } else {\n        printf(\"Queue'da %d öğe var.\\n\", q->rear - q->front + 1);\n    }\n}\n\n// Açıklama: queueStatus() fonksiyonu, queue'nun durumunu kontrol eder ve içerdiği öğe sayısını gösterir. Eğer queue boşsa, uygun bir mesaj verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192578"
  },
  {
    "question": "Verilen kodda bir stack yapısında öğeleri tersine çevirme işlemi yapılacak ancak fonksiyon eksik. Bu fonksiyonu tamamla ve açıklama ekle.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 100\n\nstruct Stack {\n    int top;\n    int items[MAX];\n};\n\nvoid initStack(struct Stack* s) {\n    s->top = -1;\n}\n\nvoid reverseStack(struct Stack* s) {\n    struct Stack temp;\n    initStack(&temp);\n    while (s->top != -1) {\n        temp.items[++temp.top] = s->items[s->top--];\n    }\n    *s = temp;\n}\n\n// Açıklama: reverseStack() fonksiyonu, mevcut stack'in öğelerini tersine çevirir. Yani en üstteki öğe en alta, en alttaki öğe ise en üste gelir. Bu işlem, geçici bir stack kullanılarak gerçekleştirilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:17.192614"
  },
  {
    "question": "Stack veri yapısında eleman ekleme (push) işlemi neden beklenildiği gibi çalışmıyor?",
    "answer": "Muhtemelen, stack'in üst kısmını (top) güncellemeyi unuttunuz. Eleman eklendikten sonra, stack'in üst göstericisini yeni elemanın konumuna ayarlamalısınız. Örnek düzeltme:\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nvoid push(Stack* stack, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = stack->top;\n    stack->top = newNode; // Stack'in üstünü güncelle\n}\n```\nBu şekilde, her yeni eleman eklenmesinde stack'in üstü doğru şekilde güncellenir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401252"
  },
  {
    "question": "Queue veri yapısında eleman çıkarma (dequeue) işlemi neden bir hata veriyor?",
    "answer": "Hata genellikle queue'nin boş olup olmadığını kontrol etmeden dequeue işlemi yapmaktan kaynaklanır. Boş bir queue'dan eleman çıkarmaya çalışmak, bellek erişim hatasına neden olabilir. Düzeltmek için, dequeue işleminden önce queue'nin boş olup olmadığını kontrol edin:\n\n```c\nint dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue boş! Eleman çıkarılamaz.\");\n        return -1; // Hata kodu\n    }\n    Node* temp = queue->front;\n    int data = temp->data;\n    queue->front = queue->front->next;\n    free(temp);\n    return data;\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401295"
  },
  {
    "question": "Stack veri yapısında eleman çıkarma (pop) işlemi neden yanlış sonuç veriyor?",
    "answer": "Pop işlemi sırasında, stack'in üstünü güncellemeyi unuttuysanız, stack'in üstü yanlış bir konuma işaret edebilir. Düzeltmek için, pop işleminde üst göstericiyi güncellemeyi unutmayın:\n\n```c\nint pop(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack boş! Eleman çıkarılamaz.\");\n        return -1; // Hata kodu\n    }\n    Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = stack->top->next; // Üstü güncelle\n    free(temp);\n    return data;\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401322"
  },
  {
    "question": "Queue veri yapısında eleman eklerken (enqueue) neden sürekli aynı elemanı ekliyorum?",
    "answer": "Muhtemelen, queue'nin arka (rear) göstericisini güncellemeyi unuttunuz. Her yeni eleman eklemeden sonra rear göstericisini yeni eklenen elemanın konumuna ayarlamalısınız. Düzeltmek için:\n\n```c\nvoid enqueue(Queue* queue, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    if (queue->rear == NULL) {\n        queue->front = queue->rear = newNode; // İlk eleman\n    } else {\n        queue->rear->next = newNode;\n        queue->rear = newNode; // Rear'i güncelle\n    }\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401349"
  },
  {
    "question": "Stack'in içeriğini yazdırırken (print) neden her seferinde aynı sonucu alıyorum?",
    "answer": "Muhtemelen, stack'in elemanlarını yazdırırken stack'in yapısını değiştiren bir işlem yapıyorsunuz. Her seferinde stack'in üzerine bir işlem uygulamak yerine, geçici bir değişken kullanmalısınız. Düzeltmek için:\n\n```c\nvoid printStack(Stack* stack) {\n    Node* current = stack->top;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401376"
  },
  {
    "question": "Queue'da elemanları doğru sırayla almıyorum, sorunu nasıl çözebilirim?",
    "answer": "Queue'nun FIFO (ilk giren ilk çıkar) özelliğini korumak için, elemanları ekleyip çıkarırken doğru göstericileri kullanmalısınız. Genellikle front ve rear göstericilerini doğru güncellemeyi unuttuğunuzda bu sorun ortaya çıkar. Düzeltmek için her ekleme ve çıkarma işleminde bu göstericileri doğru güncelleyin:\n\n```c\nint dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue boş! Eleman çıkarılamaz.\");\n        return -1;\n    }\n    Node* temp = queue->front;\n    int data = temp->data;\n    queue->front = queue->front->next;\n    if (queue->front == NULL) {\n        queue->rear = NULL; // Boşsa rear'i de sıfırla\n    }\n    free(temp);\n    return data;\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401400"
  },
  {
    "question": "Stack'ten elemanları çıkarma işlemi sonrası hafıza sızıntısı yaşıyorum, nedeni ne olabilir?",
    "answer": "Elemanları çıkardıktan sonra serbest bırakmayı unuttuysanız, hafıza sızıntısı meydana gelir. Her pop işleminden sonra çıkarılan elemanı serbest bırakmayı unutmayın:\n\n```c\nint pop(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack boş! Eleman çıkarılamaz.\");\n        return -1;\n    }\n    Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = stack->top->next;\n    free(temp); // Hafıza serbest bırak\n    return data;\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401428"
  },
  {
    "question": "Queue'da eleman ekleme (enqueue) işlemi sürekli hata veriyor, ne yapmalıyım?",
    "answer": "Hata genellikle bellek tahsis hatalarından kaynaklanabilir. malloc fonksiyonunun dönüş değerini kontrol etmediğinizde bu tür hatalar meydana gelebilir. Düzeltmek için, malloc'un dönüş değerini kontrol edin:\n\n```c\nvoid enqueue(Queue* queue, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"Bellek tahsis hatası!\");\n        return;\n    }\n    newNode->data = value;\n    newNode->next = NULL;\n    if (queue->rear == NULL) {\n        queue->front = queue->rear = newNode;\n    } else {\n        queue->rear->next = newNode;\n        queue->rear = newNode;\n    }\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401454"
  },
  {
    "question": "Stack ve Queue arasındaki farkları anlamıyorum. Açıklayabilir misin?",
    "answer": "Stack, LIFO (Last In First Out) prensibiyle çalışan bir veri yapısıdır; yani son eklenen eleman ilk çıkar. Örneğin, bir işlem geri alma mekanizması (undo) stack kullanabilir. Queue ise FIFO (First In First Out) prensibiyle çalışan bir veri yapısıdır; yani ilk eklenen eleman ilk çıkar. Örneğin, bir müşteri destek çağrısını sırayla yanıtlamak için queue kullanılır. Kod örneği:\n\n```c\nStack stack;\nQueue queue;\n// Stack eleman ekleme\npush(&stack, 1);\npush(&stack, 2);\n// Queue eleman ekleme\nenqueue(&queue, 1);\nenqueue(&queue, 2);\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:10:46.401476"
  },
  {
    "question": "Bir stack uygulaması geliştirdim ama pop işlemi her zaman NULL döndürüyor. Sorun ne olabilir?",
    "answer": "Bu sorun genellikle stack'in boş olduğu durumlarda pop işlemi yapılmasından kaynaklanır. Eğer stack'in başındaki `top` işaretçisi NULL ise, pop işlemi sırasında NULL dönecektir. Aşağıdaki örnek kodda hatayı düzeltebiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nint pop(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack is empty!\\n\");\n        return -1;  // Hata durumu\n    }\n    Node* temp = stack->top;\n    int popped = temp->data;\n    stack->top = stack->top->next;\n    free(temp);\n    return popped;\n}\n```\nBu kodda, stack'in boş olup olmadığını kontrol ettikten sonra pop işlemini gerçekleştiriyoruz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611414"
  },
  {
    "question": "Bir queue uygulaması yapıyorum ama enqueue işlemi sonrasında eleman sırası bozuluyor. Nedeni ne olabilir?",
    "answer": "Bu durum, enqueue işlemi sırasında yeni elemanın sırasının düzgün bir şekilde ayarlanmadığı anlamına gelebilir. FIFO (First In First Out) yapısına göre queue'da, yeni eleman her zaman arka kısma eklenmelidir. İşte bu durumu düzeltecek bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nQueue* createQueue() {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->front = queue->rear = NULL;\n    return queue;\n}\n\nvoid enqueue(Queue* queue, int value) {\n    Node* temp = (Node*)malloc(sizeof(Node));\n    temp->data = value;\n    temp->next = NULL;\n    if (queue->rear == NULL) {\n        queue->front = queue->rear = temp;\n        return;\n    }\n    queue->rear->next = temp;\n    queue->rear = temp;\n}\n```\nBu kodda, enqueue işlemini gerçekleştirdikten sonra `rear`'i güncelleyip, sıranın korunmasını sağlıyoruz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611481"
  },
  {
    "question": "Stack'te push işlemi yaparken bellek sızıntısı yaşanıyor. Bu durumun kaynağı ne olabilir?",
    "answer": "Bellek sızıntısı genellikle malloc ile tahsis edilen belleğin serbest bırakılmaması durumunda ortaya çıkar. Eğer bir eleman stack'e ekleniyorsa ancak daha sonra serbest bırakılmıyorsa bu sızıntıya neden olur. Aşağıda bu durumu düzeltmek için bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nvoid push(Stack* stack, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nvoid freeStack(Stack* stack) {\n    while (stack->top != NULL) {\n        Node* temp = stack->top;\n        stack->top = stack->top->next;\n        free(temp);\n    }\n    free(stack);\n}\n```\nBurada `freeStack` fonksiyonu kullanılarak stack içindeki düğümler serbest bırakılıyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611526"
  },
  {
    "question": "Queue'dan eleman çıkarırken her zaman en son eklenen elemanı çıkarıyor. Neden böyle oluyor?",
    "answer": "Bu durum, queue'nun doğru bir şekilde FIFO mantığına göre çalışmadığını gösterir. Çıkarma işlemi sırasında front'un güncellenmesi gerektiği halde, rear güncelleniyor olabilir. Aşağıdaki düzeltme ile bu sorun çözülebilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nQueue* createQueue() {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->front = queue->rear = NULL;\n    return queue;\n}\n\nint dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue is empty!\\n\");\n        return -1;\n    }\n    Node* temp = queue->front;\n    int data = temp->data;\n    queue->front = queue->front->next;\n    if (queue->front == NULL) {\n        queue->rear = NULL;\n    }\n    free(temp);\n    return data;\n}\n```\nBu kodda, front'un doğru bir şekilde güncellenmesi sağlanıyor, böylece FIFO mantığına sadık kalınıyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611557"
  },
  {
    "question": "Stack uygulamamda, peek işlemi bazen yanlış değer döndürüyor. Bu neden olabilir?",
    "answer": "Peek işlemi, stack'in üstündeki değeri döndürmelidir. Eğer stack'in boş olup olmadığını kontrol etmezseniz, üst nokta NULL olduğunda yanlış değer dönebilir. Aşağıdaki örnekte bu durumu düzeltelim:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nint peek(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack is empty!\\n\");\n        return -1;  // Hata durumu\n    }\n    return stack->top->data;\n}\n```\nBu kodda, peek fonksiyonu öncelikle stack'in boş olup olmadığını kontrol eder, böylece yanlış değer döndürme durumu ortadan kalkar.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611586"
  },
  {
    "question": "Queue'da eleman silerken bellekte çökmelere neden oluyorum. Sorun ne olabilir?",
    "answer": "Bu durum genellikle queue'dan bir eleman silinirken, silinen elemanın belleğinin düzgün bir şekilde serbest bırakılmamasından kaynaklanır. Aşağıda bu durumu düzeltecek bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nQueue* createQueue() {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->front = queue->rear = NULL;\n    return queue;\n}\n\nvoid dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue is empty!\\n\");\n        return;\n    }\n    Node* temp = queue->front;\n    queue->front = queue->front->next;\n    free(temp);\n    if (queue->front == NULL) {\n        queue->rear = NULL;\n    }\n}\n```\nBu örnekte, dequeue işlemi sırasında silinen düğüm bellekte serbest bırakılıyor ve bu sayede çökme durumu engelleniyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611647"
  },
  {
    "question": "Stack'te elemanları ters sırada döndürmek istiyorum ama doğru bir şekilde çalışmıyor. Neden olabilir?",
    "answer": "Bu sorun, stack'in doğru bir şekilde kullanılmamasından kaynaklanıyor olabilir. Örneğin, elemanları eklerken ve çıkartırken sıralamanın düzgün bir şekilde yönetilmemesi bu duruma sebep olur. Aşağıdaki örnek ile bu durumu düzeltebiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nvoid reverseStack(Stack* stack) {\n    Stack* tempStack = createStack();\n    while (stack->top != NULL) {\n        int data = pop(stack);\n        push(tempStack, data);\n    }\n    while (tempStack->top != NULL) {\n        push(stack, pop(tempStack));\n    }\n}\n```\nBu kodda, geçici bir stack kullanarak orijinal stack'i ters çeviriyoruz, böylece elemanların sırası doğru bir şekilde geri yükleniyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611679"
  },
  {
    "question": "Queue'da elemanları çıkartmaya çalışırken bellek hatası alıyorum. Bu durumun kaynağı nedir?",
    "answer": "Bellek hatası genellikle queue boş olduğunda eleman çıkarmaya çalışmak veya silinen elemanların belleğinin serbest bırakılmaması durumunda ortaya çıkar. Aşağıda bu durumu düzeltecek bir örnek bulabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nQueue* createQueue() {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->front = queue->rear = NULL;\n    return queue;\n}\n\nint dequeue(Queue* queue) {\n    if (queue->front == NULL) {\n        printf(\"Queue is empty!\\n\");\n        return -1;  // Hata durumu\n    }\n    Node* temp = queue->front;\n    int data = temp->data;\n    queue->front = queue->front->next;\n    free(temp);\n    if (queue->front == NULL) {\n        queue->rear = NULL;\n    }\n    return data;\n}\n```\nBu örnekte, dequeue fonksiyonu öncelikle queue'nun boş olup olmadığını kontrol ediyor, böylece bellek hatası oluşumunu engelliyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611707"
  },
  {
    "question": "Stack'te döngüsel bir yapı oluşturdum fakat bellek yönetiminde sorun yaşıyorum. Neden böyle oldu?",
    "answer": "Döngüsel bir yapı oluşturmak, stack'in doğru kullanılmadığı anlamına gelebilir. Elemanlar eklendikçe ve çıkartıldıkça bellek serbest bırakılmıyorsa, bu bellek yönetiminde sorunlara yol açabilir. Aşağıda bu durumu düzeltecek bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nvoid push(Stack* stack, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nvoid freeStack(Stack* stack) {\n    while (stack->top != NULL) {\n        Node* temp = stack->top;\n        stack->top = stack->top->next;\n        free(temp);\n    }\n    free(stack);\n}\n```\nBu örnekte, stack içindeki düğümler serbest bırakılarak bellek yönetimi sağlanıyor.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:11:32.611737"
  },
  {
    "question": "Bir stack nedir ve ne amaçla kullanılır?",
    "answer": "Stack, 'Son Giren İlk Çıkar' (LIFO) prensibi ile çalışan bir veri yapısıdır. Yani, en son eklenen eleman en önce çıkar. Stack'ler, fonksiyon çağrıları, geri alma işlemleri veya derleyici işlemleri gibi durumlarda kullanılır. Örneğin, bir web tarayıcısında geri butonuna bastığınızda, en son ziyaret ettiğiniz sayfa (en son eklenen) önce açılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344673"
  },
  {
    "question": "Queue nedir ve hangi senaryolarda kullanılır?",
    "answer": "Queue, 'İlk Giren İlk Çıkar' (FIFO) prensibi ile çalışan bir veri yapısıdır. Yani, en önce eklenen eleman en önce çıkar. Queue'lar, görev sıralama veya işleme gibi durumlarda kullanılır. Örneğin, bir yazıcı kuyruğunda belgeler sırayla basılır; yani, ilk sıraya eklenen belge ilk olarak basılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344710"
  },
  {
    "question": "Stack'in temel işlemleri nelerdir?",
    "answer": "Stack'in temel işlemleri arasında 'push', 'pop' ve 'peek' yer alır. 'Push', stack'e eleman ekler; 'pop', en üstteki elemanı çıkarır ve döndürür; 'peek', en üstteki elemanı çıkarılmadan gösterir. Örneğin, bir oyun uygulamasında son hamlelerinizi izlemek için bir stack kullanabilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344738"
  },
  {
    "question": "Queue'nin temel işlemleri nelerdir?",
    "answer": "Queue'nin temel işlemleri 'enqueue', 'dequeue' ve 'front'dur. 'Enqueue', kuyruğa eleman ekler; 'dequeue', en öndeki elemanı çıkarır ve döndürür; 'front', en öndeki elemanı çıkarılmadan gösterir. Örneğin, bir müşteri hizmetleri çağrı merkezinde gelen çağrılar bir queue kullanılarak işlenir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344755"
  },
  {
    "question": "Stack ve Queue arasındaki temel farklar nelerdir?",
    "answer": "Stack, LIFO prensibi ile çalışırken, Queue FIFO prensibi ile çalışır. Stack'te son eklenen eleman önce çıkar, Queue'da ise ilk eklenen eleman önce çıkar. Örneğin, bir yemek tarifinde malzemeleri hazırlarken stack kullanabilirsiniz (son eklenen malzeme önce kullanılır), ancak yemek servisi yaparken queue kullanmanız gerekir (ilk hazırlanan yemek önce servis edilir).",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344775"
  },
  {
    "question": "Stack yapısını nasıl implement edebilirim?",
    "answer": "Stack'i bir dizi veya bağlantılı liste kullanarak implement edebiliriz. Örneğin, bir dizi ile basit bir stack implementasyonu şöyle olabilir:\n```c\n#define MAX 100\nint stack[MAX];\nint top = -1;\nvoid push(int value) {\n    if (top < MAX - 1) {\n        stack[++top] = value;\n    }\n}\nint pop() {\n    if (top >= 0) {\n        return stack[top--];\n    }\n    return -1; // Hata durumu\n}\n```\nBu örnekte, 'push' ile bir değer ekliyoruz, 'pop' ile en üstteki değeri çıkarıyoruz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344793"
  },
  {
    "question": "Queue yapısını nasıl implement edebilirim?",
    "answer": "Queue'yu da bir dizi veya bağlantılı liste ile implement edebiliriz. Dizi ile klasik bir örnek şöyle olabilir:\n```c\n#define MAX 100\nint queue[MAX];\nint front = 0, rear = 0;\nvoid enqueue(int value) {\n    if (rear < MAX) {\n        queue[rear++] = value;\n    }\n}\nint dequeue() {\n    if (front < rear) {\n        return queue[front++];\n    }\n    return -1; // Hata durumu\n}\n```\nBu örnekte, 'enqueue' ile kuyruğa bir değer ekliyoruz, 'dequeue' ile en öndeki değeri çıkarıyoruz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344823"
  },
  {
    "question": "Stack kullanarak bir ifadenin parantezlerinin dengeli olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir stack kullanarak parantezlerin dengeli olup olmadığını kontrol edebiliriz. Her açılan parantezi stack'e push, her kapanan parantezi ise pop işlemi ile kontrol ederiz. Eğer stack sonunda boş ise parantezler dengelidir. Örnek bir kod şöyle olabilir:\n```c\nbool isBalanced(char* expression) {\n    Stack s;\n    for (int i = 0; expression[i] != '\\0'; i++) {\n        if (expression[i] == '(') {\n            push(&s, '(');\n        } else if (expression[i] == ')') {\n            if (pop(&s) == -1) return false;\n        }\n    }\n    return isEmpty(&s);\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344851"
  },
  {
    "question": "Queue kullanarak bir bankada müşteri hizmetleri sırasını nasıl yönetebilirim?",
    "answer": "Queue kullanarak bir bankada müşteri hizmetleri sırasını yönetebiliriz. Müşteriler kuyruğa eklendikçe, 'enqueue' kullanarak sıraya alınabilir. Hizmet verilirken 'dequeue' kullanarak ilk müşteri çağrılabilir. Örnek bir uygulama şöyle olabilir:\n```c\nvoid serveCustomer() {\n    int customer = dequeue();\n    printf(\"Müşteri %d hizmet veriliyor\\n\", customer);\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344885"
  },
  {
    "question": "Bir stack'te elemanları tersine çevirmenin bir yolu var mı?",
    "answer": "Evet, bir stack'teki elemanları tersine çevirmek için başka bir stack veya bir queue kullanabiliriz. Öncelikle mevcut stack'in tüm elemanlarını çıkarıp yeni stack'e ekleyerek tersine çevirebiliriz. Örnek bir kod:\n```c\nvoid reverseStack(Stack* stack) {\n    Stack temp;\n    while (!isEmpty(stack)) {\n        push(&temp, pop(stack));\n    }\n    *stack = temp;\n}\n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:32.344909"
  },
  {
    "question": "Stack nedir ve hangi senaryolarda kullanılır?",
    "answer": "Stack, LIFO (Last In First Out) prensibine göre çalışan bir veri yapısıdır. Yani son eklenen eleman, ilk çıkar. Stack, fonksiyon çağrıları, geri alma (undo) işlemleri gibi senaryolar için idealdir. Örneğin, bir metin editöründe yapılan değişiklikleri geri almak için kullanılan bir stack yapısı düşünülebilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983771"
  },
  {
    "question": "Queue nedir ve hangi durumlarda faydalıdır?",
    "answer": "Queue, FIFO (First In First Out) prensibine göre çalışan bir veri yapısıdır. Yani ilk eklenen eleman, ilk çıkar. Queue, görevlerin sırayla işlenmesi gereken durumlarda kullanılır. Örneğin, yazıcı kuyruklarında, isteklerin sırayla işlenmesi için bir queue yapısı kullanılır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983811"
  },
  {
    "question": "Stack veri yapısında eleman ekleme ve çıkarma işlemleri nasıl çalışır?",
    "answer": "Stack'te eleman eklemek için 'push' işlemi, eleman çıkarmak için ise 'pop' işlemi kullanılır. 'Push' işlemi, stack'in en üstüne yeni bir eleman eklerken, 'pop' işlemi en üstteki elemanı çıkarır ve geri döner. Örneğin, bir stack'e 1, 2, 3 eklediğimizde, 'pop' işlemi ile önce 3, sonra 2 ve en son 1 elde edilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983848"
  },
  {
    "question": "Queue veri yapısında eleman ekleme ve çıkarma işlemleri nasıl gerçekleştirilir?",
    "answer": "Queue'da eleman eklemek için 'enqueue' işlemi, eleman çıkarmak için ise 'dequeue' işlemi kullanılır. 'Enqueue', kuyruk sonuna yeni bir eleman eklerken, 'dequeue' kuyruğun önünden bir eleman çıkarır. Örneğin, bir queue'ya 1, 2, 3 eklediğinizde, 'dequeue' işlemi ile önce 1, sonra 2 ve en son 3 elde edilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983878"
  },
  {
    "question": "Bir stack'in en üstündeki elemanı nasıl kontrol edebilirim?",
    "answer": "Stack'te en üstteki elemanı kontrol etmek için 'peek' veya 'top' adı verilen bir yöntem kullanılır. Bu yöntem, stack'ten eleman çıkarmadan en üstteki elemanı döner. Örneğin, bir stack'te 1, 2, 3 elemanları varsa, 'peek' işlemi 3 değerini döner.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983913"
  },
  {
    "question": "Queue'da bir elemanın mevcut olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Queue'da belirli bir elemanın mevcut olup olmadığını kontrol etmek için genellikle bir döngü kullanılır. Tüm elemanları kontrol ederek, aradığınız elemanı bulmaya çalışırsınız. Ancak bazı durumlarda, Queue'yu bir koleksiyon gibi kullanarak elemanları saklayabilir ve 'contains' gibi metodlar ile kontrol edebilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983948"
  },
  {
    "question": "Bir stack ve queue'yı C dilinde nasıl tanımlarım?",
    "answer": "C dilinde bir stack için genellikle bir dizi ve bir üst gösterici (top pointer) kullanılır. Queue için ise iki gösterici (front ve rear) ile bir dizi kullanılabilir. Örnek olarak: \n\n```c \n#define MAX 100 \ntypedef struct { \n    int items[MAX]; \n    int top; \n} Stack; \n\ntypedef struct { \n    int items[MAX]; \n    int front, rear; \n} Queue; \n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.983974"
  },
  {
    "question": "Stack ve Queue'nın bellek yönetimi açısından avantajları nelerdir?",
    "answer": "Stack ve Queue gibi dinamik veri yapıları, bellek yönetimi açısından esneklik sağlar. Stack, fonksiyon çağrıları sırasında bellekte geçici alanlar oluşturur ve işlemler tamamlandığında otomatik olarak bu alanları serbest bırakır. Queue ise görevlerin sıralı bir şekilde işlenmesini sağlar, böylece bellek etkin bir şekilde kullanılır ve gereksiz alan tüketimi önlenir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.984002"
  },
  {
    "question": "C dilinde bir stack'in overflow durumunu nasıl kontrol edebilirim?",
    "answer": "Stack'in overflow durumu, stack'in maksimum kapasitesini aştığınızda gerçekleşir. C dilinde bunu kontrol etmek için, 'push' işlemi öncesinde stack'in 'top' değerinin maksimum kapasiteyi aşıp aşmadığını kontrol edersiniz. Örneğin: \n\n```c \nif (stack.top >= MAX - 1) { \n    printf(\"Stack Overflow\"); \n} \n```",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:12:51.984028"
  },
  {
    "question": "Stack veri yapısını kullanarak bir kelimenin tersini nasıl bulabiliriz?",
    "answer": "Bir kelimenin tersini bulmak için stack veri yapısını kullanabiliriz. Stack, LIFO (Last In First Out) prensibine göre çalıştığı için, kelimenin her karakterini stack'e ekleyerek, sonrasında bu karakterleri stack'ten çıkararak ters sırayla elde edebiliriz. Örneğin, 'hello' kelimesini alalım. Öncelikle her karakteri stack'e ekleyeceğiz: 'h', 'e', 'l', 'l', 'o'. Sonra stack'ten çıkarırsak, 'o', 'l', 'l', 'e', 'h' elde ederiz. İşte bu, kelimenin tersidir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062156"
  },
  {
    "question": "Queue veri yapısının gerçek hayattaki bir uygulaması nedir?",
    "answer": "Queue veri yapısının en iyi bilinen uygulamalarından biri, bir müşteri hizmetleri merkezi veya bankada gelen müşteri sırasıdır. Müşteriler sırayla hizmet alır ve ilk gelen ilk hizmet alır (FIFO - First In First Out). Bu durumda, gelen her müşteri bir queue'ya eklenir ve hizmet verildiğinde ilk sıradaki müşteri çıkarılır. Bu model, işlem süreçlerini düzenli ve adil bir şekilde yönetmeyi sağlar.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062193"
  },
  {
    "question": "Bir stack'in boş olup olmadığını nasıl kontrol edebiliriz?",
    "answer": "Stack'in boş olup olmadığını kontrol etmek için, stack'in eleman sayısını kontrol edebiliriz. Eğer eleman sayısı sıfırsa, stack boştur. C dilinde bunu implement etmek için bir 'top' değişkeni tutabiliriz. 'top' sıfır ise, stack boştur; aksi takdirde, doludur. Örnek bir kontrol: 'if (top == 0) { // stack boştur }'.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062217"
  },
  {
    "question": "Queue veri yapısını kullanarak bir görev yöneticisi nasıl oluşturabiliriz?",
    "answer": "Bir görev yöneticisi oluşturmak için queue yapısını kullanabiliriz. Her yeni görev, queue'ya eklenir. Görevler sırayla işlemlerden geçirilir. Queue'da ilk sıradaki görev, işleme alınır ve tamamlandığında queue'dan çıkarılır. Böylece sistem, en son eklenen görevin en son işlendiği bir sıralama sağlar. Uygulama, CPU zaman paylaşımı gibi senaryolar için idealdir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062240"
  },
  {
    "question": "Stack ve Queue arasındaki temel fark nedir?",
    "answer": "Stack ve Queue arasındaki temel fark, veri ekleme ve çıkarma sıralamalarıdır. Stack, LIFO (Last In First Out) prensibiyle çalışır; yani son eklenen ilk çıkar. Queue ise FIFO (First In First Out) prensibiyle çalışır; yani ilk eklenen ilk çıkar. Bu farklılık, her iki yapı için farklı uygulama alanları yaratır. Örneğin, stack genelde algoritmalarda ve geri izleme işlemlerinde kullanılırken, queue ise işlem sıralaması ve görev yönetiminde daha yaygındır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062259"
  },
  {
    "question": "Stack veri yapısında n tane eleman ekleyip, ardından bunları nasıl kaldırabiliriz?",
    "answer": "Stack veri yapısında n tane eleman eklemek için bir döngü kullanabiliriz. Her bir elemanı stack'e eklemek için 'push' fonksiyonunu çağırırız. Tüm elemanlar eklendikten sonra, aynı döngüyü tersine çalıştırarak 'pop' fonksiyonu ile elemanları kaldırabiliriz. Örnek: 'for (int i = 0; i < n; i++) { push(stack, i); }', ardından 'for (int i = 0; i < n; i++) { pop(stack); }' ile elemanları kaldırabiliriz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062287"
  },
  {
    "question": "Queue veri yapısında araya eleman eklemenin etkisini nasıl yönetebiliriz?",
    "answer": "Queue veri yapısında araya eleman eklemek, standart FIFO yapısını bozar. Ancak, bunu yönetmek için öncelikle queue'yu geçici bir yapı olarak kullanabiliriz. Yeni elemanı eklemek istediğimiz konumdan itibaren tüm elemanları geçici bir queue'ya çıkarırız, yeni elemanı ekledikten sonra, geri kalan elemanları tekrar orijinal queue'ya ekleriz. Bu işlem zaman alıcı olabilir, bu yüzden araya ekleme yerine push ve pop işlemlerini kullanmak genellikle daha verimlidir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062310"
  },
  {
    "question": "Bir stack'te en yüksek elemanı nasıl bulabiliriz?",
    "answer": "Bir stack'te en yüksek elemanı bulmak için, stack'i geçici bir stack kullanarak tarayabiliriz. Öncelikle en yüksek değeri bir değişkende tutarız. Stack'ten her elemanı pop yaparak bu değişkenle karşılaştırırız. Eğer pop edilen eleman, mevcut en yüksek değerden büyükse, bu değeri güncelleriz. Son olarak, en yüksek değeri döndürürüz. Bu işlem, stack'in boyutuna bağlı olarak O(n) zaman alır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062330"
  },
  {
    "question": "Bir Queue'yu nasıl tersine çevirebiliriz?",
    "answer": "Bir Queue'yu tersine çevirmek için geçici bir stack kullanabiliriz. Öncelikle tüm elemanları queue'dan alarak stack'e ekleriz. Sonra stack'ten elemanları çıkararak yeniden queue'ya ekleriz. Bu işlem, queue'daki tüm elemanların ters sırayla yeniden sıralanmasını sağlar. Uygulama: 'while (!isEmpty(queue)) { int elem = dequeue(queue); push(stack, elem); } while (!isEmpty(stack)) { enqueue(queue, pop(stack)); }'.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062348"
  },
  {
    "question": "Stack üzerinde bir dizi parantez denetimi nasıl yapılır?",
    "answer": "Bir dizi parantez denetimi yapmak için stack kullanabiliriz. Parantezlerin açılma ve kapanma sırasını takip etmek için her açılan parantezi stack'e ekleriz. Her kapanan parantez için stack'ten bir açılan parantez çıkarırız ve uyumlu olup olmadığını kontrol ederiz. Eğer tüm parantezler eşleşirse, stack sonunda boş olacaktır. Eğer stack'te eşleşmeyen parantezler varsa, dizi geçersizdir. Bu yöntem, parantezlerin doğru kullanıldığını kontrol etmemize olanak tanır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:13:29.062369"
  },
  {
    "question": "Bir yığın (stack) veri yapısını nasıl tanımlarsınız ve temel işlemlerini (push, pop, peek) nasıl gerçekleştirirsiniz?",
    "answer": "C dilinde bir yığın yapısını tanımlamak için bir yapı (struct) oluşturabiliriz. Yığının üzerinde işlem yapabilmek için push, pop ve peek fonksiyonları yazmamız gerekecek. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (!isFull(s)) {\n        s->items[++(s->top)] = item;\n    } else {\n        printf(\"Stack is full\\n\");\n    }\n}\n\nint pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->items[(s->top)--];\n    } else {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n}\n\nint peek(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->items[s->top];\n    } else {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n}\n```\nBu kod, yığın (stack) veri yapısında temel işlemleri gerçekleştirmek için bir yapı ve fonksiyonlar içermektedir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718553"
  },
  {
    "question": "Bir dizi kullanarak kuyruk (queue) veri yapısını nasıl tanımlarsınız ve enqueue, dequeue, front işlemlerini nasıl gerçekleştirirsiniz?",
    "answer": "C dilinde bir kuyruk veri yapısını tanımlamak için bir yapı (struct) oluşturabiliriz. Aynı zamanda, kuyruk üzerinde işlem yapabilmek için enqueue, dequeue ve front fonksiyonlarını yazmamız gerekecek. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nint isFull(Queue* q) {\n    return (q->rear + 1) % MAX == q->front;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == -1;\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (!isFull(q)) {\n        if (isEmpty(q)) {\n            q->front = 0;\n        }\n        q->rear = (q->rear + 1) % MAX;\n        q->items[q->rear] = item;\n    } else {\n        printf(\"Queue is full\\n\");\n    }\n}\n\nint dequeue(Queue* q) {\n    if (!isEmpty(q)) {\n        int item = q->items[q->front];\n        if (q->front == q->rear) {\n            q->front = -1;\n            q->rear = -1;\n        } else {\n            q->front = (q->front + 1) % MAX;\n        }\n        return item;\n    } else {\n        printf(\"Queue is empty\\n\");\n        return -1;\n    }\n}\n\nint front(Queue* q) {\n    if (!isEmpty(q)) {\n        return q->items[q->front];\n    } else {\n        printf(\"Queue is empty\\n\");\n        return -1;\n    }\n}\n```\nBu kod, kuyruk (queue) veri yapısında temel işlemleri gerçekleştirmek için bir yapı ve fonksiyonlar içermektedir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718636"
  },
  {
    "question": "Bir yığın kullanarak bir ifadeyi ters çevirmek için bir algoritma nasıl yazarsınız?",
    "answer": "Bir yığın kullanarak bir ifadeyi ters çevirmek için, karakterleri yığına itebiliriz ve ardından yığından alarak ters sırayla yazdırabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct {\n    char items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nvoid push(Stack* s, char item) {\n    s->items[++(s->top)] = item;\n}\n\nchar pop(Stack* s) {\n    return s->items[(s->top)--];\n}\n\nvoid reverseExpression(char* expression) {\n    Stack s;\n    initStack(&s);\n    for (int i = 0; expression[i] != '\\0'; i++) {\n        push(&s, expression[i]);\n    }\n    while (s.top != -1) {\n        printf(\"%c\", pop(&s));\n    }\n}\n\nint main() {\n    char expression[] = \"Hello World\";\n    reverseExpression(expression);\n    return 0;\n}\n```\nBu kod, belirtilen ifadeyi ters çevirir ve çıktısı 'dlroW olleH' olur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718682"
  },
  {
    "question": "Kuyruk veri yapısını kullanarak bir işlemci zamanlama algoritması nasıl oluşturursunuz?",
    "answer": "Kuyruk veri yapısı, işlemci zamanlaması için yararlı olabilir. İşlemleri sırayla işlemek için bir kuyruk kullanabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int processID;\n    int burstTime;\n} Process;\n\ntypedef struct {\n    Process items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nvoid enqueue(Queue* q, Process p) {\n    if (q->rear == MAX - 1) {\n        printf(\"Queue is full\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->items[++q->rear] = p;\n}\n\nProcess dequeue(Queue* q) {\n    Process p = q->items[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front++;\n    }\n    return p;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == -1;\n}\n\nvoid scheduleProcesses() {\n    Queue q;\n    initQueue(&q);\n\n    Process p1 = {1, 5};\n    Process p2 = {2, 3};\n    Process p3 = {3, 8};\n\n    enqueue(&q, p1);\n    enqueue(&q, p2);\n    enqueue(&q, p3);\n\n    while (!isEmpty(&q)) {\n        Process p = dequeue(&q);\n        printf(\"Processing %d for %d units\\n\", p.processID, p.burstTime);\n    }\n}\n\nint main() {\n    scheduleProcesses();\n    return 0;\n}\n```\nBu kod, basit bir işlemci zamanlama algoritması uygulayarak işlemleri sıralı bir şekilde işler.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718723"
  },
  {
    "question": "Bir yığın veri yapısını kullanarak bir parantez dengeleme algoritması nasıl yazarsınız?",
    "answer": "Yığın kullanarak parantez dengeleme işlemini gerçekleştirebiliriz. Açık parantezleri yığına itebiliriz ve kapalı parantezleri kontrol ederek dengeyi sağlayabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct {\n    char items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nvoid push(Stack* s, char item) {\n    s->items[++(s->top)] = item;\n}\n\nchar pop(Stack* s) {\n    return s->items[(s->top)--];\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nint isBalanced(char* expression) {\n    Stack s;\n    initStack(&s);\n    for (int i = 0; expression[i] != '\\0'; i++) {\n        if (expression[i] == '(') {\n            push(&s, expression[i]);\n        } else if (expression[i] == ')') {\n            if (isEmpty(&s)) return 0;\n            pop(&s);\n        }\n    }\n    return isEmpty(&s);\n}\n\nint main() {\n    char expression[] = \"((a + b) * (c - d))\";\n    if (isBalanced(expression)) {\n        printf(\"Dengeli\\n\");\n    } else {\n        printf(\"Dengesiz\\n\");\n    }\n    return 0;\n}\n```\nBu kod, verilen ifadeyi kontrol ederek dengeyi sağlar ve 'Dengeli' ya da 'Dengesiz' çıktısı verir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718766"
  },
  {
    "question": "Kuyruk veri yapısını kullanarak bir web tarayıcısında geri gitme (back) ve ileri gitme (forward) işlevselliği nasıl sağlanır?",
    "answer": "Web tarayıcısında geri gitme ve ileri gitme işlemleri için iki ayrı kuyruk yapısı kullanabiliriz. Bir kuyruk, geçmişi (back) tutarken, diğeri ileri gitme (forward) işlemleri için kullanılabilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct {\n    char* items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nvoid enqueue(Queue* q, char* url) {\n    if (q->rear == MAX - 1) {\n        printf(\"Queue is full\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->items[++q->rear] = url;\n}\n\nchar* dequeue(Queue* q) {\n    if (isEmpty(q)) return NULL;\n    return q->items[q->front++];\n}\n\nint isEmpty(Queue* q) {\n    return q->front > q->rear;\n}\n\nvoid back(Queue* backQueue, Queue* forwardQueue) {\n    if (!isEmpty(backQueue)) {\n        char* url = dequeue(backQueue);\n        printf(\"Geri gidildi: %s\\n\", url);\n        enqueue(forwardQueue, url);\n    } else {\n        printf(\"Geri gidilemez!\\n\");\n    }\n}\n\nvoid forward(Queue* forwardQueue) {\n    if (!isEmpty(forwardQueue)) {\n        char* url = dequeue(forwardQueue);\n        printf(\"İleri gidildi: %s\\n\", url);\n    } else {\n        printf(\"İleri gidilemez!\\n\");\n    }\n}\n\nint main() {\n    Queue backQueue;\n    Queue forwardQueue;\n    initQueue(&backQueue);\n    initQueue(&forwardQueue);\n\n    enqueue(&backQueue, \"google.com\");\n    enqueue(&backQueue, \"stackoverflow.com\");\n    enqueue(&backQueue, \"github.com\");\n\n    back(&backQueue, &forwardQueue);\n    back(&backQueue, &forwardQueue);\n    forward(&forwardQueue);\n    return 0;\n}\n```\nBu kod, web tarayıcısında geri ve ileri gitme işlevselliğini simüle eder.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718831"
  },
  {
    "question": "Bir yığın kullanarak bir sayının faktöriyelini nasıl hesaplayabilirsiniz?",
    "answer": "Yığın kullanarak faktöriyel hesaplama işlemi, tekrar eden işlemleri yığının içine atarak gerçekleştirilebilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nvoid push(Stack* s, int item) {\n    s->items[++(s->top)] = item;\n}\n\nint pop(Stack* s) {\n    return s->items[(s->top)--];\n}\n\nint factorial(int n) {\n    Stack s;\n    initStack(&s);\n    for (int i = n; i > 1; i--) {\n        push(&s, i);\n    }\n    int result = 1;\n    while (s.top != -1) {\n        result *= pop(&s);\n    }\n    return result;\n}\n\nint main() {\n    int num = 5;\n    printf(\"%d! = %d\\n\", num, factorial(num));\n    return 0;\n}\n```\nBu kod, belirtilen bir sayının faktöriyelini hesaplar ve çıktısı '5! = 120' olur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718869"
  },
  {
    "question": "Bir kuyruk veri yapısı kullanarak bir bankanın sıra bekleme sistemi nasıl simüle edilir?",
    "answer": "Bir kuyruk kullanarak bir bankada müşteri bekleme sistemini simüle edebiliriz. Müşterileri sıraya alabilir ve hizmet ettikçe çıkarabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int customerID;\n} Customer;\n\ntypedef struct {\n    Customer items[MAX];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\nvoid enqueue(Queue* q, Customer c) {\n    if (q->rear == MAX - 1) {\n        printf(\"Queue is full\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n    }\n    q->items[++q->rear] = c;\n}\n\nCustomer dequeue(Queue* q) {\n    if (isEmpty(q)) return (Customer){-1};\n    return q->items[q->front++];\n}\n\nint isEmpty(Queue* q) {\n    return q->front > q->rear;\n}\n\nvoid simulateBankQueue() {\n    Queue q;\n    initQueue(&q);\n\n    for (int i = 1; i <= 5; i++) {\n        Customer c = {i};\n        enqueue(&q, c);\n        printf(\"Müşteri %d sıraya alındı.\\n\", c.customerID);\n    }\n\n    while (!isEmpty(&q)) {\n        Customer c = dequeue(&q);\n        printf(\"Müşteri %d hizmet alıyor.\\n\", c.customerID);\n    }\n}\n\nint main() {\n    simulateBankQueue();\n    return 0;\n}\n```\nBu kod, bankada müşteri bekleme sistemini simüle ederek müşterileri sırayla işler.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718914"
  },
  {
    "question": "Bir yığın kullanarak bir dizideki maksimum değeri nasıl bulursunuz?",
    "answer": "Bir yığın kullanarak bir dizideki maksimum değeri bulmak için, dizinin elemanlarını yığına ekleyebiliriz ve ardından en büyük elemanı bulmak için yığından çıkarabiliriz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nvoid push(Stack* s, int item) {\n    s->items[++(s->top)] = item;\n}\n\nint pop(Stack* s) {\n    return s->items[(s->top)--];\n}\n\nint findMax(int arr[], int size) {\n    Stack s;\n    initStack(&s);\n    for (int i = 0; i < size; i++) {\n        push(&s, arr[i]);\n    }\n    int max = pop(&s);\n    while (s.top != -1) {\n        int value = pop(&s);\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n\nint main() {\n    int arr[] = {3, 5, 1, 8, 2};\n    int max = findMax(arr, 5);\n    printf(\"Maksimum değer: %d\\n\", max);\n    return 0;\n}\n```\nBu kod, verilen bir dizideki maksimum değeri bulur ve çıktısı 'Maksimum değer: 8' olur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:15:30.718963"
  },
  {
    "question": "C dilinde bir stack veri yapısını nasıl tanımlayıp temel işlemlerini (push, pop, isEmpty) implement edersiniz?",
    "answer": "Öncelikle stack'in bir dizi veya bağlı liste kullanarak tanımlanması gerekir. Aşağıda bir dizi ile yapılan bir implementasyon örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nint isFull(Stack* s) {\n    return s->top == MAX - 1;\n}\n\nvoid push(Stack* s, int item) {\n    if (!isFull(s)) {\n        s->items[++s->top] = item;\n    }\n}\n\nint pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->items[s->top--];\n    }\n    return -1; // Hata durumu\n}\n\nint main() {\n    Stack s;\n    init(&s);\n    push(&s, 10);\n    printf(\"Popped: %d\\n\", pop(&s));\n    return 0;\n}\n```\nBu kod, bir stack tanımlar ve temel işlevlerini gerçekleştirir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055793"
  },
  {
    "question": "C dilinde bir queue veri yapısını nasıl tanımlayıp temel işlemlerini (enqueue, dequeue, isEmpty) implement edersiniz?",
    "answer": "Queue, FIFO (First In First Out) prensibiyle çalışan bir veri yapısıdır. Aşağıdaki örnekte, bağlı liste kullanarak bir queue implementasyonu bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* front;\n    Node* rear;\n} Queue;\n\nvoid init(Queue* q) {\n    q->front = q->rear = NULL;\n}\n\nint isEmpty(Queue* q) {\n    return q->front == NULL;\n}\n\nvoid enqueue(Queue* q, int item) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = item;\n    newNode->next = NULL;\n    if (isEmpty(q)) {\n        q->front = q->rear = newNode;\n    } else {\n        q->rear->next = newNode;\n        q->rear = newNode;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) return -1; // Hata durumu\n    Node* temp = q->front;\n    int data = temp->data;\n    q->front = q->front->next;\n    if (q->front == NULL) q->rear = NULL;\n    free(temp);\n    return data;\n}\n\nint main() {\n    Queue q;\n    init(&q);\n    enqueue(&q, 20);\n    printf(\"Dequeued: %d\\n\", dequeue(&q));\n    return 0;\n}\n```\nBu kod, bir queue tanımlar ve temel işlevlerini gerçekleştirir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055841"
  },
  {
    "question": "Stack kullanarak bir ifadenin parantezlerinin düzgün kapatılıp kapatılmadığını kontrol eden bir algoritma yazınız.",
    "answer": "Bu algoritma, parantezlerin doğru eşleşip eşleşmediğini kontrol etmek için bir stack kullanır. Aşağıdaki kod örneği bunu gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\ntypedef struct {\n    char items[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, char item) {\n    s->items[++s->top] = item;\n}\n\nchar pop(Stack* s) {\n    return s->items[s->top--];\n}\n\nint isBalanced(char* expr) {\n    Stack s;\n    init(&s);\n    for (int i = 0; i < strlen(expr); i++) {\n        if (expr[i] == '(') {\n            push(&s, expr[i]);\n        } else if (expr[i] == ')') {\n            if (isEmpty(&s)) return 0;\n            pop(&s);\n        }\n    }\n    return isEmpty(&s);\n}\n\nint main() {\n    char expr[] = \"(a + b) * (c + d)\";\n    printf(\"Dengeli mi? %s\\n\", isBalanced(expr) ? \"Evet\" : \"Hayır\");\n    return 0;\n}\n```\nBu kod, girilen ifadede parantezlerin dengeli olup olmadığını kontrol eder.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055873"
  },
  {
    "question": "C dilinde bir stack'in maksimum değerini bulan bir fonksiyon yazınız.",
    "answer": "Bu görev için, stack üzerinde gezinip en büyük değeri bulmamız gerekecek. Aşağıdaki örnekte bunu gerçekleştiren bir fonksiyon bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (s->top < MAX - 1) {\n        s->items[++s->top] = item;\n    }\n}\n\nint pop(Stack* s) {\n    if (!isEmpty(s)) {\n        return s->items[s->top--];\n    }\n    return -1; // Hata durumu\n}\n\nint maxInStack(Stack* s) {\n    if (isEmpty(s)) return -1; // Hata durumu\n    int max = s->items[0];\n    for (int i = 1; i <= s->top; i++) {\n        if (s->items[i] > max) {\n            max = s->items[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    Stack s;\n    init(&s);\n    push(&s, 5);\n    push(&s, 10);\n    push(&s, 3);\n    printf(\"Max: %d\\n\", maxInStack(&s));\n    return 0;\n}\n```\nBu kod, bir stack'in maksimum değerini bulur.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055898"
  },
  {
    "question": "C dilinde bir queue'yu tersine çeviren bir algoritma yazınız.",
    "answer": "Queue'yu tersine çevirmek için bir stack kullanarak verileri alıp yığmak ve sonra stack'ten geri almak gerekir. Aşağıdaki örnek bu işlemi gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* front;\n    Node* rear;\n} Queue;\n\ntypedef struct {\n    int items[100];\n    int top;\n} Stack;\n\nvoid initQueue(Queue* q) {\n    q->front = q->rear = NULL;\n}\n\nvoid enqueue(Queue* q, int item) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = item;\n    newNode->next = NULL;\n    if (q->rear == NULL) {\n        q->front = q->rear = newNode;\n    } else {\n        q->rear->next = newNode;\n        q->rear = newNode;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (q->front == NULL) return -1;\n    Node* temp = q->front;\n    int data = temp->data;\n    q->front = q->front->next;\n    if (q->front == NULL) q->rear = NULL;\n    free(temp);\n    return data;\n}\n\nvoid initStack(Stack* s) {\n    s->top = -1;\n}\n\nvoid push(Stack* s, int item) {\n    s->items[++s->top] = item;\n}\n\nint pop(Stack* s) {\n    return s->items[s->top--];\n}\n\nvoid reverseQueue(Queue* q) {\n    Stack s;\n    initStack(&s);\n    while (q->front != NULL) {\n        push(&s, dequeue(q));\n    }\n    while (s.top != -1) {\n        enqueue(q, pop(&s));\n    }\n}\n\nint main() {\n    Queue q;\n    initQueue(&q);\n    enqueue(&q, 1);\n    enqueue(&q, 2);\n    enqueue(&q, 3);\n    reverseQueue(&q);\n    printf(\"Dequeued: %d\\n\", dequeue(&q));\n    return 0;\n}\n```\nBu kod, bir queue'yu tersine çevirir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055921"
  },
  {
    "question": "C dilinde bir stack'in içeriğini tersine çevirerek yeni bir stack oluşturan bir algoritma yazınız.",
    "answer": "Stack'in içeriğini tersine çevirmek için, geçici bir stack kullanmak gerekir. Aşağıdaki örnek bu işlemi gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (s->top < MAX - 1) {\n        s->items[++s->top] = item;\n    }\n}\n\nint pop(Stack* s) {\n    return s->items[s->top--];\n}\n\nvoid reverseStack(Stack* s, Stack* temp) {\n    while (!isEmpty(s)) {\n        push(temp, pop(s));\n    }\n}\n\nint main() {\n    Stack original, reversed;\n    init(&original);\n    init(&reversed);\n    push(&original, 1);\n    push(&original, 2);\n    push(&original, 3);\n    reverseStack(&original, &reversed);\n    printf(\"Reversed: %d\\n\", pop(&reversed)); // 1\n    return 0;\n}\n```\nBu kod, bir stack'in içeriğini tersine çevirir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055955"
  },
  {
    "question": "C dilinde bir queue'yu iki stack kullanarak implement edin.",
    "answer": "Bu algoritma, iki stack kullanarak bir queue oluşturmayı sağlar. İşte bunun bir örneği:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* top1;\n    Node* top2;\n} Queue;\n\nvoid init(Queue* q) {\n    q->top1 = NULL;\n    q->top2 = NULL;\n}\n\nvoid push(Node** top, int item) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = item;\n    newNode->next = *top;\n    *top = newNode;\n}\n\nint pop(Node** top) {\n    if (*top == NULL) return -1; // Hata durumu\n    Node* temp = *top;\n    int data = temp->data;\n    *top = (*top)->next;\n    free(temp);\n    return data;\n}\n\nvoid enqueue(Queue* q, int item) {\n    push(&q->top1, item);\n}\n\nint dequeue(Queue* q) {\n    if (q->top2 == NULL) {\n        while (q->top1 != NULL) {\n            push(&q->top2, pop(&q->top1));\n        }\n    }\n    return pop(&q->top2);\n}\n\nint main() {\n    Queue q;\n    init(&q);\n    enqueue(&q, 1);\n    enqueue(&q, 2);\n    printf(\"Dequeued: %d\\n\", dequeue(&q));\n    return 0;\n}\n```\nBu kod, iki stack kullanarak bir queue implementasyonu sağlar.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.055978"
  },
  {
    "question": "C dilinde bir stack'den n elemanını silen bir algoritma yazınız.",
    "answer": "Bu işlem, stack'in elemanlarını geçici bir stack'e alarak gerçekleştirilir. İşte bunun bir örneği:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int items[MAX];\n    int top;\n} Stack;\n\nvoid init(Stack* s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack* s) {\n    return s->top == -1;\n}\n\nvoid push(Stack* s, int item) {\n    if (s->top < MAX - 1) {\n        s->items[++s->top] = item;\n    }\n}\n\nint pop(Stack* s) {\n    return s->items[s->top--];\n}\n\nvoid deleteN(Stack* s, int n) {\n    Stack temp;\n    init(&temp);\n    int count = 0;\n    while (!isEmpty(s)) {\n        if (count != n) {\n            push(&temp, pop(s));\n        } else {\n            pop(s); // n. elemanı sil\n        }\n        count++;\n    }\n    while (!isEmpty(&temp)) {\n        push(s, pop(&temp));\n    }\n}\n\nint main() {\n    Stack s;\n    init(&s);\n    push(&s, 1);\n    push(&s, 2);\n    push(&s, 3);\n    deleteN(&s, 1); // 2. elemanı sil\n    printf(\"Top: %d\\n\", pop(&s)); // 3\n    return 0;\n}\n```\nBu kod, stack'ten belirtilen n'inci elemanı siler.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:16:27.056001"
  },
  {
    "question": "Bir stack uygulaması oluştururken bellek yönetimi konularını nasıl optimize edersiniz?",
    "answer": "Stack uygulaması oluştururken bellek yönetimini optimize etmek için dinamik bellek tahsisi yerine sabit boyutlu bir dizi kullanmayı düşünebilirsiniz. Bu, bellek parçalanmasını azaltır ve erişim sürelerini kısaltır. Örneğin, sabit bir boyuttaki bir dizi ile stack'i yönetmek için bir 'top' indeksine sahip olun. Push ve pop işlemleri bu indeksi güncelleyerek basit bir şekilde gerçekleştirilebilir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106011"
  },
  {
    "question": "Queue uygulamanızda, performansı artırmak için hangi veri yapısını kullanmalısınız?",
    "answer": "Queue uygulamanızda, performansı artırmak için dairesel bir dizi (circular array) kullanabilirsiniz. Standart bir dizi kullanıldığında, enqueue ve dequeue işlemleri için her seferinde dizi elemanlarını kaydırmak gerekebilir. Dairesel dizi kullanarak, baş ve kuyruk indekslerini döngüsel olarak güncelleyebilir ve böylece tüm elemanları taşımadan işlemlerinizi gerçekleştirebilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106053"
  },
  {
    "question": "Stack'te bir elemanın en üstte olup olmadığını kontrol etmenin en verimli yolu nedir?",
    "answer": "Stack'teki en üst elemanı kontrol etmek için 'peek' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, stack'in en üstündeki elemanı döndürür fakat stack'i değiştirmez. Örneğin, peek fonksiyonu kullanarak, 'top' indeksine erişebilir ve bu işlemi O(1) zaman karmaşıklığında gerçekleştirebilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106082"
  },
  {
    "question": "Bir queue'daki en eski elemanı bulmak için hangi yöntemi önerirsiniz?",
    "answer": "Queue'daki en eski elemana erişmek için, ilk elemanı doğrudan erişim ile bulabilirsiniz. Eğer normal bir linked list yapısı kullanıyorsanız, head (baş) işaretçisini kullanarak O(1) zaman karmaşıklığı ile en eski elemanı bulabilirsiniz. İsterseniz, sıralamak yerine bir 'front' işaretçisi tutarak en eski elemana sürekli erişim sağlayabilirsiniz.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106108"
  },
  {
    "question": "Stack ve Queue yapılarını kullanarak bir ifadeyi tersine çevirmek için nasıl bir algoritma geliştirebilirsiniz?",
    "answer": "Bir ifadeyi tersine çevirmek için, önce ifadeyi bir stack'e yerleştirin. Daha sonra, stack'ten elemanları çıkartarak yeni bir dizi veya string oluşturun. Örneğin, bir 'for' döngüsü ile stack içerisindeki tüm elemanları pop ederek yeni bir string oluşturabilirsiniz. Bu işlemler O(n) zaman karmaşıklığında gerçekleşir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106141"
  },
  {
    "question": "FIFO (First In First Out) prensibini sağlamak üzere iki stack kullanarak bir queue nasıl oluşturulur?",
    "answer": "İki stack kullanarak bir queue oluşturmak için 'enqueue' işlemi bir stack'e, 'dequeue' işlemi ise diğer stack'e aktarılmalıdır. Enqueue sırasında elemanlar doğrudan ilk stack'e eklenir. Dequeue işlemi sırasında, eğer ikinci stack boşsa, birinci stack'teki tüm elemanları pop ederek ikinci stack'e aktarın. Bu sayede, ilk eklenen eleman ilk çıkacak şekilde kontrol sağlanır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106173"
  },
  {
    "question": "Queue'da öncelik sırasına göre bir eleman eklemek için ne tür bir yapı önerirsiniz?",
    "answer": "Öncelik sırası ile çalışan bir queue oluşturmak için, bir min-heap veya max-heap yapısını tercih edebilirsiniz. Elemanları eklerken öncelik değerine göre heap yapısına ekleyerek, en yüksek önceliğe (veya en düşük) sahip elemanı O(log n) karmaşıklığında alabilirsiniz. Bu yöntem, öncelik tabanlı işlemler için oldukça etkilidir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106201"
  },
  {
    "question": "Bir stack'te belirli bir elemanın bulunup bulunmadığını kontrol etmek için hangi algoritmayı kullanmalısınız?",
    "answer": "Belirli bir elemanın stack içinde bulunup bulunmadığını kontrol etmek için, bir geçici stack kullanabilirsiniz. Mevcut stack'ten elemanları geçici stack'e aktarırken, her elemanı kontrol edin. Eğer aradığınız elemanı bulursanız, orijinal stack'inizi geri yükleyerek işlemi tamamlayabilirsiniz. Bu yöntem, stack'in orijinal düzenini koruyarak O(n) zaman karmaşıklığında çalışır.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106231"
  },
  {
    "question": "Stack veri yapısını kullanarak parantezlerin dengeli olup olmadığını kontrol etmek için nasıl bir algoritma geliştirirsiniz?",
    "answer": "Parantezlerin dengeli olup olmadığını kontrol etmek için bir stack kullanabilirsiniz. Her açılan parantezi stack'e ekleyin. Kapatılan bir parantezle karşılaştığınızda, stack'ten bir eleman pop edin ve bu elemanın türünü kontrol edin. Eğer tür uyumsuzsa, parantezler dengeli değildir. Tüm karakterler geçildikten sonra stack boşsa, parantezler dengelidir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106263"
  },
  {
    "question": "Bir queue'dan belirli bir sayıda eleman çıkartıp kalan elemanları nasıl etkili bir şekilde yeniden düzenlersiniz?",
    "answer": "Kalan elemanları yeniden düzenlemek için, çıkardığınız elemanları geçici bir stack'e yerleştirin. Çıkardığınız elemanların sayısını belirledikten sonra, geçici stack'i tekrar queue'ya ekleyin. Bu yöntem, elemanların sırasını koruyarak O(n) zaman karmaşıklığında çalışır ve işlemlerinizi daha verimli hale getirir.",
    "category": "data_structures",
    "topic": "stacks_queues",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Stack ve Queue",
    "timestamp": "2025-06-01T16:17:53.106298"
  },
  {
    "question": "Bir ağaç yapısında düğüm eklemek için gerekli fonksiyonu tamamla. Düğüm yapısı şöyle tanımlanmış: 'struct Node { int data; struct Node* left; struct Node* right; };'",
    "answer": "void insert(struct Node** root, int value) { if (*root == NULL) { *root = (struct Node*)malloc(sizeof(struct Node)); (*root)->data = value; (*root)->left = NULL; (*root)->right = NULL; } else if (value < (*root)->data) { insert(&(*root)->left, value); } else { insert(&(*root)->right, value); } } // Bu fonksiyon, verilen değeri uygun yere ekleyerek ikili ağaçta düğüm oluşturuyor.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248758"
  },
  {
    "question": "Verilen bir ağaçta öncelikli dolaşım (pre-order traversal) yapacak bir fonksiyon yaz.",
    "answer": "void preOrder(struct Node* root) { if (root != NULL) { printf(\"%d \", root->data); preOrder(root->left); preOrder(root->right); } } // Bu fonksiyon, önce kökü ziyaret eder, ardından sol alt ağacı ve son olarak sağ alt ağacı ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248804"
  },
  {
    "question": "Bir ağaçta düğüm sayısını hesaplayan bir fonksiyon yaz.",
    "answer": "int countNodes(struct Node* root) { if (root == NULL) return 0; return 1 + countNodes(root->left) + countNodes(root->right); } // Bu fonksiyon, her düğümü sayar ve toplam düğüm sayısını döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248826"
  },
  {
    "question": "Bir ağaçta en derin düğümü bulan bir fonksiyon yaz.",
    "answer": "int maxDepth(struct Node* node) { if (node == NULL) return 0; int leftDepth = maxDepth(node->left); int rightDepth = maxDepth(node->right); return (leftDepth > rightDepth) ? leftDepth + 1 : rightDepth + 1; } // Bu fonksiyon, ağaçtaki en derin düğümün derinliğini hesaplar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248847"
  },
  {
    "question": "Bir ikili arama ağacında (binary search tree) belirli bir değerin var olup olmadığını kontrol eden bir fonksiyon yaz.",
    "answer": "int search(struct Node* root, int value) { if (root == NULL) return 0; if (root->data == value) return 1; else if (value < root->data) return search(root->left, value); else return search(root->right, value); } // Bu fonksiyon, ağaçta değerin var olup olmadığını kontrol eder ve 1 veya 0 döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248883"
  },
  {
    "question": "Bir ağacı seviye seviyesinde (level order) dolaşmak için gerekli kodu tamamla.",
    "answer": "void levelOrder(struct Node* root) { if (root == NULL) return; queue<Node*> q; q.push(root); while (!q.empty()) { Node* current = q.front(); q.pop(); printf(\"%d \", current->data); if (current->left != NULL) q.push(current->left); if (current->right != NULL) q.push(current->right); } } // Bu fonksiyon, ağaç düğümlerini seviyelerine göre ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248919"
  },
  {
    "question": "Bir ağacı tersine dolaşmak (post-order traversal) için gerekli fonksiyonu yaz.",
    "answer": "void postOrder(struct Node* root) { if (root != NULL) { postOrder(root->left); postOrder(root->right); printf(\"%d \", root->data); } } // Bu fonksiyon, önce sol alt ağacı, sonra sağ alt ağacı, en son ise kökü ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248946"
  },
  {
    "question": "Bir ağacı silmek için gerekli fonksiyonu tamamla.",
    "answer": "void freeTree(struct Node* root) { if (root != NULL) { freeTree(root->left); freeTree(root->right); free(root); } } // Bu fonksiyon, ağaçtaki tüm düğümleri serbest bırakır ve bellek sızıntısını önler.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248965"
  },
  {
    "question": "Bir ağacın simetrik olup olmadığını kontrol etmek için bir fonksiyon yaz.",
    "answer": "int isSymmetric(struct Node* root) { if (root == NULL) return 1; return isMirror(root->left, root->right); } int isMirror(struct Node* left, struct Node* right) { if (left == NULL && right == NULL) return 1; if (left == NULL || right == NULL) return 0; return (left->data == right->data) && isMirror(left->left, right->right) && isMirror(left->right, right->left); } // Bu fonksiyon, ağacın simetrik olup olmadığını kontrol eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.248988"
  },
  {
    "question": "Bir ağaçta belirli bir değeri içeren düğümleri silmek için gerekli fonksiyonu yaz.",
    "answer": "struct Node* deleteNode(struct Node* root, int value) { if (root == NULL) return root; if (value < root->data) root->left = deleteNode(root->left, value); else if (value > root->data) root->right = deleteNode(root->right, value); else { if (root->left == NULL) return root->right; else if (root->right == NULL) return root->left; struct Node* temp = minValueNode(root->right); root->data = temp->data; root->right = deleteNode(root->right, temp->data); } return root; } // Bu fonksiyon, belirli bir değeri içeren düğümü siler ve ağaç yapısını korur.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:16.249014"
  },
  {
    "question": "İkili ağaç yapısında bir düğüm ekleyen fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return newNode(data);\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    return node;\n}\n\n// Kullanım örneği:\n// struct Node* root = NULL;\n// root = insert(root, 10);\n// insert(root, 5);\n// insert(root, 15);",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346073"
  },
  {
    "question": "Bir ikili ağacın pre-order (önceden) traversalını yazın.",
    "answer": "#include <stdio.h>\n\nvoid preOrder(struct Node* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    preOrder(root->left);\n    preOrder(root->right);\n}\n\n// Kullanım örneği:\n// preOrder(root); // root, ikili ağacın başı",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346113"
  },
  {
    "question": "İkili ağaçta bir değerin var olup olmadığını kontrol eden fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint search(struct Node* root, int key) {\n    if (root == NULL) return 0;\n    if (root->data == key) return 1;\n    if (key < root->data) return search(root->left, key);\n    return search(root->right, key);\n}\n\n// Kullanım örneği:\n// int found = search(root, 10); // 10 değerinin varlığını kontrol et",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346142"
  },
  {
    "question": "İkili ağacın yükseklik hesaplayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint height(struct Node* node) {\n    if (node == NULL) return -1;\n    int leftHeight = height(node->left);\n    int rightHeight = height(node->right);\n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}\n\n// Kullanım örneği:\n// int h = height(root); // İkili ağacın yüksekliğini bul",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346163"
  },
  {
    "question": "İkili ağacın in-order (sıralı) traversalını gerçekleştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid inOrder(struct Node* root) {\n    if (root == NULL) return;\n    inOrder(root->left);\n    printf(\"%d \", root->data);\n    inOrder(root->right);\n}\n\n// Kullanım örneği:\n// inOrder(root); // Ağacın elemanlarını sıralı şekilde yazdıracak",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346191"
  },
  {
    "question": "İkili ağaçta düğüm silme işlemini gerçekleştiren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node* deleteNode(struct Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->data)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->data)\n        root->right = deleteNode(root->right, key);\n    else {\n        // Bir çocuk veya hiç çocuk yoksa\n        if (root->left == NULL) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        // İki çocuk varsa\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n// minValueNode ve diğer yardımcı fonksiyonlar eklenmelidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346215"
  },
  {
    "question": "Bir ikili ağacın en küçük değerini bulacak bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != NULL)\n        current = current->left;\n    return current;\n}\n\n// Kullanım örneği:\n// struct Node* minNode = minValueNode(root); // En küçük değeri bul",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346238"
  },
  {
    "question": "Bir ikili ağacın tüm düğümlerini düz bir dizide saklayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nvoid storeInArray(struct Node* root, int arr[], int* index) {\n    if (root == NULL) return;\n    storeInArray(root->left, arr, index);\n    arr[(*index)++] = root->data;\n    storeInArray(root->right, arr, index);\n}\n\n// Kullanım örneği:\n// int arr[100];\n// int index = 0;\n// storeInArray(root, arr, &index); // Ağacın elemanlarını arr dizisine koy",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346264"
  },
  {
    "question": "İkili ağacın simetrik olup olmadığını kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint isMirror(struct Node* tree1, struct Node* tree2) {\n    if (tree1 == NULL && tree2 == NULL) return 1;\n    if (tree1 == NULL || tree2 == NULL) return 0;\n    return (tree1->data == tree2->data) && \n           isMirror(tree1->right, tree2->left) && \n           isMirror(tree1->left, tree2->right);\n}\n\nint isSymmetric(struct Node* root) {\n    return isMirror(root, root);\n}\n\n// Kullanım örneği:\n// int symmetric = isSymmetric(root); // Ağacın simetrik olup olmadığını kontrol et",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:18:45.346288"
  },
  {
    "question": "Bir ikili arama ağacında belirli bir değeri arayan bir fonksiyonu tamamlayın.",
    "answer": "```c\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* search(Node* root, int value) {\n    if (root == NULL || root->data == value) {\n        return root;\n    }\n    if (value < root->data) {\n        return search(root->left, value);\n    } else {\n        return search(root->right, value);\n    }\n}\n``` Bu fonksiyon, bir ikili arama ağacında belirli bir değeri arar. Eğer değer bulunursa, o değere ait düğümü döner, aksi takdirde NULL döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570583"
  },
  {
    "question": "Bir ikili arama ağacına yeni bir değer ekleyen bir fonksiyonu tamamlayın.",
    "answer": "```c\nvoid insert(Node** root, int value) {\n    if (*root == NULL) {\n        *root = (Node*)malloc(sizeof(Node));\n        (*root)->data = value;\n        (*root)->left = (*root)->right = NULL;\n        return;\n    }\n    if (value < (*root)->data) {\n        insert(&(*root)->left, value);\n    } else {\n        insert(&(*root)->right, value);\n    }\n}\n``` Bu fonksiyon, verilen değeri ikili arama ağacına ekler. Eğer ağaç boşsa, yeni bir düğüm oluşturur ve değeri buraya atar. Aksi takdirde, uygun alt ağaçta insert fonksiyonunu çağırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570644"
  },
  {
    "question": "Bir ikili ağaçta düğümlerin toplamını hesaplayan bir fonksiyonu tamamlayın.",
    "answer": "```c\nint sum(Node* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return root->data + sum(root->left) + sum(root->right);\n}\n``` Bu fonksiyon, ikili ağacın her düğümünün değerlerini toplar. Eğer düğüm NULL ise 0 döner, aksi takdirde düğümün verisini toplama dahil ederek sol ve sağ alt ağaçlardaki değerleri toplar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570687"
  },
  {
    "question": "Bir ikili ağacın yüksekliğini hesaplayan bir fonksiyonu tamamlayın.",
    "answer": "```c\nint height(Node* root) {\n    if (root == NULL) {\n        return -1;\n    }\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}\n``` Bu fonksiyon, bir ikili ağacın yüksekliğini hesaplar. Eğer düğüm NULL ise -1 döner. Düğüm mevcutsa, sol ve sağ alt ağaçların yüksekliklerini hesaplayarak daha büyük olanı alır ve 1 ekleyerek döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570726"
  },
  {
    "question": "Bir ikili ağaçta inorder (sırasıyla) gezinti uygulayan bir fonksiyonu tamamlayın.",
    "answer": "```c\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n``` Bu fonksiyon, ikili ağacın düğümlerini inorder sırasına göre gezerek ekrana yazdırır. İlk önce sol alt ağacı, ardından kök düğümü ve son olarak sağ alt ağacı ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570770"
  },
  {
    "question": "Bir ikili ağacı postorder (sonda) gezinti uygulayan bir fonksiyonu tamamlayın.",
    "answer": "```c\nvoid postorder(Node* root) {\n    if (root != NULL) {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \", root->data);\n    }\n}\n``` Bu fonksiyon, ikili ağacın düğümlerini postorder sırasına göre gezerek ekrana yazdırır. İlk önce sol alt ağacı, ardından sağ alt ağacı ve son olarak kök düğümü ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570815"
  },
  {
    "question": "Bir ikili arama ağacından bir düğüm silmek için bir fonksiyonu tamamlayın.",
    "answer": "```c\nNode* deleteNode(Node* root, int value) {\n    if (root == NULL) {\n        return root;\n    }\n    if (value < root->data) {\n        root->left = deleteNode(root->left, value);\n    } else if (value > root->data) {\n        root->right = deleteNode(root->right, value);\n    } else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\nNode* minValueNode(Node* node) {\n    Node* current = node;\n    while (current && current->left != NULL)\n        current = current->left;\n    return current;\n}\n``` Bu fonksiyon, ikili arama ağacından belirli bir düğümü siler. Düğüm bulunduğunda, silme işlemine göre uygun durumda işlemi gerçekleştirir: eğer hiç çocuk yoksa, bir çocuk varsa ya da iki çocuğu varsa uygun şekilde işlem yapar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570865"
  },
  {
    "question": "Bir ikili ağacın düzlemdeki düğümlerini sıralı bir diziye yerleştiren bir fonksiyonu tamamlayın.",
    "answer": "```c\nvoid storeInorder(Node* root, int* arr, int* index) {\n    if (root != NULL) {\n        storeInorder(root->left, arr, index);\n        arr[(*index)++] = root->data;\n        storeInorder(root->right, arr, index);\n    }\n}\n``` Bu fonksiyon, ikili ağacı inorder sırasına göre gezerek her bir düğümün değerini verilen diziye yerleştirir. `index` değişkeni dizinin hangi elemanına yazılacağını takip eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570914"
  },
  {
    "question": "Bir ikili ağaçta bir değeri güncelleyen bir fonksiyonu tamamlayın.",
    "answer": "```c\nNode* updateValue(Node* root, int oldValue, int newValue) {\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root->data == oldValue) {\n        root->data = newValue;\n    } else if (oldValue < root->data) {\n        root->left = updateValue(root->left, oldValue, newValue);\n    } else {\n        root->right = updateValue(root->right, oldValue, newValue);\n    }\n    return root;\n}\n``` Bu fonksiyon, ikili arama ağacında belirli bir değeri bulur ve yeni bir değer ile günceller. Düğüm bulunduğunda, değeri günceller ve ardından ağacın kalan kısmını etkilemeyecek şekilde geri döner.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570953"
  },
  {
    "question": "Bir ikili ağacı seviyesine göre gezinen bir fonksiyonu tamamlayın.",
    "answer": "```c\nvoid levelOrder(Node* root) {\n    if (root == NULL) return;\n    Queue* q = createQueue();\n    enqueue(q, root);\n    while (!isEmpty(q)) {\n        Node* current = dequeue(q);\n        printf(\"%d \", current->data);\n        if (current->left) enqueue(q, current->left);\n        if (current->right) enqueue(q, current->right);\n    }\n}\n``` Bu fonksiyon, ikili ağacı seviyelerine göre gezerek her düğümün değerini ekrana yazdırır. İlk olarak kök düğüm kuyrukta saklanır, ardından kuyruktan düğümler çıkarılarak çocuk düğümler eklenir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:11.570992"
  },
  {
    "question": "Ağaç yapımında düğüm eklerken, yanlış şekilde 'malloc' kullanıldığında ne olur?",
    "answer": "Yanlışlıkla 'malloc' kullanımında, bellekte yeterli alan ayrılmadığında program 'NULL' dönebilir. Bu durumda, düğüm oluşturulamaz ve program 'segmentation fault' hatası alabilir. Doğru kullanımda, 'malloc' ile yeterli bellek ayrılmalı ve bu pointer kontrol edilmelidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.314908"
  },
  {
    "question": "Ağaçta düğüm silme işlemi yaparken, 'parent' pointer'ını güncellemeyi unuttuğumda ne olur?",
    "answer": "Eğer 'parent' pointer'ı güncellenmezse, silinen düğüm hala ağaçta mevcut gibi görünür. Bu durumda, ağaç yapısı bozulur ve bellek sızıntılarına yol açabilir. Silme işlemi sırasında, 'parent' pointer'ını güncellemek önemlidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.314983"
  },
  {
    "question": "Ağaçta derinlik hesaplama fonksiyonu yanlış çalışıyorsa, muhtemel nedenler neler olabilir?",
    "answer": "Eğer derinlik hesaplama fonksiyonunda her düğüm için 'depth' değerini doğru bir şekilde artırmazsanız, yanlış sonuç alırsınız. Ayrıca, bir düğümün çocuklarının doğru şekilde kontrol edilmemesi de derinliğin yanlış hesaplanmasına yol açabilir. Her düğüm için 'depth' değerini artırdığınızdan ve çocuk düğümleri doğru bir şekilde ziyaret ettiğinizden emin olun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315029"
  },
  {
    "question": "Ağaç üzerinden sıralı gezinti (in-order traversal) yaparken, 'left' çocuk düğümüne erişimi atladığımda ne olur?",
    "answer": "Eğer 'left' çocuğa erişimi atlarsanız, ağaçtaki bazı düğümleri göz ardı edersiniz ve sıralı gezinti sırasında eksik düğümler ile sonuçlanır. Bu durumda, çıktınız düzensiz ve eksik olur. Her düğüm için hem 'left' hem de 'right' çocukları ziyaret etmek gerekir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315088"
  },
  {
    "question": "Ağaç yapısındaki düğümlerin veri alanlarını güncellerken, pointer'ları yanlış kullanırsam ne olur?",
    "answer": "Pointer'ları yanlış kullanmak, bellek adreslerinin kaybolmasına veya yanlış verilere erişilmesine neden olabilir. Bu durumda, program 'undefined behavior' ile karşılaşabilir. Düğüm veri alanlarının güncellenmesi sırasında doğru pointer'ların kullanıldığından emin olun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315143"
  },
  {
    "question": "Ağaçta arama işlemi yaparken, 'base case' kontrolünü atladığımda ne olur?",
    "answer": "Eğer 'base case' kontrolünü atlarsanız, arama işlemi sonsuz döngüye girebilir veya stack overflow hatasına neden olabilir. Her arama işlemi için temel durumu kontrol etmek, algoritmanın düzgün çalışması için kritik öneme sahiptir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315188"
  },
  {
    "question": "Çift yönlü bağlı ağaçta 'next' ve 'prev' pointerlarını güncellemeyi unuttuğumda ne olur?",
    "answer": "Eğer 'next' ve 'prev' pointerlarını güncellemeyi unutursanız, ağaçta gezinme işlemleri yapılamaz hale gelir. Bu, ağaç yapısının bozulmasına ve programın beklenmedik şekilde çalışmasına neden olabilir. Bağlı düğümler arasındaki pointer'ların doğru güncellenmesi gereklidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315238"
  },
  {
    "question": "Ağaçta düğüm ekleme işlemi yaparken, bir döngü içinde yanlışlıkla aynı veriyi eklersem ne olur?",
    "answer": "Eğer bir döngü içinde aynı veriyi eklemeye çalışırsanız, ağaçta tekrar eden düğümler oluşabilir. Bu, ağaç yapısında gereksiz karmaşıklık yaratır ve arama işlemlerini yavaşlatabilir. Ağaç yapısına yeni bir düğüm eklemeden önce, verinin zaten mevcut olup olmadığını kontrol etmek önemlidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315288"
  },
  {
    "question": "Ağaçta düğüm silme işlemi sırasında 'free' kullanmayı unuttuğumda ne olur?",
    "answer": "Eğer 'free' fonksiyonunu unutur ve düğümü serbest bırakmazsanız, bellek sızıntısına neden olursunuz. Program uzun süre çalıştığında, bu bellek sızıntıları sisteminizin performansını olumsuz etkileyebilir. Her düğüm silindikten sonra bellek alanının serbest bırakılması önemlidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315330"
  },
  {
    "question": "Ağaçta ağaç yapısını temsil eden yapı tanımında 'struct' anahtar kelimesini unuttuğumda ne olur?",
    "answer": "Eğer 'struct' anahtar kelimesini unutursanız, derleyici hata verecektir çünkü yapıyı tanımlamak için 'struct' kullanılmadan nesne oluşturulamaz. Yapıyı tanımlamak için 'struct' anahtar kelimesinin kullanılması gereklidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315379"
  },
  {
    "question": "Ağaçta 'post-order' gezinti yaparken, 'right' çocuğu ziyaret etmeyi unuttuğumda ne olur?",
    "answer": "Eğer 'right' çocuğu ziyaret etmeyi unutursanız, gezinti sırasındaki bazı düğümleri atlamış olursunuz. Bu durum, çıktının eksik ve düzensiz olmasına neden olacaktır. Her düğümü gezdirirken 'left' ve 'right' çocuklarının her ikisini de ziyaret etmelisiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:37.315428"
  },
  {
    "question": "Bir ikili ağaçta düğüm ekleme işlemi sırasında, eklenen düğüm belirtilen yere değil de ağacın en sonuna ekleniyor. Neden böyle oluyor?",
    "answer": "Düğüm ekleme fonksiyonunun mantığında bir hata olabilir. Genellikle, yeni bir düğüm eklerken doğru konumu bulmak için 'sol' ve 'sağ' çocukları kontrol edilmelidir. Eğer bu kontrol doğru şekilde yapılmıyorsa, yeni düğüm her zaman en sonuna eklenir. Örnek düzeltme: Yeni düğüm eklerken, geçerli düğümün değerine göre solda mı sağda mı yer alacağını kontrol etmeniz gerekir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822676"
  },
  {
    "question": "Ağaçta derinlik hesaplama fonksiyonu her zaman 0 döndürüyor. Hatanın kaynağı ne olabilir?",
    "answer": "Derinlik hesaplama fonksiyonunda, her bir düğüm için derinliği artırmak yerine sabit bir değer döndürülüyor olabilir. Düğümün derinliğini hesaplamak için, her bir çocuğa rekurziv olarak derinlik fonksiyonunu çağırmalı ve maksimum derinlik değerini almalısınız. Örnek düzeltme: 'depth' değişkenini her seferinde rekurziv çağrıdan elde edilen değere göre güncelleyin.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822721"
  },
  {
    "question": "Ağaçta dolaşım sırasında bazı düğümler atlanıyor. Neden böyle bir durum söz konusu?",
    "answer": "Bu durum genellikle dolaşım algoritmasında bir hata olduğunu gösterir. Özellikle, 'sol' ve 'sağ' çocuklar arasında geçiş yaparken bir koşul atlanmış olabilir. Örnek düzeltme: Dolaşım fonksiyonunun mantığını kontrol edin ve tüm düğümleri ziyaret ettiğinizden emin olun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822750"
  },
  {
    "question": "Bir ağaç içindeki düğümlerin toplamını hesaplayan fonksiyon her zaman 0 dönüyor. Hatanın nedeni nedir?",
    "answer": "Düğüm değerlerini toplarken, muhtemelen yalnızca 'NULL' olan düğümleri kontrol ediyorsunuz. Düğüm değeri yoksa 0 döndürmek yerine, düğümün değerini toplamak için güncelleme yapmalısınız. Örnek düzeltme: 'node->value' değerini mevcut toplamınıza ekleyin ve çocuk düğümler için rekurzif çağrınızı unutmayın.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822780"
  },
  {
    "question": "Ağaçta belirli bir değeri arama işlemi, değer ağacın içinde yoksa bile 'bulundu' mesajı veriyor. Neden böyle oluyor?",
    "answer": "Arama fonksiyonunuzda, değeri bulamadığınız durumlarda yanlış bir koşul ile 'bulundu' ifadesini döndürüyor olabilirsiniz. Doğru bir şekilde 'NULL' kontrolü yaparak düğümü kontrol etmeniz gerekir. Örnek düzeltme: Düğüm değeri ile hedef değeri karşılaştırın ve eğer 'NULL' ise 'bulunamadı' döndürün.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822817"
  },
  {
    "question": "İkili arama ağacındaki dalların sıralaması doğru değil. Hatanın kaynağı ne olabilir?",
    "answer": "Düğümleri eklerken, ekleme koşullarını kontrol etmediğiniz veya yanlış uyguladığınız için bu durum ortaya çıkabilir. İkili arama ağacında, ekleyeceğiniz değer, mevcut düğümün değerinden küçükse solu, büyükse sağına eklenmelidir. Örnek düzeltme: Eklenirken her düğüm için bu koşulları doğru bir şekilde kontrol edin.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822845"
  },
  {
    "question": "Ağaçta en yükseğe çıkma (height) fonksiyonu, derinlik ile aynı değeri döndürüyor. Bu neden kaynaklanıyor?",
    "answer": "En yükseğe çıkma ve derinlik hesaplaması arasında bir karışıklık yaşıyor olabilirsiniz. Derinlik, belirli bir düğümden köke kadar olan mesafeyi ölçerken, yükseklik tüm alt ağacın en yüksek derinliğini ölçer. Örnek düzeltme: Yükseklik hesaplamak için, sol ve sağ alt ağaçların yüksekliklerini karşılaştırarak maksimum değeri döndürmelisiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822878"
  },
  {
    "question": "Ağaç silme fonksiyonu, kök düğüm silindiğinde ağacın tamamını silmiyor. Neden böyle bir sorun var?",
    "answer": "Ağaç silme işlemi sırasında, yalnızca 'kök' düğüm silindiğinde, o düğümün çocuklarının nasıl yönetileceğini doğru bir şekilde tanımlamamış olabilirsiniz. Eğer kök düğüm silinirken çocukları yönetmezseniz, ağaçta hala düğümler kalır. Örnek düzeltme: Kök silindiğinde, çocuk düğümleri yeniden organize ederek yeni kök oluşturmalısınız.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822916"
  },
  {
    "question": "Ağaç yapısında bir düğüm silindiğinde hafıza sızıntısı yaşıyorum. Hatanın kaynağı nedir?",
    "answer": "Düğüm silme işlemi sırasında, silinen düğüm için ayrılmış bellek alanını serbest bırakmayı unutmuş olabilirsiniz. Bellek sızıntılarının önlenmesi için, silme işlemi sonrasında 'free()' fonksiyonunu kullanmalısınız. Örnek düzeltme: Silme işleminin sonunda, silinen düğüm için 'free(node)' çağrısını ekleyin.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822943"
  },
  {
    "question": "Ağaç yapısının derinliği hesaplanıyor ancak her zaman 1 dönüyor. Neden böyle bir durum var?",
    "answer": "Derinlik hesaplama fonksiyonunuzda, rekurzif çağrı gerçekleştirmeden yalnızca mevcut düğümün derinliğini döndürüyor olabilirsiniz. Düğümün çocuklarına rekurzif çağrı yapmadığınız için derinlik her zaman 1 olarak kalır. Örnek düzeltme: Çocukların derinliğini hesaplamak için rekurzif çağrılar ekleyin ve bunlardan maksimum değeri alarak döndürün.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:19:59.822972"
  },
  {
    "question": "Ağaç yapısında, düğümlerin veri alanını güncelleyen bir fonksiyon yazdım ama güncelleme işleminden sonra ağaçta veri kaybı yaşıyorum. Hata nerede olabilir?",
    "answer": "Bu tür bir sorun genellikle ağaç yapısını güncellemeden sonra doğru belleği ayırmadığınızda veya mevcut düğümün bağlantılarını doğru bir şekilde güncelleyemediğinizde ortaya çıkar. Güncellemeyi yapmadan önce, mevcut düğümün veri alanını doğru bir şekilde kontrol etmeniz ve bağlantıların kaybolmadığından emin olmalısınız. Ayrıca, düğüm silme veya ekleme işlemlerinden sonra ağaç yapısını yeniden dengelemek de önemlidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395672"
  },
  {
    "question": "Ağaçta belirli bir değeri arayan bir fonksiyonum var ama her zaman NULL döndürüyor. Neden?",
    "answer": "Fonksiyonunuz muhtemelen ağaçta doğru şekilde gezmiyor olabilir. Ağaçta gezinmek için doğru karşılaştırma operatörlerini kullanmadığınızda veya recursive olarak doğru dallara gitmediğinizde bu sorunla karşılaşabilirsiniz. Fonksiyonunuzu gözden geçirerek, tüm olası yolları kontrol ettiğinizden ve her dağılma noktasında doğru karşılaştırmalar yaptığınızdan emin olun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395717"
  },
  {
    "question": "Ağacımda düğüm sayısını hesaplamak için yazdığım fonksiyon beklediğimden fazla döngü yapıyor. Bu durumu nasıl düzeltebilirim?",
    "answer": "Fonksiyonunuz muhtemelen sonsuz döngüye girmekte veya gereksiz yere düğümleri tekrar ziyaret etmektedir. Bu durumu önlemek için her düğümün ziyaret edildiğini işaretleyen bir bayrak kullanarak veya recursive fonksiyonlarınızda doğru çıkış koşullarını tanımlayarak bu problemi çözebilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395752"
  },
  {
    "question": "Ağaç yapısında bir düğümü silmek için yazdığım fonksiyonun bazı durumlarda çökmesine neden olan bir hata var. Hatanın kaynağı nedir?",
    "answer": "Silme işlemi sırasında, eğer düğüm bir çocuk düğüme sahipse ve bu çocuk düğüm de kendi çocuklarına sahipse, doğru bağlantıları güncelleyemiyor olabilirsiniz. Silme işleminde, silinecek düğümün yerine geçecek düğümü doğru seçmeniz ve bağlantıları düzgün bir şekilde güncellemeniz gerekir. Bu durumda, örneğin, silinecek düğümün sağ alt düğümünü veya sol alt düğümünü kullanarak geçici bir çözüm uygulamanız gerekebilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395790"
  },
  {
    "question": "Ağaçta öncelikli olarak gezinti yaparken beklenmedik bir çıkış yapıyorum. Bu durumu nasıl izole edebilirim?",
    "answer": "Bu durum genellikle döngülerin veya recursive çağrıların yanlış yapısından kaynaklanır. Öncelikle her adımda hangi düğümün ziyaret edildiğini takip ederek ve döngüdeki her çağrıda doğru bir şekilde kontrol yaparak durumu izole edebilirsiniz. Ayrıca, debug modunda, her adımda hangi düğüm üzerinde işlem yaptığınızı loglayarak da sorunun kaynağını bulabilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395822"
  },
  {
    "question": "Ağacın en yüksek derinliğini bulmak için yazdığım fonksiyon her zaman sıfır dönüyor. Sorunu çözmek için ne yapmalıyım?",
    "answer": "Bu hata genellikle ağaç yapısının başlangıç koşullarında veya recursive derinlik hesaplama mantığında bir hata olduğunu gösterir. Fonksiyonun başlangıcında ağaç boş mu diye kontrol etmelisiniz. Eğer ağaç boş değilse, tüm çocuk düğümleri ile recursive olarak derinliği hesaplamanız gerekir. Düğüm derinliğini her çağrıda artırmayı unutmayın.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395856"
  },
  {
    "question": "Ağaç yapısında iki düğümün en yakın ortak atasını bulmaya çalışıyorum ama sonuçlarım yanlış. Bunun nedeni nedir?",
    "answer": "En yakın ortak ata bulma algoritmanız büyük ihtimalle iki düğüm üzerinde yeterince derinlemesine gezmiyor veya bu düğümlere ulaşmak için doğru yolları takip etmiyor olabilir. Bunun için, her iki düğümün ebeveynlerini takip ederek bir yol oluşturmaya çalışmalısınız. İki düğüm aynı yolda buluşana kadar ebeveynleri takip edin ve bu noktada durun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395896"
  },
  {
    "question": "Ağacımı serbest bırakmaya çalıştım ama bellekte hafıza sızıntısı yaşıyorum. Hata nerede olabilir?",
    "answer": "Bellek sızıntısı genellikle düğümleri serbest bırakma işlemini yapmamaktan veya ağaç yapısını tam olarak gezmeden bazı düğümleri atlamaktan kaynaklanır. Her düğümü serbest bırakmadan önce, tüm alt düğümleri ziyaret ettiğinizden ve belleği doğru bir şekilde serbest bıraktığınızdan emin olun. Recursive bir serbest bırakma fonksiyonu yazarak bu işlemi gerçekleştirebilir ve her düğümü ziyaret ettiğinizden emin olabilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395931"
  },
  {
    "question": "Ağaç veri yapısına ekleme işlemi yaparken bazı düğümler kayboluyor gibi görünüyor. Hatanın kaynağı nedir?",
    "answer": "Ekleme işlemi sırasında, yeni düğümü eklerken mevcut düğüm bağlantılarını doğru bir şekilde güncellemiyor olabilirsiniz. Özellikle, yeni düğümü eklerken doğru ebeveyn düğümünü bulmuyor veya bağlantıları oluştururken yanlış referanslar kullanıyorsanız bu tür sorunlar yaşanabilir. Ekleme işleminizi gözden geçirerek her düğümün doğru bir şekilde işaretlendiğinden ve bağlantıların doğru kurulduğundan emin olun.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395960"
  },
  {
    "question": "İkili arama ağacında arama işlemi yaparken beklenmeyen sonuçlar alıyorum. Bu durumu nasıl düzeltebilirim?",
    "answer": "İkili arama ağaçlarında arama işlemi, verilerin sıralı bir şekilde yerleştirildiği varsayımına dayanır. Eğer ağaçta veriler yanlış yerleştirilmişse veya ağaç dengede değilse, arama işlemi beklenmeyen sonuçlara yol açabilir. Arama algoritmanızı kontrol edin ve ağaçta her düğümün veri ilişkisinin doğru olduğundan emin olun. Ağaç yapısını yeniden dengelemeyi de düşünebilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:30.395992"
  },
  {
    "question": "Ağaç yapıları nedir ve nerelerde kullanılır?",
    "answer": "Ağaç yapıları, düğümler ve bağlantılar (kenarlar) ile tanımlanan hiyerarşik veri yapılarıdır. Genellikle dosya sistemleri, veritabanları ve oyun geliştirme gibi alanlarda kullanılır. Örneğin, bir dosya sisteminde klasörler ve dosyalar arasındaki hiyerarşiyi temsil etmek için ağaç yapıları kullanılabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.523935"
  },
  {
    "question": "Ağaç yapısında 'düğüm' nedir?",
    "answer": "Ağaç yapısında, düğüm (node) temel veri birimidir. Her düğüm bir değer saklayabilir ve diğer düğümlerle bağlantı kurarak ağaç yapısını oluşturur. Örneğin, bir binary tree'de her düğüm en fazla iki çocuk (left ve right) düğümüne sahip olabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.523971"
  },
  {
    "question": "Binary tree nedir?",
    "answer": "Binary tree, her düğümün en fazla iki çocuğa sahip olduğu bir ağaç yapısıdır. Bu yapı, verileri düzenli bir şekilde depolamak ve hızlı erişim sağlamak için kullanılır. Örneğin, bir binary search tree (BST) belirli bir sıralamaya göre düğümleri yerleştirir, böylece arama işlemleri daha hızlı gerçekleşir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.523989"
  },
  {
    "question": "Ağaçta düğümleri nasıl ekleriz?",
    "answer": "Ağaç yapısına düğüm eklemek için öncelikle eklenecek değerin hangi düğüm ile karşılaştırılacağına karar vermek gerekir. Örnek olarak, bir binary search tree'de, eklenecek değer mevcut düğümün değerine göre sol veya sağ alt ağaçta yer almalıdır. Eğer sol alt ağaç boşsa, yeni düğüm buraya eklenir. Eğer doluysa, bu işlem alt düğüme devam eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524005"
  },
  {
    "question": "Ağaç yapısında düğüm silmek nasıl yapılır?",
    "answer": "Düğüm silme işlemi, silinecek düğümün çocuk sayısına bağlı olarak değişir. Hiç çocuğu olmayan bir düğüm direkt olarak silinir, bir çocuğu olan bir düğüm mevcut çocuğuyla değiştirilir, iki çocuğu olan bir düğüm ise genellikle in-order successor (sırasıyla sonraki düğüm) ile değiştirilir. Bu işlem ağaç yapısının bütünlüğünü korur.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524023"
  },
  {
    "question": "Ağaç yapısında gezinme (traversal) nedir?",
    "answer": "Ağaçta gezinme, düğümleri belirli bir sıraya göre ziyaret etme işlemidir. Üç ana gezinme yöntemi vardır: Pre-order (öncelikli), In-order (sıralı) ve Post-order (sonradan). Örneğin, bir binary tree'de in-order gezinme, soldan sağa doğru sıralı bir şekilde düğümleri ziyaret eder ve sıralı bir çıktı verir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524042"
  },
  {
    "question": "Ağaç yapılarında denge (balance) nedir?",
    "answer": "Ağaç yapılarında denge, ağacın yüksekliğini minimize edip düğümlerin daha eşit dağılmasını sağlamaktır. Dengesiz bir ağaç, arama işlemlerini yavaşlatır. AVL ağaçları ve Red-Black ağaçları gibi dengeli ağaçlar, bu dengeyi sağlamak için çeşitli kurallar ve rotasyonlar kullanır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524060"
  },
  {
    "question": "Ağaç yapısının derinliği nedir?",
    "answer": "Ağaç yapısının derinliği, kök düğümden belirli bir düğüme kadar olan düğüm sayısını ifade eder. Örneğin, bir ağaçta kök düğümün derinliği 0'dır, onun çocuklarının derinliği 1, torunlarının derinliği ise 2'dir. Ağaç derinliği, ağaçtaki en derin düğüm ile kök arasında olan mesafeyi gösterir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524076"
  },
  {
    "question": "Ağaç yapısında yaprak (leaf) düğüm nedir?",
    "answer": "Yaprak düğüm, herhangi bir çocuğa sahip olmayan düğümlerdir. Yani, ağaç yapısının en alt seviyesinde yer alırlar. Örneğin, bir binary tree'de yaprak düğümler, diğer düğümlerin altında yer alan ve başka düğümlere sahip olmayan son düğümlerdir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524095"
  },
  {
    "question": "Ağaç yapılarında dışarıdan bir kütüphane kullanarak nasıl ağaç oluşturabilirim?",
    "answer": "Örneğin, C dilinde bir ağaç yapısı oluşturmak için 'glib' kütüphanesini kullanabilirsiniz. Kütüphane, ağaç yapıları ile ilgili birçok işlev sunar. İlk olarak, kütüphaneyi programınıza dahil etmeli ve daha sonra `g_tree_new()` fonksiyonu ile yeni bir ağaç oluşturmalısınız.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524120"
  },
  {
    "question": "Ağaç yapılarında arama işlemi nasıl gerçekleştirilir?",
    "answer": "Ağaç yapısında arama işlemi, genellikle recursive (özyinelemeli) bir yöntemle yapılır. Örneğin, bir binary search tree'de arama işlemi, aranan değerin kök düğümden başlayarak sol veya sağ alt ağaçta olup olmadığını kontrol ederek devam eder. Her adımda, mevcut düğümün değeri ile karşılaştırarak arama işlemi gerçekleştirilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:20:57.524139"
  },
  {
    "question": "Ağaç veri yapıları nedir ve neden kullanılır?",
    "answer": "Ağaç veri yapıları, hiyerarşik bir düzenleme ile verilerin saklanmasını sağlayan bir yapıdır. Her ağaç, bir kök düğümden (root) başlar ve ona bağlı olan düğümler (children) ile genişler. Kullanım alanları arasında dosya sistemleri, veritabanları ve yapısal veri organizasyonları bulunur. Ağaçlar, verileri hiyerarşik olarak düzenlemenin yanı sıra, arama ve sıralama işlemlerini optimize etmek için de etkilidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420763"
  },
  {
    "question": "İkili ağaç (binary tree) nedir, nasıl çalışır?",
    "answer": "İkili ağaç, her düğümün en fazla iki çocuğa sahip olduğu ağaç yapısıdır. Düğümler genellikle 'sol' ve 'sağ' çocuklar olarak adlandırılır. İkili ağaçlarda arama, ekleme ve silme işlemleri genellikle O(log n) zaman karmaşıklığına sahiptir. Uygulama senaryoları arasında ifade ağaçları, arama ağaçları ve ağaç tabanlı veri yapıları bulunur.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420804"
  },
  {
    "question": "Ağaçları dolaşmanın en yaygın yöntemleri nelerdir?",
    "answer": "Ağaçları dolaşmanın en yaygın yöntemleri derinlik öncelikli (DFS) ve genişlik öncelikli (BFS) arama yöntemleridir. DFS, bir dalı tamamen gezip sonra diğer dallara geçerken, BFS, her seferinde bir seviyeyi ziyaret eder. Bu yöntemler, özellikle veri yapıları üzerinde işlem yaparken (arama, ekleme, silme) kullanılır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420825"
  },
  {
    "question": "Ağaç yapılarında düğüm silme işlemi nasıl gerçekleştirilir?",
    "answer": "Ağaç yapısında düğüm silme işlemi, silinmek istenen düğümün durumuna göre üç farklı şekilde yapılır: 1) Düğüm yapraksa (çocuğu yoksa), doğrudan silinir. 2) Düğüm bir çocuğa sahipse, çocuğun doğrudan üst düğümü ile değiştirilir. 3) Düğüm iki çocuğa sahipse, genellikle sağ alt ağaçtaki en küçük veya sol alt ağaçtaki en büyük düğüm ile değiştirilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420865"
  },
  {
    "question": "BFS (Genişlik Öncelikli Arama) algoritması nasıl uygulanır?",
    "answer": "BFS algoritması, bir kuyruk (queue) kullanarak ağaçlar üzerinde çalışır. Başlangıçta kök düğüm kuyruğa eklenir. Kuyruktan bir düğüm çıkarılır, işlenir ve ardından o düğümün çocukları kuyruğa eklenir. Bu işlem, kuyruk boşalana kadar devam eder. BFS, düzey düzey gezi yaparak ağaç yapısındaki tüm düğümleri ziyaret eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420893"
  },
  {
    "question": "Ağaç veri yapısında derinlik ve yükseklik kavramları arasındaki fark nedir?",
    "answer": "Ağaçta 'derinlik', bir düğümün kök düğümüne olan uzaklığını ifade eder. Yani, kökten düğüme ulaşmak için geçilmesi gereken kenar sayısıdır. 'Yükseklik' ise, bir düğümden başlayarak ulaşılabilen en uzun yaprak yolunun uzunluğudur. Yükseklik, yaprağın derinliği ile ters orantılıdır; yapraklar genellikle yükseklik 0 kabul edilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420922"
  },
  {
    "question": "İkili arama ağacı (binary search tree) nasıl çalışır?",
    "answer": "İkili arama ağacı, sol alt ağacındaki tüm değerlerin, düğüm değerinden küçük; sağ alt ağacındaki tüm değerlerin ise büyük olacak şekilde düzenlenmiş bir ikili ağaçtır. Bu yapı sayesinde, arama, ekleme ve silme işlemleri O(log n) zaman karmaşıklığı ile gerçekleştirilebilir. Bu özellik, ağaçtaki verilerin sıralı bir şekilde düzenlenmesine olanak tanır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420952"
  },
  {
    "question": "Ağaç yapısındaki düğümlerin veri alanlarını nasıl temsil edebilirim?",
    "answer": "Ağaç yapısındaki düğümlerin veri alanlarını temsil etmek için genellikle bir yapı (struct) tanımlanır. Bu yapı, her düğüm için veri ve iki çocuk düğüm için işaretçi (pointer) içerir. Örneğin:",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420975"
  },
  {
    "question": "Ağaç yapıları ile ilgili sık karşılaşılan problemler nelerdir?",
    "answer": "Ağaç yapıları ile ilgili sık karşılaşılan problemler arasında düğüm ekleme, düğüm silme, ağaç dolaşımı, ağaç yüksekliğini hesaplama ve belirli bir değerin varlığını kontrol etme yer alır. Bu problemler, ağaç yapılarının temel özelliklerini anlamak ve uygulamak için önemlidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.420997"
  },
  {
    "question": "Ağacın simetrik dolaşımı (in-order traversal) nasıl yapılır?",
    "answer": "Simetrik dolaşım, her düğümün sol alt ağacını, ardından kendisini ve son olarak sağ alt ağacını ziyaret eder. Bu yöntem, ikili arama ağaçlarını sıralamak için sıklıkla kullanılır. Örneğin, bir ikili arama ağacında simetrik dolaşım yaparsanız, ağaçtaki tüm değerleri sıralı olarak elde edersiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:24.421021"
  },
  {
    "question": "Ağaç yapılarının temel özellikleri nelerdir ve neden veri yapıları arasında önemlidirler?",
    "answer": "Ağaç yapıları, düğümlerden ve her düğümün sıfır veya daha fazla alt düğümden oluşan hiyerarşik bir veri yapısıdır. Temel özellikleri arasında kök düğüm, yaprak düğümler ve alt düğümler arasındaki ilişki bulunur. Ağaçlar, verilerin hiyerarşik olarak düzenlenmesini sağlar, bu da arama, ekleme ve silme işlemlerinin daha verimli yapılmasına olanak tanır. Özellikle büyük veri setlerinde, ağaçlar arama süreçlerini O(log n) karmaşıklığı ile gerçekleştirebilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647602"
  },
  {
    "question": "İkili ağaç (Binary Tree) nedir ve ne gibi durumlarda kullanılır?",
    "answer": "İkili ağaç, her düğümün en fazla iki alt düğüme sahip olduğu bir ağaçtır. İkili ağaçlar, sıralı verilerin depolanması ve bu verilere hızlı erişim sağlamak için yaygın olarak kullanılır. Örneğin, bir ikili arama ağacı (Binary Search Tree - BST) oluşturduğunuzda, verilerin sıralı bir şekilde depolanmasını ve arama işlemlerinin hızlı bir şekilde yapılmasını sağlarsınız. Bu yapılar, veritabanı indeksleme ve dosya sistemleri gibi uygulamalarda kullanılır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647667"
  },
  {
    "question": "Ağacın derinliği ve yüksekliği arasındaki fark nedir?",
    "answer": "Ağacın derinliği, bir düğümün kök düğümden ne kadar uzakta olduğunu ifade ederken, ağaç yüksekliği, kök düğümden en derin yaprak düğümüne kadar olan en uzun yolu temsil eder. Yükseklik, tüm ağacın genel özelliklerini belirler ve ağacın dengesizliğini değerlendirmede önemli bir faktördür. Örneğin, bir ağacın yüksekliği O(n) olursa, bu ağaç dengeli değildir ve işlemler yavaşlayabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647704"
  },
  {
    "question": "Ağaç yapısında düğümleri sırayla ziyaret etmenin farklı yolları nelerdir?",
    "answer": "Ağaç yapısında düğümleri ziyaret etmenin başlıca yöntemleri öncelikli (pre-order), sıralı (in-order) ve sonralı (post-order) gezintidir. Öncelikli gezinti, önce kök düğüm, sonra sol alt ağaç ve en son sağ alt ağaç şeklinde yapılır. Sıralı gezintide önce sol alt ağaç, sonra kök ve sağ alt ağaç ziyaret edilir. Sonralı gezintide ise önce sol alt ağaç, sağ alt ağaç ve en son kök düğüm ziyaret edilir. Her bir gezinti yöntemi, farklı uygulama senaryoları için faydalıdır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647746"
  },
  {
    "question": "Dengeli ağaç (Balanced Tree) nedir ve neden önemlidir?",
    "answer": "Dengeli ağaç, her alt ağacın yükseklik farkının en fazla 1 olduğu bir ağaçtır. Bu tür ağaçlar, arama, ekleme ve silme işlemlerinin O(log n) karmaşıklığı ile gerçekleştirilmesini sağlar. Örneğin, AVL ağaçları ve Kırmızı-Siyah ağaçlar, dengesiz ağaçlardan daha hızlı işlemler sunarak performansı artırır. Veri tabanlarında, dengeli ağaçlar, veri erişim sürelerini azaltarak sistemin genel verimliliğini artırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647785"
  },
  {
    "question": "Hangi durumlarda bir Trie veri yapısını kullanmalısınız?",
    "answer": "Trie, karakter dizilerini depolamak için kullanılan bir ağaç yapısıdır ve kelime arama, tamamlama ve önek arama gibi işlemlerde yüksek verimlilik sağlar. Örneğin, bir arama motorunda veya otomatik tamamlama sistemlerinde, kullanıcıların girdiği kelimelerin hızlı bir şekilde bulunması durumunda Trie kullanmak oldukça faydalıdır. Trie yapısı, kelimelerin ortak prefix'lerini paylaşarak bellek kullanımını optimize eder ve arama sürelerini kısaltır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647822"
  },
  {
    "question": "Ağaç yapıları ile grafik yapıları arasındaki temel farklar nelerdir?",
    "answer": "Ağaç yapıları, hiyerarşik bir yapıdadır ve döngü içermezken, grafik yapıları düğümler arasında döngüler içerebilir ve daha karmaşık ilişkileri temsil eder. Ağaçlarda her düğümün yalnızca bir ebeveyni varken, grafiklerde bir düğümün birden fazla ebeveyni olabilir. Ağaçlar genellikle verilerin sıralı bir biçimde tutulması için kullanılırken, grafikler daha karmaşık ilişkiler ve bağlantılar için idealdir. Örneğin, sosyal ağlar ve yol haritaları grafik yapılarıdır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647872"
  },
  {
    "question": "Ağacın en küçük ortak üst düğümünü (Lowest Common Ancestor - LCA) nasıl bulursunuz?",
    "answer": "Bir ağacın iki düğümünün en küçük ortak üst düğümünü bulmak için, her iki düğümün kök düğümden itibaren karşılaştırılması gerekir. İlk olarak, kök düğüm ile iki düğüm arasındaki yolları buluruz. Daha sonra bu yolları karşılaştırarak ilk farklı noktayı buluruz. Bu nokta, iki düğümün LCA'sıdır. Bu işlem, genellikle O(n) karmaşıklığındadır ancak dengeli ağaçlarda O(log n) karmaşıklığına kadar düşürülebilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647923"
  },
  {
    "question": "Ağaç yapılarında döngüsel referansları nasıl önlersiniz?",
    "answer": "Ağaç yapılarında döngüsel referanslar, genellikle yanlış tasarım veya kod hatalarından kaynaklanır. Bu tür problemleri önlemek için, düğümlerin ebeveynlerini izlemek ve her düğümün yalnızca bir kenar ile bağlantılı olduğundan emin olmak gerekir. Ayrıca, ağacı oluştururken her düğümün benzersiz bir kimliğe sahip olduğundan emin olmak, döngülerin oluşmasını önler. Örneğin, bir ağaç oluşturma fonksiyonu, her yeni düğüm eklenmeden önce mevcut düğümlerde döngü kontrolü yapmalıdır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647958"
  },
  {
    "question": "Ağaç yapısında düğüm silme işlemi nasıl gerçekleştirilir?",
    "answer": "Ağaç yapısında bir düğüm silme işlemi, silinmek istenen düğümün durumuna göre farklılık gösterir. Üç temel durum vardır: Düğüm bir yapraksa, basitçe silinir; bir çocuğu varsa, silinen düğümün yerini çocuğuyla değiştirebiliriz; eğer iki çocuğu varsa, genellikle silinecek düğümün sağ alt ağacındaki en küçük düğüm (veya sol alt ağacındaki en büyük düğüm) ile yer değişimi yapılarak silme işlemi gerçekleştirilir. Bu işlemin karmaşıklığı genellikle O(h), burada h ağacın yüksekliğidir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:21:52.647994"
  },
  {
    "question": "Temel bir ikili ağaç yapısını nasıl oluşturabilirim?",
    "answer": "Öncelikle bir düğüm yapısı tanımlamalıyız. Daha sonra bu yapıyı kullanarak bir ağaç oluşturabiliriz. İşte basit bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604332"
  },
  {
    "question": "İkili ağaçta düğüm eklemek için bir fonksiyon nasıl yazabilirim?",
    "answer": "Düğüm eklemek için, öncelikle mevcut ağacın kökünü kontrol ederiz. Eğer kök boşsa yeni düğümü kök olarak atarız. Aksi takdirde, veriyi eklemek için uygun yeri bulmalıyız. İşte bir örnek:\n\n```c\nvoid insert(struct Node** node, int data) {\n    if (*node == NULL) {\n        *node = createNode(data);\n        return;\n    }\n    if (data < (*node)->data) {\n        insert(&((*node)->left), data);\n    } else {\n        insert(&((*node)->right), data);\n    }\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604393"
  },
  {
    "question": "İkili ağaçta düğüm aramak için bir fonksiyon nasıl yazabilirim?",
    "answer": "Düğüm aramak için, kök düğüm ile başlayarak verilere göre sola veya sağa giderek arama yapmamız gerekir. İşte örnek bir fonksiyon:\n\n```c\nstruct Node* search(struct Node* root, int data) {\n    if (root == NULL || root->data == data) {\n        return root;\n    }\n    if (data < root->data) {\n        return search(root->left, data);\n    }\n    return search(root->right, data);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604434"
  },
  {
    "question": "İkili ağacın ön sıralama (pre-order) traversali nasıl yapılır?",
    "answer": "Ön sıralama için, önce kök düğümü ziyaret ederiz, sonra sol alt ağacı, ardından sağ alt ağacı. İşte implementasyonu:\n\n```c\nvoid preOrderTraversal(struct Node* node) {\n    if (node == NULL) return;\n    printf(\"%d \", node->data);\n    preOrderTraversal(node->left);\n    preOrderTraversal(node->right);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604478"
  },
  {
    "question": "İkili ağacın sıralı (in-order) traversali nasıl yapılır?",
    "answer": "Sıralı traversalde sol alt ağaç, kök ve sağ alt ağaç sırasını takip ederiz. Aşağıdaki gibi bir implementation:\n\n```c\nvoid inOrderTraversal(struct Node* node) {\n    if (node == NULL) return;\n    inOrderTraversal(node->left);\n    printf(\"%d \", node->data);\n    inOrderTraversal(node->right);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604534"
  },
  {
    "question": "İkili ağacın son sıralama (post-order) traversali nasıl yapılır?",
    "answer": "Son sıralama, önce sol alt ağaç, sonra sağ alt ağaç ve en son kök düğüm sırasını takip eder. İşte örnek:\n\n```c\nvoid postOrderTraversal(struct Node* node) {\n    if (node == NULL) return;\n    postOrderTraversal(node->left);\n    postOrderTraversal(node->right);\n    printf(\"%d \", node->data);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604577"
  },
  {
    "question": "Bir ikili ağacın yüksekliğini nasıl hesaplayabilirim?",
    "answer": "Bir ağacın yüksekliğini hesaplamak için, her bir düğüm için sol ve sağ alt ağaçların yüksekliklerini karşılaştırıp maksimum olanı bulmalıyız. İşte bir örnek:\n\n```c\nint height(struct Node* node) {\n    if (node == NULL) return -1;\n    int leftHeight = height(node->left);\n    int rightHeight = height(node->right);\n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604610"
  },
  {
    "question": "İkili ağacı nasıl temizleyebilirim?",
    "answer": "Ağacı temizlemek için, her bir düğümü ziyaret edip bellekten serbest bırakmalıyız. İşte bir örnek:\n\n```c\nvoid freeTree(struct Node* node) {\n    if (node == NULL) return;\n    freeTree(node->left);\n    freeTree(node->right);\n    free(node);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604647"
  },
  {
    "question": "İkili arama ağacında belirli bir değeri silmek için bir fonksiyon nasıl yazabilirim?",
    "answer": "Düğüm silmek için önce düğümün yerini bulmalı, ardından uygun duruma göre düğümü silmeli ve yerini doldurmalıyız. İşte bir örnek:\n\n```c\nstruct Node* deleteNode(struct Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data) {\n        root->left = deleteNode(root->left, data);\n    } else if (data > root->data) {\n        root->right = deleteNode(root->right, data);\n    } else {\n        if (root->left == NULL) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604696"
  },
  {
    "question": "İkili ağaçta düğüm sayısını nasıl hesaplayabilirim?",
    "answer": "Düğüm sayısını hesaplamak için, her bir düğümü ziyaret ederek saymalıyız. İşte bir örnek:\n\n```c\nint countNodes(struct Node* node) {\n    if (node == NULL) return 0;\n    return 1 + countNodes(node->left) + countNodes(node->right);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:18.604730"
  },
  {
    "question": "Bir ikili arama ağacı (BST) oluşturmak için C dilinde bir yapı nasıl tasarlanır ve temel ekleme işlemi nasıl yapılır?",
    "answer": "İkili arama ağacı oluşturmak için öncelikle bir düğüm yapısı tanımlamalıyız. Her düğüm, bir tamsayı değeri ve sol/sağ alt düğümleri için işaretçiler içermelidir. Ağaçta yeni bir değer eklemek için, değeri karşılaştırarak uygun konuma yerleştiririz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* insert(struct Node* root, int data) {\n    if (root == NULL) return createNode(data);\n    if (data < root->data)\n        root->left = insert(root->left, data);\n    else\n        root->right = insert(root->right, data);\n    return root;\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 70);\n    return 0;\n}\n```\nBu kod, bir BST'nin nasıl oluşturulup değer ekleyeceğini gösterir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125318"
  },
  {
    "question": "Bir ikili ağacın (binary tree) derinliğini (yüksekliğini) hesaplamak için C dilinde bir fonksiyon nasıl yazılır?",
    "answer": "Bir ağacın derinliği, kök düğümden en derin yaprak düğüme kadar olan maksimum derinliktir. Rekürsif bir fonksiyon ile her alt ağacın derinliğini hesaplayarak en yüksek değeri döndürmeliyiz. Örnek kod:\n\n```c\nint height(struct Node* node) {\n    if (node == NULL) return 0;\n    int leftHeight = height(node->left);\n    int rightHeight = height(node->right);\n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}\n```\nBu kod, verilen bir düğüm için derinliği hesaplar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125396"
  },
  {
    "question": "Bir ikili ağacın sıralı (inorder) dolaşımını C dilinde nasıl gerçekleştiririz?",
    "answer": "Sıralı dolaşım, sol alt ağacı, kök düğümü ve ardından sağ alt ağacı ziyaret eder. Rekürsif bir fonksiyon ile bu işlemi gerçekleştirebiliriz. Örnek kod:\n\n```c\nvoid inorderTraversal(struct Node* root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->data);\n        inorderTraversal(root->right);\n    }\n}\n```\nBu fonksiyon, verilen bir ağacın elemanlarını sıralı olarak yazdırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125443"
  },
  {
    "question": "Bir ikili ağacı düzleştirip (flatten) bir bağlı listeye dönüştürmek için C dilinde bir fonksiyon yazın.",
    "answer": "Ağacı düzleştirip bağlı listeye dönüştürmek, her düğümü bir sonraki düğüme bağlamak anlamına gelir. Bunun için in-order traversalle düğümlerin değerlerini sıralı bir şekilde toplarız ve her düğümün 'next' işaretçisini güncelleyerek bağlı liste oluştururuz. Örnek kod:\n\n```c\nstruct ListNode {\n    int data;\n    struct ListNode* next;\n};\n\nstruct ListNode* flatten(struct Node* root) {\n    if (root == NULL) return NULL;\n    struct ListNode* list = (struct ListNode*)malloc(sizeof(struct ListNode));\n    list->data = root->data;\n    list->next = flatten(root->right);\n    return list;\n}\n```\nBu kod, ikili ağacı düzleştirerek bir bağlı liste oluşturur.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125500"
  },
  {
    "question": "Bir ikili ağacı, seviyelerine göre (level order) nasıl dolaşırız?",
    "answer": "Seviye sıralı dolaşım, her seviyeyi soldan sağa ziyaret eder. Bir kuyruk yapısı kullanarak her bir düğümü sıraya alıp ziyaret edebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Queue {\n    struct Node** arr;\n    int front, rear;\n};\n\nvoid enqueue(struct Queue* q, struct Node* node) {\n    q->arr[q->rear++] = node;\n}\n\nstruct Node* dequeue(struct Queue* q) {\n    return q->arr[q->front++];\n}\n\nvoid levelOrder(struct Node* root) {\n    if (root == NULL) return;\n    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));\n    q->arr = (struct Node**)malloc(100 * sizeof(struct Node*));\n    q->front = 0;\n    q->rear = 0;\n    enqueue(q, root);\n    while (q->front < q->rear) {\n        struct Node* node = dequeue(q);\n        printf(\"%d \", node->data);\n        if (node->left) enqueue(q, node->left);\n        if (node->right) enqueue(q, node->right);\n    }\n}\n```\nBu kod, bir ikili ağacı seviyelerine göre dolaşarak elemanları yazdırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125569"
  },
  {
    "question": "Bir ikili ağaçta belirli bir değeri aramak için C dilinde bir fonksiyon yazın.",
    "answer": "Ağaçta belirli bir değeri bulmak için, kök düğümden başlayarak, değeri karşılaştırarak sol veya sağ alt ağaca geçiş yapmalıyız. Örnek kod:\n\n```c\nint search(struct Node* root, int key) {\n    if (root == NULL) return 0;\n    if (root->data == key) return 1;\n    if (key < root->data) return search(root->left, key);\n    return search(root->right, key);\n}\n```\nBu fonksiyon, belirtilen değerin ağaçta olup olmadığını kontrol eder.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125614"
  },
  {
    "question": "Bir ikili ağacı ayna (mirror) yapmak için C dilinde bir fonksiyon yazın.",
    "answer": "Bir ağacı aynalamak, her düğümün sol ve sağ alt düğümlerinin yerlerini değiştirmek anlamına gelir. Rekürsif bir yaklaşım ile bu işlemi gerçekleştirebiliriz. Örnek kod:\n\n```c\nvoid mirror(struct Node* node) {\n    if (node == NULL) return;\n    struct Node* temp = node->left;\n    node->left = node->right;\n    node->right = temp;\n    mirror(node->left);\n    mirror(node->right);\n}\n```\nBu fonksiyon, verilen bir ağacı aynalar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125659"
  },
  {
    "question": "Bir ikili arama ağacında bir değeri silmek için C dilinde bir fonksiyon yazın.",
    "answer": "Bir değeri silmek için üç durumla karşılaşırız: Değer bir yaprağa, bir alt düğümü olan bir düğüme veya iki alt düğümü olan bir düğüme ait olabilir. Her duruma uygun şekilde düğüm silme işlemi yapılmalıdır. Örnek kod:\n\n```c\nstruct Node* deleteNode(struct Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->data) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->data) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == NULL) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n```\nBu kod, belirtilen değeri silmek için gerekli işlemleri yapar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125703"
  },
  {
    "question": "Bir ikili ağacın tüm düğümlerinin toplamını hesaplamak için C dilinde bir fonksiyon yazın.",
    "answer": "Ağacın tüm düğümlerinin toplamını bulmak için her düğümün değerini toplamak amacıyla rekürsif bir fonksiyon kullanabiliriz. Örnek kod:\n\n```c\nint sum(struct Node* node) {\n    if (node == NULL) return 0;\n    return node->data + sum(node->left) + sum(node->right);\n}\n```\nBu fonksiyon, verilen bir ağacın tüm düğümlerinin toplamını döndürür.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:22:54.125751"
  },
  {
    "question": "İkili ağaç yapısında düğüm ekleme işlemini nasıl gerçekleştirebiliriz?",
    "answer": "İkili ağaç yapısında düğüm eklemek için, öncelikle eklemek istediğimiz değeri karşılaştırarak uygun bir yere yerleştirmemiz gerekiyor. Ağaçta gezinirken, eğer eklemek istediğimiz değer, mevcut düğümün değerinden küçükse sol alt düğüme, büyükse sağ alt düğüme geçiyoruz. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return createNode(data);\n    if (data < node->data) {\n        node->left = insert(node->left, data);\n    } else {\n        node->right = insert(node->right, data);\n    }\n    return node;\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = insert(root, 15);\n    insert(root, 10);\n    insert(root, 20);\n    return 0;\n}\n```\nBu kodda bir ikili ağaç oluşturulmakta ve düğümler eklenmektedir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300730"
  },
  {
    "question": "İkili arama ağacında bir değeri nasıl bulabiliriz?",
    "answer": "İkili arama ağaçlarında bir değeri bulmak için, ağaçta gezinirken her düğümde mevcut değeri kontrol ederiz. Eğer aradığımız değer mevcut düğümden küçükse sol alt düğüme, büyükse sağ alt düğüme geçeriz. Bulduğumuzda ya da ağaçta gezmeyi tamamladığımızda, değeri bulup bulamadığımızı belirtiriz. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nint search(struct Node* root, int key) {\n    if (root == NULL) return 0;\n    if (root->data == key) return 1;\n    if (key < root->data) return search(root->left, key);\n    return search(root->right, key);\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = createNode(15);\n    root->left = createNode(10);\n    root->right = createNode(20);\n    printf(\"%d\", search(root, 10)); // 1 döner\n    return 0;\n}\n```\nBu kodda belirli bir değerin ikili ağaçta bulunup bulunmadığını kontrol edebiliriz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300767"
  },
  {
    "question": "Bir ikili ağacın yüksekliğini nasıl hesaplayabiliriz?",
    "answer": "Bir ikili ağacın yüksekliğini hesaplamak için, her düğüm için sol ve sağ alt ağaçların yüksekliklerini bulup bunları karşılaştırmamız gerekiyor. Ağaçların yüksekliği, her düğümün yüksekliğinin 1 fazlasıdır. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nint height(struct Node* node) {\n    if (node == NULL) return 0;\n    int leftHeight = height(node->left);\n    int rightHeight = height(node->right);\n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    root->left->left = createNode(4);\n    printf(\"Yükseklik: %d\", height(root)); // 3 döner\n    return 0;\n}\n```\nBu kod, ikili ağacın yüksekliğini hesaplamaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300787"
  },
  {
    "question": "İkili arama ağacında bir değeri silme işlemini nasıl yaparız?",
    "answer": "İkili arama ağaçlarında bir değeri silmek için üç durum vardır: Silinecek düğüm yaprağı ise doğrudan silinir, bir çocuğu varsa o çocuğu alır ve bağlantıyı keseriz, iki çocuğu varsa en küçük değeri (inorder successor) bularak onu sileriz. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != NULL) current = current->left;\n    return current;\n}\n\nstruct Node* deleteNode(struct Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->data) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->data) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == NULL) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\nint main() {\n    struct Node* root = NULL;\n    root = createNode(15);\n    root->left = createNode(10);\n    root->right = createNode(20);\n    root = deleteNode(root, 10);\n    return 0;\n}\n```\nBu kodda bir ikili arama ağacında belirli bir değeri silmek için gerekli işlemler yapılmaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300811"
  },
  {
    "question": "Bir ikili ağaçta preorder traversal (öncelikli gezinti) nasıl yapılır?",
    "answer": "Preorder traversal'da, önce mevcut düğümün değeri yazdırılır, ardından sol alt düğüm, en son sağ alt düğüm gezilir. Bu işlem için rekürsif bir fonksiyon kullanabiliriz. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nvoid preorder(struct Node* node) {\n    if (node == NULL) return;\n    printf(\"%d \", node->data);\n    preorder(node->left);\n    preorder(node->right);\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    preorder(root); // 1 2 3\n    return 0;\n}\n```\nBu kodda preorder traversal yöntemi ile ağaçtaki düğümler sıralı şekilde yazdırılmaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300836"
  },
  {
    "question": "Bir ikili ağaçta inorder traversal (orta gezinti) nasıl yapılır?",
    "answer": "Inorder traversal'da, önce sol alt düğüm, ardından mevcut düğümün değeri yazdırılır ve en son sağ alt düğüm gezilir. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nvoid inorder(struct Node* node) {\n    if (node == NULL) return;\n    inorder(node->left);\n    printf(\"%d \", node->data);\n    inorder(node->right);\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root); // 2 1 3\n    return 0;\n}\n```\nBu kodda inorder traversal yöntemi ile ağaçtaki düğümler sıralı şekilde yazdırılmaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300865"
  },
  {
    "question": "Bir ikili ağaçta postorder traversal (sonradan gezinti) nasıl yapılır?",
    "answer": "Postorder traversal'da, önce sol alt düğüm, ardından sağ alt düğüm, en son mevcut düğümün değeri yazdırılır. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nvoid postorder(struct Node* node) {\n    if (node == NULL) return;\n    postorder(node->left);\n    postorder(node->right);\n    printf(\"%d \", node->data);\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    postorder(root); // 2 3 1\n    return 0;\n}\n```\nBu kodda postorder traversal yöntemi ile ağaçtaki düğümler ters sıralı şekilde yazdırılmaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300887"
  },
  {
    "question": "İkili ağaçta düğüm sayısını nasıl hesaplayabiliriz?",
    "answer": "Bir ikili ağaçta düğüm sayısını hesaplamak için, her düğümü ziyaret ederek toplam düğüm sayısını artırmamız gerekiyor. İşte bir örnek kod:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nint countNodes(struct Node* node) {\n    if (node == NULL) return 0;\n    return 1 + countNodes(node->left) + countNodes(node->right);\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    printf(\"Düğüm Sayısı: %d\", countNodes(root)); // 3 döner\n    return 0;\n}\n```\nBu kod, ikili ağaçtaki toplam düğüm sayısını hesaplamaktadır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:23:51.300909"
  },
  {
    "question": "Bir ikili arama ağacında belirli bir değeri aramak için en etkili yöntemi nasıl yazarsınız? Kodunuzu optimize ederken neleri göz önünde bulundurmalısınız?",
    "answer": "İkili arama ağacında belirli bir değeri aramak için recursive bir yöntem kullanabiliriz. Ağaç dengesizse, performans düşebilir. Bu nedenle, ağacın dengeli kalmasını sağlamak için AVL veya Red-Black ağaçları gibi dengeli ağaç yapıları kullanmak faydalı olabilir. İşte basit bir arama fonksiyonu:\n\n```c\ntypedef struct Node {\n    int value;\n    struct Node *left, *right;\n} Node;\n\nNode* search(Node* root, int target) {\n    if (root == NULL || root->value == target) {\n        return root;\n    }\n    if (target < root->value) {\n        return search(root->left, target);\n    }\n    return search(root->right, target);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447443"
  },
  {
    "question": "Bir ikili ağaçta tüm düğümlerin toplamını hesaplayan bir fonksiyon yazın. Bu fonksiyonu optimize etmek için neleri dikkate almalısınız?",
    "answer": "Ağaçtaki tüm düğümlerin toplamını hesaplamak için bir DFS (derinlik öncelikli arama) yaklaşımı kullanabiliriz. Bu işlemi yaparken, gereksiz hesaplamalardan kaçınmalıyız. Ayrıca, ağaç dengesizse, derinlik çok fazla olabilir, bu da stack overflow'a neden olabilir. Iteratif bir yaklaşım kullanmak bu durumu önleyebilir:\n\n```c\nint sum(Node* root) {\n    if (root == NULL) return 0;\n    return root->value + sum(root->left) + sum(root->right);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447500"
  },
  {
    "question": "Bir ikili ağacın simetrik olup olmadığını kontrol eden bir fonksiyon yazın. Kodunuzu nasıl optimize edersiniz?",
    "answer": "Bir ağacın simetrik olup olmadığını kontrol etmek için, ağacın sol ve sağ alt ağaçlarını karşılaştırabiliriz. Her iki alt ağaçın simetrik olup olmadığını kontrol eden bir yardımcı fonksiyon yazmak yararlı olacaktır. BFS (genişlik öncelikli arama) ile de çözülebilir. İşte bir örnek:\n\n```c\nint isMirror(Node* left, Node* right) {\n    if (left == NULL && right == NULL) return 1;\n    if (left == NULL || right == NULL) return 0;\n    return (left->value == right->value) && \n           isMirror(left->right, right->left) && \n           isMirror(left->left, right->right);\n}\n\nint isSymmetric(Node* root) {\n    return isMirror(root->left, root->right);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447551"
  },
  {
    "question": "Bir ikili ağacın derinliğini hesaplamak için bir fonksiyon yazın. Özellikle büyük ağaçlarda performansı artırmak için ne yapmalısınız?",
    "answer": "Bir ikili ağacın derinliğini hesaplamak için DFS veya BFS yöntemleri kullanılabilir. Derinlik hesaplama işlemi için, her düğümde derinliği bir artırarak ilerleyebiliriz. Ayrıca, aşırı derin ağaçlar için iteratif bir yaklaşım almak stack overflow riskini azaltacaktır:\n\n```c\nint maxDepth(Node* root) {\n    if (root == NULL) return 0;\n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447587"
  },
  {
    "question": "Bir ikili ağacın pre-order ve in-order gezintilerini kullanarak post-order gezintisini elde eden bir yöntem yazın. Kodunuzu optimize etmek için neleri göz önünde bulundurmalısınız?",
    "answer": "Pre-order ve in-order dizilerini kullanarak post-order dizisini elde etmek için, öncelikle kök düğümü bulmalı ve ardından sol ve sağ alt ağaçları ayırmalıyız. Bu işlem O(n^2) karmaşıklığına sahip olabilir, bu nedenle daha verimli bir yaklaşım için hash tabloları kullanarak işlemleri hızlandırabiliriz:\n\n```c\nvoid postOrderFromPreIn(int* pre, int* in, int* post, int inStart, int inEnd, int* preIndex) {\n    if (inStart > inEnd) return;\n\n    int rootValue = pre[*preIndex];\n    (*preIndex)++;\n\n    int inIndex;\n    for (inIndex = inStart; inIndex <= inEnd; inIndex++) {\n        if (in[inIndex] == rootValue) break;\n    }\n\n    postOrderFromPreIn(pre, in, post, inStart, inIndex - 1, preIndex);\n    postOrderFromPreIn(pre, in, post, inIndex + 1, inEnd, preIndex);\n    post[inEnd] = rootValue;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447645"
  },
  {
    "question": "Bir ikili ağacı düz bir diziye dönüştürmek için bir fonksiyon yazın. Dönüşüm sırasında performansı artırmak için neleri düşünebilirsiniz?",
    "answer": "İkili ağacı düz bir diziye dönüştürmek için bir DFS yaklaşımı kullanmak yararlıdır. Diziye eklenecek elemanların sırası önemlidir. Dizi boyutunu önceden bilmek, gereksiz bellek tahsisatını önleyecektir. İşte basit bir örnek:\n\n```c\nvoid flattenTree(Node* root, int* arr, int* index) {\n    if (root == NULL) return;\n    arr[(*index)++] = root->value;\n    flattenTree(root->left, arr, index);\n    flattenTree(root->right, arr, index);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447682"
  },
  {
    "question": "Bir ikili ağaçtaki belirli bir değeri silmek için bir fonksiyon yazın. Bu işlemi yaparken performansı artırmak için önerileriniz nelerdir?",
    "answer": "İkili ağaçtan bir değeri silerken üç durumla karşılaşabiliriz: silinecek düğüm bir yapraksa, bir alt düğümü varsa veya iki alt düğümü varsa. Ağaç dengesizse, AVL ağaçları gibi dengeleme yapıları kullanmak faydalı olabilir. İşte basit bir silme fonksiyonu:\n\n```c\nNode* deleteNode(Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->value) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->value) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->value = temp->value;\n        root->right = deleteNode(root->right, temp->value);\n    }\n    return root;\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447719"
  },
  {
    "question": "Bir ikili ağaçta belirli bir seviyedeki düğümleri toplayan bir fonksiyon yazın. Performansı artırmak için ne gibi değişiklikler yapabilirsiniz?",
    "answer": "Belirli bir seviyedeki düğümleri toplamak için BFS yaklaşımını kullanabiliriz. Ayrıca, her seviyede düğüm sayısını bilmek, işlemi daha verimli hale getirebilir. Böylece her seferinde tüm düğümleri gezmek yerine sadece belirli bir seviyeyi gezebiliriz:\n\n```c\nint sumAtLevel(Node* root, int level) {\n    if (root == NULL) return 0;\n    if (level == 0) return root->value;\n    return sumAtLevel(root->left, level - 1) + sumAtLevel(root->right, level - 1);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447756"
  },
  {
    "question": "Bir ikili ağacın en yüksek derinliğindeki yaprak düğümleri bulmak için bir fonksiyon yazın. Performansı artırmak için hangi yöntemleri önerirsiniz?",
    "answer": "En yüksek derinlikteki yaprak düğümleri bulmak için DFS (derinlik öncelikli arama) kullanabiliriz. Ayrıca, derinliği takip ederek en son seviyedeki yaprakları bir listeye eklemek, performansı artırabilir. Aşağıda bir örnek bulunmaktadır:\n\n```c\nvoid findLeavesAtMaxDepth(Node* root, int depth, int* maxDepth, int* leaves, int* leafIndex) {\n    if (root == NULL) return;\n    if (depth > *maxDepth) {\n        *maxDepth = depth;\n        *leafIndex = 0;\n    }\n    if (depth == *maxDepth) {\n        leaves[(*leafIndex)++] = root->value;\n    }\n    findLeavesAtMaxDepth(root->left, depth + 1, maxDepth, leaves, leafIndex);\n    findLeavesAtMaxDepth(root->right, depth + 1, maxDepth, leaves, leafIndex);\n}\n```",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:25.447793"
  },
  {
    "question": "Ağaç yapısını kullanarak bir binary search tree (BST) oluşturun. Hangi durumlarda AVL veya Red-Black ağaçları tercih edilmelidir?",
    "answer": "Binary Search Tree (BST) iyi bir veri yapısıdır fakat dengesiz hale geldiğinde performansı düşer. AVL veya Red-Black ağaçları, ağaç dengesini koruyarak arama, ekleme ve silme işlemlerinin O(log n) karmaşıklıkta kalmasını sağlar. AVL ağaçları daha sıkı bir denge sağlarken, Red-Black ağaçları daha basit bir dengeleme mantığına sahiptir ve daha hızlı ekleme/silme işlemleri sunar.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425472"
  },
  {
    "question": "Ağaçta belirli bir değerin varlığını kontrol eden bir C fonksiyonu yazarken, hangi durumları göz önünde bulundurmalıyız?",
    "answer": "Ağaçta belirli bir değerin varlığını kontrol eden bir fonksiyon yazarken, ağaç yapısının boş olup olmadığını, hangi düğüme ulaştığımızı ve arama kriterinin hangi dalda olduğunu göz önünde bulundurmalıyız. Ayrıca, kodun zaman karmaşıklığını O(h) (h: ağaç yüksekliği) kadar düşürmek için doğru karşılaştırma işlemlerini kullanmalıyız.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425546"
  },
  {
    "question": "Ağaç yapısında alt ağaçları sayan bir fonksiyon yazınız. Kodunuzu gözden geçirip optimizasyon önerilerinde bulunun.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazılabilir: \n```c\nint countSubtrees(Node* root) {\n    if (root == NULL) return 0;\n    return 1 + countSubtrees(root->left) + countSubtrees(root->right);\n}\n``` \nBu fonksiyon, her alt ağaç için bir sayım yapar. Ancak, bu işlevselliği daha hızlı hale getirmek için düğüm başına bir sayım yaparak her düğüm için mevcut sayıyı saklayabilirsiniz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425590"
  },
  {
    "question": "Ağaç yapısında inorder, preorder ve postorder traversals'ı gerçekleştirmek için en etkili yöntemler nelerdir?",
    "answer": "Traversal işlemleri için recursive yöntemler genellikle daha basit ve okunaklıdır. Ancak, büyük ağaçlar söz konusu olduğunda stack overflow hatası ile karşılaşabilirsiniz. Bu nedenle, iterative yöntemler kullanmak daha sağlıklı olabilir. Örneğin: \nInorder traversals için: \n```c\nvoid inorderTraversal(Node* root) {\n    stack<Node*> s;\n    Node* curr = root;\n    while (curr != NULL || !s.empty()) {\n        while (curr != NULL) {\n            s.push(curr);\n            curr = curr->left;\n        }\n        curr = s.top();\n        s.pop();\n        printf(\"%d \", curr->data);\n        curr = curr->right;\n    }\n}\n``` \nBu yöntem, hem yığın hafızasını kullanarak hem de stack overflow sorununu aşarak performansı artırır.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425630"
  },
  {
    "question": "Ağaç yapısında bir düğüm silme işlemi yaparken karşılaşabileceğiniz zorluklar nelerdir ve bunları nasıl aşarsınız?",
    "answer": "Bir düğüm silme işlemi, üç duruma bağlıdır: silinecek düğüm bir yaprağa sahip ise, bir çocuğa sahip ise veya iki çocuğa sahip ise. Bu durumlarda, doğru şekilde güncellenmesi gereken referanslar ve değerler vardır. İki çocuğa sahip düğümler için en küçük değeri içeren düğümü bulup yer değiştirmek yaygın bir yöntemdir. Bu işlemi yaparken, her durumda ağaç dengesini korumak için ek kontrol mekanizmaları eklemeliyiz.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425661"
  },
  {
    "question": "C dilinde bir n-ary ağaç yapısını nasıl tanımlarsınız ve bir düğüm eklemek için hangi yaklaşımı kullanmalısınız?",
    "answer": "N-ary ağaç yapısı için her düğüm, bir veri alanı ve çocuk düğümlerinin bir listesi içerebilir. Örnek yapı: \n```c\ntypedef struct Node {\n    int data;\n    struct Node** children;\n    int childCount;\n} Node;\n``` \nDüğüm eklerken, yeni düğümü mevcut düğümün çocuklar listesine ekleyebiliriz. Dikkate alınması gereken, çocuk sayısını güncellemektir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425695"
  },
  {
    "question": "Bir ağaçta belirli bir derinlikteki düğümlerin toplamını hesaplayan bir C fonksiyonu yazın. Gözden geçirip optimize edin.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz: \n```c\nint sumAtDepth(Node* root, int depth) {\n    if (root == NULL) return 0;\n    if (depth == 0) return root->data;\n    return sumAtDepth(root->left, depth - 1) + sumAtDepth(root->right, depth - 1);\n}\n``` \nAncak bu fonksiyon O(n) karmaşıklığındadır. İyileştirme için, her düğümün derinliğini hesaplayarak bir kez geçip toplamı saklamak daha etkili olabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425728"
  },
  {
    "question": "Ağaç yapısında döngüleri tespit etmenin etkili bir yöntemi nedir ve C dilinde bunu nasıl uygularsınız?",
    "answer": "Ağaç yapılarında döngüleri tespit etmek için genellikle bir visit seti kullanılır. Her düğüm ziyaret edildiğinde, onu takibe alabiliriz. Eğer tekrar ziyaret etmeye çalışırsak, bir döngü olduğuna dair sonuç çıkarabiliriz. C dilinde bunu şu şekilde uygulayabiliriz: \n```c\nbool hasCycle(Node* root, HashSet* visited) {\n    if (root == NULL) return false;\n    if (hashSetContains(visited, root)) return true;\n    hashSetAdd(visited, root);\n    return hasCycle(root->left, visited) || hasCycle(root->right, visited);\n}\n``` \nBu yöntem, O(n) zaman karmaşıklığına sahiptir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425758"
  },
  {
    "question": "Ağaç yapısında iki düğüm arasındaki en düşük ortak atayı (LCA) bulmak için bir fonksiyon yazınız. Performansını değerlendirin.",
    "answer": "Ayna ağaçta iki düğüm arasındaki LCA'yı bulmak için aşağıdaki gibi bir fonksiyon yazabilirsiniz: \n```c\nNode* findLCA(Node* root, Node* n1, Node* n2) {\n    if (root == NULL) return NULL;\n    if (root == n1 || root == n2) return root;\n    Node* leftLCA = findLCA(root->left, n1, n2);\n    Node* rightLCA = findLCA(root->right, n1, n2);\n    if (leftLCA && rightLCA) return root;\n    return leftLCA != NULL ? leftLCA : rightLCA;\n}\n``` \nBu fonksiyon, O(n) zaman karmaşıklığına sahiptir. Ancak, her düğümde bir kez ziyaret yapılması gerektiğinden, derinlik kontrolü ve kaydedilmiş sonuçlarla daha hızlı hale getirilebilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425794"
  },
  {
    "question": "Bir ağaç yapısında belirli bir yüksekliğe ulaşmak için gereken minimum düğüm sayısını hesaplayan bir C fonksiyonu yazın. Gözden geçirin.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz: \n```c\nint minNodesForHeight(int height) {\n    return pow(2, height) - 1;\n}\n``` \nAncak bu fonksiyon, belirli bir derinliği aşmak için gereken minimum düğüm sayısını verir. Daha fazla optimize etmek için, bu bilgiyi daha önce hesaplayarak saklamayı düşünebilirsiniz. Ayrıca, karmaşıklığı O(1) olacak şekilde kullanılabilir.",
    "category": "data_structures",
    "topic": "trees",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Ağaç yapıları",
    "timestamp": "2025-06-01T16:24:50.425832"
  },
  {
    "question": "Aşağıdaki C kodu, bir tamsayı dizisini sıralamak için kullanılıyor. Ancak 'bubbleSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                // Elemanları yer değiştir\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'bubbleSort' fonksiyonu ile bir dizi elemanlarını sıralar. Dış döngü toplam n-1 kez dönerken, iç döngü her seferinde son kısımları göz ardı ederek elemanları karşılaştırır ve gerektiğinde yer değiştirir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441483"
  },
  {
    "question": "Aşağıdaki kodda 'selectionSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int min_index = i;\n        for (int j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        // En küçük elemanı baştaki ile yer değiştir\n        int temp = arr[min_index];\n        arr[min_index] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'selectionSort' fonksiyonu ile bir dizi elemanlarını sıralar. Dış döngü her döngüde en küçük elemanı bulur ve onu baştaki ile değiştirir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441547"
  },
  {
    "question": "Aşağıdaki C kodunda 'insertionSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        // Yerleştirme işlemi\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    insertionSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'insertionSort' fonksiyonu ile bir dizi elemanlarını sıralar. Her adımda eleman eklenir ve uygun yerinde konumlanır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441575"
  },
  {
    "question": "Aşağıdaki kodda 'quickSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'quickSort' fonksiyonu ile bir dizi elemanlarını sıralar. Pivot eleman seçilir ve diğer elemanlar ile karşılaştırılarak sıralama yapılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441602"
  },
  {
    "question": "Aşağıdaki C kodunda 'merge' ve 'mergeSort' fonksiyonları eksik. Bu fonksiyonları tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; j = 0; k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'mergeSort' fonksiyonu ile bir dizi elemanlarını sıralar. Dizi sürekli ikiye bölünerek sıralanır ve sonrasında birleştirilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441684"
  },
  {
    "question": "Aşağıdaki C kodunun 'heapify' ve 'heapSort' fonksiyonları eksik. Bu fonksiyonları tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nvoid swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) \n        heapify(arr, n, i);\n    for (int i = n - 1; i >= 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    heapSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'heapSort' fonksiyonu ile bir dizi elemanlarını sıralar. Öncelikle dizi bir heap yapısına dönüştürülür ve ardından sıralama işlemi gerçekleştirilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441719"
  },
  {
    "question": "Aşağıdaki C kodunda 'countingSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nvoid countingSort(int arr[], int size) {\n    int output[size];\n    int count[100] = {0}; // 100, elemanların aralığına bağlıdır\n\n    for (int i = 0; i < size; ++i)\n        count[arr[i]]++;\n\n    for (int i = 1; i <= 99; ++i)\n        count[i] += count[i - 1];\n\n    for (int i = size - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    for (int i = 0; i < size; i++)\n        arr[i] = output[i];\n}\n\nint main() {\n    int arr[] = {1, 4, 1, 2, 7, 5, 2};\n    int size = sizeof(arr)/sizeof(arr[0]);\n    countingSort(arr, size);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'countingSort' fonksiyonu ile belirli bir aralıkta sayıları sıralar. Sıralama işlemi, elemanların sayısını sayarak ve bu sayıları kullanarak gerçekleştirilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441748"
  },
  {
    "question": "Aşağıdaki C kodunda 'bucketSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid bucketSort(float arr[], int n) {\n    int bucketCount = 10; // Bucket sayısı\n    float buckets[bucketCount][n];\n    int bucketSizes[bucketCount];\n    for (int i = 0; i < bucketCount; i++) {\n        bucketSizes[i] = 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int bucketIndex = arr[i] * bucketCount;\n        buckets[bucketIndex][bucketSizes[bucketIndex]++] = arr[i];\n    }\n\n    for (int i = 0; i < bucketCount; i++) {\n        // Sıralama yapılacak her bir bucket\n        // Burada, her bucket için bir sıralama algoritması kullanılabilir (örneğin 'insertionSort')\n        // Örnek olarak basit bir sıralama yapıyoruz\n        for (int j = 0; j < bucketSizes[i]; j++) {\n            for (int k = j + 1; k < bucketSizes[i]; k++) {\n                if (buckets[i][j] > buckets[i][k]) {\n                    float temp = buckets[i][j];\n                    buckets[i][j] = buckets[i][k];\n                    buckets[i][k] = temp;\n                }\n            }\n        }\n    }\n\n    // Sıralanmış sonuçları yazdırma\n    for (int i = 0, j = 0; i < bucketCount; i++) {\n        for (int k = 0; k < bucketSizes[i]; k++) {\n            arr[j++] = buckets[i][k];\n        }\n    }\n}\n\nint main() {\n    float arr[] = {0.78, 0.17, 0.39, 0.26, 0.72, 0.94};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%.2f \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'bucketSort' fonksiyonu ile ondalıklı sayıları sıralar. Sayılar belirli bucket'lara yerleştirilir ve her bir bucket içindeki sayılar sıralanır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441776"
  },
  {
    "question": "Aşağıdaki C kodunda 'radixSort' fonksiyonu eksik. Bu fonksiyonu tamamlayın ve diziyi sıralayın.",
    "answer": "#include <stdio.h>\n\nint getMax(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    return max;\n}\n\nvoid countingSortForRadix(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    int m = getMax(arr, n);\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countingSortForRadix(arr, n, exp);\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    radixSort(arr, n);\n    printf(\"Sıralanmış dizi: \");\n    for (int i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Bu kod, 'radixSort' fonksiyonu ile sayıları basamaklarına göre sıralar. Öncelikle en büyük eleman bulunur, ardından her basamak için sıralama yapılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:26:11.441803"
  },
  {
    "question": "C dilinde bir dizi üzerinde bubble sort algoritmasını nasıl uygularım? Kodun eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Değiştir\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, bubble sort algoritmasını kullanarak verilen bir diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604441"
  },
  {
    "question": "C dilinde bir dizi için insertion sort algoritmasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        // Yerleştirme işlemi\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, insertion sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604490"
  },
  {
    "question": "C dilinde bir dizi üzerinde selection sort algoritmasının kodunu yazın, eksik kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        // Değiştir\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, selection sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604559"
  },
  {
    "question": "C dilinde bir dizi için quick sort algoritmasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  // Pivotu seç\n    int i = (low - 1);  // En küçük elemanı izleyin\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;  // En küçük elemanı artır\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, quick sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604611"
  },
  {
    "question": "C dilinde bir dizi için merge sort algoritmasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, merge sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604646"
  },
  {
    "question": "C dilinde bir dizi için heap sort algoritmasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i >= 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, heap sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.604681"
  },
  {
    "question": "C dilinde bir dizi üzerinde radix sort algoritmasını nasıl uygularım? Kodun eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint getMax(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > max)\n            max = arr[i];\n    return max;\n}\n\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n]; // Çıktı dizisi\n    int count[10] = {0};\n\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    int m = getMax(arr, n);\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countingSort(arr, n, exp);\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    radixSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, radix sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.605012"
  },
  {
    "question": "C dilinde bir dizi için shell sort algoritmasını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {12, 34, 54, 2, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    shellSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n// Açıklama: Bu kod, shell sort algoritmasını kullanarak verilen diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:27:11.605130"
  },
  {
    "question": "C dilinde bir dizi içindeki öğeleri Quick Sort algoritması ile sıralamak için eksik olan kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivot = partition(arr, low, high);\n        quickSort(arr, low, pivot - 1);\n        quickSort(arr, pivot + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Bu kod, Quick Sort algoritmasını kullanarak bir diziyi sıralar. partition fonksiyonu, pivot öğesinin etrafındaki öğeleri yer değiştirerek sıralar. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168456"
  },
  {
    "question": "C dilinde Merge Sort algoritmasının eksik kısmını tamamlayın ve kullanımı hakkında bilgi verin.",
    "answer": "#include <stdio.h>\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    i = 0; j = 0; k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, arr_size - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Merge Sort, diziyi iki alt diziye böler ve her birini sıraladıktan sonra birleştirir. Dikkatlice kontrol edilmesi gereken bir algoritmadır. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168550"
  },
  {
    "question": "C dilinde bir diziyi Selection Sort algoritması ile sıralamak için gereken kod parçalarını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Selection Sort, diziyi sıralamak için her seferinde en küçük öğeyi bulur ve baştaki öğe ile yer değiştirir. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168605"
  },
  {
    "question": "C dilinde Insertion Sort algoritması için eksik olan bölümü tamamlayın ve algoritmanın nasıl çalıştığını açıklayın.",
    "answer": "#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Insertion Sort, diziyi kısmi sıralı bir dizi olarak düşünerek çalışır. Her bir öğe, sıralı dizinin uygun yerine yerleştirilir. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168662"
  },
  {
    "question": "C dilinde Heap Sort algoritmasının eksik kodunu tamamlayın ve heap yapısının nasıl kullanıldığını açıklayın.",
    "answer": "#include <stdio.h>\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n    if (largest != i) {\n        int swap = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = swap;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) \n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Heap Sort, öncelikle diziyi bir heap yapısına dönüştürür ve daha sonra en büyük öğeyi kökten çıkararak diziyi sıralar. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168715"
  },
  {
    "question": "C dilinde bir diziyi Radix Sort algoritması ile sıralamak için gereken kodu eksik yerleri tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    for (int exp = 1; exp < 1000000; exp *= 10)\n        countingSort(arr, n, exp);\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    radixSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Radix Sort, sayıları basamaklarına göre sıralar. Öncelikle en düşük basamaktan başlayarak sıralama yapılır. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168766"
  },
  {
    "question": "C dilinde bir diziyi Shell Sort algoritması ile sıralamak için gereken kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {12, 34, 54, 2, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    shellSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Shell Sort, dizi elemanlarını belirli aralıklarla (gap) karşılaştırarak sıralar. Bu, daha hızlı bir sıralama sağlar. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168813"
  },
  {
    "question": "C dilinde bir diziyi Comb Sort algoritması ile sıralamak için gereken kod parçalarını tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid combSort(int arr[], int n) {\n    float gap = n;\n    bool swapped = true;\n\n    while (gap > 1 || swapped) {\n        gap = gap / 1.247;\n        if (gap < 1) gap = 1;\n        swapped = false;\n\n        for (int i = 0; i + gap < n; i++) {\n            if (arr[i] > arr[i + gap]) {\n                int temp = arr[i];\n                arr[i] = arr[i + gap];\n                arr[i + gap] = temp;\n                swapped = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {5, 3, 2, 1, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    combSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Comb Sort, bir dizi elemanı ile belirli bir aralıkta bulunan başka bir elemanı karşılaştırarak sıralar. Hızlı bir sıralama yöntemi olarak kabul edilir. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168862"
  },
  {
    "question": "C dilinde bir diziyi Gnome Sort algoritması ile sıralamak için gereken kodu eksik yerleri tamamlayın.",
    "answer": "#include <stdio.h>\n\nvoid gnomeSort(int arr[], int n) {\n    int index = 0;\n    while (index < n) {\n        if (index == 0)\n            index++;\n        if (arr[index] >= arr[index - 1])\n            index++;\n        else {\n            int temp = arr[index];\n            arr[index] = arr[index - 1];\n            arr[index - 1] = temp;\n            index--;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {34, 2, 10, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    gnomeSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n\n/* Açıklama: Gnome Sort, dizi elemanlarını karşılaştırarak ve gerektiğinde geri geri giderek sıralar. Kullanımı kolay, ancak verimliliği daha düşüktür. */",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:04.168912"
  },
  {
    "question": "Bir dizi tam sayıyı sıralamak için basit bir seçim sıralama algoritması yazdım ama sonuçlar beklediğim gibi değil. Hata nerede olabilir?",
    "answer": "Seçim sıralama algoritmasında genellikle en küçük elemanı bulup dizinin başına yerleştiririz. Eğer diziyi sıralarken her döngüde en küçük elemanı bulup yerleştirmiyorsanız veya dizinin bir kısmını atlayarak işlem yapıyorsanız bu hatalı sonuçlara neden olabilir. Aşağıda doğru bir seçim sıralama örneği verilmiştir:\n\n```c\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        int temp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755544"
  },
  {
    "question": "Bir diziyi balon sıralama (bubble sort) ile sıraladım ama sıralama çalışmıyor gibi görünüyor. Neden?",
    "answer": "Balon sıralama algoritmasında her iterasyonda bitişik elemanları karşılaştırarak sıralama yaparız. Eğer karşılaştırma veya yer değiştirme işlemlerinde bir hata yapıyorsanız veya dış döngünün koşulunu yanlış ayarladıysanız bu sorunları yaşayabilirsiniz. İşte doğru bir balon sıralama örneği:\n\n```c\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755673"
  },
  {
    "question": "Büyük veri kümesi üzerinde sıralama yaparken programım donuyor. Hatanın sebebi ne olabilir?",
    "answer": "Büyük veri kümeleri ile çalışırken, sıralama algoritmanızın zaman karmaşıklığı çok önemlidir. Örneğin, balon sıralama O(n^2) karmaşıklığına sahiptir ve büyük veri setlerinde verimsiz olabilir. Bunun yerine, hızlı sıralama (quick sort) veya birleştirme sıralama (merge sort) gibi daha verimli algoritmalar kullanmalısınız. İşte hızlı sıralama örneği:\n\n```c\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755705"
  },
  {
    "question": "Sıralama işlemi sırasında dizinin elemanları kayboluyor. Bunun nedeni ne olabilir?",
    "answer": "Sıralama algoritmanızda bir hata, özellikle elemanları yer değiştirirken dizinin sınırlarını aşmanıza neden olabilir. Bu genellikle dizinin boyutunu kontrol etmeden erişim yapmaktan kaynaklanır. Yer değiştirme işlemleri sırasında kullanacağınız geçici bir değişkenin doğru bir şekilde tanımlandığından emin olun. İşte bir örnek:\n\n```c\nvoid swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755733"
  },
  {
    "question": "Sıralama algoritmamı yazdım ama dizinin son durumu beklediğim gibi değil. Hata nerede olabilir?",
    "answer": "Son durumun beklentilerinizi karşılamaması, genellikle algoritmanın döngü koşullarında veya karşılaştırma şartlarında bir hata yapmış olabileceğiniz anlamına gelir. Koşul ifadelerinizi kontrol edin ve dizinin her elemanını tam olarak kontrol ettiğinizden emin olun. İşte örnek bir düzeltme:\n\n```c\nfor (int i = 0; i < n-1; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n        if (arr[j] > arr[j+1]) {\n            swap(&arr[j], &arr[j+1]);\n        }\n    }\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755763"
  },
  {
    "question": "Sıralama algoritmamda bazı elemanlar sıralanmıyor. Hatanın kaynağı ne olabilir?",
    "answer": "Bu durum, algoritmanın elemanları karşılaştırma ve yer değiştirme işlemlerini doğru bir şekilde yapmadığından kaynaklanıyor olabilir. Özellikle son elemanın kontrolünü atlamış olabilirsiniz. Dış ve iç döngülerin koşullarını kontrol edin. İşte basit bir düzeltme:\n\n```c\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n        if (arr[j] > arr[j+1]) {\n            swap(&arr[j], &arr[j+1]);\n        }\n    }\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755789"
  },
  {
    "question": "Sıralama algoritmamda negatif sayılarla çalışırken beklenmedik sonuçlar alıyorum. Ne olabilir?",
    "answer": "Sıralama algoritmalarında negatif sayılarla çalışırken, karşılaştırmaların doğru yapıldığından emin olmalısınız. Bazı algoritmalar, pozitif sayılar için tasarlanmış olabilir veya karşılaştırma mantığınızda bir hata olabilir. Aşağıdaki örnekte, negatif sayılarla doğru çalışacak şekilde karşılaştırma yapılmıştır:\n\n```c\nif (arr[j] < arr[minIndex]) {\n    minIndex = j;\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755816"
  },
  {
    "question": "Sıralama yapmama rağmen dizim hala sıralı görünmüyor. Hatalı bir durum var mı?",
    "answer": "Diziyi sıraladıktan sonra, sıralama işleminin sonucu kontrol edilmelidir. Eğer sıralama algoritması doğru çalışıyorsa ancak sonuçları görmüyorsanız, dizinin elemanlarını ekrana yazdırmayı unuttunuz demektir. İşte örnek bir yazdırma işlemi:\n\n```c\nfor (int i = 0; i < n; i++) {\n    printf(\"%d \", arr[i]);\n}\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755846"
  },
  {
    "question": "Sıralama algoritmamda tüm elemanlar aynı (örneğin tümü sıfır) olduğunda hata alıyorum. Bu durumu nasıl çözebilirim?",
    "answer": "Eğer tüm elemanlar aynıysa, bazı algoritmalar gereksiz yere yer değiştiriyor olabilir. Bu durum, bir değişim yapılmadan dizi üzerinde işlem yapıldığında hata almanıza neden olabilir. Bunun için, karşılaştırma yapmadan önce dizinin tüm elemanlarının eşit olduğunu kontrol edebilirsiniz. İşte bir kontrol ekleme:\n\n```c\nif (arr[j] == arr[j + 1]) continue;\n```",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:24.755881"
  },
  {
    "question": "Bubble sort algoritmasında neden bazı durumlarda sıralama tamamlanmadan döngü bitiyor?",
    "answer": "Bubble sort algoritmasında dış döngü, listenin tüm elemanları üzerinde geçerken, iç döngü her iki komşu elemanı karşılaştırarak daha büyük olanı sağa kaydırır. Eğer bir geçişte hiç değişiklik olmazsa, yani listenin sıralandığını anladığımızda, dış döngü sonlandırılmalıdır. Bu durum kontrol edilmediğinde gereksiz döngü çalışmaları ve zaman kaybı olur. Bu problemi çözmek için bir 'değişiklik oldu mu' kontrolü eklenmelidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200314"
  },
  {
    "question": "Merge sort algoritmasında oluşan geçici diziyi bellek sızıntısı yaşamamak için nasıl yönetmeliyim?",
    "answer": "Merge sort algoritmasında, her iki alt diziyi birleştirirken geçici bir dizi oluştururuz. Bu diziyi her bir birleştirme işleminden sonra serbest bırakmak önemlidir. 'malloc' ile bellek ayırdığınızda, 'free' fonksiyonu ile bu belleği kullanmadığınızda geri vermek gereklidir. Aksi takdirde, uygulamanız bellek sızıntısı yaşar. Örnek: 'int* temp = (int*)malloc(sizeof(int) * (n1 + n2));' kullandıysanız, birleştirme işlemi tamamlandıktan sonra 'free(temp);' ile belleği serbest bırakmalısınız.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200369"
  },
  {
    "question": "Quick sort algoritmasında pivot seçimi neden performansı etkiler ve en kötü durum senaryosu nedir?",
    "answer": "Quick sort algoritmasında pivot seçiminde kötü bir seçim, algoritmanın O(n^2) karmaşıklığa düşmesine neden olabilir. En kötü durum senaryosu, sıralı bir dizide her zaman en küçük veya en büyük elemanın pivot olarak seçilmesidir. Bu durum, her seferinde yalnızca bir elemanı doğru konumuna yerleştireceği için alt diziler çok dengesiz hale gelir. Bu durumu önlemek için, pivot seçiminde rastgele veya medyan seçimi gibi stratejiler kullanmak faydalıdır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200402"
  },
  {
    "question": "Selection sort algoritmasında neden her seferinde en küçük elemanı bulmak verimliliği düşürüyor?",
    "answer": "Selection sort algoritması, dizinin her bir elemanını kontrol ederek en küçük olanı bulur ve her dış döngüde bu işlemi tekrarlar. Bu, algoritmanın her durumda O(n^2) karmaşıklığa sahip olmasına neden olur. Verimliliği artırmak için daha etkili sıralama algoritmaları (örneğin, quick sort veya merge sort) tercih edilmelidir. Ayrıca, her döngüde en küçük elemanı bulma işlemi yerine, bir 'flag' kullanarak sadece değişiklik olduğunda swap yapmak daha iyi bir yaklaşım olabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200433"
  },
  {
    "question": "Radix sort uygularken hangi veri türlerinde bu algoritmanın en iyi performansı gösterdiğini belirtin.",
    "answer": "Radix sort, tam sayılar gibi sabit uzunlukta ve belirli aralıkta olan veri türlerinde en iyi performansı gösterir. Bu algoritmanın avantajı, verilerin karşılaştırmasından ziyade, basamakları sıralayarak çalışmasıdır. Örneğin, 32 bitlik tamsayıları sıralarken, her basamağı ayrı ayrı dikkate alarak sıralama yapar, böylece O(n*k) karmaşıklığına ulaşır (n: eleman sayısı, k: basamak sayısı). String verilerde de kullanılabilir ama sabit uzunlukta olmaları tercih edilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200465"
  },
  {
    "question": "Heap sort algoritmasında heap yapısının oluşturulması sırasında neden 'index out of bounds' hatası alıyorum?",
    "answer": "Heap sort algoritmasında, heap yapısını oluştururken, çocuk düğümlerin indekslerini hesaplamak için '2*i + 1' ve '2*i + 2' formüllerini kullanırız. Eğer bu hesaplamalar dizinin boyutunu aşıyorsa, 'index out of bounds' hatası alırsınız. Bu nedenle, çocuk düğümlerin indekslerinin dizinin boyutundan küçük olup olmadığını kontrol etmelisiniz. Örnek: 'if (left < n) {...}' ve 'if (right < n) {...}' kontrollerini ekleyin.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200500"
  },
  {
    "question": "Insertion sort algoritmasında dizinin sonuna ekleme yaparken neden sıralama hatası yaşayabilirim?",
    "answer": "Insertion sort algoritmasında, dizinin sonuna ekleme yaparken yeni elemanı doğru konumuna yerleştiremezseniz, sıralama hatası yaşarsınız. Özellikle, yeni elemanı eklemeden önce dizinin sonundaki elemanları kontrol etmeniz ve gerekirse kaydırmanız gerekmektedir. Eğer yeni eleman dizinin en başına geliyorsa, öncelikle tüm elemanları kaydırmak gerekecektir. Bunu yaparken, döngünün doğru bir şekilde sınırlarını belirlediğinizden emin olun (örneğin, 'for (int j = i; j > 0 && arr[j - 1] > key; j--) {...}' gibi).",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200548"
  },
  {
    "question": "Shell sort algoritmasında gap değerlerinin seçimi neden sıralama verimliliğini etkiler?",
    "answer": "Shell sort algoritmasında gap değerlerinin seçimi, sort işleminin verimliliğini doğrudan etkiler. Doğru gap değerleri ile başlangıçta daha büyük sıralamalar yaparak, dizinin daha hızlı bir şekilde sıralanmasına yardımcı olabilirsiniz. Popüler gap serileri arasında Shell, Hibbard ve Sedgewick serileri bulunmaktadır. Her biri farklı sıralama verimlilikleri sunar; bu nedenle deneyerek en uygun olanı bulmak önemlidir. Yanlış bir gap değerinin seçilmesi, algoritmanın performansını olumsuz etkileyebilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200584"
  },
  {
    "question": "Counting sort algoritmasında negatif sayılarla çalışırken hangi önlemleri almalıyım?",
    "answer": "Counting sort, doğrudan sayıların indeksini kullanarak çalıştığı için negatif sayılarla çalışırken özel bir dikkat gerektirir. Negatif sayıları yönetmek için, en küçük sayının değerini bulup, bu değeri normalize etmeniz gerekir. Örneğin, en küçük sayı -5 ise, tüm elemanlardan -5 çıkararak diziyi pozitif aralığa getirebilirsiniz. Böylece, dizinin boyutunu artırarak doğru indekslemeyi sağlarsınız. Örnek: 'int minVal = findMin(arr); for (int i = 0; i < n; i++) count[arr[i] - minVal]++;'.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200613"
  },
  {
    "question": "Topological sort algoritmasında döngü tespiti yapmadığımda hangi sorunlarla karşılaşabilirim?",
    "answer": "Topological sort, yönlendirilmiş asiklik grafiklerde (DAG) çalışır. Eğer döngü tespiti yapmazsanız, döngü içeren bir grafikte bu algoritmayı uygulamaya çalıştığınızda sonsuz döngüler veya hatalı sonuçlar alırsınız. Bu sorunları önlemek için, grafikteki düğümleri ziyaret ederken, bir ziyaret durumu dizisi kullanarak hangi düğümlerin ziyaret edildiğini takip etmelisiniz. Eğer bir düğüm tekrar ziyaret edilirse, bu durum bir döngünün var olduğunu gösterir ve sıralama yapılmaz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:28:49.200642"
  },
  {
    "question": "Bubble sort algoritmasının implementasyonunda, iki ardışık elemanı karşılaştırırken bir hata alıyorum. Nedenini ve çözümünü açıklar mısınız?",
    "answer": "Bubble sort algoritmasında iki ardışık elemanı karşılaştırırken, doğru indekslerin kullanıldığından emin olmalısınız. Hata, genellikle döngü sınırlarının yanlış ayarlanmasından kaynaklanır. Örneğin, iç döngü 'i < n - 1' yerine 'i < n' şeklinde yazılmışsa, bellek taşmasına neden olabilir. Çözüm olarak, iç döngüdeki koşulu 'i < n - 1' olacak şekilde güncelleyin.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.653947"
  },
  {
    "question": "Insertion sort algoritması kullanırken, listeyi doğru sıralayamıyorum. Hatanın nerede olduğunu bulabilir misiniz?",
    "answer": "Insertion sort algoritması, her bir elemanı sıralı bir alt dizi içinde doğru konuma yerleştirmelidir. Eğer elemanlar doğru yerleştirilmiyorsa, muhtemelen iç döngüdeki 'while' koşulunu yanlış ayarlamış olabilirsiniz. Örneğin, 'while (arr[j] > key)' yerine 'while (j >= 0 && arr[j] > key)' ifadesini kullanmalısınız. Bu, dizinin başına kadar kontrol yapmanızı sağlar ve dizinin dışına çıkmanızı engeller.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.653995"
  },
  {
    "question": "Quick sort algoritmamda 'pivot' seçimi yaparken beklenmedik sonuçlar alıyorum. Bu durumu nasıl düzeltebilirim?",
    "answer": "Quick sort algoritmasında pivot seçimi önemlidir. Eğer her zaman ilk veya son elemanı pivot olarak seçiyorsanız, zaten sıralı bir dizi üzerinde performans düşüklüğü yaşayabilirsiniz. Bunun yerine, 'median of three' yöntemini kullanarak, dizinin ortasındaki, en baştaki ve en sondaki elemanın medyanını pivot olarak seçebilirsiniz. Bu, daha dengeli bölmeler sağlar ve performansı artırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654030"
  },
  {
    "question": "Merge sort algoritması kullanırken, iki alt diziyi birleştirme kısmında 'out of bounds' hatası alıyorum. Sorunu çözebilir misiniz?",
    "answer": "Merge sort algoritmasında iki alt diziyi birleştirirken, dizinin sınırlarını kontrol edebilmek için iki işaretçi kullanmalısınız. Eğer alt dizilerin boyutlarını kontrol etmezseniz, 'out of bounds' hatası alabilirsiniz. 'while' döngüsü içinde her iki dizinin de bitip bitmediğini kontrol edin. Örneğin, 'while (i < n1 && j < n2)' koşulunu kullanarak, her iki dizi için de geçerli indeksler olduğundan emin olun.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654069"
  },
  {
    "question": "Heap sort algoritmasında, heap yapısını oluştururken bazı elemanların yanlış yerlerde olduğunu düşünüyorum. Nasıl düzeltebilirim?",
    "answer": "Heap sort algoritmasında, heap yapısını oluştururken 'heapify' işlemi sırasında doğru indeks hesaplamalarının yapılması önemlidir. Eğer 'left' ve 'right' alt düğümler için indeks hesaplamalarınızı yanlış yaparsanız (örneğin, '2 * i + 1' ve '2 * i + 2' yerine 'i * 2 + 1' yazarsanız), dizinin doğru yapılandırılmamasına neden olabilirsiniz. Doğru hesaplamaları yaparak ve her iki alt düğümü de kontrol ederek 'heapify' fonksiyonunu güncelleyin.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654103"
  },
  {
    "question": "Radix sort uygulamamda, sayıları doğru bir şekilde sıralayamıyorum. Hatanın nedeni nedir?",
    "answer": "Radix sort, sayıları sıralarken her basamağı tek tek ele alır. Eğer basamak sayısını belirlerken veya 'counting sort' işlemi sırasında dizinin boyutunu yanlış ayarlarsanız, beklenmedik sıralama sonuçları alabilirsiniz. Özellikle, 'counting sort' fonksiyonunda kullanılan dizinin boyutunun, sayının en yüksek basamağına göre ayarlandığından emin olun. Gerekirse, her basamak için sayıları uygun şekilde normalize edin.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654131"
  },
  {
    "question": "Shell sort algoritmamda, en yüksek sıralama sonucunu elde edemiyorum. Hatanın kaynağını bulabilir misiniz?",
    "answer": "Shell sort, elemanları belirli aralıklarla karşılaştırarak sıralar. Eğer sıralama aralıkları (gap) yanlış belirlenmişse, performans düşebilir. Yanlış gap dizisi kullanıyorsanız, sıralama sonuçları beklediğinizden daha kötü olabilir. Gap dizisini belirlerken, genellikle 'n/2' gibi bir başlangıç değeri ile başlayarak, her adımda yarıya indirin. Bu şekilde daha iyi sonuçlar alabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654161"
  },
  {
    "question": "Counting sort algoritmamda negatif sayılarla çalışırken hata alıyorum. Bu durumu nasıl çözebilirim?",
    "answer": "Counting sort, genellikle pozitif sayılarla çalışmak üzere tasarlanmıştır. Negatif sayılar var ise, dizinin boyutunu tanımlarken bu negatif sayıları da göz önünde bulundurmalısınız. Örneğin, negatif sayılara 0'dan başlayarak bir offset ekleyebilir ve bu offset'i kullanarak sayıları pozitif hale getirip, counting dizisini bu şekilde oluşturabilirsiniz. Bu, algoritmanın düzgün çalışmasını sağlar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654197"
  },
  {
    "question": "Tim sort algoritmasının uygulamasında, dizi parçalarını birleştirirken beklenmedik sonuçlar alıyorum. Hatanın kaynağı nedir?",
    "answer": "Tim sort, hem merge sort hem de insertion sort kullanarak çalışır. Eğer dizi parçalarını birleştirirken, birleştirme işlemini doğru yapmazsanız (örneğin, başlangıç ve bitiş indekslerini yanlış ayarlarsanız), beklenmedik sıralama sonuçları elde edebilirsiniz. 'merge' fonksiyonundaki parametrelerin doğru ayarlandığından emin olun ve her iki alt dizinin de bitiş koşullarını dikkatlice kontrol edin.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654232"
  },
  {
    "question": "Bucket sort algoritmamda, bazı 'bucket'lar boş kalıyor ve sıralama beklediğimden daha uzun sürüyor. Hatanın kaynağı nedir?",
    "answer": "Bucket sort algoritmasında, her bir bucket için elemanların doğru bir şekilde dağıtılması önemlidir. Eğer bucket'ların sayısını yanlış ayarlarsanız veya elemanların hangi bucket'a yerleştirileceğini belirlerken hata yaparsanız, bazı bucket'lar boş kalabilir. Elemanları yerleştirirken, hesaplama sırasında 'bucket_index = (value - min) / range' gibi bir formül kullanmalısınız. Bu, her elemanın doğru bucket'a yerleştirilmesini sağlar ve sıralama sürecini hızlandırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:20.654283"
  },
  {
    "question": "Bubble Sort algoritması nasıl çalışır ve nerelerde kullanılır?",
    "answer": "Bubble Sort, basit bir sıralama algoritmasıdır. Algoritma, dizideki her iki ardışık elemanı karşılaştırır ve gerekirse yer değiştirir. Bu işlem dizinin sonuna kadar devam eder. En büyük eleman her iterasyonda en sona 'baloncuk' gibi yükselir. Bu algoritmanın karmaşıklığı O(n^2) olduğundan, küçük diziler için uygundur. Örneğin, kullanıcıdan alınan küçük bir sayı listesinde sıralama yapmak için kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252662"
  },
  {
    "question": "Selection Sort algoritması nedir ve nasıl çalışır?",
    "answer": "Selection Sort, sıralama işlemini parça parça yapan bir algoritmadır. Algoritma, dizideki en küçük (veya en büyük) elemanı bulur ve dizinin başıyla yer değiştirir. Bu işlem, dizinin tamamı sıralanana kadar devam eder. Karmaşıklığı O(n^2) olan bu algoritma, daha az veri hareketi gerektirdiği için bazen tercih edilir. Örneğin, bir öğrenci notları dizisini sıralamak için kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252706"
  },
  {
    "question": "Insertion Sort algoritması ne zaman tercih edilmelidir?",
    "answer": "Insertion Sort, verilerin büyük ölçüde sıralı olduğu durumlarda daha iyi performans gösterir. Algoritma, sıralı bir alt dizi oluşturarak yeni elemanları bu diziye ekler. Çoğu zaman küçük dizilerde veya kısmen sıralı verilerde etkili bir seçimdir. Örneğin, bir kullanıcıdan gelen küçük bir isim listesini sıralamak için bu algoritmayı seçebilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252728"
  },
  {
    "question": "Merge Sort algoritmasının temel prensipleri nelerdir?",
    "answer": "Merge Sort, 'böl ve fethet' (divide and conquer) yaklaşımını kullanır. Diziyi ikiye böler, bu alt dizileri sıralar ve ardından sıralı alt dizileri birleştirir. Bu algoritmanın karmaşıklığı O(n log n) olduğundan, büyük veri setleri için etkilidir. Örneğin, bir e-ticaret sitesinde ürünleri fiyatlarına göre sıralamak için merge sort kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252747"
  },
  {
    "question": "Quick Sort algoritması nasıl çalışır ve avantajları nelerdir?",
    "answer": "Quick Sort, bir pivot elemanı seçip diziyi bu eleman etrafında iki alt diziye bölen bir algoritmadır. Alt diziler ayrı ayrı sıralanır ve bu işlem tekrarlanır. Quick Sort'un ortalama karmaşıklığı O(n log n) olup, genellikle büyük veriler için hızlıdır. Örneğin, kullanıcıların en hızlı bir şekilde arama sonuçlarını sıralamak için bu algoritmayı kullanabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252768"
  },
  {
    "question": "Radix Sort algoritması hangi durumlarda etkilidir?",
    "answer": "Radix Sort, sayıları basamaklarına göre sıralayarak çalışan bir algoritmadır. Genellikle, sayıları veya kelimeleri sıralamak için etkili olup, O(nk) karmaşıklığı vardır. Burada 'n' eleman sayısını ve 'k' en uzun basamak sayısını temsil eder. Örneğin, bir banka sisteminde müşteri hesap numaralarını sıralamak için bu algoritma tercih edilebilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252786"
  },
  {
    "question": "Heapsort algoritması nedir ve nasıl çalışır?",
    "answer": "Heapsort, bir dizi üzerinde sıralama yapmak için ikili ağaç yapısını kullanan bir algoritmadır. Öncelikle dizi bir heap yapısına dönüştürülür, ardından en büyük (veya en küçük) eleman sürekli dizinin sonuna yerleştirilir. Karmaşıklığı O(n log n) olduğu için büyük veri setleri için idealdir. Örneğin, bir iş uygulamasında çalışanların maaşlarını sıralamak için kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252807"
  },
  {
    "question": "Shell Sort algoritmasının çalışma prensibi nedir?",
    "answer": "Shell Sort, Insertion Sort'un bir geliştirmesidir. Üzerinde çalıştığı dizi, öncelikle daha büyük alt dizilere bölünür ve bu alt diziler sıralanır. Zamanla alt dizilerin uzunluğu azalır ve dizi genel olarak sıralanmış hale gelir. Karmaşıklığı O(n^2) ile O(n log n) arasında değişir. Örneğin, bir kullanıcıdan alınan kitap isimleri dizisini daha hızlı sıralamak için kullanabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252825"
  },
  {
    "question": "Counting Sort algoritması ne zaman kullanılır?",
    "answer": "Counting Sort, belirli bir aralıktaki tam sayıları sıralamak için etkili bir algoritmadır. Her elemanın sayısını tutarak, diziyi sıralar. Bu algoritma, O(n + k) karmaşıklığına sahiptir, burada 'k' sıralanacak elemanların aralığıdır. Örneğin, bir sınavda alınan notların sıralanmasında kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252843"
  },
  {
    "question": "Bucket Sort algoritmasının mantığı nedir?",
    "answer": "Bucket Sort, verileri bir dizi 'kova' (bucket) içine dağıtarak sıralama yapan bir algoritmadır. Her kova ayrı bir dizi gibi davranır ve bu alt diziler sıralanır. Sonuçta, sıralı alt diziler birleştirilerek sonuç elde edilir. Karmaşıklığı O(n + k) olan bu algoritma, özellikle verilerin uniform dağıldığı durumlarda etkilidir. Örneğin, bir otelin oda fiyatlarını sıralamak için kullanabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:29:40.252861"
  },
  {
    "question": "Bubble Sort algoritması nedir ve nasıl çalışır?",
    "answer": "Bubble Sort, en basit sıralama algoritmalarından biridir. Temel prensibi, sıralanacak dizideki elemanları karşılaştırmak ve gerektiğinde yer değiştirmektir. Algoritma, dizinin başından sonuna kadar giderek her iki bitişik elemanı karşılaştırır ve büyük olanı sağ tarafa iter. Bu işlem, dizinin tamamı sıralanana kadar tekrar edilir. Örneğin, [5, 3, 8, 4, 2] dizisi için, ilk adımda 5 ve 3 karşılaştırılır ve yer değiştirir. Sonuç olarak, dizi [3, 5, 8, 4, 2] olur. Bu işlemler tüm elemanlar için tekrarlanır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027038"
  },
  {
    "question": "Merge Sort algoritması nedir ve hangi durumlarda tercih edilmelidir?",
    "answer": "Merge Sort, yine 'böl ve fethet' yaklaşımını kullanan bir sıralama algoritmasıdır. Dizi iki alt diziye bölünür, her alt dizi sıralanır ve sonrasında bu iki sıralı alt dizi birleştirilir. Örneğin, [38, 27, 43, 3, 9, 82, 10] dizisinde önce diziyi [38, 27, 43] ve [3, 9, 82, 10] şeklinde ikiye böleriz. Daha sonra bu diziler sıralanır ve birleştirilir. Merge Sort, stabildir ve büyük veri setlerinde, özellikle dizinin büyük kısmı sıralı olduğunda tercih edilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027095"
  },
  {
    "question": "Selection Sort algoritmasının mantığı nedir ve zaman karmaşıklığı nedir?",
    "answer": "Selection Sort, sıralanacak dizideki en küçük elemanı bulup, dizinin başındaki eleman ile yer değiştirme prensibine dayanır. Bu işlem, dizinin tüm elemanları için tekrarlanır. Örneğin, [29, 10, 14, 37, 13] dizisinde önce 10 en küçük olarak seçilir, 29 ile yer değiştirir. Sonra kalan dizideki en küçük eleman olan 13, 29 ile değiştirilir. Zaman karmaşıklığı O(n²) olduğundan, küçük ve sıralı dizilerde etkilidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027124"
  },
  {
    "question": "Insertion Sort algoritmasının nasıl çalıştığını açıklayın.",
    "answer": "Insertion Sort, diziyi sıralı bir alt dizi ile başlatır ve her yeni elemanı bu sıralı alt dizinin doğru konumuna yerleştirir. Başlangıçta sıralı alt dizi sadece ilk elemandır. Örneğin, [12, 11, 13, 5, 6] dizisinde 11, 12 ile karşılaştırılır ve 12'nin önüne yerleştirilir. Bu işlem, tüm elemanlar için tekrarlanır. Zaman karmaşıklığı en iyi durumda O(n), en kötü durumda O(n²) şeklindedir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027148"
  },
  {
    "question": "Radix Sort algoritması nedir ve nasıl uygulanır?",
    "answer": "Radix Sort, basamak basamak sıralama yapan bir algoritmadır. Öncelikle en düşük basamaktan başlayarak, her basamağa göre sıralama yapılır. Örneğin, [170, 45, 75, 90, 802, 24, 2, 66] dizisinde, önce 1'ler basamağına göre sıralama yapılır, ardından 10'lar ve en sonunda 100'ler basamağına göre sıralanır. Radix Sort, özellikle sabit uzunlukta sayılar ile çalışırken etkilidir ve zaman karmaşıklığı O(nk) olur.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027170"
  },
  {
    "question": "Heap Sort algoritması nedir ve nasıl çalışır?",
    "answer": "Heap Sort, verileri bir ikili ağaç yapısı olan heap üzerinde sıralayan bir algoritmadır. Öncelikle verilen dizi bir max heap yapısına dönüştürülür. En büyük eleman dizinin sonunda yer alır, ardından kalan elemanlar ile heap yeniden oluşturulur. Bu işlem, dizinin tamamı sıralanana kadar devam eder. Örneğin, [3, 5, 1, 10, 2] dizisini önce max heap yapısına dönüştürerek başlayıp, ardından sıralama işlemi yapılır. Zaman karmaşıklığı O(n log n) olarak bilinir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027191"
  },
  {
    "question": "Counting Sort algoritmasını nerelerde kullanabiliriz?",
    "answer": "Counting Sort, belirli bir aralıkta tam sayı değerlerini sıralamak için kullanılan bir algoritmadır. Bu algoritma, her elemanın sayısını tutarak, bittiğinde sıralı bir dizi oluşturur. Örneğin, [4, 2, 2, 8, 3, 3, 1] dizisinde 0'dan 8'e kadar olan değerlerin sayısı tutulur ve bu sayılar kullanılarak sıralama yapılır. Counting Sort, özellikle 0 ile k arasında değerler bulunuyorsa etkili bir şekilde çalışır ve zaman karmaşıklığı O(n + k) şeklindedir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027213"
  },
  {
    "question": "Shell Sort algoritması nedir ve nasıl çalışır?",
    "answer": "Shell Sort, Insertion Sort'un geliştirilmiş bir versiyonudur. Diziyi, belirli aralıklarla alt dizilere böler ve bu alt dizileri sıralar. Ardından, aralıklar küçültülerek sıralama işlemi devam eder. Örneğin, [5, 2, 9, 1, 5, 6] dizisinde önce 2'lik aralıklarla sıralama yapılır. Bu işlem, dizinin büyüklüğüne göre aralıklar azaltılarak sona erer. Shell Sort, zaman karmaşıklığı O(n^(3/2)) veya O(n log n) civarındadır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027234"
  },
  {
    "question": "Sıralama algoritmalarında 'stabillik' nedir ve neden önemlidir?",
    "answer": "Sıralama algoritmalarında 'stabillik', eşit değerlere sahip elemanların sıralama işlemi sonrasında aynı sırada kalması anlamına gelir. Örneğin, eğer bir dizide iki '5' değeri varsa, bu değerler sıralama sonrası da aynı sırada olmalıdır. Stabil sıralama, veri yapıları ve kullanıcı arayüzleri gibi birçok alanda önemlidir, çünkü benzer değerlerin mantıksal sırasını korur. Stability, özellikle sıralama işlemi sonrası ek özellikler eklenmesi gerektiğinde faydalıdır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:07.027261"
  },
  {
    "question": "Hızlı sıralama algoritmasının temel mantığı nedir ve nasıl çalışır?",
    "answer": "Hızlı sıralama (QuickSort), 'böl ve yönet' (divide and conquer) prensibi ile çalışan bir sıralama algoritmasıdır. Algoritma, bir 'pivot' elemanı seçer ve diziyi bu pivot etrafında iki alt diziye böler: pivotdan küçük ve büyük elemanlar. Bu işlem, her alt dizi için rekürsif olarak tekrarlanır. Sonuçta, alt diziler sıralandığında, tüm dizi sıralı hale gelir. Örneğin, bir dizi [3, 6, 8, 10, 1, 2, 1] verildiğinde, 6 pivot olarak seçilebilir. Dizi [3, 1, 2, 1] (küçük) ve [8, 10] (büyük) alt dizilerine bölünür ve her biri bağımsız olarak sıralanır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.244989"
  },
  {
    "question": "Bir diziyi sıralarken zaman karmaşıklığını optimize etmek için ne gibi stratejiler kullanılabilir?",
    "answer": "Zaman karmaşıklığını optimize etmenin birkaç yolu vardır: 1) Pivot seçimi yaparken, ortalama veya medyan değeri seçmek; 2) Küçük diziler için farklı bir sıralama algoritması kullanmak (örneğin, Insertion Sort); 3) Rekürsif derinliği azaltmak için dizi boyutunu izlemek ve eşit olan elemanları uygun bir şekilde işlemek. Örneğin, dizideki tüm elemanlar aynı ise, algoritma gereksiz yere çok fazla rekürsif çağrı yapmaktan kaçınabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245065"
  },
  {
    "question": "Bir diziyi sıralamak için birleştirme sıralaması (MergeSort) kullanırken dikkat edilmesi gerekenler nelerdir?",
    "answer": "Birleştirme sıralaması, sıralı iki alt diziyi birleştirerek çalışır. Dikkat edilmesi gereken noktalar: 1) Bellek kullanımı, çünkü MergeSort, ek bellek alanı gerektirir; 2) Çift sayıdaki dizilerde, iki alt diziye eşit şekilde bölme yapabilmek; 3) Rekürsif işlenirken, temel durumu doğru belirlemek. Örneğin, dizinin boyutu 1 olduğunda, bu dizi sıralıdır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245116"
  },
  {
    "question": "Yığın sıralama (HeapSort) algoritmasını açıklayın ve hangi durumlarda kullanılmalıdır?",
    "answer": "Yığın sıralama, bir yığın veri yapısı kullanarak sıralama yapar. İlk önce diziyi bir yığın haline getirir, ardından en üstteki eleman çıkarılarak dizinin sonuna eklenir. Bu işlemler, tüm elemanlar sıralanana kadar devam eder. HeapSort, bellek kullanımı açısından avantajlıdır çünkü ek bellek gerektirmez. Ayrıca, en kötü durum zaman karmaşıklığı O(n log n) olduğu için büyük diziler için etkilidir. Örneğin, büyük veri setleri için tercih edilebilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245161"
  },
  {
    "question": "Radix sıralaması (Radix Sort) algoritmasının mantığı nedir ve hangi tür veriler için uygundur?",
    "answer": "Radix sıralaması, sayıları basamaklarına göre sıralayarak çalışan bir algoritmadır. Örneğin, 3 basamaklı sayılar sıralanırken önce en düşük basamaktan (birler) başlanır, ardından onluğa ve yüzlüğe geçilir. Bu algoritma, sayısal veriler için uygundur ve en iyi performansı sabit uzunlukta tamsayı dizileri üzerinde gösterir. Zaman karmaşıklığı O(nk) şeklindedir; burada n eleman sayısını, k ise en yüksek sayının basamak sayısını temsil eder. Örneğin, 170, 45, 75, 90 sayıları için Radix sıralaması uygulanabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245210"
  },
  {
    "question": "Sıralama algoritmalarının en iyi durum, ortalama durum ve en kötü durum zaman karmaşıklıkları nasıl hesaplanır?",
    "answer": "Her sıralama algoritması için en iyi, ortalama ve en kötü durum zaman karmaşıklıkları, algoritmanın temel işleyişine ve dizi düzenine bağlıdır. En iyi durumda, sıralı bir dizi için (örneğin, Insertion Sort O(n)), ortalama durumda genellikle O(n log n) (örneğin, QuickSort) ve en kötü durumda O(n^2) (örneğin, QuickSort ve Bubble Sort) gibi değerler gösterir. Her algoritmanın performansı dizinin eleman sayısına ve yapısına göre değişebilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245295"
  },
  {
    "question": "Sıralama algoritmalarının stabil olup olmadığını nasıl değerlendiririz?",
    "answer": "Bir sıralama algoritmasının stabil olup olmadığını belirlemek için, eşit elemanların sıralama sonucunda orijinal dizideki sıralarını koruyup korumadığına bakarız. Örneğin, Insertion Sort ve MergeSort stabil sıralama algoritmalarıdır çünkü aynı değere sahip elemanların sıralarını değiştirmezler. Ancak, QuickSort ve HeapSort genellikle stabil değildir. Stabil sıralamalar, kullanıcı arayüzlerinde sıralama yaparken önceliklerin korunması gereken durumlarda önemlidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245334"
  },
  {
    "question": "Bir sıralama algoritması uygularken bellek kullanımını azaltmak için hangi teknikler kullanılabilir?",
    "answer": "Bellek kullanımını azaltmak için, 1) Yerel veya in-place sıralama algoritmaları seçmek (örneğin, QuickSort); 2) Ek bellek gereksinimlerini minimize edecek şekilde verileri doğrudan dizide değiştirmek; 3) Bellek parçalarını birleştirerek daha az bellek kullanıp kullanmadığını kontrol etmek gibi teknikler kullanılabilir. Örneğin, MergeSort kullanırken iki diziyi birleştirirken, geçici bir dizi yerine mevcut dizi üzerinde doğrudan işlem yaparak bellek tasarrufu sağlanabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245379"
  },
  {
    "question": "Sıralama algoritmalarını uygularken hangi faktörler performansı etkiler?",
    "answer": "Sıralama algoritmalarının performansını etkileyen faktörler şunlardır: 1) Dizi boyutu: Büyük dizilerde daha etkili algoritmalar kullanmak gerekir; 2) Dizi düzeni: Sıralı dizilerde bazı algoritmalar daha hızlı çalışabilir; 3) Bellek kısıtlamaları: Ek bellek kullanımı nedeniyle bazı algoritmalar daha yavaş olabilir; 4) Kullanıcı arayüzü gereksinimleri: Stabil sıralama gereksinimi performansı etkileyebilir. Örneğin, büyük veri setleri için QuickSort'un tercih edilmesi, daha düşük bellek kullanımı ve daha iyi zaman karmaşıklığı sağlar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245414"
  },
  {
    "question": "Sıralama algoritmaları için karşılaştırma bazlı ve karşılaştırma dışı yöntemler arasındaki farklar nelerdir?",
    "answer": "Karşılaştırma bazlı sıralama algoritmaları, dizideki elemanları karşılaştırarak sıralama yapar ve en iyi zaman karmaşıklığı O(n log n) ile sınırlıdır. Örnekler: QuickSort, MergeSort. Karşılaştırma dışı sıralama yöntemleri ise belirli türdeki veriler için daha hızlı sonuçlar verir ve O(n) zaman karmaşıklığına ulaşabilir. Örnekler: Counting Sort, Radix Sort. Karşılaştırma bazlı algoritmalar genel amaçlıdır, ancak karşılaştırma dışı algoritmalar belirli koşullarda daha etkilidir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:30:34.245460"
  },
  {
    "question": "Bir dizi içindeki sayıları artan sırayla sıralamak için 'Bubble Sort' algoritmasını nasıl uygularım?",
    "answer": "Bubble Sort algoritmasını kullanarak bir dizi içindeki sayıları artan sırayla sıralamak için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Değiştir\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, 'Bubble Sort' algoritması ile sayıları sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644527"
  },
  {
    "question": "Seçim sıralama algoritmasını (Selection Sort) örnekle gösterir misiniz?",
    "answer": "Seçim sıralama algoritması, her adımda en küçük (veya en büyük) öğeyi bulup, dizinin başına yerleştirir. Örnek bir uygulama aşağıda verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        // Değiştir\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, diziyi 'Selection Sort' algoritması ile sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644570"
  },
  {
    "question": "Hızlı sıralama algoritması (Quick Sort) ile bir diziyi nasıl sıralarım?",
    "answer": "Hızlı sıralama algoritması, böl ve fethet tekniğini kullanır. Aşağıdaki kod, bir diziyi 'Quick Sort' ile sıralar:\n\n```c\n#include <stdio.h>\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; \n    int i = (low - 1); \n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, 'Quick Sort' algoritması ile diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644597"
  },
  {
    "question": "Bir diziyi Birleştirme sıralama algoritması (Merge Sort) ile nasıl sıralarım?",
    "answer": "Birleştirme sıralama algoritması, dizinin ortasından iki parçaya ayrılır ve ardından bu parçalar sıralanarak birleştirilir. Aşağıdaki kod örneği bunu gösterir:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j])\n            arr[k++] = L[i++];\n        else\n            arr[k++] = R[j++];\n    }\n    while (i < n1)\n        arr[k++] = L[i++];\n    while (j < n2)\n        arr[k++] = R[j++];\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, 'Merge Sort' algoritması ile diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644623"
  },
  {
    "question": "Bir diziyi Sıralama (Sorting) için C dilinde stdlib kütüphanesinin qsort fonksiyonunu nasıl kullanırım?",
    "answer": "C dilinde stdlib kütüphanesindeki qsort fonksiyonu, diziyi sıralamak için kullanılabilir. Aşağıdaki örnek bunu göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    qsort(arr, n, sizeof(int), compare);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, qsort fonksiyonu ile diziyi sıralar. 'compare' fonksiyonu, iki elemanı karşılaştırmak için kullanılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644653"
  },
  {
    "question": "Dizi içerisindeki aynı elemanları gruplamak için bir sıralama algoritması nasıl uygulanır?",
    "answer": "Aynı elemanları gruplamak için, sıralama işlemi sonrasında dizi üzerinde tekrar bir geçiş yaparak benzer öğeleri gruplamak mümkündür. Aşağıdaki örnek, 'Bubble Sort' ile sıralayıp gruplar:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {3, 1, 2, 2, 1, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n\n    printf(\"Gruplandırılmış dizi: \");\n    int count = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] == arr[i - 1]) {\n            count++;\n        } else {\n            printf(\"%d (%d) \", arr[i - 1], count);\n            count = 1;\n        }\n    }\n    printf(\"%d (%d) \", arr[n - 1], count);\n    return 0;\n}\n```\nBu kod, diziyi önce sıralayıp sonra aynı elemanları gruplar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644680"
  },
  {
    "question": "Bir diziyi sıralamak için 'Insertion Sort' algoritmasını nasıl uygularım?",
    "answer": "Insertion Sort algoritması, diziyi parça parça sıralar. Her yeni elemanı doğru konumuna yerleştirir. Aşağıda bu algoritmanın nasıl uygulanacağı gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, 'Insertion Sort' algoritması ile diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644704"
  },
  {
    "question": "Dizideki negatif ve pozitif sayıları ayrı ayrı sıralamak için bir algoritma nasıl yazılır?",
    "answer": "Dizideki sayıları pozitif ve negatif olarak ayırmak ve sıralamak için iki ayrı sıralama algoritması kullanabilirsiniz. Aşağıdaki kod, 'Bubble Sort' ile bu işlemi gerçekleştirir:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {12, -11, -13, 5, 6, -7};\n    int size = sizeof(arr)/sizeof(arr[0]);\n    int pos[size], neg[size];\n    int posCount = 0, negCount = 0;\n\n    for (int i = 0; i < size; i++) {\n        if (arr[i] >= 0) {\n            pos[posCount++] = arr[i];\n        } else {\n            neg[negCount++] = arr[i];\n        }\n    }\n    bubbleSort(pos, posCount);\n    bubbleSort(neg, negCount);\n\n    printf(\"Pozitif sayılar: \");\n    for (int i = 0; i < posCount; i++)\n        printf(\"%d \", pos[i]);\n    printf(\"\\nNegatif sayılar: \");\n    for (int i = 0; i < negCount; i++)\n        printf(\"%d \", neg[i]);\n\n    return 0;\n}\n```\nBu kod, dizideki pozitif ve negatif sayıları ayırır ve her bir grubu sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:31:15.644731"
  },
  {
    "question": "Bir diziyi sıralamak için quicksort algoritmasını nasıl uygulayabilirim?",
    "answer": "Quicksort, böl ve fethet yaklaşımını kullanan bir sıralama algoritmasıdır. Diziyi pivot elemanına göre iki alt diziye ayırır ve daha sonra bu alt dizileri sıralar. İşte bir örnek uygulama:\n\n```c\n#include <stdio.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; \n    int i = (low - 1);  \n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;    \n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini quicksort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419406"
  },
  {
    "question": "Bir diziyi sıralamak için merge sort algoritmasını nasıl uygularım?",
    "answer": "Merge sort, yine bir böl ve fethet algoritmasıdır. Dizi, alt dizilere bölünür ve her alt dizi sıralandıktan sonra birleştirilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; j = 0; k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, arr_size - 1);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini merge sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419444"
  },
  {
    "question": "Bir diziyi sıralamak için bubble sort algoritmasını nasıl yazabilirim?",
    "answer": "Bubble sort, ardışık elemanları karşılaştırarak ve gerektiğinde takas yaparak diziyi sıralayan basit bir algoritmadır. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++)\n        for (int j = 0; j < n - i - 1; j++)\n            if (arr[j] > arr[j + 1])\n                swap(&arr[j], &arr[j + 1]);\n}\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nYukarıdaki kod, `arr` dizisini bubble sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419467"
  },
  {
    "question": "Bir diziyi sıralamak için selection sort algoritmasını nasıl kullanabilirim?",
    "answer": "Selection sort, her seferinde en küçük (veya en büyük) elemanı bulup dizinin başındaki boş alana yerleştirerek çalışan bir sıralama algoritmasıdır. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++)\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        swap(&arr[min_idx], &arr[i]);\n    }\n}\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini selection sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419490"
  },
  {
    "question": "Radix sort algoritmasını kullanarak bir diziyi nasıl sıralayabilirim?",
    "answer": "Radix sort, rakamları temel alarak sıralama yapan bir algoritmadır. Öncelikle diziyi en düşük basamaktan en yüksek basamağa doğru sıralar. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n]; // Sıralama için çıkış dizisi\n    int count[10] = {0}; // Rakamların sayımı için\n\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > max)\n            max = arr[i];\n\n    for (int exp = 1; max / exp > 0; exp *= 10)\n        countingSort(arr, n, exp);\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    radixSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini radix sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419532"
  },
  {
    "question": "Bir diziyi sıralamak için shell sort algoritmasını nasıl uygularım?",
    "answer": "Shell sort, ardışık elemanları sıralamak için belirli bir aralık (gap) kullanarak sıralama yapan bir algoritmadır. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {12, 34, 54, 2, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    shellSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini shell sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419554"
  },
  {
    "question": "Bir diziyi sıralamak için heap sort algoritmasını nasıl yazabilirim?",
    "answer": "Heap sort, dizi üzerinde ikili arama ağacı (heap) yapısını oluşturarak sıralama yapan bir algoritmadır. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) \n        heapify(arr, n, i);\n\n    for (int i = n - 1; i >= 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini heap sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419577"
  },
  {
    "question": "Bir diziyi sıralamak için counting sort algoritmasını nasıl kullanabilirim?",
    "answer": "Counting sort, belirli bir aralıkta yer alan tam sayıları sıralamak için kullanılan bir algoritmadır. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nvoid countingSort(int arr[], int n) {\n    int output[n]; // Sıralı dizi için çıkış\n    int count[10] = {0}; // Sayma dizisi\n\n    for (int i = 0; i < n; i++)\n        count[arr[i]]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nint main() {\n    int arr[] = {4, 2, 2, 8, 3, 3, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    countingSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, `arr` dizisini counting sort ile sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:32:02.419600"
  },
  {
    "question": "Hızlı sıralama algoritmasını (Quick Sort) C dilinde nasıl implement edersiniz? Örnek bir dizi ile gösterin.",
    "answer": "Hızlı sıralama, böl ve fethet (divide and conquer) stratejisi ile çalışan bir sıralama algoritmasıdır. Aşağıda hızlı sıralama algoritmasının C dilindeki bir implementasyonu bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivot = partition(arr, low, high);\n\n        quickSort(arr, low, pivot - 1);\n        quickSort(arr, pivot + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, bir dizi alır ve hızlı sıralama algoritmasını uygulayarak diziyi sıralar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797450"
  },
  {
    "question": "Bir diziyi birleştirme sıralaması (Merge Sort) algoritması ile sıralayın. Algoritmanın C dilindeki uygulamasını ve çalışma mantığını açıklayın.",
    "answer": "Birleştirme sıralaması, diziyi sürekli olarak iki alt diziye bölüp, bu alt dizileri sıralayıp birleştirerek çalışan bir algoritmadır. Aşağıda Merge Sort'un C dilinde bir uygulaması verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; j = 0; k = l;\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu kod, bir dizi alır, Merge Sort algoritmasını kullanarak sıralar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797524"
  },
  {
    "question": "Seçme sıralama (Selection Sort) algoritmasını kullanarak bir diziyi nasıl sıralarsınız? C dilinde uygulamasını gösterin.",
    "answer": "Seçme sıralama, sıralanmamış dizinin en küçük (veya en büyük) öğesini bulup, bunu sıralanmış alt diziye ekler. Aşağıdaki C kodu, Seçme Sıralama algoritmasını göstermektedir:\n\n```c\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    selectionSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu algoritma, diziyi sıralarken her bir adımda en küçük öğeyi bulur ve yer değiştirir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797560"
  },
  {
    "question": "Kabarcık sıralama (Bubble Sort) algoritmasını C dilinde nasıl yazarsınız? Algoritmanın çalışma mantığını açıklayın.",
    "answer": "Kabarcık sıralama, dizinin ardışık elemanlarını karşılaştırarak çalışır. Eğer elemanlar yanlış sıradaysa, yer değiştirir ve dizinin sonunda en büyük eleman 'kabarcık' gibi su yüzeyine çıkar. Aşağıda C dilinde Kabarcık Sıralama algoritması verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    bubbleSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nKabarcık sıralama, basit ama etkili bir yöntemdir; ancak büyük diziler için verimsizdir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797593"
  },
  {
    "question": "Yığın sıralama (Heap Sort) algoritmasını C dilinde nasıl uygularsınız? Algoritmanın adımlarını açıklayın.",
    "answer": "Yığın sıralama, bir dizi oluşturulup bu dizideki en büyük öğe alınarak sıralama yapar. Yığın yapısını kullanır. Aşağıda C dilinde Yığın Sıralama algoritması verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        int swap = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = swap;\n\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) \n        heapify(arr, n, i);\n\n    for (int i = n - 1; i >= 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    heapSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nBu algoritmanın çalışma mantığı, diziyi önce bir yığın haline getirmek ve ardından sıralamaktır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797634"
  },
  {
    "question": "Hesaplama kaynaklarını optimize etmek için bir dizi üzerinde sıralama yaparken Timsort algoritmasını C dilinde nasıl uygularsınız?",
    "answer": "Timsort, hem birleştirme hem de sıralama metodlarını kullanan bir sıralama algoritmasıdır. Aşağıda Timsort'un basit bir implementasyonu verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define RUN 32\n\nvoid insertionSort(int arr[], int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int len1 = mid - left + 1, len2 = right - mid;\n    int leftArr[len1], rightArr[len2];\n\n    for (int i = 0; i < len1; i++)\n        leftArr[i] = arr[left + i];\n    for (int i = 0; i < len2; i++)\n        rightArr[i] = arr[mid + 1 + i];\n\n    int i = 0, j = 0, k = left;\n    while (i < len1 && j < len2) {\n        if (leftArr[i] <= rightArr[j]) {\n            arr[k++] = leftArr[i++];\n        } else {\n            arr[k++] = rightArr[j++];\n        }\n    }\n    while (i < len1)\n        arr[k++] = leftArr[i++];\n    while (j < len2)\n        arr[k++] = rightArr[j++];\n}\n\nvoid timSort(int arr[], int n) {\n    for (int i = 0; i < n; i += RUN)\n        insertionSort(arr, i, fmin(i + RUN - 1, n - 1));\n\n    for (int size = RUN; size < n; size *= 2) {\n        for (int left = 0; left < n; left += 2 * size) {\n            int mid = fmin(left + size - 1, n - 1);\n            int right = fmin((left + 2 * size - 1), (n - 1));\n            if (mid < right)\n                merge(arr, left, mid, right);\n        }\n    }\n}\n\nint main() {\n    int arr[] = {5, 21, 7, 23, 19};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    timSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nTimsort, özellikle büyük veri setleri üzerinde optimize edilmiş performans sunar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797668"
  },
  {
    "question": "Bir diziyi karşılaştırma sıralaması olmadan sıralamak için Radix Sıralama algoritmasını nasıl uygularsınız? C dilinde örnek verin.",
    "answer": "Radix sıralama, sayıları basamaklarına göre sıralayan bir algoritmadır. Aşağıda Radix Sıralama algoritmasının C dilindeki bir implementasyonu verilmiştir:\n\n```c\n#include <stdio.h>\n\n#define MAX 1000\n#define EXP 10\n\nvoid countingSort(int arr[], int size, int exp) {\n    int output[size];\n    int count[EXP] = {0};\n\n    for (int i = 0; i < size; i++)\n        count[(arr[i] / exp) % EXP]++;\n\n    for (int i = 1; i < EXP; i++)\n        count[i] += count[i - 1];\n\n    for (int i = size - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % EXP] - 1] = arr[i];\n        count[(arr[i] / exp) % EXP]--;\n    }\n\n    for (int i = 0; i < size; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++)\n        if (arr[i] > max)\n            max = arr[i];\n\n    for (int exp = 1; max / exp > 0; exp *= 10)\n        countingSort(arr, size, exp);\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    radixSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nRadix sıralama, sayıları basamaklarına göre sıraladığı için sayılar üzerinde doğrudan karşılaştırma yapmaz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797703"
  },
  {
    "question": "Sıralama algoritmalarından biri olan Cocktail Sort algoritmasını C dilinde nasıl uygularsınız? Çalışma mantığını açıklayın.",
    "answer": "Cocktail Sort, Kabarcık Sıralamanın bir varyantıdır; diziyi iki yönde sıralar. Aşağıda C dilinde Cocktail Sort algoritmasının bir implementasyonu verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid cocktailSort(int arr[], int n) {\n    int swapped = 1;\n    int start = 0, end = n - 1;\n\n    while (swapped) {\n        swapped = 0;\n\n        for (int i = start; i < end; i++) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                swapped = 1;\n            }\n        }\n\n        if (!swapped)\n            break;\n\n        swapped = 0;\n        end--;\n\n        for (int i = end - 1; i >= start; i--) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                swapped = 1;\n            }\n        }\n        start++;\n    }\n}\n\nint main() {\n    int arr[] = {5, 1, 4, 2, 8};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    cocktailSort(arr, n);\n\n    printf(\"Sıralanmış dizi: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n```\nCocktail Sort, diziyi hem ileri hem de geri sıralayarak daha verimli hale gelir. Bu durum, sıralama esnasında elemanların daha hızlı yer değiştirmesini sağlar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:33:16.797736"
  },
  {
    "question": "Bubble Sort algoritması nasıl optimize edilebilir?",
    "answer": "Bubble Sort algoritması, sıradaki elemanları karşılaştırarak ve gerektiğinde takas yaparak çalışır. Ancak, her döngü sonunda dizi sıralı hale geliyorsa, gereksiz döngülere girmemek için bir bayrak (flag) kullanarak optimize edebiliriz. Eğer bir döngü sırasında takas yapılmazsa, dizinin sıralı olduğunu anlayabiliriz ve döngüyü sonlandırabiliriz.\n\nÖrnek kod:\n```c\nvoid optimizedBubbleSort(int arr[], int n) {\n    int i, j, temp;\n    int swapped;\n    for (i = 0; i < n - 1; i++) {\n        swapped = 0;\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = 1;\n            }\n        }\n        if (swapped == 0) break;\n    }\n}\n```\nBu şekilde, gereksiz döngüleri önleyerek performansı artırmış oluyoruz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781046"
  },
  {
    "question": "Selection Sort algoritmasında zaman karmaşıklığını nasıl iyileştirebiliriz?",
    "answer": "Selection Sort algoritması, her geçen döngüde minimum elemanı bulur ve onunla takas yapar. Ancak, bu işlem her seferinde dizinin tamamını taradığı için O(n^2) zaman karmaşıklığına sahiptir. Zaman karmaşıklığını iyileştirmek için, dizinin sıralı olup olmadığını kontrol ederek, zaten sıralı olan kısımlarda takas yapılmasını engelleyebiliriz. Bu, algoritmanın pratikte daha hızlı çalışmasını sağlar.\n\nÖrnek kod:\n```c\nvoid optimizedSelectionSort(int arr[], int n) {\n    int i, j, minIdx;\n    int sorted = 1;\n    for (i = 0; i < n - 1; i++) {\n        minIdx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIdx]) {\n                minIdx = j;\n                sorted = 0;\n            }\n        }\n        if (sorted) break;\n        int temp = arr[minIdx];\n        arr[minIdx] = arr[i];\n        arr[i] = temp;\n    }\n}\n```\nBu şekilde, dizinin sıralı kısımlarında ekstra işlemler yapmamış oluyoruz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781088"
  },
  {
    "question": "Insertion Sort'un çalışma prensibi ve en iyi durum senaryosu nedir?",
    "answer": "Insertion Sort, her bir elemanı sıralı bir alt dizi içine yerleştirerek çalışır. En iyi durum senaryosu, dizinin zaten sıralı olduğu durumdur. Bu durumda, her eleman doğrudan yerinde kalır ve algoritma O(n) zaman karmaşıklığına sahip olur. Kodunuzu daha performanslı hale getirmek için, bu durumu kontrol eden bir bayrak ekleyebiliriz.\n\nÖrnek kod:\n```c\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n```\nBurada, dizinin sıralı olduğu durumlarda dış döngüdeki adımlar en aza indirilmiş olur.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781114"
  },
  {
    "question": "Quick Sort algoritmasında 'pivot' seçimi neden önemlidir?",
    "answer": "Quick Sort algoritmasında pivot seçimi, algoritmanın verimliliği üzerinde büyük bir etkiye sahiptir. Uygun bir pivot seçilmezse, algoritmanın zaman karmaşıklığı O(n^2) olabilir. En iyi sonuçlar için pivot, dizinin ortasından veya rastgele bir noktadan seçilebilir. Ayrıca, 'median-of-three' tekniği kullanılarak ilk, orta ve son elemanlar arasındaki medyan seçilebilir.\n\nÖrnek kod:\n```c\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Son elemanı pivot olarak seç\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n```\nBu şekilde, uygun bir pivot ile daha dengeli bölmeler elde edebiliriz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781136"
  },
  {
    "question": "Merge Sort algoritmasının avantajları nelerdir?",
    "answer": "Merge Sort, O(n log n) zaman karmaşıklığına sahip olduğu için büyük veri setleri üzerinde etkili bir sıralama algoritmasıdır. Ayrıca, kararlı bir algoritmadır, yani eşit elemanların sıralanmasında orijinal sıralama korunur. Ayrıca, diziler yerine bağlı listelerle de çalışabilir. Bununla birlikte, ek bellek kullanımı gerektirdiği için hafıza kısıtlamaları olan durumlarda dikkatli kullanılmalıdır.\n\nÖrnek kod:\n```c\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    i = 0; j = 0; k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++; k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++; k++;\n    }\n}\n```\nBu kod ile birlikte Merge Sort'un temel mantığını görebiliriz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781153"
  },
  {
    "question": "Heapsort algoritması nasıl çalışır ve avantajları nelerdir?",
    "answer": "Heapsort, bir dizi elemanını önce bir ikili yığın (heap) yapısına dönüştürerek ve ardından en büyük (veya en küçük) elemanları çıkararak çalışır. O(n log n) zaman karmaşıklığına sahiptir ve yerinde sıralama yapar. Ayrıca, kararlı bir algoritma değildir, ancak bellek kullanımı bakımından verimlidir. Bir dezavantajı, uygulaması için karmaşık yapıya ihtiyaç duymasıdır.\n\nÖrnek kod:\n```c\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n```\nBu kod, Heapsort algoritmasının yığın yapısını oluşturan 'heapify' fonksiyonunu temsil eder.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781174"
  },
  {
    "question": "Counting Sort algoritması hangi durumlarda kullanılmalıdır?",
    "answer": "Counting Sort, elemanların belirli bir aralıkta sayıldığı ve sıralama işlemine dayandığı bir algoritmadır. Bu algoritmanın en büyük avantajı, O(n + k) zaman karmaşıklığına sahip olmasıdır. Ancak, sadece belirli aralıkta sayılabilir veriler için uygundur (örneğin, 0-100 arası tam sayılar). Ayrıca, bellek kullanımı açısından da dikkatli olunmalıdır. Uygun durumlar arasında, tam sayıları sıralamak veya belirli bir aralıkta sınırlı veri setleri bulunur.\n\nÖrnek kod:\n```c\nvoid countingSort(int arr[], int n, int k) {\n    int output[n];\n    int count[k + 1];\n    for (int i = 0; i <= k; ++i)\n        count[i] = 0;\n    for (int i = 0; i < n; ++i)\n        count[arr[i]]++;\n    for (int i = 1; i <= k; ++i)\n        count[i] += count[i - 1];\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n```\nBu kod, Counting Sort algoritmasını uygulamak için kullanılabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781193"
  },
  {
    "question": "Radix Sort algoritmasının çalışma mantığı nedir?",
    "answer": "Radix Sort, rakamların sıralanmasına dayalı bir algoritmadır ve genellikle tam sayılar için kullanılır. Bu algoritma, en düşük basamaktan başlayarak her basamağı sıralar. Örneğin, önce birler, ardından onlar, yüzler vb. sırayla işlem yapılır. Bu yöntem, O(nk) zaman karmaşıklığına sahip olup, k basamak sayısıdır. Radix Sort, Counting Sort veya Bucket Sort gibi bir alt algoritmayı kullanır.\n\nÖrnek kod:\n```c\nvoid countingSortForRadix(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n```\nBu şekilde, Radix Sort'un temel işleyişini görebiliriz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781212"
  },
  {
    "question": "Shell Sort algoritması, Insertion Sort'tan nasıl farklıdır?",
    "answer": "Shell Sort, Insertion Sort'un bir genelleştirilmiş versiyonudur. Temel fark, diziyi belirli aralıklarla (gap) sıralayarak başlar. Bu, elemanların birbirine daha yakın olduğu durumlarda daha hızlı sıralama yapabilmesini sağlar. Shell Sort, O(n log n) ile O(n^2) arasında bir zaman karmaşıklığına sahiptir. Bu nedenle, büyük veri setlerinde Insertion Sort'tan daha hızlı çalışır.\n\nÖrnek kod:\n```c\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n```\nBu kod, Shell Sort algoritmasının temel işleyişini göstermektedir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:08.781232"
  },
  {
    "question": "Quick sort algoritmasını kullanarak büyük bir dizi sıralamak istiyorum. Ancak, pivot seçimi konusunda bir sorun yaşıyorum. Bu durumu nasıl optimize edebilirim?",
    "answer": "Pivot seçimi, quick sort algoritmasının performansını büyük ölçüde etkiler. En iyi performans için, genellikle \"median of three\" stratejisini kullanmalısınız; bu strateji, dizinin ilk, ortadaki ve son elemanlarının ortalamasını alır. Bu şekilde, dizinin sıralı olup olmamasına bağlı olarak en kötü durum senaryosunu minimize edebilirsiniz. Ayrıca, küçük alt diziler için insertion sort kullanarak performansı artırabilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624476"
  },
  {
    "question": "Merge sort algoritmasını C dilinde uygulamak istiyorum fakat bellek yönetimi konusunda sorun yaşıyorum. Bu durumu nasıl yönetebilirim?",
    "answer": "Merge sort, genellikle O(n log n) karmaşıklığına sahip olmasına rağmen, ek bellek kullanır. Bu durumu yönetmek için, sıralama işlemi sırasında dizi kopyalamak yerine, dizi içindeki elemanların yerlerini değiştirmek üzere 'in-place' bir merge sort uygulaması düşünebilirsiniz. Bu, daha karmaşık bir algoritma gerektirse de, bellek kullanımını önemli ölçüde azaltabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624558"
  },
  {
    "question": "Hızlı sıralama algoritmasının en kötü durum senaryosunu nasıl iyileştirebilirim?",
    "answer": "Hızlı sıralama algoritmasının en kötü durumu, dizinin sıralı olduğu veya ters sıralı olduğu durumlarda ortaya çıkar. Bunun önüne geçmek için, pivot seçimini rastgele yapmayı deneyebilirsiniz. Ayrıca, dizinin boyutu küçük olduğunda insertion sort kullanmak da performansı artırabilir. Bu ikisi, en kötü durum senaryolarını azaltacaktır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624586"
  },
  {
    "question": "Bir diziyi sıralamak için radix sort kullanmaya çalışıyorum, ancak bu algoritmanın çalışma mantığını tam olarak anlamıyorum. Radix sort nasıl çalışır?",
    "answer": "Radix sort, sayıların her bir basamağını sıralayarak çalışır. Öncelikle, en düşük basamaktan başlayarak, her bir basamağa göre 'counting sort' uygulayarak sıralama yapılır. Bu işlem, sayının en yüksek basamağına ulaşana kadar devam eder. Bu yöntem, sabit uzunlukta sayılar için oldukça etkilidir, çünkü O(n) zaman karmaşıklığına sahiptir. Ancak, sayının basamak sayısına bağlı olarak bellek kullanımı artabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624634"
  },
  {
    "question": "Heap sort algoritmasını uygularken performans sorunları yaşıyorum. Bu durumu nasıl optimize edebilirim?",
    "answer": "Heap sort, O(n log n) zaman karmaşıklığına sahiptir, ancak bellek erişim verimliliği sorunları yaşanabilir. Performansı artırmak için, dizi üzerinde heap yapısını oluşturan 'build_heap' aşamasında, sellere doğrudan erişim yerine, ebeveyn ve çocuklar arasındaki ilişkileri optimize edebilirsiniz. Ayrıca, heapify işlemini iteratif olarak yapmak, bazı durumlarda daha iyi performans sağlayabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624663"
  },
  {
    "question": "Bubble sort algoritmasının gereksiz döngülerden kurtulmasını istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Bubble sort algoritmasında, her iç döngüde, hiçbir değişiklik yapılmadığında sıralamanın tamamlandığını anlayarak döngüyü kırmak için bir 'flag' kullanabilirsiniz. Bu sayede, gereksiz döngülerden kaçınarak algoritmanın ortalama performansını artırabilirsiniz. 'flag' değişkeni, iç döngüde bir değişiklik yapıldığında true olur ve eğer döngü sonunda değişiklik olmamışsa dış döngüden çıkılır.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624690"
  },
  {
    "question": "Counting sort algoritmasını kullanarak büyük bir dizi sıralamak istiyorum, ancak dizi elemanlarının aralığı çok büyük. Bu durumu nasıl optimize edebilirim?",
    "answer": "Counting sort, dizi elemanlarının aralığına bağlı olarak bellek kullanımında sorun yaşayabilir. Bunun için, elemanların aralıklarını daraltmak üzere 'offset' kullanabilirsiniz. Eğer elemanlarınıza belirli bir aralıkla erişebiliyorsanız, bu aralığı normalize ederek belleği daha verimli kullanabilirsiniz. Ayrıca, daha büyük diziler için, counting sort'un yerine daha verimli sıralama algoritlarını değerlendirmeniz faydalı olabilir.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624734"
  },
  {
    "question": "Sıralama algoritmalarını karşılaştırmak için bir test senaryosu oluşturmak istiyorum. Hangi kriterlere odaklanmalıyım?",
    "answer": "Sıralama algoritmlarını karşılaştırırken odaklanmanız gereken birkaç önemli kriter vardır: zaman karmaşıklığı (en iyi, ortalama ve en kötü durum), bellek kullanımı (in-place olup olmadığı), stabilite (eşit elemanların sıralaması), ve veri setinin boyutu. Ayrıca, farklı veri dağılımları (rastgele, sıralı, ters sıralı) ile test etmek de performanslarını anlamanızı kolaylaştırır. İyi yapılandırılmış bir test senaryosu, bu kriterleri baz alarak çeşitli algoritmaların sonuçlarını karşılaştırmanızı sağlar.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624765"
  },
  {
    "question": "Shell sort algoritmasının C dilindeki uygulamasında performansı nasıl artırabilirim?",
    "answer": "Shell sort algoritmasında performansı artırmak için, boşluk (gap) değerlerini dikkatli bir şekilde seçmelisiniz. Farklı boşluk dizileri kullanarak sıralama performansını artırabilirsiniz; örneğin, Hibbard veya Sedgewick boşluk dizileri sıklıkla daha iyi sonuçlar verir. Ayrıca, iç döngüde kullanılan sıralama algoritmasını da değiştirebilir, örneğin insertion sort kullanarak daha iyi sonuçlar elde edebilirsiniz.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624789"
  },
  {
    "question": "Sıralama algoritmalarını optimize etmek için hangi genel prensipleri izlemeliyim?",
    "answer": "Sıralama algoritmalarını optimize etmek için birkaç genel prensip izleyebilirsiniz: öncelikle, algoritmanın karmaşıklığını ve bellek kullanımını göz önünde bulundurun; ikinci olarak, veri setinizin özelliklerini (büyüklük, sıralı olup olmadığı) analiz edin ve uygun algoritmayı seçin; üçüncü olarak, algoritmanın içindeki sabitleri ve döngüleri azaltmaya çalışın; son olarak, algoritmayı gerçek veri üzerinde test ederek performansını sürekli olarak değerlendirin ve dönüştürün.",
    "category": "data_structures",
    "topic": "sorting",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Sıralama algoritmaları",
    "timestamp": "2025-06-01T16:34:34.624812"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak bir dizide lineer arama algoritmasını uygulayın. int linearSearch(int arr[], int n, int x) { /* kod burada */ }",
    "answer": "int linearSearch(int arr[], int n, int x) { \n    for (int i = 0; i < n; i++) { \n        if (arr[i] == x) \n            return i; \n    } \n    return -1; \n} \n\nAçıklama: Bu kod, verilen dizinin her bir elemanını kontrol eder ve aranan değeri bulursa indeksini döner. Eğer değer bulunamazsa -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669601"
  },
  {
    "question": "Aşağıdaki eksik kodu tamamlayarak bir dizide ikili arama algoritmasını uygulayın. int binarySearch(int arr[], int left, int right, int x) { /* kod burada */ }",
    "answer": "int binarySearch(int arr[], int left, int right, int x) { \n    while (left <= right) { \n        int mid = left + (right - left) / 2; \n        if (arr[mid] == x) \n            return mid; \n        if (arr[mid] < x) \n            left = mid + 1; \n        else \n            right = mid - 1; \n    } \n    return -1; \n} \n\nAçıklama: Bu algoritma, sıralı bir dizide aranan değeri bulmak için kullanılır. Her seferinde dizinin ortasını kontrol eder ve aranan değerin hangi yarıda olduğunu belirleyerek arama alanını daraltır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669665"
  },
  {
    "question": "Verilen dizide belirli bir elemanı bulmak için eksik kodu tamamlayın. void findElement(int arr[], int size, int element) { /* kod burada */ }",
    "answer": "void findElement(int arr[], int size, int element) { \n    for (int i = 0; i < size; i++) { \n        if (arr[i] == element) { \n            printf(\"Element found at index: %d\\n\", i); \n            return; \n        } \n    } \n    printf(\"Element not found\\n\"); \n} \n\nAçıklama: Bu fonksiyon, verilen dizide aranan elemanı bulmaya çalışır ve bulursa indeksini yazdırır, aksi takdirde 'Element not found' mesajını gösterir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669708"
  },
  {
    "question": "Aşağıdaki eksik kodda verilen dizide arama yapmak için bir döngü ekleyin. int search(int arr[], int n, int x) { /* döngü burada */ }",
    "answer": "int search(int arr[], int n, int x) { \n    for (int i = 0; i < n; i++) { \n        if (arr[i] == x) \n            return i; \n    } \n    return -1; \n} \n\nAçıklama: Bu kod, bir dizide lineer arama yapmak için bir döngü kullanır. Eleman bulunduğunda indeksi döner, bulunamazsa -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669751"
  },
  {
    "question": "Aşağıdaki eksik kodda diziyi sıraladıktan sonra ikili arama yapın. void sortAndSearch(int arr[], int n, int x) { /* sıralama ve arama burada */ }",
    "answer": "void sortAndSearch(int arr[], int n, int x) { \n    // Sıralama \n    for (int i = 0; i < n-1; i++) { \n        for (int j = 0; j < n-i-1; j++) { \n            if (arr[j] > arr[j+1]) { \n                int temp = arr[j]; \n                arr[j] = arr[j+1]; \n                arr[j+1] = temp; \n            } \n        } \n    } \n    int result = binarySearch(arr, 0, n-1, x); \n    if (result != -1) \n        printf(\"Element found at index: %d\\n\", result); \n    else \n        printf(\"Element not found\\n\"); \n} \n\nAçıklama: Bu kod, önce diziyi sıralar ve ardından sıralanan dizide ikili arama yapar. Bulunan elemanın indeksini veya bulunamadığını belirtir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669796"
  },
  {
    "question": "Aşağıdaki eksik kodda verilen bir dizide aranan sayının kaç kez geçtiğini bulun. int countOccurrences(int arr[], int n, int x) { /* kod burada */ }",
    "answer": "int countOccurrences(int arr[], int n, int x) { \n    int count = 0; \n    for (int i = 0; i < n; i++) { \n        if (arr[i] == x) \n            count++; \n    } \n    return count; \n} \n\nAçıklama: Bu fonksiyon, dizide aranan elemanın kaç kez geçtiğini sayar ve sonucu döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669840"
  },
  {
    "question": "Aşağıdaki eksik kodda verilen dizide arama yaparken aynı zamanda en yüksek değeri bulun. void findMaxAndSearch(int arr[], int n, int x) { /* kod burada */ }",
    "answer": "void findMaxAndSearch(int arr[], int n, int x) { \n    int max = arr[0]; \n    int found = 0; \n    for (int i = 0; i < n; i++) { \n        if (arr[i] > max) \n            max = arr[i]; \n        if (arr[i] == x) \n            found = 1; \n    } \n    printf(\"Max value: %d\\n\", max); \n    if (found) \n        printf(\"Element found\\n\"); \n    else \n        printf(\"Element not found\\n\"); \n} \n\nAçıklama: Bu kod, dizide hem arama yapar hem de en yüksek değeri bulur. En yüksek değeri yazdırır ve aranan elemanın bulunup bulunmadığını belirtir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669892"
  },
  {
    "question": "Aşağıdaki eksik kodda dizide aranan elemanın indeksini ve bulunduğu eleman sayısını döndüren bir fonksiyon yazın. void searchAndCount(int arr[], int n, int x) { /* kod burada */ }",
    "answer": "void searchAndCount(int arr[], int n, int x) { \n    int index = -1; \n    int count = 0; \n    for (int i = 0; i < n; i++) { \n        if (arr[i] == x) { \n            index = i; \n            count++; \n        } \n    } \n    printf(\"Index: %d, Count: %d\\n\", index, count); \n} \n\nAçıklama: Bu fonksiyon, dizide aranan elemanın indeksini ve toplam kaç kez bulunduğunu döner. Eğer eleman bulunamazsa -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669945"
  },
  {
    "question": "Aşağıdaki eksik kodda dizinin ortasındaki elemanı bulmak için bir arama fonksiyonu yazın. int findMiddle(int arr[], int n) { /* kod burada */ }",
    "answer": "int findMiddle(int arr[], int n) { \n    if (n % 2 == 0) \n        return -1; // çift sayıda eleman varsa ortası yoktur \n    return arr[n / 2]; \n} \n\nAçıklama: Bu fonksiyon, dizinin ortasındaki elemanı bulur. Eğer dizi çift sayıda elemana sahipse -1 döner.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:02.669987"
  },
  {
    "question": "Bir dizi içinde bir elemanın binary search algoritması ile nasıl aranacağını gösteren eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Sağ yarıya git\n        } else {\n            right = mid - 1; // Sol yarıya git\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 4;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, sıralı bir dizide binary search (ikili arama) algoritmasını kullanarak verilen hedef elemanı bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.536857"
  },
  {
    "question": "Bir bağlı listede aranacak bir elemanın bulunabilmesi için eksik olan kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint searchList(struct Node* head, int target) {\n    struct Node* current = head;\n    while (current != NULL) {\n        if (current->data == target) {\n            return 1; // Eleman bulundu\n        }\n        current = current->next;\n    }\n    return 0; // Eleman bulunamadı\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    int target = 2;\n    if (searchList(head, target)) {\n        printf(\"Eleman bulundu.\\n\");\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, bağlı liste içinde belirtilen hedef değeri bulmak için bir arama fonksiyonu tanımlamaktadır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.536927"
  },
  {
    "question": "Bir dizide sıralama ve ardından sıralı arama yapacak eksik kodu tamamlayın. (Bubble sort ve binary search kullanın)",
    "answer": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, size);\n    int target = 22;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, önce diziyi 'bubble sort' ile sıralar, ardından 'binary search' aracılığıyla hedef elemanı arar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.536989"
  },
  {
    "question": "Bir dizide eleman ararken, bir rekurzif (özyinelemeli) yaklaşım kullanarak eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint recursiveBinarySearch(int arr[], int left, int right, int target) {\n    if (right >= left) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] > target) {\n            return recursiveBinarySearch(arr, left, mid - 1, target); // Sol yarı\n        }\n        return recursiveBinarySearch(arr, mid + 1, right, target); // Sağ yarı\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = recursiveBinarySearch(arr, 0, size - 1, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, verilen dizide rekurzif bir binary search algoritması ile hedef elemanı arar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.537040"
  },
  {
    "question": "Dizi elemanlarının sıralı olduğunu varsayarak, linear search algoritmasının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Eleman bulundu\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 30;\n    int result = linearSearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, sıralı bir dizide linear search (doğrusal arama) algoritmasını kullanarak belirtilen hedef elemanı bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.537090"
  },
  {
    "question": "Bir dizi içinde döngüsel binary search algoritmasının eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n\nint iterativeBinarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 7;\n    int result = iterativeBinarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, bir dizide döngüsel binary search algoritması kullanarak hedef elemanı arar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.537134"
  },
  {
    "question": "Bir dizide en yüksek değeri bulmak için eksik olan kodu ekleyin ve ardından bu değeri aramak için binary search kullanın.",
    "answer": "#include <stdio.h>\n\nint findMax(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {5, 1, 8, 12, 3};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int max = findMax(arr, size);\n    printf(\"En yüksek değer: %d\\n\", max);\n    int result = binarySearch(arr, size, max);\n    if (result != -1) {\n        printf(\"En yüksek değer %d dizinin %d. indeksinde bulundu.\\n\", max, result);\n    } else {\n        printf(\"En yüksek değer bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, dizideki en yüksek değeri bulur ve ardından bu değeri binary search ile arar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.537194"
  },
  {
    "question": "Bir dizi içinde tüm elemanları sıraladıktan sonra, herhangi bir elemanı aramak için eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivot = partition(arr, low, high);\n        quickSort(arr, low, pivot - 1);\n        quickSort(arr, pivot + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return i + 1;\n}\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {10, 80, 30, 90, 40, 50, 70};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, size - 1);\n    int target = 30;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod önce quick sort ile diziyi sıralar, ardından binary search ile hedef elemanı arar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:35:53.537245"
  },
  {
    "question": "Binary search algoritmasını tamamlayın. Aşağıdaki eksik kodu tamamlayın:",
    "answer": "```c\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Hedef bulundu\n        } else if (arr[mid] < target) {\n            left = mid + 1; // Sağ yarıya geç\n        } else {\n            right = mid - 1; // Sol yarıya geç\n        }\n    }\n    return -1; // Hedef bulunamadı\n}\n``` Bu kod, sıralı bir dizide hedef öğeyi bulmak için ikili arama algoritmasını gerçekleştirmektedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636591"
  },
  {
    "question": "Bir diziyi sıralayıp ardından ikili arama ile bir elemanın varlığını kontrol eden eksik kodu tamamlayın:",
    "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\nsort(int *array, int size) {\n    // Sıralama algoritması burada uygulanacak\n}\n\nint binarySearch(int arr[], int size, int target) {\n    // Yukarıdaki binarySearch fonksiyonu kullanılacak\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 4, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    sort(arr, size); // Diziyi sırala\n    int target = 4;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Hedef %d, dizide bulundu.\\n\", target);\n    } else {\n        printf(\"Hedef %d, dizide bulunamadı.\\n\", target);\n    }\n    return 0;\n}\n``` Burada, diziyi sıralamak için bir sıralama fonksiyonu ve ardından ikili arama uygulayan bir ana program tamamlanmalıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636645"
  },
  {
    "question": "Verilen dizide bir elemanın kaç kez tekrarlandığını bulmak için eksik kodu tamamlayın:",
    "answer": "```c\nint countOccurrences(int arr[], int size, int target) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}\n``` Bu fonksiyon, verilen dizide hedef öğenin kaç kez bulunduğunu sayar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636673"
  },
  {
    "question": "Diziyi tersine çevirdikten sonra, belirli bir elemanı bulmak için eksik kodu tamamlayın:",
    "answer": "```c\nvoid reverseArray(int arr[], int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - i - 1];\n        arr[size - i - 1] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, size);\n    int target = 3;\n    int result = binarySearch(arr, size, target);\n    // Sonuç kontrolü burada yapılacak\n}\n``` Burada, diziyi tersine çevirmek için bir fonksiyon ve ardından ikili arama kullanılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636701"
  },
  {
    "question": "Verilen bir diziyi sıraladıktan sonra, en küçük ve en büyük elemanı bulmak için eksik kodu tamamlayın:",
    "answer": "```c\n#include <limits.h>\nvoid findMinMax(int arr[], int size, int *min, int *max) {\n    *min = INT_MAX;\n    *max = INT_MIN;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        }\n        if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}\n``` Bu fonksiyon, dizinin en küçük ve en büyük elemanlarını bulmak için kullanılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636733"
  },
  {
    "question": "Bir dizideki elemanları sıraladıktan sonra, sıralı diziyi kullanarak ikili arama uygulayın:",
    "answer": "```c\nvoid bubbleSort(int arr[], int size) {\n    for(int i = 0; i < size - 1; i++) {\n        for(int j = 0; j < size - i - 1; j++) {\n            if(arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, size);\n    int target = 13;\n    int result = binarySearch(arr, size, target);\n    // Sonuç kontrolü burada yapılacak\n}\n``` Burada, balon sıralama algoritması ile diziyi sıralayıp ardından ikili arama yapılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636760"
  },
  {
    "question": "Bir dizi içindeki tekrarlayan elemanları bulmak için eksik kodu tamamlayın:",
    "answer": "```c\nvoid findDuplicates(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (arr[i] == arr[j]) {\n                printf(\"%d, dizide tekrar ediyor.\\n\", arr[i]);\n            }\n        }\n    }\n}\n``` Bu fonksiyon, verilen dizideki tekrar eden elemanları bulmak için iki döngü kullanır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636783"
  },
  {
    "question": "Verilen bir dizide ikili arama algoritması ile hedef sayıyı bulmak için gerekli olan eksik kodu tamamlayın:",
    "answer": "```c\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {2, 4, 6, 8, 10};\n    int target = 6;\n    int result = binarySearch(arr, sizeof(arr)/sizeof(arr[0]), target);\n    // Sonuç kontrolü burada yapılacak\n}\n``` Bu kod, verilen bir dizide hedef sayıyı bulmak için ikili arama algoritmasını uygular.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636816"
  },
  {
    "question": "Bir dizide en çok tekrar eden elemanı bulmak için eksik kodu tamamlayın:",
    "answer": "```c\nint mostFrequent(int arr[], int size) {\n    int maxCount = 0, maxValue;\n    for (int i = 0; i < size; i++) {\n        int count = 0;\n        for (int j = 0; j < size; j++) {\n            if (arr[j] == arr[i]) {\n                count++;\n            }\n        }\n        if (count > maxCount) {\n            maxCount = count;\n            maxValue = arr[i];\n        }\n    }\n    return maxValue;\n}\n``` Bu fonksiyon, verilen dizide en çok tekrar eden elemanı bulmak için kullanılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:23.636840"
  },
  {
    "question": "Bir dizi içinde belirli bir sayıyı bulmak için yazılmış bir lineer arama fonksiyonunda neden her elemanı kontrol ediyorum?",
    "answer": "Lineer arama algoritması, dizinin her elemanını sırayla kontrol ederek belirli bir sayıyı bulmaya çalışır. Eğer dizi sıralı değilse, bu yöntem en basit ve doğrudan yoldur. Ancak, en kötü durum senaryosunda O(n) zaman karmaşıklığına sahiptir. Eğer dizi sıralı olsaydı, ikili arama algoritmasını kullanmak daha verimli olurdu.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660501"
  },
  {
    "question": "İkili arama algoritması neden yalnızca sıralı dizilerde çalışır?",
    "answer": "İkili arama algoritması, dizinin ortasındaki öğeyi kontrol ederek arama alanını yarıya indirir. Bu, dizinin sıralı olmasını gerektirir, çünkü sıralı olmayan bir dizide, ortadaki eleman, aradığınız değerin konumunu tahmin edemez. Bu yüzden, sıralı bir dizide daha hızlı sonuç alabilirsiniz; zaman karmaşıklığı O(log n) olur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660580"
  },
  {
    "question": "Aşağıdaki kodda hata nedir? `int linearSearch(int arr[], int size, int target) { for(int i = 0; i <= size; i++) { if(arr[i] == target) return i; } return -1; }`",
    "answer": "Döngü koşulu `i <= size` yerine `i < size` olmalıdır. Çünkü dizinin boyutu `size` olduğunda, dizinin son elemanına erişim `size-1` indeksindedir. `i <= size` kullanırsanız, dizinin sınırlarının dışına çıkıp belirsiz bir bellek alanına erişmeye çalışırsınız, bu da programın çökmesine yol açabilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660642"
  },
  {
    "question": "İkili arama algoritmasının uygulamasında `mid` değişkeninin doğru hesaplanmaması neye yol açar?",
    "answer": "Eğer `mid` değişkenini hesaplamak için `mid = (left + right) / 2` kullanırsanız, `left` ve `right` çok büyük sayılar ise taşma (overflow) riski vardır. Bunun yerine `mid = left + (right - left) / 2` şeklinde yazmak daha güvenlidir. Bu, taşma riskini ortadan kaldırır ve doğru orta noktayı bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660681"
  },
  {
    "question": "Bir dizideki tüm indekslerdeki belirli bir elemanı bulmak için lineer arama yaparken, hangi durumda en kötü performansı görürüm?",
    "answer": "En kötü performans, aranan elemanın dizinin son elemanında olduğu veya dizide hiç bulunmadığı durumlarda ortaya çıkar. Bu durumlarda, lineer arama bütün diziyi kontrol etmek zorunda kalır ve zaman karmaşıklığı O(n) olur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660728"
  },
  {
    "question": "Dizinin sıralı olup olmadığını kontrol etmek için yazılmış bir kodda hata varsa ne olabilir? `bool isSorted(int arr[], int size) { for(int i = 0; i <= size; i++) { if(arr[i] > arr[i+1]) return false; } return true; }`",
    "answer": "Döngü koşulu `i <= size` yerine `i < size - 1` olmalıdır. Çünkü dizinin son elemanını kontrol ederken, `arr[i+1]` ifadesi dizinin sınırlarını aşar ve belirsiz bir bellek alanına erişim sağlanır. Bu da programın çökmesine yol açar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660800"
  },
  {
    "question": "İkili arama algoritması ile ilgili aşağıdaki kodda hata nedir? `int binarySearch(int arr[], int left, int right, int target) { if(left <= right) { int mid = (left + right) / 2; if(arr[mid] == target) return mid; else if(arr[mid] < target) return binarySearch(arr, mid + 1, right, target); else return binarySearch(arr, left, mid - 1, target); } return -1; }`",
    "answer": "Kodda mantıksal bir hata yok, ancak `mid` hesaplaması taşma riski taşıyor. Daha güvenli bir hesaplama için `int mid = left + (right - left) / 2;` kullanmalısınız. Bu, taşma riskini ortadan kaldırarak doğru bir şekilde orta noktayı bulmanızı sağlar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660909"
  },
  {
    "question": "Karmaşık bir dizide (örneğin bir nesne dizisi) belirli bir nesneyi bulmak için nasıl bir arama algoritması kullanmalıyım?",
    "answer": "Eğer nesneler belirli bir özellik (örneğin bir ID) üzerinden sıralıysa, ikili arama algoritması kullanılabilir. Ancak nesneler sıralı değilse veya sıralı olmayabilecekse, lineer arama kullanılmalıdır. Örneğin, `struct Employee { int id; char name[50]; };` şeklinde bir yapı ile çalışıyorsanız, lineer arama fonksiyonu ile her elemanı kontrol etmeniz gerekebilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660949"
  },
  {
    "question": "Dizinin tüm elemanlarını sıralayarak daha verimli bir arama yapmak için öncelikle hangi sıralama algoritmasını kullanmalıyım?",
    "answer": "Genellikle, küçük diziler için `Insertion Sort` veya `Selection Sort` gibi basit sıralama algoritmaları yeterli olabilirken, büyük diziler için `Quick Sort` veya `Merge Sort` gibi daha verimli algoritmalar tercih edilmelidir. Bu sayede diziyi sıraladıktan sonra ikili arama algoritmasını kullanarak arama sürecini hızlandırabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.660982"
  },
  {
    "question": "Bir dizi içinde aradığım elemanın sıralı olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Dizinin sıralı olup olmadığını kontrol etmek için, dizinin her elemanını bir sonraki eleman ile karşılaştırmalısınız. Eğer bir eleman, kendisinden sonra gelen elemandan büyükse, dizi sıralı değildir. Aşağıdaki gibi bir fonksiyon yazabilirsiniz: `bool isSorted(int arr[], int size) { for(int i = 0; i < size - 1; i++) { if(arr[i] > arr[i + 1]) return false; } return true; }`",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:36:48.661009"
  },
  {
    "question": "Binary search algoritmasında döngü koşulunun yanlış ayarlanması ne gibi hatalara yol açar?",
    "answer": "Binary search algoritmasında, döngü koşulu genellikle 'left <= right' şeklinde ayarlanır. Eğer bu koşul 'left < right' olarak ayarlanırsa, bazı elemanlar göz önünde bulundurulmaz ve arama tamamlanmadan sonlanır. Bu durumda aradığınız elemanı bulamazsınız. Doğru koşul ile kodun düzgün çalışmasını sağlayarak tüm aralığı kontrol edebilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398458"
  },
  {
    "question": "Linear search algoritmasında dizi boyutunun yanlış hesaplanması ne tür hatalara yol açar?",
    "answer": "Dizi boyutunu yanlış hesaplamak, arama işlemi sırasında dizinin sınırlarını aşmanıza neden olabilir. Örneğin, döngü koşulunu dizinin boyutuna göre değil de sabit bir değere göre ayarlarsanız, program bellek hatası verebilir veya beklenmedik sonuçlar döndürebilir. Bu nedenle, dizinin gerçek boyutunu kullanarak döngü koşulunu güncelleyerek hatalardan kaçınmalısınız.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398499"
  },
  {
    "question": "Depth-First Search (DFS) algoritmasında stack yapısının yanlış kullanılması ne gibi sorunlar doğurur?",
    "answer": "DFS algoritmasında, keşfedilen düğümler bir stack yapısında tutulur. Eğer stack yapısını kullanmak yerine bir queue kullanırsanız, algoritmanın davranışı değişir. Bu durumda, algılamanız gereken tüm yolları keşfetmek yerine, sadece ilk bulduğunuz yolu takip ederek en kısa yolu bulamayabilirsiniz. Stack yapısını doğru kullanarak derinlik öncelikli arama gerçekleştirilmelidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398552"
  },
  {
    "question": "Breadth-First Search (BFS) algoritmasında kullanılan queue'un başlangıçta boş olması ne gibi sorunlara yol açar?",
    "answer": "BFS algoritmasında, ilk düğüm keşfedilmeden queue boş olursa, algoritma çalışmaz ve program hata verir. Başlangıç düğümünü queue'ya eklemeyi unuttuysanız, algoritma bir eleman üzerinde işlem yapamayacaktır. Bu nedenle, BFS başlangıcında ilk düğümün queue'ya eklenmesini sağlamalısınız.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398585"
  },
  {
    "question": "Binary search algoritmasında ortalama değerin hesaplanmasında overflow hatası nasıl oluşur?",
    "answer": "Binary search algoritmasında, ortalama değeri hesaplamak için 'mid = (left + right) / 2' kullanmak, 'left' ve 'right' büyük sayılar olduğunda overflow hatasına yol açabilir. Bu durumu önlemek için, 'mid = left + (right - left) / 2' şeklinde bir formül kullanmalısınız. Bu şekilde daha güvenli bir hesaplama yaparak overflow riskini azaltabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398613"
  },
  {
    "question": "Arama algoritmalarında farklı veri yapılarının yanlış kullanımı sonucu ne tür hatalar ortaya çıkabilir?",
    "answer": "Arama algoritmalarında, uygun veri yapısının seçilmemesi performans sorunlarına yol açabilir. Örneğin, sıralı bir dizide binary search kullanmak verimliyken, sırasız bir dizide aynı algoritmayı kullanmak gereksiz yere zaman kaybına neden olur. Veriyi doğru yapılandırarak ve uygun arama yöntemini seçerek optimize edilmiş bir çözüm elde edebilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398643"
  },
  {
    "question": "Recursion (özyineleme) ile yapılan arama algoritmalarında stack overflow hatası nasıl önlenir?",
    "answer": "Özyinelemeli arama algoritmalarında, çok derin bir özyineleme seviyesi, stack overflow hatasına sebep olabilir. Bu durumda, algoritmayı iteratif bir yapıya dönüştürmek veya özyinelemeli derinliği sınırlamak (örneğin; derinliği kontrol eden bir sınır eklemek) çözümler arasında yer alır. Bu sayede hafıza aşımını önleyebilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398671"
  },
  {
    "question": "Linear search algoritmasında, eleman bulunduğunda döngünün bitmemesi için ne yapmalıyız?",
    "answer": "Linear search algoritmasında bir eleman bulunduğunda, genellikle bir 'break' ifadesi ile döngüyü sonlandırmalısınız. Eğer bu 'break' ifadesini eklemezseniz, algoritma tüm dizi elemanlarını kontrol etmeye devam edecektir; bu da gereksiz hesaplama yapmanıza ve performans kaybına neden olacaktır. Bulunan eleman için döngüyü sonlandırmak önemlidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398697"
  },
  {
    "question": "Arama algoritmasında sonuçların sıralı olup olmadığını kontrol etmek neden önemlidir?",
    "answer": "Arama algoritmalarında sonuçların sıralı olması, özellikle binary search gibi algoritmaların doğru çalışabilmesi için kritik öneme sahiptir. Eğer dizi sıralı değilse, binary search yanlış sonuçlar verebilir veya hiç sonuç bulamayabilir. Bu nedenle, arama yapmadan önce verilerin sıralı olup olmadığını kontrol etmelisiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398722"
  },
  {
    "question": "Arama algoritmalarında eleman bulunamadığında hangi durumlarla karşılaşabilirsiniz?",
    "answer": "Arama algoritmalarında eleman bulunamadığında genellikle -1 veya null gibi bir değer döndürülür. Ancak, bu durumu işleyebilmek için doğru hata yönetimini yapmalısınız. Eğer eleman bulunamazsa uygun bir mesaj görüntülemek, kullanıcı deneyimini artırır. Kodu bu durumu ele alacak şekilde yazmalısınız.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:06.398745"
  },
  {
    "question": "Binary search algoritması uygulanırken dizinin sıralı olduğundan nasıl emin olabilirim? Eğer dizi sıralı değilse ne olur?",
    "answer": "Binary search algoritması, yalnızca sıralı diziler üzerinde çalışır. Eğer dizi sıralı değilse, algoritma yanlış sonuçlar verebilir. Örneğin, eğer dizide aradığınız eleman sıralı olmayan bir dizide bulunuyorsa, algoritma bu elemanı bulamayabilir. Diziyi sıralamak için quicksort veya mergesort gibi bir sıralama algoritması kullanabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141701"
  },
  {
    "question": "Linear search ile binary search arasındaki performans farkını nasıl ölçebilirim? Örnek bir kod ile göster.",
    "answer": "Performans farkını ölçmek için her iki arama algoritmasını bir dizi üzerinde çalıştırabilir ve geçen süreyi karşılaştırabilirsiniz. İşte basit bir C kodu:\n\n```c\n#include <stdio.h>\n#include <time.h>\n\nint linear_search(int arr[], int n, int x) {\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == x) return i;\n    }\n    return -1;\n}\n\nint binary_search(int arr[], int l, int r, int x) {\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) return mid;\n        if (arr[mid] < x) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int x = 3;\n    clock_t start;\n\n    // Linear Search\n    start = clock();\n    linear_search(arr, 5, x);\n    printf(\"Linear search time: %f\\n\", ((double)(clock() - start)) / CLOCKS_PER_SEC);\n\n    // Binary Search\n    start = clock();\n    binary_search(arr, 0, 4, x);\n    printf(\"Binary search time: %f\\n\", ((double)(clock() - start)) / CLOCKS_PER_SEC);\n    return 0;\n}\n```\nBu kod, her iki arama algoritmasının ne kadar süre aldığını kıyaslamanızı sağlar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141778"
  },
  {
    "question": "Dizideki tekrar eden elemanları aramak için hangi algoritmayı kullanmalıyım? Neden?",
    "answer": "Dizideki tekrar eden elemanları aramak için hash tabanlı bir yaklaşım kullanabilirsiniz. Hash tabanlı bir algoritma, her bir elemanı bir hash tablosuna ekleyerek tekrar eden elemanları kolayca bulmanıza olanak tanır. Bu yaklaşım genellikle O(n) zaman karmaşıklığına sahiptir. Örnek bir C kodu:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\nint hash[MAX];\n\nvoid find_duplicates(int arr[], int n) {\n    memset(hash, 0, sizeof(hash));\n    for (int i = 0; i < n; i++) {\n        if (hash[arr[i]] == 1) {\n            printf(\"Duplicate found: %d\\n\", arr[i]);\n        } else {\n            hash[arr[i]] = 1;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 1, 2, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    find_duplicates(arr, n);\n    return 0;\n}\n```\nBu kod, dizideki tekrar eden elemanları bulur ve ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141825"
  },
  {
    "question": "Dizideki en küçük elemanı bulurken binary search kullanılır mı? Neden veya neden olmaz?",
    "answer": "Binary search, sıralı dizilerde belirli bir elemanı bulmak için kullanılırken, dizinin en küçük elemanını bulmak için uygun değildir. En küçük elemanı bulmak için basit bir linear search yeterlidir ve O(n) zaman karmaşıklığına sahiptir. Eğer dizi sıralı değilse, O(log n) karmaşıklığına sahip binary search kullanmak mümkün değildir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141874"
  },
  {
    "question": "Arama algoritmalarında kullanılan 'divide and conquer' tekniği nedir? Örnek bir uygulama veriniz.",
    "answer": "'Divide and conquer', problemi daha küçük parçalara bölerek çözmeyi amaçlayan bir yöntemdir. Bu teknik binary search ve mergesort gibi algoritmalarda kullanılır. Örnek olarak binary search algoritmasını ele alalım. Dizi sıralı olduğunda, her seferinde dizinin ortasındaki elemanı kontrol ederek arama alanını yarıya indirir. Bu sayede arama süresi O(log n) olur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141935"
  },
  {
    "question": "Arama algoritmalarında 'worst case' ve 'average case' zaman karmaşıklığını nasıl belirlerim?",
    "answer": "'Worst case' zaman karmaşıklığı, algoritmanın en kötü senaryoda ne kadar süre alacağını gösterir. 'Average case' ise algoritmanın ortalama bir girişte ne kadar süre alacağını belirtir. Her iki durumu belirlemek için, algoritmanın her adımında olası tüm durumları inceleyerek analiz yapmak gerekir. Örneğin, linear search algoritmasında 'worst case' tüm elemanları kontrol etmek gerektiğinde O(n) olurken, 'average case' O(n) olarak kabul edilir çünkü dizinin ortasında eleman bulma ihtimali vardır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.141984"
  },
  {
    "question": "Dizide tek bir elemanı aramak için hangi algoritma daha etkilidir: linear search mi yoksa binary search? Neden?",
    "answer": "Eğer dizi sıralıysa binary search daha etkilidir çünkü O(log n) zaman karmaşıklığına sahiptir. Ancak dizi sıralı değilse, linear search kullanmak zorundasınız ve bu O(n) zaman karmaşıklığına sahiptir. Bu nedenle, dizinin sıralı olup olmadığını kontrol etmek ve uygun algoritmayı seçmek önemlidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.142044"
  },
  {
    "question": "Recursive (özyinelemeli) bir binary search algoritması yazarken dikkat edilmesi gereken noktalar nelerdir?",
    "answer": "Recursive binary search yazarken dikkat edilmesi gerekenler şunlardır: 1) Temel durumu doğru belirlemek, yani dizide arama alanı kalmadığında fonksiyonu durdurmak. 2) Her çağrıda arama alanını doğru bir şekilde güncellemek. 3) Bellek sızıntılarını önlemek için gereksiz değişkenler tanımlamaktan kaçınmak. İşte basit bir özyinelemeli binary search örneği:\n\n```c\nint recursive_binary_search(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) return mid;\n        if (arr[mid] > x) return recursive_binary_search(arr, l, mid - 1, x);\n        return recursive_binary_search(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n```\nBu kod, her çağrıda dizinin arama alanını yarıya indirir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.142096"
  },
  {
    "question": "Dizinin sıralı olup olmadığını kontrol etmeden binary search algoritmasını kullanmak neden sorunludur?",
    "answer": "Binary search, yalnızca sıralı dizilerde doğru çalışır. Eğer dizi sıralı değilse, algoritma aradığınız elemanı bulmayabilir veya yanlış bir indeks döndürebilir. Bu nedenle, binary search ile arama yapmadan önce dizinin sıralı olup olmadığını kontrol etmek önemlidir. Aksi halde, arama sonuçları yanıltıcı olabilir ve program hatalı sonuçlar üretebilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.142145"
  },
  {
    "question": "Farklı veri yapılarını kullanarak arama algoritmalarının performansını nasıl artırabilirim?",
    "answer": "Veri yapıları, arama algoritmalarının performansını önemli ölçüde etkileyebilir. Örneğin, sıralı listeler yerine ağaç yapıları (binary search tree) veya hash tabloları kullanarak arama sürelerini azaltabilirsiniz. Ayrıca, dizi yerine bağlantılı listeler kullanmak, ekleme ve silme işlemlerinde avantaj sağlarken arama işlemlerinde zorluk çıkarabilir. Algoritmalarınızı, kullanacağınız veri yapısına göre optimize ederek performansı artırabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:37:45.142190"
  },
  {
    "question": "Dizideki bir sayıyı bulmak için hangi temel arama algoritmasını kullanmalıyım?",
    "answer": "Dizideki bir sayıyı bulmak için en temel arama algoritması olan 'Doğrusal Arama' (Linear Search) kullanılabilir. Doğrusal arama, dizinin her elemanını sırayla kontrol ederek aradığınız elemanı bulmaya çalışır. Örneğin, bir dizi [5, 3, 8, 6, 2] ise ve 6 sayısını arıyorsanız, algoritma 5 ile başlar, ardından 3, 8 ve 6'ya geçer. 6'yı bulduğunda arama tamamlanır. Bu algoritmanın dezavantajı, dizinin boyutu büyüdükçe arama süresinin artmasıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261050"
  },
  {
    "question": "Sıralı bir dizideki bir elemanı bulmak için hangi arama algoritmasını kullanmalıyım?",
    "answer": "Sıralı bir dizide, elemanı bulmak için 'İkili Arama' (Binary Search) algoritması daha etkilidir. İkili arama, dizinin ortasındaki elemanı kontrol ederek başlar. Eğer aradığınız sayı ortadaki sayıdan küçükse, arama sol yarıda devam eder; büyükse sağ yarıda devam eder. Bu işlem, arama alanını her adımda yarıya indirdiği için daha hızlı sonuç verir. Örneğin, [1, 3, 5, 7, 9] dizisinde 7 arıyorsanız, önce 5 ile karşılaştırılır, ardından sağ yarıda 7 bulunur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261111"
  },
  {
    "question": "Küçük bir dizide hızlı arama yapmak için hangi algoritmayı tercih etmeliyim?",
    "answer": "Küçük diziler için 'Doğrusal Arama' algoritması yeterli ve basit bir seçenektir. Küçük bir dizi ile çalıştığınızda, dizinin her elemanını kontrol etmek hızlıdır ve karmaşık bir algoritmaya ihtiyaç duyulmaz. Örneğin, [4, 1, 3, 2] dizisinde 2 sayısını ararken, algoritma 4'ü kontrol eder, sonra 1 ve 3'ü geçer ve 2'yi bulur. Bu, küçük diziler için pratik bir yaklaşımdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261152"
  },
  {
    "question": "Bir diziye yeni eleman ekledikten sonra arama yapmanın en iyi yolu nedir?",
    "answer": "Bir diziye yeni bir eleman ekledikten sonra arama yapmanın en iyi yolu, dizinin sıralı olup olmadığına bağlıdır. Eğer dizi sıralı değilse, önce diziyi sıralamak gereken 'Sıralama Algoritmaları' (örneğin, Seçim Sıralaması veya Hızlı Sıralama) kullanılarak sıralama yapılabilir. Ardından 'İkili Arama' algoritması ile arama gerçekleştirilebilir. Örneğin, [8, 2, 5, 1] dizisine 4 ekledikten sonra, önce diziyi sıralamak ve sonra 4'ü bulmak için ikili arama yapmak mantıklı olur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261193"
  },
  {
    "question": "Bir arama algoritmasının karmaşıklığını nasıl değerlendirebilirim?",
    "answer": "Bir arama algoritmasının karmaşıklığını değerlendirmek için 'Zaman Karmaşıklığı' ve 'Alan Karmaşıklığı' kavramlarını kullanmalısınız. Zaman karmaşıklığı, algoritmanın çalışması için geçen süreyi belirtir. Örneğin, doğrusal arama O(n) zaman karmaşıklığına sahiptir, bu da dizinin boyutuna bağlı olarak zaman alacağı anlamına gelir. İkili arama ise O(log n) ile daha hızlıdır. Alan karmaşıklığı ise algoritmanın ne kadar bellek kullandığını gösterir. Bu iki karmaşıklık türü, algoritmanın verimliliğini değerlendirmek için önemlidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261229"
  },
  {
    "question": "Bir dizi içinde tekrar eden elemanları bulmak için hangi algoritmayı kullanmalıyım?",
    "answer": "Dizi içinde tekrar eden elemanları bulmak için 'Hash Tablosu' yapısını kullanabilirsiniz. Hash tablosu, verileri anahtar-değer çiftleri olarak depolar. Diziyi kontrol ederken, her bir elemanı hash tablosuna ekleyebilirsiniz. Eğer eklemeye çalıştığınız eleman zaten varsa, bu elemanın tekrar ettiğini tespit edebilirsiniz. Örneğin, [1, 2, 3, 1, 2] dizisinde 1 ve 2 tekrar eder, bu durumda hash tablosu kullanılarak bu tekrarları kolayca bulabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261271"
  },
  {
    "question": "Bir dizi içinde en küçük ve en büyük sayıyı bulmak için hangi algoritmayı kullanmalıyım?",
    "answer": "Bir dizi içinde en küçük ve en büyük sayıyı bulmak için en basit yöntem doğrusal arama yapmaktır. Dizinin her elemanını tek tek kontrol ederek en küçük ve en büyük değerleri güncelleyebilirsiniz. Örneğin, [7, 2, 5, 1, 9] dizisinde, 2'yi gördüğünüzde en küçük değer 2 olur, 9'u gördüğünüzde ise en büyük değer 9 olur. Bu algoritma O(n) zaman karmaşıklığına sahiptir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261317"
  },
  {
    "question": "Bir dizide belirli bir aralıkta bulunan sayıları bulmak için hangi algoritmayı kullanmalıyım?",
    "answer": "Bir dizide belirli bir aralıkta bulunan sayıları bulmak için yine doğrusal arama yapmak en basit yöntemdir. Dizinin her elemanını kontrol ederek, belirlediğiniz aralık içinde olan sayıları seçebilirsiniz. Örneğin, [10, 5, 20, 15] dizisinde 10 ile 15 arasındaki sayıları bulmak istiyorsanız, her elemanı kontrol ederek 10, 15'i bulursunuz. Alternatif olarak, diziyi öncelikle sıralayıp ardından ikili arama ile aralığı bulmak daha hızlı olabilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261361"
  },
  {
    "question": "Bir dizi içinde en sık tekrar eden elemanı bulmak için hangi algoritmayı kullanmalıyım?",
    "answer": "Bir dizide en sık tekrar eden elemanı bulmak için 'Hash Tablosu' veya 'Dizi' kullanabilirsiniz. Hash tablosu ile her bir elemanı sayarak en fazla sayıya sahip olanı belirleyebilirsiniz. Örneğin, [3, 1, 3, 2, 1, 3] dizisinde 3 sayısı üç kez, 1 sayısı iki kez geçmektedir. Bu durumda hash tablosu kullanarak en sık geçen eleman 3 olarak belirlenir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261408"
  },
  {
    "question": "Bir dizideki tüm elemanları belirli bir değere göre filtrelemek için hangi yaklaşımı benimsemeliyim?",
    "answer": "Bir dizideki tüm elemanları belirli bir değere göre filtrelemek için yine doğrusal arama yapılabilir. Dizi üzerinde döngü ile geçerek, belirtilen değere uyan elemanları toplayabilirsiniz. Örneğin, [5, 8, 10, 3, 7] dizisinde 5'ten büyük olanları bulmak istiyorsanız, 8, 10 ve 7'yi seçebilirsiniz. Bu işlem O(n) zaman karmaşıklığına sahip olup her elemanı kontrol etmeniz gerektiği için basittir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:24.261461"
  },
  {
    "question": "İkili arama algoritması nedir ve nasıl çalışır?",
    "answer": "İkili arama algoritması, sıralanmış bir dizi içinde belirli bir elemanı bulmak için kullanılan etkili bir yöntemdir. Algoritma, aranan elemanı dizinin orta noktasındaki elemanla karşılaştırır. Eğer aranan eleman orta elemandan küçükse, arama dizinin sol yarısında devam eder; büyükse sağ yarısında devam eder. Bu işlem, aranan eleman bulunana kadar veya alt dizi boşalana kadar tekrarlanır. İkili arama, O(log n) zaman karmaşıklığına sahiptir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841463"
  },
  {
    "question": "Sıralı bir dizide binary search ile nasıl arama yaparım?",
    "answer": "Sıralı bir dizide ikili arama yapmak için öncelikle dizinin sıralı olduğundan emin olmalısınız. Daha sonra, dizinin en yüksek ve en düşük indekslerini belirleyin. Bir döngü başlatın; her döngüde orta indeksi hesaplayın ve aranan eleman ile orta elemanı karşılaştırın. Eğer eşleşme yoksa, arama aralığını güncelleyerek bu işlemi tekrarlayın. Sonuçta, aranan eleman bulunursa, ilgili indeks döndürülür; bulunamazsa -1 döndürülür.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841552"
  },
  {
    "question": "İkili arama algoritmasının avantajları nelerdir?",
    "answer": "İkili arama algoritmasının en büyük avantajı, büyük veri kümelerinde bile hızlı bir şekilde sonuç vermesidir. Zaman karmaşıklığı O(log n) olduğundan, veriler büyüdükçe arama süresi oldukça kısa kalır. Ayrıca, algoritmanın basit bir mantığı vardır ve çoğu programlama diliyle kolayca uygulanabilir. Bununla birlikte, dizinin sıralı olması gerektiği için, ilk baştaki sıralama işlemi ek bir maliyet getirir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841587"
  },
  {
    "question": "Lineer arama ve ikili arama arasındaki fark nedir?",
    "answer": "Lineer arama, bir dizide aranan elemanı bulmak için tüm elemanları tek tek kontrol eder. Bu yöntem, sıralı olup olmamasına bakmaksızın çalışır ancak zaman karmaşıklığı O(n) ile daha yavaştır. İkili arama ise sıralı dizilerde daha hızlıdır ve O(log n) zaman karmaşıklığına sahiptir. Bu nedenle, büyük veri setlerinde ikili arama genellikle daha verimlidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841619"
  },
  {
    "question": "İkili arama algoritması bir dizi içinde kaç defa uygulanabilir?",
    "answer": "İkili arama algoritması, bir dizide birden fazla kez uygulanabilir. Ancak, her uygulamada dizinin sıralı olması şarttır. Örneğin, bir dizi içinde aynı eleman birden fazla kez bulunuyorsa, her seferinde ikili arama algoritması ile bu elemanları bulabilirsiniz. Ancak, her aramada dizinin sıralı olması ve belirli bir aralıkta aranması gerektiğini unutmamalısınız.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841675"
  },
  {
    "question": "İkili arama algoritmasının en kötü durum senaryosu nedir?",
    "answer": "İkili arama algoritmasının en kötü durum senaryosu, aranan elemanın dizide bulunmadığı durumdur. Bu durumda algoritma, dizinin uzunluğuna bağlı olarak O(log n) kadar adım atmayı gerektirir. Ancak, her ne kadar eleman bulunmasa da, algoritma her durumda dizinin boyutuna göre azalan bir şekilde ilerlediği için oldukça verimlidir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841715"
  },
  {
    "question": "İkili arama algoritmasını C dilinde nasıl yazabilirim?",
    "answer": "C dilinde ikili arama algoritması şu şekildedir: Öncelikle bir fonksiyon tanımlayın ve bu fonksiyona diziyi, dizinin boyutunu ve aranan elemanı parametre olarak geçin. Fonksiyon içinde en düşük ve en yüksek indeksleri belirleyip bir döngü oluşturun. Orta indeksi hesaplayarak aranan eleman ile karşılaştırma yapın. Eğer eşleşme varsa orta indeks, yoksa uygun aralığı güncelleyerek devam edin. İşte örnek kod:\n\n```c\nint binarySearch(int arr[], int size, int target) {\n    int low = 0, high = size - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamazsa\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841746"
  },
  {
    "question": "İkili arama algoritmasında hangi veri yapıları kullanılabilir?",
    "answer": "İkili arama algoritması, genellikle dizilerde uygulanır. Ancak, sıralı olarak düzenlenmiş bağlantılı listeler üzerinde de uygulanabilir. Her iki durumda da veri yapısının sıralı olması gerektiğini hatırlamak önemlidir. Ayrıca, ikili ağaçlar gibi daha karmaşık veri yapıları da kullanılarak arama süreçleri hızlandırılabilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841779"
  },
  {
    "question": "İkili arama algoritması hangi durumlarda daha verimli hale gelir?",
    "answer": "İkili arama algoritması, veri setinin büyük olduğu durumlarda daha verimli hale gelir. Özellikle, sıralı bir dizi ile çalışırken, verinin boyutu arttıkça O(log n) karmaşıklığı sayesinde arama süresi çok daha kısa hale gelir. Ayrıca, önceden sıralanmış veri setleri ile çalışmak, ikili aramanın verimliliğini artırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841811"
  },
  {
    "question": "Binary search algoritmasının uygulanabileceği gerçek dünya senaryoları nedir?",
    "answer": "Binary search algoritması, birçok gerçek dünya senaryosunda kullanılabilir. Örneğin, bir telefon rehberi içinde kişileri aramak, bir kütüphane veritabanında kitap aramak veya bir e-ticaret sitesinde ürünleri filtrelemek için sıralı listelerde ikili arama yapılabilir. Ayrıca, büyük veri kümeleri ile çalışırken, performans artırmak amacıyla sıralama ve arama işlemleri sıkça kullanılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:38:46.841847"
  },
  {
    "question": "Binary search algoritması nedir ve nasıl çalışır?",
    "answer": "Binary search, sıralı bir dizi içinde arama yaparken kullanılan bir algoritmadır. Algoritmanın çalışma mantığı, aranan değeri bulmak için diziyi sürekli olarak ikiye bölmektir. İlk olarak, dizinin ortasındaki eleman ile aranan değer karşılaştırılır. Eğer eşleşme yoksa, aranan değerin dizinin ortasındaki elemandan küçük veya büyük olduğuna göre, arama işlemi dizinin sadece bir yarısında devam eder. Bu süreç, aranan değer bulunana kadar veya dizinin tamamı kontrol edilene kadar tekrarlanır. Örneğin, bir telefon rehberinde bir isim ararken, isimlerin alfabetik sıraya göre düzenli olduğunu varsayıyorsak, binary search ile arama yapabiliriz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140426"
  },
  {
    "question": "Lineer arama algoritması ile binary arama algoritması arasındaki farklar nelerdir?",
    "answer": "Lineer arama, bir dizideki her elemanı sırasıyla kontrol ederek aranan değeri bulmayı amaçlar. Bu yöntem, dizinin sıralı olup olmamasına bakmaksızın çalışır ve en kötü durumda O(n) zaman karmaşıklığına sahiptir. Öte yandan, binary arama yalnızca sıralı dizilerde çalışır ve O(log n) zaman karmaşıklığı sunar. Yani, büyük veri setlerinde binary arama, lineer aramadan çok daha verimlidir. Örneğin, bir mesaj kutusundaki belirli bir mesajı bulmak için lineer arama kullanırsanız, her mesajı sırayla kontrol etmeniz gerekirken, sıralı bir dosya sisteminde binary arama yaparak çok daha hızlı sonuca ulaşabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140469"
  },
  {
    "question": "Küçük bir dizide binary search uygulamak istiyorum, kod örneği verebilir misin?",
    "answer": "Elbette. Aşağıdaki C kodu, binary search algoritmasını basit bir dizide uygulamaktadır:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;  // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;  // Sağ yarısında devam et\n        } else {\n            right = mid - 1;  // Sol yarısında devam et\n        }\n    }\n    return -1;  // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman bulundu, index: %d\\n\", result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kodda, diziye yerleştirilmiş bir sayıyı aramak için binary search fonksiyonu kullanılıyor.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140498"
  },
  {
    "question": "Binary search algoritmasını recursive olarak nasıl uygulayabilirim?",
    "answer": "Recursive bir binary search algoritması, her çağrıda dizinin bir alt kümesine odaklanarak çalışır. İşte recursive bir C implementasyonu:\n\n```c\n#include <stdio.h>\n\nint recursiveBinarySearch(int arr[], int left, int right, int target) {\n    if (right >= left) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] > target) {\n            return recursiveBinarySearch(arr, left, mid - 1, target);\n        }\n        return recursiveBinarySearch(arr, mid + 1, right, target);\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 3;\n    int result = recursiveBinarySearch(arr, 0, size - 1, target);\n    if (result != -1) {\n        printf(\"Eleman bulundu, index: %d\\n\", result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu versiyonda, her çağrıda dizinin sadece bir yarısında arama yapılır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140554"
  },
  {
    "question": "Arama algoritmalarının zaman karmaşıklıkları nasıl değerlendirilir?",
    "answer": "Arama algoritmalarının zaman karmaşıklığı, genellikle en kötü durum, ortalama durum ve en iyi durum olarak üçe ayrılır. En kötü durum, arama algoritmasının aranan değeri bulması için gereken maksimum süreyi ifade eder. Ortalama durum, elemanların nasıl dağıldığına bağlı olarak beklenen süreyi gösterir. En iyi durum ise aranan değerin ilk kontrol edilen eleman olması durumunda geçen süredir. Örneğin, binary search O(log n) zaman karmaşıklığına sahipken, lineer arama O(n) zaman karmaşıklığına sahiptir. Bu değerlendirmeler, algoritmanın verimliliğini anlamak açısından kritik öneme sahiptir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140582"
  },
  {
    "question": "Arama algoritmalarında en kötü durum senaryosunu nasıl belirleriz?",
    "answer": "En kötü durum senaryosu, arama algoritmasının en fazla süre harcadığı durumu ifade eder. Örneğin, bir dizinin son elemanında aranan değerin bulunması veya aranan değerin dizide hiç olmaması durumları en kötü senaryolar olarak değerlendirilebilir. Binary search algoritmasında, aranan değer olmadığında, algoritmanın tüm dizi üzerinde çalışması gerekecektir. Bu durumda, O(log n) karmaşıklığında çalışır. Lineer arama içinse, dizinin tüm elemanlarının kontrol edilmesi gerektiğinden, O(n) karmaşıklığına sahiptir. Uygulama sırasında en kötüyü tahmin etmek, algoritmanın genel performansını değerlendirmede yardımcı olur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140605"
  },
  {
    "question": "Hash tabanlı arama algoritmaları nedir ve avantajları nelerdir?",
    "answer": "Hash tabanlı arama algoritmaları, bir veri yapısına anahtar-değer çiftlerini depolamak için hash fonksiyonları kullanır. Bu yöntem, arama, ekleme ve silme işlemlerinin genellikle O(1) zaman karmaşıklığına sahip olmasını sağlar. Hash tabanlı yapılar, büyük veri setlerinde daha hızlı erişim sağlar. Örneğin, kullanıcı kimliklerinin ve şifrelerinin saklandığı bir sistemde, kimliklerin hızlı bir şekilde doğrulanması için hash tabanlı bir yapı kullanılabilir. Bununla birlikte, hash çakışmaları gibi dezavantajları da vardır ve bu durum, performansı etkileyebilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140626"
  },
  {
    "question": "Depth-first search (DFS) algoritması nedir ve hangi senaryolar için uygundur?",
    "answer": "Depth-first search (DFS), graf veya ağaç yapılarında kullanılabilen bir arama algoritmasıdır. DFS, başlangıç düğümünden başlayarak, mümkün olan en derin düğümlere kadar inip, geri dönmeden önce tüm yan dalları keşfeder. Bu yöntem, belirli bir hedefe ulaşmak için tüm yolları denemek gerektiğinde etkilidir. Örneğin, bir labirentte çıkışı ararken, DFS yardımıyla her bir yolu deneyerek çıkışı bulmaya çalışabilirsiniz. Ancak, bu algoritmanın en büyük dezavantajı, bazı durumlarda sonsuz döngülere girebilmesidir, bu nedenle yeterli kontrol mekanizmalarının uygulanması gerekir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140653"
  },
  {
    "question": "Breadth-first search (BFS) algoritması nedir ve nasıl çalışır?",
    "answer": "Breadth-first search (BFS), bir graf veya ağaç yapısında en yakın düğümleri keşfetme yöntemidir. BFS, başlangıç düğümünden başlayarak, o düğümün komşularını keşfeder ve ardından komşuların komşularına geçer. Bu süreç, tüm düğümler keşfedilene kadar devam eder. BFS'nin en büyük avantajı, en kısa yol bulma amacına yönelik etkili bir yöntem olmasıdır. Örneğin, sosyal medya ağlarında iki kullanıcının birbirine olan uzaklığını hesaplamak için BFS kullanılabilir. BFS, genellikle bir kuyruk veri yapısı kullanılarak uygulanır ve O(V + E) zaman karmaşıklığına sahiptir, burada V düğüm sayısı ve E kenar sayısını ifade eder.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:39:22.140688"
  },
  {
    "question": "Bir dizide belirli bir sayının var olup olmadığını kontrol etmek için nasıl bir algoritma yazabilirim?",
    "answer": "Dizideki elemanları tek tek kontrol ederek arama yapabiliriz. Bu basit bir doğrusal arama (linear search) algoritmasıdır. Aşağıda bir örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i; // Eleman bulundu, indeksini döndür\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {2, 4, 6, 8, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 8;\n    int result = linearSearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, verilen dizide hedef sayının indeksini döndürecektir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931031"
  },
  {
    "question": "Sıralı bir dizide ikili arama (binary search) algoritmasını nasıl uygulayabilirim?",
    "answer": "İkili arama, sıralı bir dizide daha hızlı bir arama yöntemidir. Dizi sıralı ise, hedef değeri bulmak için dizinin ortasındaki değeri kontrol ederiz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Hedef sağ yarıda\n        } else {\n            right = mid - 1; // Hedef sol yarıda\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 4;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, sıralı dizide hedef sayıyı bulmak için ikili arama yapar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931101"
  },
  {
    "question": "Bir dizide belirli bir sayının kaç kez tekrar ettiğini nasıl bulabilirim?",
    "answer": "Tekrar sayısını bulmak için dizinin her elemanını kontrol edebiliriz. Aşağıda, tekrar sayısını bulan bir algoritma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint countOccurrences(int arr[], int size, int target) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 4, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 2;\n    int count = countOccurrences(arr, size, target);\n    printf(\"Eleman %d dizide %d kez bulunuyor.\\n\", target, count);\n    return 0;\n}\n```\nBu kod, hedef sayının dizide kaç kez bulunduğunu sayar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931147"
  },
  {
    "question": "Bir dizideki en küçük elemanı bulmak için hangi algoritmayı kullanabilirim?",
    "answer": "En küçük elemanı bulmak için diziyi bir kez dolaşarak en küçük değeri saklayabiliriz. Aşağıdaki örnek bu yöntemi göstermektedir:\n\n```c\n#include <stdio.h>\n\nint findMin(int arr[], int size) {\n    int min = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    return min;\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 1, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int min = findMin(arr, size);\n    printf(\"Dizideki en küçük eleman: %d\\n\", min);\n    return 0;\n}\n```\nBu kod, dizideki en küçük elemanı bulur ve ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931191"
  },
  {
    "question": "Bir dizide sıralamadan sonra ikili arama yapmanın mantığını açıklayabilir misin?",
    "answer": "İkili arama, sıralı dizilerde kullanılır; bu nedenle, diziyi sıraladıktan sonra hedef değeri bulmak için ikili arama yapabiliriz. İşte sıralama ve ardından ikili arama yapan bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 1, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    qsort(arr, size, sizeof(int), compare); // Diziyi sıralama\n    int target = 3;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indeksinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, diziyi sıralar ve ardından ikili arama ile hedef sayıyı bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931232"
  },
  {
    "question": "Bir dizideki tüm elemanların toplamını nasıl bulabilirim?",
    "answer": "Dizideki elemanların toplamını bulmak için diziyi dolaşarak her bir elemanı toplayabiliriz. Aşağıda bu işlemi gerçekleştiren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int total = sumArray(arr, size);\n    printf(\"Dizideki elemanların toplamı: %d\\n\", total);\n    return 0;\n}\n```\nBu kod, dizideki tüm elemanların toplamını hesaplar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931267"
  },
  {
    "question": "Bir dizide belirli bir aralıktaki elemanları bulmak için nasıl bir algoritma yazabilirim?",
    "answer": "Belirli bir aralıktaki elemanları bulmak için diziyi dolaşarak her bir elemanı kontrol edebiliriz. Aşağıda bu işlemi gerçekleştiren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid printRange(int arr[], int size, int min, int max) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] >= min && arr[i] <= max) {\n            printf(\"%d \", arr[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 5, 10, 15, 20, 25};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printRange(arr, size, 10, 20); // 10 ile 20 arasındaki elemanları yazdır\n    return 0;\n}\n```\nBu kod, belirtilen aralıktaki elemanları diziden bulur ve ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931313"
  },
  {
    "question": "Bir dizi içerisindeki elemanların ortalamasını nasıl hesaplayabilirim?",
    "answer": "Dizinin ortalamasını bulmak için önce toplamı bulmalı ve ardından eleman sayısına bölmeliyiz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nfloat calculateAverage(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return (float)sum / size;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    float average = calculateAverage(arr, size);\n    printf(\"Dizinin ortalaması: %.2f\\n\", average);\n    return 0;\n}\n```\nBu kod, dizinin ortalamasını hesaplar ve sonucu ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931350"
  },
  {
    "question": "Dizideki en büyük elemanı bulmak için hangi algoritmayı kullanabilirim?",
    "answer": "En büyük elemanı bulmak için diziyi bir kez dolaşarak en büyük değeri saklayabiliriz. Aşağıdaki örnek bu yöntemi göstermektedir:\n\n```c\n#include <stdio.h>\n\nint findMax(int arr[], int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 1, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int max = findMax(arr, size);\n    printf(\"Dizideki en büyük eleman: %d\\n\", max);\n    return 0;\n}\n```\nBu kod, dizideki en büyük elemanı bulur ve ekrana yazdırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:02.931389"
  },
  {
    "question": "Binary search algoritmasını bir dizideki elemanı bulmak için nasıl implement edersiniz?",
    "answer": "Binary search, sıralanmış bir dizide arama yapmanın etkili bir yoludur. Algoritma, dizinin orta elemanını kontrol eder ve aranan değer ile karşılaştırma yaparak diziyi ikiye böler. İşte C dilinde bir implementasyonu:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Eleman bulundu\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = binarySearch(arr, size, target);\n    if (result != -1) {\n        printf(\"Eleman %d dizinin %d. indexinde bulundu.\\n\", target, result);\n    } else {\n        printf(\"Eleman bulunamadı.\\n\");\n    }\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734659"
  },
  {
    "question": "Dizideki tekrar eden elemanları bulmak için hash tablosu kullanarak bir algoritma nasıl yazılır?",
    "answer": "Hash tablosu kullanarak, dizideki elemanların tekrar sayılarını hızlı bir şekilde takip edebiliriz. İşte bir C implementasyonu:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define TABLE_SIZE 100\n\ntypedef struct Node {\n    int key;\n    int count;\n    struct Node* next;\n} Node;\n\nNode* hashTable[TABLE_SIZE];\n\nint hashFunction(int key) {\n    return key % TABLE_SIZE;\n}\n\nvoid insert(int key) {\n    int index = hashFunction(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->count = 1;\n    newNode->next = NULL;\n\n    if (hashTable[index] == NULL) {\n        hashTable[index] = newNode;\n    } else {\n        Node* current = hashTable[index];\n        while (current != NULL) {\n            if (current->key == key) {\n                current->count++;\n                free(newNode);\n                return;\n            }\n            if (current->next == NULL) {\n                current->next = newNode;\n                return;\n            }\n            current = current->next;\n        }\n    }\n}\n\nvoid displayDuplicates() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        Node* current = hashTable[i];\n        while (current != NULL) {\n            if (current->count > 1) {\n                printf(\"Eleman %d, %d kez tekrar ediyor.\\n\", current->key, current->count);\n            }\n            current = current->next;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 2, 1, 4, 5, 3};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    for (int i = 0; i < size; i++) {\n        insert(arr[i]);\n    }\n    displayDuplicates();\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734705"
  },
  {
    "question": "Depth-First Search (DFS) algoritmasını bir graf üzerinde nasıl uygularsınız?",
    "answer": "DFS, bir grafın kök düğümünden başlayarak derinlemesine bir arama yapar. Aşağıdaki C kodu bir graf üzerinde DFS algoritmasını göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], visited[MAX];\nint n;\n\nvoid dfs(int vertex) {\n    visited[vertex] = 1; // Düğümü ziyaret et\n    printf(\"%d \", vertex);\n    for (int i = 0; i < n; i++) {\n        if (graph[vertex][i] && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint main() {\n    printf(\"Düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Grafı girin (0 veya 1): \");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    int startVertex;\n    printf(\"Başlangıç düğümünü girin: \");\n    scanf(\"%d\", &startVertex);\n\n    printf(\"DFS: \");\n    dfs(startVertex);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734733"
  },
  {
    "question": "Breadth-First Search (BFS) algoritmasını bir graf üzerinde nasıl uygularsınız?",
    "answer": "BFS, bir grafın kök düğümünden başlayarak katman katman ilerler. Aşağıdaki C kodu bir graf üzerinde BFS algoritmasını göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], visited[MAX];\nint n;\n\nvoid bfs(int startVertex) {\n    int queue[MAX], front = 0, rear = 0;\n    visited[startVertex] = 1;\n    queue[rear++] = startVertex;\n\n    while (front < rear) {\n        int currentVertex = queue[front++];\n        printf(\"%d \", currentVertex);\n\n        for (int i = 0; i < n; i++) {\n            if (graph[currentVertex][i] && !visited[i]) {\n                visited[i] = 1;\n                queue[rear++] = i;\n            }\n        }\n    }\n}\n\nint main() {\n    printf(\"Düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Grafı girin (0 veya 1): \");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    int startVertex;\n    printf(\"Başlangıç düğümünü girin: \");\n    scanf(\"%d\", &startVertex);\n\n    printf(\"BFS: \");\n    bfs(startVertex);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734760"
  },
  {
    "question": "Fibonacci dizisinde bir sayının var olup olmadığını kontrol etmek için bir algoritma yazınız.",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Aşağıda, Fibonacci dizisinde bir sayının var olup olmadığını kontrol eden bir algoritma verilmiştir:\n\n```c\n#include <stdio.h>\n\nint isFibonacci(int n) {\n    int a = 0, b = 1, c;\n    if (n == a || n == b) return 1;\n    c = a + b;\n    while (c <= n) {\n        if (c == n) return 1;\n        a = b;\n        b = c;\n        c = a + b;\n    }\n    return 0;\n}\n\nint main() {\n    int number;\n    printf(\"Bir sayı girin: \");\n    scanf(\"%d\", &number);\n    if (isFibonacci(number)) {\n        printf(\"%d Fibonacci dizisindedir.\\n\", number);\n    } else {\n        printf(\"%d Fibonacci dizisinde değildir.\\n\", number);\n    }\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734788"
  },
  {
    "question": "Bir dizideki en küçük elemanı bulmak için bir algoritma nasıl yazılır?",
    "answer": "Dizideki en küçük elemanı bulmak için, dizinin her bir elemanını kontrol eden basit bir algoritma yazabiliriz. İşte bir C kodu:\n\n```c\n#include <stdio.h>\n\nint findMin(int arr[], int size) {\n    int min = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    return min;\n}\n\nint main() {\n    int arr[] = {12, 3, 5, 7, 19};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int min = findMin(arr, size);\n    printf(\"Dizideki en küçük eleman: %d\\n\", min);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734812"
  },
  {
    "question": "Dizideki elemanların medianını bulmak için bir algoritma yazınız.",
    "answer": "Median, bir diziyi sıraladıktan sonra ortada kalan değerdir. Eğer dizinin eleman sayısı tek ise orta eleman, çift ise ortadaki iki elemanın ortalaması alınır. İşte bir C implementasyonu:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\ndouble findMedian(int arr[], int size) {\n    qsort(arr, size, sizeof(int), compare);\n    if (size % 2 == 0) {\n        return (arr[size / 2 - 1] + arr[size / 2]) / 2.0;\n    } else {\n        return arr[size / 2];\n    }\n}\n\nint main() {\n    int arr[] = {12, 3, 5, 7, 19};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    double median = findMedian(arr, size);\n    printf(\"Dizinin medianı: %.2f\\n\", median);\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734835"
  },
  {
    "question": "Bir dizideki elemanların sıralanması için Merge Sort algoritmasını nasıl implement edersiniz?",
    "answer": "Merge Sort, ayır ve fethet (divide and conquer) prensibi ile çalışan bir sıralama algoritmasıdır. Aşağıda bir C implementasyonu verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    i = 0; j = 0; k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int arrSize = sizeof(arr) / sizeof(arr[0]);\n\n    mergeSort(arr, 0, arrSize - 1);\n\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < arrSize; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734861"
  },
  {
    "question": "Dizideki elemanların sıralanması için Quick Sort algoritmasını nasıl yazarsınız?",
    "answer": "Quick Sort, seçilen bir pivot eleman etrafında diziyi iki bölüme ayırarak sıralama yapan bir algoritmadır. İşte bir C implementasyonu:\n\n```c\n#include <stdio.h>\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Pivot eleman\n    int i = (low - 1); // Küçük elemanların indexi\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int arrSize = sizeof(arr) / sizeof(arr[0]);\n\n    quickSort(arr, 0, arrSize - 1);\n\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < arrSize; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:40:57.734884"
  },
  {
    "question": "Binary search algoritmasını C dilinde nasıl uygularsınız? Bir dizi içerisinde bir öğe aramak için kod örneği verin.",
    "answer": "Binary search (ikili arama) algoritması sıralı bir dizide belirli bir öğeyi bulmak için kullanılır. Aşağıda C dilinde temel bir ikili arama algoritması örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid; // Öğeyi bulduk\n        }\n        if (arr[mid] < target) {\n            left = mid + 1; // Sağ yarıyı kontrol et\n        } else {\n            right = mid - 1; // Sol yarıyı kontrol et\n        }\n    }\n    return -1; // Öğeyi bulamadık\n}\n\nint main() {\n    int arr[] = {2, 3, 4, 10, 40};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 10;\n    int result = binarySearch(arr, size, target);\n    if (result == -1) {\n        printf(\"Öğe bulunamadı.\");\n    } else {\n        printf(\"Öğe %d. indekste bulundu.\", result);\n    }\n    return 0;\n}\n```\nBu kod, sıralı bir dizi içinde hedef öğeyi aramakta ve bulunduğunda indeksini döndürmektedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.473863"
  },
  {
    "question": "Depth First Search (DFS) algoritmasını bir graf üzerinde nasıl uygularsınız? C dilinde bir örnek verin.",
    "answer": "DFS, bir grafın tüm düğümlerini derinlemesine aramak için kullanılan bir algoritmadır. Aşağıda DFS algoritmasının C dilinde bir graf üzerinde nasıl uygulanacağına dair bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], visited[MAX];\nint n;\n\nvoid dfs(int v) {\n    visited[v] = 1; // Düğümü ziyaret et\n    printf(\"%d \", v);\n    for (int i = 0; i < n; i++) {\n        if (graph[v][i] && !visited[i]) {\n            dfs(i); // Ziyaret edilmemiş komşuları ziyaret et\n        }\n    }\n}\n\nint main() {\n    printf(\"Grafın düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Grafın kenarlarını girin (örnek: 0 1, 1 2, 2 0):\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph[i][j] = 0;\n        }\n    }\n    int edges;\n    printf(\"Kenar sayısını girin: \");\n    scanf(\"%d\", &edges);\n    for (int i = 0; i < edges; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1; // Grafı oluştur\n    }\n    printf(\"DFS sırası: \");\n    dfs(0); // 0. düğümden başla\n    return 0;\n}\n```\nBu kod, kullanıcıdan alınan bir graf yapısı üzerinde DFS algoritmasını çalıştırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.473938"
  },
  {
    "question": "Breadth First Search (BFS) algoritmasını bir graf üzerinde nasıl uygularsınız? C dilinde bir örnek verin.",
    "answer": "BFS, bir grafın tüm düğümlerini genişlik öncelikli olarak aramak için kullanılır. Aşağıda BFS algoritmasının C dilinde uygulanmasına dair bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], visited[MAX];\nint queue[MAX], front = -1, rear = -1;\nint n;\n\nvoid enqueue(int v) {\n    if (rear == MAX - 1) return;\n    if (front == -1) front = 0;\n    queue[++rear] = v;\n}\n\nint dequeue() {\n    if (front == -1) return -1;\n    int data = queue[front];\n    if (front >= rear) front = rear = -1;\n    else front++;\n    return data;\n}\n\nvoid bfs(int start) {\n    visited[start] = 1;\n    enqueue(start);\n    while (front != -1) {\n        int current = dequeue();\n        printf(\"%d \", current);\n        for (int i = 0; i < n; i++) {\n            if (graph[current][i] && !visited[i]) {\n                visited[i] = 1;\n                enqueue(i);\n            }\n        }\n    }\n}\n\nint main() {\n    printf(\"Grafın düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Grafın kenarlarını girin (örnek: 0 1, 1 2, 2 0):\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph[i][j] = 0;\n        }\n    }\n    int edges;\n    printf(\"Kenar sayısını girin: \");\n    scanf(\"%d\", &edges);\n    for (int i = 0; i < edges; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1; // Grafı oluştur\n    }\n    printf(\"BFS sırası: \");\n    bfs(0); // 0. düğümden başla\n    return 0;\n}\n```\nBu kod, kullanıcıdan alınan bir graf yapısı üzerinde BFS algoritmasını çalıştırır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.473988"
  },
  {
    "question": "A* algoritmasını kullanarak bir yol bulma senaryosunu C dilinde nasıl uygularsınız? Örnek verin.",
    "answer": "A* algoritması, hedefe en kısa yolu bulmak için kullanılan bir arama algoritmasıdır. Aşağıda C dilinde basit bir A* algoritması örneği verilmiştir. Bu örnekte, bir ızgara üzerinde bir hedefe en kısa yolu bulma simüle edilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX 100\n\ntypedef struct {\n    int x, y;\n} Node;\n\ntypedef struct {\n    Node node;\n    int f, g, h;\n} AStarNode;\n\nAStarNode openList[MAX];\nint openListSize = 0;\n\nint heuristic(Node a, Node b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nvoid addToOpenList(Node node, Node goal, int g) {\n    AStarNode astarNode;\n    astarNode.node = node;\n    astarNode.g = g;\n    astarNode.h = heuristic(node, goal);\n    astarNode.f = astarNode.g + astarNode.h;\n    openList[openListSize++] = astarNode;\n}\n\nNode getLowestF() {\n    int index = 0;\n    for (int i = 1; i < openListSize; i++) {\n        if (openList[i].f < openList[index].f) {\n            index = i;\n        }\n    }\n    Node lowestNode = openList[index].node;\n    openList[index] = openList[--openListSize]; // En düşük f'yi kaldır\n    return lowestNode;\n}\n\nint main() {\n    Node start = {0, 0};\n    Node goal = {4, 4};\n    addToOpenList(start, goal, 0);\n    while (openListSize > 0) {\n        Node current = getLowestF();\n        if (current.x == goal.x && current.y == goal.y) {\n            printf(\"Hedefe ulaşıldı: (%d, %d)\\n\", current.x, current.y);\n            return 0;\n        }\n        // Burada komşu düğümlere ekleme yapılır (sağa, sola, yukarı, aşağı)\n        // Örnek: addToOpenList((Node){current.x+1, current.y}, goal, g + 1);\n    }\n    printf(\"Hedefe ulaşılamadı.\");\n    return 0;\n}\n```\nBu örnek, A* algoritmasının temel yapısını içermekte olup, komşu düğümlerin eklenmesi eksiktir; buna göre geliştirilebilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.474043"
  },
  {
    "question": "Rabin-Karp algoritması ile bir metin içerisinde bir alt diziyi nasıl ararsınız? C dilinde bir örnek verin.",
    "answer": "Rabin-Karp algoritması, metin arama işlemlerinde karma tabanlı bir yaklaşım kullanır. Aşağıda bu algoritmanın C dilindeki bir uygulaması verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid rabinKarp(char *text, char *pattern, int d, int q) {\n    int M = strlen(pattern);\n    int N = strlen(text);\n    int i, j;\n    int p = 0; // Desenin hash'i\n    int t = 0; // Metnin hash'i\n    int h = 1;\n\n    // h = d^(M-1) mod q\n    for (i = 0; i < M - 1; i++) {\n        h = (h * d) % q;\n    }\n\n    // İlk hash hesaplama\n    for (i = 0; i < M; i++) {\n        p = (d * p + pattern[i]) % q;\n        t = (d * t + text[i]) % q;\n    }\n\n    // Hash karşılaştırma\n    for (i = 0; i <= N - M; i++) {\n        if (p == t) {\n            // Alt dizi bulundu\n            for (j = 0; j < M; j++) {\n                if (text[i + j] != pattern[j]) break;\n            }\n            if (j == M) {\n                printf(\"Alt dizi %d. indekste bulundu.\\n\", i);\n            }\n        }\n        // Sonraki hash hesaplama\n        if (i < N - M) {\n            t = (d * (t - text[i] * h) + text[i + M]) % q;\n            if (t < 0) t += q;\n        }\n    }\n}\n\nint main() {\n    char text[] = \"Gelecekte bir gün, bu kod çalışacak!\";\n    char pattern[] = \"kod\";\n    int d = 256; // Karakter seti boyutu\n    int q = 101; // Bir asal sayı\n    rabinKarp(text, pattern, d, q);\n    return 0;\n}\n```\nBu kod, verilen bir metinde belirli bir alt diziyi aramaktadır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.474101"
  },
  {
    "question": "Dijkstra algoritmasını C dilinde bir graf üzerinde en kısa yolu bulmak için nasıl uygularsınız? Örnek verin.",
    "answer": "Dijkstra algoritması, bir grafın belirli bir düğümünden diğer düğümlerine en kısa yolları bulmak için kullanılan bir algoritmadır. Aşağıda bir dijkstra algoritması örneği verilmiştir:\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], dist[MAX], visited[MAX];\nint n;\n\nint minDistance() {\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\nvoid dijkstra(int src) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    dist[src] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = minDistance();\n        visited[u] = 1;\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX && \n                dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n}\n\nint main() {\n    printf(\"Grafın düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Grafın kenarlarını ve ağırlıklarını girin (örnek: 0 1 4, 1 2 1, 0 2 2):\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph[i][j] = 0;\n        }\n    }\n    int edges;\n    printf(\"Kenar sayısını girin: \");\n    scanf(\"%d\", &edges);\n    for (int i = 0; i < edges; i++) {\n        int u, v, weight;\n        scanf(\"%d %d %d\", &u, &v, &weight);\n        graph[u][v] = weight;\n        graph[v][u] = weight; // Yönsüz graf\n    }\n    dijkstra(0); // 0. düğümden başla\n    printf(\"Düğümlere olan en kısa mesafeler:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d: %d\\n\", i, dist[i]);\n    }\n    return 0;\n}\n```\nBu kod, kullanıcıdan alınan bir graf yapısında Dijkstra algoritması ile en kısa yolları bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.474155"
  },
  {
    "question": "Floyd-Warshall algoritmasını C dilinde bir graf üzerinde tüm yolları nasıl bulursunuz? Örnek verin.",
    "answer": "Floyd-Warshall algoritması, bir grafın tüm düğümleri arasındaki en kısa yolları bulmak için kullanılan bir dinamik programlama yöntemidir. Aşağıda bu algoritmanın C dilinde uygulanmasına dair bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n#define MAX 100\n\nint graph[MAX][MAX];\nint n;\n\nvoid floydWarshall() {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (graph[i][k] + graph[k][j] < graph[i][j]) {\n                    graph[i][j] = graph[i][k] + graph[k][j];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    printf(\"Grafın düğüm sayısını girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Grafın kenarlarını ve ağırlıklarını girin (örnek: 0 1 3, 1 2 2):\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph[i][j] = INT_MAX;\n        }\n        graph[i][i] = 0; // Kendi kendine mesafe 0\n    }\n    int edges;\n    printf(\"Kenar sayısını girin: \");\n    scanf(\"%d\", &edges);\n    for (int i = 0; i < edges; i++) {\n        int u, v, weight;\n        scanf(\"%d %d %d\", &u, &v, &weight);\n        graph[u][v] = weight;\n    }\n    floydWarshall();\n    printf(\"Tüm düğümler arasındaki en kısa mesafeler:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (graph[i][j] == INT_MAX) {\n                printf(\"%d -> %d: sonsuz\\n\", i, j);\n            } else {\n                printf(\"%d -> %d: %d\\n\", i, j, graph[i][j]);\n            }\n        }\n    }\n    return 0;\n}\n```\nBu kod, verilen bir graf üzerinde Floyd-Warshall algoritmasını çalıştırarak tüm düğümler arasındaki en kısa yolları bulur.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.474207"
  },
  {
    "question": "Heapsort algoritmasını bir dizi sıralamak için C dilinde nasıl uygularsınız? Örnek verin.",
    "answer": "Heapsort, bir diziyi sıralamak için kullanılan bir algoritmadır. Aşağıda Heapsort algoritmasının C dilinde bir uygulaması verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    printf(\"Sıralı dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\nBu kod, verilen bir dizi üzerinde Heapsort algoritmasını çalıştırarak sıralı bir dizi döndürmektedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:18.474255"
  },
  {
    "question": "Binary search algoritmasını C dilinde nasıl implement edebilirim? Kodda ne gibi iyileştirmeler yapabilirim?",
    "answer": "Binary search, sıralı bir dizide arama yapmanın etkili bir yöntemidir. C dilinde temel bir implementasyon şöyle olabilir:\n\n```c\nint binary_search(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n```\n\nİyileştirme önerisi: 'mid' hesaplamasında overflow riskini azaltmak için 'left + (right - left) / 2' gibi bir formül kullanmak iyidir. Ayrıca, dizinin sıralı olduğundan emin olmalısınız.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467064"
  },
  {
    "question": "Bir dizideki elemanları lineer arama ile nasıl bulabilirim? Performans iyileştirmesi olarak ne yapabilirim?",
    "answer": "Lineer arama, her elemanı tek tek kontrol ederek arama yapar. Temel bir implementasyon şöyle olabilir:\n\n```c\nint linear_search(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n```\n\nPerformans iyileştirmesi: Eğer dizi üzerinde çok sayıda arama yapacaksanız, diziyi sıralamak ve ardından binary search kullanmak daha hızlı sonuç verebilir. Ayrıca, arama yapmadan önce dizinin sıklığını tutan bir harita (hashmap) ile önbellekleme yapabilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467109"
  },
  {
    "question": "C dilinde bir dizide belirli bir elemanı bulmak için kullanılan 'strstr' fonksiyonu ile ilgili bir örnek verebilir misiniz?",
    "answer": "'strstr' fonksiyonu, bir karakter dizisi içinde başka bir karakter dizisini arar. Örnek olarak, şöyle kullanılabilir:\n\n```c\n#include <string.h>\n\nchar* find_substring(const char* str, const char* substr) {\n    return strstr(str, substr);\n}\n```\n\nİyileştirme önerisi: Bu fonksiyon, karakter dizisini tararken her karakter için karşılaştırma yapar. Eğer arama yapılacak alt dize çok uzun ve sık kullanılıyorsa, KMP (Knuth-Morris-Pratt) algoritması gibi daha verimli algoritmalar tercih edilebilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467148"
  },
  {
    "question": "C dilinde ikili ağaçta bir değeri aramak için bir algoritma yazabilir misiniz? Performans artışı için neler yapabiliriz?",
    "answer": "İkili ağaçta arama yapmak için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* search(struct Node* root, int target) {\n    if (root == NULL || root->data == target) {\n        return root;\n    }\n    if (target < root->data) {\n        return search(root->left, target);\n    }\n    return search(root->right, target);\n}\n```\n\nPerformans iyileştirmesi: İkili arama ağacı dengeli olmalıdır. Aksi takdirde, en kötü durumda zaman karmaşıklığı O(n) olur. AVL ağaçları veya Kırmızı-siyah ağaçlar gibi dengeli ağaç yapıları kullanarak bu durumu iyileştirebilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467182"
  },
  {
    "question": "C dilinde bir dizinin en küçük ve en büyük elemanlarını bulmak için bir algoritma yazabilir misiniz?",
    "answer": "Aşağıdaki gibi bir fonksiyon ile dizinin en küçük ve en büyük elemanlarını bulabilirsiniz:\n\n```c\nvoid find_min_max(int arr[], int size, int* min, int* max) {\n    *min = arr[0];\n    *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) {\n            *min = arr[i];\n        }\n        if (arr[i] > *max) {\n            *max = arr[i];\n        }\n    }\n}\n```\n\nİyileştirme önerisi: Tek bir geçişte minimum ve maksimum değerleri bulmak için döngü kullanıyorsunuz. Ancak, dizinin boyutunu 2 ile bölüp iki elemanı birleştirerek karşılaştırma yapılabilir, bu da geçiş sayısını azaltır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467212"
  },
  {
    "question": "C dilinde 'jump search' algoritmasını nasıl implement ederim? Hangi durumlarda tercih edilir?",
    "answer": "Jump search, sıralı dizilerde arama yapmak için kullanılır ve ikili arama ile karşılaştırıldığında daha yüksek bir zaman karmaşıklığına sahiptir. Örnek implementasyon:\n\n```c\nint jump_search(int arr[], int size, int target) {\n    int jump = (int)sqrt(size);\n    int prev = 0;\n\n    while (arr[min(jump, size) - 1] < target) {\n        prev = jump;\n        jump += (int)sqrt(size);\n        if (prev >= size) return -1;\n    }\n\n    while (arr[prev] < target) {\n        prev++;\n        if (prev == min(jump, size)) return -1;\n    }\n    return (arr[prev] == target) ? prev : -1;\n}\n```\n\nBu algoritma genellikle büyük verilerin bulunduğu dizilerde tercih edilir. Hızlı erişim noktası (jump) ile arama yapmak diziyi küçük parçalara bölerek daha hızlı arama yapılmasını sağlar.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467241"
  },
  {
    "question": "Bir dizideki elemanları sıralamak için 'quick sort' algoritmasını nasıl implement ederim? Performansı nasıl artırabilirim?",
    "answer": "Quick sort algoritması, böl ve yönet stratejisini kullanır. Temel bir örnek aşağıdaki gibidir:\n\n```c\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quick_sort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quick_sort(arr, low, pi - 1);\n        quick_sort(arr, pi + 1, high);\n    }\n}\n```\n\nPerformans iyileştirmesi: Pivot seçimini daha iyi yaparak (örneğin, medyanı seçmek) algoritmanın en kötü durum performansını iyileştirebilirsiniz. Ayrıca, dizinin boyutu küçükse, 'insertion sort' ile birleştirerek daha verimli hale getirebilirsiniz.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467275"
  },
  {
    "question": "C dilinde 'heap sort' algoritmasını nasıl implement ederim? Hangi durumlarda uygundur?",
    "answer": "Heap sort, verimli bir sıralama algoritmasıdır ve  O(n log n) karmaşıklığına sahiptir. Örnek implementasyon:\n\n```c\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heap_sort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n```\n\nHeap sort, bellek kullanımında düşük seviyelerde veri sıralamak için uygundur. Ayrıca, sıralama işlemi yapılırken ek bir diziye ihtiyaç duymadığı için yerel (in-place) bir sıralama algoritmasıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467302"
  },
  {
    "question": "C dilinde 'radix sort' algoritmasını nasıl implement ederim? Hangi durumlarda etkili olur?",
    "answer": "Radix sort, sayıları sıralamak için kullanılan bir algoritmadır ve genellikle çok büyük sayılarla çalışırken tercih edilir. Aşağıdaki örnek, en düşük basamaktan başlayarak sıralama yapar:\n\n```c\nvoid counting_sort(int arr[], int size, int exp) {\n    int output[size]; // Çıktı dizisi\n    int count[10] = {0}; // 0-9 arasındaki sayılar için\n\n    for (int i = 0; i < size; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = size - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    for (int i = 0; i < size; i++)\n        arr[i] = output[i];\n}\n\nvoid radix_sort(int arr[], int size) {\n    int max = *max_element(arr, arr + size);\n    for (int exp = 1; max / exp > 0; exp *= 10)\n        counting_sort(arr, size, exp);\n}\n```\n\nRadix sort, sıralanacak sayıların belirli bir aralıkta olduğu durumlarda etkilidir (örneğin, 0-9999 gibi). Ayrıca, sabit uzunluktaki anahtarlar üzerinde çalışırsa, çok etkili olabilir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467329"
  },
  {
    "question": "C dilinde 'merge sort' algoritmasını nasıl implement ederim? Hangi durumlarda tercih edilir?",
    "answer": "Merge sort, böl ve yönet stratejisini kullanarak sıralama yapan bir algoritmadır. Aşağıdaki gibi bir implementasyon yapılabilir:\n\n```c\nvoid merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = left;\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k++] = L[i++];\n        } else {\n            arr[k++] = R[j++];\n        }\n    }\n\n    while (i < n1)\n        arr[k++] = L[i++];\n    while (j < n2)\n        arr[k++] = R[j++];\n}\n\nvoid merge_sort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        merge_sort(arr, left, mid);\n        merge_sort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n```\n\nMerge sort, özellikle büyük veri setleri ve bağlı liste yapıları için uygundur. Zaman karmaşıklığı O(n log n) olup, istikrarlı bir sıralama algoritmasıdır.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:42:57.467357"
  },
  {
    "question": "Binary search algoritmasını kullanarak bir sıralı dizi içinde bir elemanı nasıl ararsınız? Kod örneği ile açıklayınız.",
    "answer": "Binary search, sıralı dizilerde hızlı bir arama yapmanızı sağlar. Aşağıdaki örnekte, binary search algoritmasının nasıl uygulanacağını görebilirsiniz:\n\n```c\nint binary_search(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Eleman bulunamadı\n}\n```\nBu kod, sıralı bir dizide 'target' değerini arar ve bulunduğunda indexini döner. Bulunamazsa -1 döner. Bu algoritmanın zaman karmaşıklığı O(log n)'dir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.370869"
  },
  {
    "question": "Depth-first search (DFS) algoritması ile bir graf üzerinde nasıl arama yapılır? Kod örneği ile gösteriniz.",
    "answer": "DFS, bir grafın tüm düğümlerini derinlemesine gezmek için kullanılır. Aşağıda DFS algoritmasının bir graf üzerinde nasıl uygulanacağını gösteren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint visited[MAX];\nint graph[MAX][MAX], n;\n\nvoid dfs(int node) {\n    if (visited[node]) return;\n    visited[node] = 1;\n    printf(\"%d \", node);\n    for (int i = 0; i < n; i++) {\n        if (graph[node][i] == 1 && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint main() {\n    // Örnek graf oluşturma\n    n = 5;\n    graph[0][1] = graph[1][0] = 1;\n    graph[0][2] = graph[2][0] = 1;\n    graph[1][3] = graph[3][1] = 1;\n    graph[2][4] = graph[4][2] = 1;\n\n    dfs(0); // 0'dan başla\n    return 0;\n}\n```\nBu kod, 0. düğümden başlayarak grafı derinlemesine gezer. 'visited' dizisi, hangi düğümlerin ziyaret edildiğini takip eder. Zaman karmaşıklığı O(V + E) şeklindedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.370946"
  },
  {
    "question": "Breadth-first search (BFS) algoritmasını kullanarak bir grafın en kısa yolunu nasıl bulursunuz? Kod örneği ile açıklayınız.",
    "answer": "BFS, bir grafın en kısa yolunu bulmak için idealdir. Aşağıda BFS algoritmasının nasıl uygulanacağını gösteren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nint graph[MAX][MAX], queue[MAX], front = -1, rear = -1;\nint n;\n\nvoid enqueue(int value) {\n    if (rear == MAX - 1) return;\n    queue[++rear] = value;\n    if (front == -1) front = 0;\n}\n\nint dequeue() {\n    if (front == -1) return -1;\n    int value = queue[front++];\n    if (front > rear) front = rear = -1;\n    return value;\n}\n\nvoid bfs(int start) {\n    bool visited[MAX] = {false};\n    enqueue(start);\n    visited[start] = true;\n\n    while (front != -1) {\n        int node = dequeue();\n        printf(\"%d \", node);\n        for (int i = 0; i < n; i++) {\n            if (graph[node][i] == 1 && !visited[i]) {\n                enqueue(i);\n                visited[i] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    // Örnek graf oluşturma\n    n = 5;\n    graph[0][1] = graph[1][0] = 1;\n    graph[0][2] = graph[2][0] = 1;\n    graph[1][3] = graph[3][1] = 1;\n    graph[2][4] = graph[4][2] = 1;\n\n    bfs(0); // 0'dan başla\n    return 0;\n}\n```\nBu kod, 0. düğümden başlayarak grafı genişlemesine arar. En kısa yolu bulmak için BFS kullanılır ve zaman karmaşıklığı O(V + E) şeklindedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371008"
  },
  {
    "question": "A* arama algoritması nedir ve nasıl çalışır? Kısaca açıklayınız ve bir örnek veriniz.",
    "answer": "A* arama algoritması, en kısa yolu bulmak için kullanılan bir graf arama algoritmasıdır. Hem mevcut maliyet hem de tahmin edilen maliyet (heuristic) hesaplanarak karar verilir. Aşağıdaki örnek A* algoritmasının temel yapısını gösterir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int x, y;\n    int g; // Gerçek maliyet\n    int h; // Tahmini maliyet\n    int f; // Toplam maliyet (g + h)\n} Node;\n\n// A* algoritması ile ilgili fonksiyonların tanımlanması ve uygulanması.\n// Bu bölümde, çeşitli fonksiyonlar yazılabilir.\n\nint main() {\n    // Örnek kod burada uygulanabilir.\n    return 0;\n}\n```\nA* algoritmasının temelinde genellikle bir açık (open) ve kapalı (closed) liste bulunur. Açık liste, keşfedilmemiş düğümlerin tutulduğu yerdir, kapalı liste ise ziyaret edilen düğümleri içerir. A* algoritmasının zaman karmaşıklığı O(b^d) şeklindedir, burada b genişleme faktörünü, d ise hedefe olan mesafeyi temsil eder.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371060"
  },
  {
    "question": "Jump search algoritmasının nasıl çalıştığını ve hangi senaryolar için uygun olduğunu açıklayınız.",
    "answer": "Jump search, sıralı bir dizi içinde arama yapmak için kullanılan bir algoritmadır. Dizinin karekökü kadar adım atarak ilerler ve hedef değeri bulduğunda, daha küçük bir arama (linear search) ile arama yapar. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nint jump_search(int arr[], int size, int target) {\n    int step = sqrt(size);\n    int prev = 0;\n    while (arr[step] < target && step < size) {\n        prev = step;\n        step += sqrt(size);\n        if (prev >= size) return -1;\n    }\n    for (int i = prev; i < step && i < size; i++) {\n        if (arr[i] == target) return i;\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 5;\n    int result = jump_search(arr, size, target);\n    printf(\"Eleman %d. indexte bulundu.\\n\", result);\n    return 0;\n}\n```\nJump search, sıralı dizilerde hızlı arama sağlar ve zaman karmaşıklığı O(√n)'dir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371123"
  },
  {
    "question": "Interpolation search algoritması nedir ve nasıl çalışır? Kod örneği veriniz.",
    "answer": "Interpolation search, sıralı dizilerde daha iyi bir arama performansı sağlamak için kullanılır. Aranan değer ile dizi elemanları arasında orantısal bir tahmin yaparak arama yapar. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint interpolation_search(int arr[], int low, int high, int target) {\n    if (low <= high && target >= arr[low] && target <= arr[high]) {\n        int pos = low + ((double)(high - low) / (arr[high] - arr[low]) * (target - arr[low]));\n        if (arr[pos] == target) return pos;\n        if (arr[pos] > target) return interpolation_search(arr, low, pos - 1, target);\n        return interpolation_search(arr, pos + 1, high, target);\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50, 60, 70, 80, 90};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 50;\n    int result = interpolation_search(arr, 0, size - 1, target);\n    printf(\"Eleman %d. indexte bulundu.\\n\", result);\n    return 0;\n}\n```\nInterpolation search, sıralı dizilerde kullanılır ve zaman karmaşıklığı O(log log n) şeklindedir; ancak dizinin düzgün bir dağılım göstermesi gerekir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371166"
  },
  {
    "question": "Exponential search algoritması nedir ve ne zaman kullanılır? Kod örneği ile açıklayınız.",
    "answer": "Exponential search, sıralı dizilerde hızlı bir arama yapmak için kullanılan bir yöntemdir. İlk olarak, aranan değerin bulunabileceği bir aralık belirler ve ardından binary search ile arama yapar. Aşağıdaki örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint binary_search(int arr[], int left, int right, int target) {\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        else if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint exponential_search(int arr[], int size, int target) {\n    if (arr[0] == target) return 0;\n    int i = 1;\n    while (i < size && arr[i] <= target) i *= 2;\n    return binary_search(arr, i / 2, (i < size ? i : size - 1), target);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 7;\n    int result = exponential_search(arr, size, target);\n    printf(\"Eleman %d. indexte bulundu.\\n\", result);\n    return 0;\n}\n```\nExponential search, özellikle büyük dizilerde etkili olup, zaman karmaşıklığı O(log n) şeklindedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371213"
  },
  {
    "question": "Fibonacci search algoritması nedir ve nasıl çalışır? Uygulamalı bir örnek veriniz.",
    "answer": "Fibonacci search, sıralı dizilerde arama yapmak için Fibonacci sayılarını kullanarak çalışan bir algoritmadır. Aranan değerin pozisyonunu tahmin etmek için Fibonacci serisi kullanılır. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint fibonacci_search(int arr[], int size, int target) {\n    int fib2 = 0; // (m-2)'nin Fibonacci sayısı\n    int fib1 = 1; // (m-1)'nin Fibonacci sayısı\n    int fib = fib1 + fib2; // m'in Fibonacci sayısı\n\n    while (fib < size) {\n        fib2 = fib1;\n        fib1 = fib;\n        fib = fib1 + fib2;\n    }\n\n    int offset = -1;\n    while (fib1 > 0) {\n        int i = (offset + fib2 < size) ? offset + fib2 : size - 1;\n        if (arr[i] < target) {\n            fib = fib1;\n            fib1 = fib2;\n            fib2 = fib - fib1;\n            offset = i;\n        } else if (arr[i] > target) {\n            fib = fib2;\n            fib1 -= fib1;\n            fib2 = fib - fib2;\n        } else return i;\n    }\n    return -1; // Eleman bulunamadı\n}\n\nint main() {\n    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target = 85;\n    int result = fibonacci_search(arr, size, target);\n    printf(\"Eleman %d. indexte bulundu.\\n\", result);\n    return 0;\n}\n```\nFibonacci search, büyük dizilerde etkili olup, zaman karmaşıklığı O(log n) şeklindedir.",
    "category": "data_structures",
    "topic": "searching",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Arama algoritmaları",
    "timestamp": "2025-06-01T16:43:55.371258"
  },
  {
    "question": "Bir dosyayı okuma işlemi yapmak istiyorum. Hangi fonksiyonları kullanmalıyım?",
    "answer": "Dosyayı okumak için `fopen()` fonksiyonunu kullanarak dosyayı açmalısınız. Ardından `fgets()` veya `fread()` gibi fonksiyonlar ile dosyadaki verileri okuyabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    dosya = fopen(\"ornek.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir); // Satırı ekrana yazdır\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162683"
  },
  {
    "question": "C dilinde bir dosyaya yazmak için ne yapmalıyım?",
    "answer": "Bir dosyaya yazmak için yine `fopen()` fonksiyonunu kullanarak dosyayı yazma modunda açmalısınız. `fprintf()` veya `fwrite()` gibi fonksiyonlar ile verileri dosyaya yazabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"ornek.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    fprintf(dosya, \"Merhaba, Dünya!\"); // Veriyi dosyaya yaz\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162719"
  },
  {
    "question": "Bir dosyayı okuduktan sonra kapatmayı unuttum, ne olur?",
    "answer": "Dosyayı kapatmayı unuttuğunuzda, dosya kaynakları sistemde açık kalır ve bu bellek sızıntısına yol açabilir. Bu nedenle her zaman dosyanızı kullanmayı bitirdiğinizde `fclose()` fonksiyonunu çağırmalısınız. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"r\");\n    // Dosya işlemleri\n    // fclose(dosya); // Kapatmayı unutursanız kaynak sızıntısı olur\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162743"
  },
  {
    "question": "Bir dosyadan tüm satırları okuyup bir diziye kaydetmek istiyorum. Nasıl yapabilirim?",
    "answer": "Bir dosyadan tüm satırları okuyup bir diziye kaydetmek için bir döngü kullanarak her satırı diziye yazabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n    char dizi[10][100]; // 10 satır için dizi\n    int i = 0;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL && i < 10) {\n        strcpy(dizi[i], satir); // Satırı diziye kopyala\n        i++;\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162770"
  },
  {
    "question": "Dosyayı açarken hata kontrolü yapmanın önemi nedir?",
    "answer": "Dosyayı açarken hata kontrolü yapmak, dosyanın mevcut olup olmadığını veya doğru şekilde açılıp açılmadığını kontrol etmenizi sağlar. Eğer dosya açılamazsa, programınız beklenmedik şekilde çalışabilir. Bu nedenle, `fopen()` fonksiyonunun döndürdüğü değeri kontrol etmelisiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\"); // Hata mesajı göster\n        return 1;\n    }\n    // Diğer dosya işlemleri\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162790"
  },
  {
    "question": "Bir dosyaya ekleme yapmak istiyorum. Hangi modda açmalıyım?",
    "answer": "Bir dosyaya ekleme yapmak için dosyayı 'a' (append) modunda açmalısınız. Bu şekilde var olan dosyanın sonuna yeni veriler ekleyebilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"a\"); // Ekleme modu\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    fprintf(dosya, \"Yeni satır ekleniyor.\");\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162812"
  },
  {
    "question": "Binary dosya okumak için hangi fonksiyonlar kullanmalıyım?",
    "answer": "Binary dosya okumak için `fopen()` ile dosyayı \"rb\" modunda açmalısınız. Verileri okumak için ise `fread()` fonksiyonunu kullanabilirsiniz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int veri[10];\n\n    dosya = fopen(\"ornek.bin\", \"rb\"); // Binary dosya aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    fread(veri, sizeof(int), 10, dosya); // Binary veriyi oku\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162832"
  },
  {
    "question": "Dosya yazma işlemi yaparken bir hata oluşursa nasıl tepki vermeliyim?",
    "answer": "Dosya yazma işlemi sırasında bir hata oluşursa, `fprintf()` veya `fwrite()` fonksiyonunun döndürdüğü değeri kontrol ederek hata yönetimi yapmalısınız. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    if (fprintf(dosya, \"Merhaba, Dünya!\") < 0) {\n        printf(\"Yazma hatası oluştu!\");\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162856"
  },
  {
    "question": "File pointer (dosya işaretçisi) nedir ve nasıl kullanılır?",
    "answer": "File pointer (dosya işaretçisi), açılan dosyayı temsil eden bir işaretçidir. `FILE *` tipinde tanımlanır ve dosya açıldığında `fopen()` fonksiyonu tarafından atanır. Dosya üzerinde okuma/yazma işlemleri bu işaretçi ile yapılır. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Dosya işlemleri\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:23.162878"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya yazmak için gerekli kodu tamamlayın. Dosya adı 'metin.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char metin[100];\n\n    // Kullanıcıdan metin al\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyayı aç ve yaz\n    file = fopen(\"metin.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    fprintf(file, \"%s\", metin);\n    fclose(file);\n    printf(\"Metin dosyaya yazıldı.\");\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir metin alır ve bunu 'metin.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227541"
  },
  {
    "question": "Bir dosyadan okunan metni ekrana yazdıran kodu tamamlayın. Dosya adı 'veri.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[255];\n\n    // Dosyayı aç\n    file = fopen(\"veri.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Dosyadan oku ve yazdır\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"%s\", buffer);\n    }\n    fclose(file);\n    return 0;\n}\n\n// Açıklama: Bu kod, 'veri.txt' dosyasını okur ve içeriği ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227592"
  },
  {
    "question": "Bir dosyaya kullanıcıdan alınan 5 tam sayıyı yazmak için gerekli kodu tamamlayın. Dosya adı 'sayilar.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int sayi;\n\n    // Dosyayı aç\n    file = fopen(\"sayilar.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // 5 tam sayı al ve yaz\n    for (int i = 0; i < 5; i++) {\n        printf(\"Bir tam sayı girin: \");\n        scanf(\"%d\", &sayi);\n        fprintf(file, \"%d\\n\", sayi);\n    }\n    fclose(file);\n    printf(\"Sayilar dosyaya yazıldı.\");\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan 5 tam sayı alır ve bunları 'sayilar.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227628"
  },
  {
    "question": "Bir dosyaya yazılan verilerin ardından dosyayı kontrol etmek için bir onay mesajı ekleyin. Dosya adı 'onay.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n\n    // Dosyayı aç\n    file = fopen(\"onay.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Veri yaz\n    fprintf(file, \"Veri yazma işlemi tamamlandı.\\n\");\n    fclose(file);\n    printf(\"Onay mesajı dosyaya yazıldı.\");\n    return 0;\n}\n\n// Açıklama: Bu kod, 'onay.txt' dosyasına bir onay mesajı yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227670"
  },
  {
    "question": "Bir dosyadan satır satır okuma yaparak sadece 'C' ile başlayan satırları yazdıran kodu tamamlayın. Dosya adı 'kelimeler.txt' olmalı.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char buffer[255];\n\n    // Dosyayı aç\n    file = fopen(\"kelimeler.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Satırları oku ve yazdır\n    while (fgets(buffer, sizeof(buffer), file)) {\n        if (buffer[0] == 'C') {\n            printf(\"%s\", buffer);\n        }\n    }\n    fclose(file);\n    return 0;\n}\n\n// Açıklama: Bu kod, 'kelimeler.txt' dosyasını okur ve sadece 'C' ile başlayan satırları ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227715"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya ekleyen kodu tamamlayın. Dosya adı 'ekleme.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char metin[100];\n\n    // Kullanıcıdan metin al\n    printf(\"Bir metin girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyayı ekleme modunda aç\n    file = fopen(\"ekleme.txt\", \"a\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n    fprintf(file, \"%s\", metin);\n    fclose(file);\n    printf(\"Metin dosyaya eklendi.\");\n    return 0;\n}\n\n// Açıklama: Bu kod, kullanıcıdan bir metin alır ve bunu 'ekleme.txt' dosyasına ekler.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227745"
  },
  {
    "question": "Bir dosyadan okunan sayıları toplamak için gerekli kodu tamamlayın. Dosya adı 'sayilar.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int sayi;\n    int toplam = 0;\n\n    // Dosyayı aç\n    file = fopen(\"sayilar.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Sayıları oku ve topla\n    while (fscanf(file, \"%d\", &sayi) != EOF) {\n        toplam += sayi;\n    }\n    fclose(file);\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n// Açıklama: Bu kod, 'sayilar.txt' dosyasındaki sayıları toplar ve sonucunu ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227775"
  },
  {
    "question": "Bir dosyaya yazma işlemi sırasında hata kontrolü yapmak için gerekli kodu tamamlayın. Dosya adı 'hata_kontrol.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"hata_kontrol.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fprintf(file, \"Yazma işlemi başarılı.\\n\");\n    fclose(file);\n    return 0;\n}\n\n// Açıklama: Bu kod, 'hata_kontrol.txt' dosyasını açmaya çalışır ve hata oluşursa açıklayıcı bir mesaj verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227814"
  },
  {
    "question": "Bir dosyadaki tüm satırları okuduktan sonra, toplam satır sayısını yazdıran kodu tamamlayın. Dosya adı 'satirlar.txt' olmalı.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[255];\n    int satirSayisi = 0;\n\n    // Dosyayı aç\n    file = fopen(\"satirlar.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\");\n        return 1;\n    }\n\n    // Satırları oku ve say\n    while (fgets(buffer, sizeof(buffer), file)) {\n        satirSayisi++;\n    }\n    fclose(file);\n    printf(\"Toplam satır sayısı: %d\\n\", satirSayisi);\n    return 0;\n}\n\n// Açıklama: Bu kod, 'satirlar.txt' dosyasını okur ve içindeki toplam satır sayısını hesaplar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:44:55.227849"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları okuyarak ekrana yazdıran bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'metin.txt' dosyasını okur ve her satırı ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.751884"
  },
  {
    "question": "Bir dosyaya kullanıcıdan alınan metin verisini yazan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char input[256];\n\n    file = fopen(\"yeni_metin.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"Bir metin girin: \");\n    fgets(input, sizeof(input), stdin);\n    fprintf(file, \"%s\", input);\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program kullanıcıdan bir metin alır ve 'yeni_metin.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.751940"
  },
  {
    "question": "Bir dosyadaki sayıları okuyarak toplamını hesaplayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int number;\n    int sum = 0;\n\n    file = fopen(\"sayilar.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%d\", &number) != EOF) {\n        sum += number;\n    }\n\n    printf(\"Toplam: %d\\n\", sum);\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'sayilar.txt' dosyasındaki tüm sayıları toplar ve sonucu ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.751969"
  },
  {
    "question": "Bir dosyadan okunan verileri başka bir dosyaya kopyalayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *source, *target;\n    char ch;\n\n    source = fopen(\"kaynak.txt\", \"r\");\n    target = fopen(\"hedef.txt\", \"w\");\n\n    if (source == NULL || target == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while ((ch = fgetc(source)) != EOF) {\n        fputc(ch, target);\n    }\n\n    fclose(source);\n    fclose(target);\n    return 0;\n}\n\n// Bu program, 'kaynak.txt' dosyasındaki içeriği 'hedef.txt' dosyasına kopyalar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.751998"
  },
  {
    "question": "Bir dosyadaki belirli bir kelimeyi arayıp kaç kez geçtiğini sayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    char *keyword = \"kelime\";\n    int count = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *pos = line;\n        while ((pos = strstr(pos, keyword)) != NULL) {\n            count++;\n            pos++;\n        }\n    }\n\n    printf(\"'%s' kelimesi %d kez bulundu.\\n\", keyword, count);\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'metin.txt' dosyasında belirli bir kelimenin kaç kez geçtiğini sayar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.752030"
  },
  {
    "question": "Dosyaya rastgele oluşturulmuş 10 sayıyı yazdıktan sonra, bu dosyadan sayıların ortalamasını hesaplayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    FILE *file;\n    int number;\n    int sum = 0;\n    float average;\n\n    file = fopen(\"rastgele_sayilar.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    srand(time(NULL));\n    for (int i = 0; i < 10; i++) {\n        number = rand() % 100;\n        fprintf(file, \"%d\\n\", number);\n    }\n    fclose(file);\n\n    file = fopen(\"rastgele_sayilar.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i < 10; i++) {\n        fscanf(file, \"%d\", &number);\n        sum += number;\n    }\n\n    average = sum / 10.0;\n    printf(\"Ortalama: %.2f\\n\", average);\n    fclose(file);\n    return 0;\n}\n\n// Bu program, rastgele 10 sayı oluşturur ve bunların ortalamasını hesaplar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.752068"
  },
  {
    "question": "Bir CSV dosyasını okuyarak her satırdaki verileri ayıran ve ekrana yazdıran bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    const char delimiter[2] = \",\";\n\n    file = fopen(\"veriler.csv\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, delimiter);\n        while (token != NULL) {\n            printf(\"%s \", token);\n            token = strtok(NULL, delimiter);\n        }\n        printf(\"\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'veriler.csv' dosyasını okur ve her satırdaki verileri ayırarak ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.752100"
  },
  {
    "question": "Bir dosyadaki tüm verileri ters sırada yazdıran bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LINES 100\n\nint main() {\n    FILE *file;\n    char lines[MAX_LINES][256];\n    int count = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(lines[count], sizeof(lines[count]), file) && count < MAX_LINES) {\n        count++;\n    }\n    fclose(file);\n\n    for (int i = count - 1; i >= 0; i--) {\n        printf(\"%s\", lines[i]);\n    }\n\n    return 0;\n}\n\n// Bu program, 'metin.txt' dosyasındaki tüm satırları okuyarak ters sırada ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.752127"
  },
  {
    "question": "Bir dosyaya yazılan verilerin, dosya kapatılmadan önce doğruluğunu kontrol eden bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char input[256];\n\n    file = fopen(\"test.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"Bir metin girin: \");\n    fgets(input, sizeof(input), stdin);\n    fprintf(file, \"%s\", input);\n\n    fflush(file); // Yazma işlemi hemen gerçekleşir.\n    fclose(file);\n\n    // Dosyadan veriyi kontrol etme\n    file = fopen(\"test.txt\", \"r\");\n    char read[256];\n    fgets(read, sizeof(read), file);\n    printf(\"Dosyadan okunan: %s\\n\", read);\n    fclose(file);\n\n    return 0;\n}\n\n// Bu program, kullanıcıdan alınan veriyi dosyaya yazar ve ardından doğruluğunu kontrol eder.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:27.752159"
  },
  {
    "question": "Dosya açma işlemi için kullanılan fopen() fonksiyonunun kullanımında bir hata var. Kod: FILE *fp = fopen('dosya.txt', 'r'); Hata nerede?",
    "answer": "Hata, dosya adının ve modunun belirtilmesindeki tırnak işaretlerindendir. C dilinde stringler için çift tırnak kullanmalısınız. Doğru kullanım: FILE *fp = fopen(\"dosya.txt\", \"r\");",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227049"
  },
  {
    "question": "Dosyaya veri yazarken fwrite() fonksiyonunu kullanıyorum. Kod: fwrite(data, sizeof(data), 1, fp); Hata neden kaynaklanıyor?",
    "answer": "Hata, 'data' değişkeninin boyutunun doğru hesaplanmamasıdır. 'sizeof(data)' ifadesi, değişkenin pointer tipindeyse her zaman bir işaretçi boyutunu döndürür. Doğru kullanım: fwrite(data, sizeof(*data), count, fp); şeklinde olmalıdır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227108"
  },
  {
    "question": "Dosyayı kapatmayı unuttum. Kod: fclose(fp) yazdım ama fp değişkeni null. Hata nerede?",
    "answer": "Hata, fopen() fonksiyonunun başarısız olması durumunda fp'nin null değer almasıdır. Dosya açılmadan fclose() çağrıldığında program hatalı çalışabilir. Kontrol ekleyin: if (fp != NULL) fclose(fp);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227144"
  },
  {
    "question": "Dosyadan veri okurken fscanf() kullanıyorum ve beklenmedik sonuçlar alıyorum. Kod: fscanf(fp, '%d', &num); Hata nerede?",
    "answer": "Hata, fscanf() fonksiyonunun döndüğü değeri kontrol etmemekte. Dosya açılmamış veya okunacak veri yoksa, fscanf() başarısız olur ve bu durumda değişkenin değeri güncellenmez. Kontrol eklemelisiniz: if (fscanf(fp, '%d', &num) != 1) { /* hata işlemleri */ }",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227187"
  },
  {
    "question": "Dosyaya ekleme yapmak istiyorum ama fopen()'u 'w' modunda kullandım. Kod: FILE *fp = fopen('dosya.txt', 'w'); Hata ne?",
    "answer": "Hata, 'w' modunun dosyayı her açtığınızda sıfırlamasıdır. Eğer dosyaya ekleme yapmak istiyorsanız 'a' (append) modunu kullanmalısınız: FILE *fp = fopen(\"dosya.txt\", \"a\");",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227233"
  },
  {
    "question": "Dizinin boyutunu yanlış belirleyip fwrite() kullanıyorum. Kod: fwrite(array, sizeof(array), 1, fp); Hata nerede?",
    "answer": "Hata, 'sizeof(array)' ile dizinin boyutunu alıyorsanız, değişken bir pointer ise, sadece pointer boyutunu döner. Dizi boyutunu almak için dizinin boyutunu doğrudan belirtmelisiniz: fwrite(array, sizeof(int) * dizi_boyutu, 1, fp);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227273"
  },
  {
    "question": "Dosyadan okuduğum veriyi işleme alırken her satır için bir döngü kurdum ama dosyanın sonunu kontrol etmiyorum. Kod: while (fgets(line, sizeof(line), fp)) { /* işleme */ } Hata ne olabilir?",
    "answer": "Hata, fgets() fonksiyonunun döngüden çıkmadan önce dosya sonuna ulaştığında hatalı işlemler yapabileceğinizdir. Dosyanın sonunu kontrol etmek için fgets() döngüsünü kullanmak doğru bir yaklaşımdır. Ancak, dosya açma ve okuma hatalarını da kontrol etmeyi unutmayın.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227342"
  },
  {
    "question": "fgets() ile okunan veriyi printf() ile yazdırırken format hatası alıyorum. Kod: printf('%s', line); Hata nerede?",
    "answer": "Hata, printf()'de format belirteçlerinin nasıl kullanıldığıyla ilgilidir. '%s' dizesi, null karakter ile sonlandırılmış bir string bekler. Eğer line dizisinin sonuna null karakter eklenmezse hata alabilirsiniz. fgets() zaten bu karakteri ekler; dolayısıyla sorun başka bir yerde olabilir ya da line dizisinin boyutunu kontrol edin.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227384"
  },
  {
    "question": "Dosyadan okunan bir değeri bir değişkene atarken yanlışlık yapıyorum. Kod: int num; fscanf(fp, '%d', num); Hata nerede?",
    "answer": "Hata, fscanf() fonksiyonuna değişkenin adresini geçmemenizdir. Değişkenin adresini belirtmek için '&' işaretini kullanmalısınız: fscanf(fp, '%d', &num);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227425"
  },
  {
    "question": "Dosyayı okuduktan sonra kapatmayı unutursam ne olur?",
    "answer": "Eğer dosyayı okuduktan sonra kapatmazsanız, bellekte yer işgal etmeye devam eder ve sistem kaynakları boşa harcanır. Bu, bellek sızıntısına yol açabilir ve programın çalışmasını olumsuz etkileyebilir. Her zaman dosya işlemlerinin sonunda fclose() çağırmalısınız.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:45:49.227450"
  },
  {
    "question": "C dilinde bir dosyadan verileri okuyup ekrana yazdırırken dosya açma işlemi başarısız oluyor. Bunun nedenleri neler olabilir?",
    "answer": "Dosya açma işlemi başarısız oluyorsa, muhtemelen dosya yolu hatalıdır veya dosya mevcut değildir. Dosya adı ve yolu kontrol edilmelidir. Ayrıca, dosya açma modunun da doğru ayarlandığından emin olunmalıdır. Örneğin, 'fopen' fonksiyonunda 'r' modu kullanıyorsanız, dosyanın okunabilir olması gerekir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.429880"
  },
  {
    "question": "Bir dosyaya veri yazarken yazma işlemi tamamlandıktan sonra dosya kapatılmıyor. Bu problem ne gibi sonuçlar doğurur?",
    "answer": "Dosyayı kapatmadığınızda, tüm yazılan verilerin diske yazılmaması riski vardır. Bu, kaydedilen verilerin kaybolmasına veya dosyanın bozulmasına neden olabilir. 'fclose' fonksiyonu kullanılarak dosya kapatılmalı.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.429942"
  },
  {
    "question": "Bir dosyadan okunan verileri diziye kaydederken, dizinin sınırlarını aşıyorum. Bunu nasıl önleyebilirim?",
    "answer": "Diziye veri okurken, okunan veri miktarını kontrol etmelisiniz. 'fgets' gibi fonksiyonlarla belirli bir karakter sayısı okuyarak dizi sınırlarını aşmanızı önleyebilirsiniz. Ayrıca, dizinin boyutunu kontrollü bir şekilde tanımlayıp, bu sınırları aşmadığınızdan emin olmalısınız.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.429974"
  },
  {
    "question": "Açtığım dosyayı okuma modunda açıyorum ama verileri yazmaya çalışıyorum. Bu durumda ne olur?",
    "answer": "Eğer bir dosyayı yalnızca okuma modunda ('r') açarsanız, dosyaya veri yazamazsınız. Bu işlem bir hata ile sonuçlanır. Dosyaya yazmak için 'w' veya 'a' modlarından birini kullanmalısınız. Yazma işlemi sırasında hataların önüne geçmek için açma modunu kontrol edin.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430003"
  },
  {
    "question": "Dosya okuma işlemi sırasında EOF (End of File) belirlendiğinde döngü nasıl çalışmalı?",
    "answer": "EOF kontrolü için 'feof' fonksiyonu kullanılabilir. Okuma döngüsünde, 'fgets' veya 'fscanf' gibi fonksiyonların dönüş değerleri kontrol edilerek döngü devam ettirilmeli. Örneğin, 'while(!feof(dosya))' şeklinde bir yapı kullanılabilir. Ancak, genellikle okuma fonksiyonunun dönüş değeri kontrol edilmelidir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430032"
  },
  {
    "question": "Bir dosyaya yazma işlemi sırasında hata kontrolü yapmadım. Bu bana ne gibi sorunlar çıkarabilir?",
    "answer": "Yazma işlemi sırasında bir hata meydana gelirse (örneğin, diskin dolu olması veya yazma izinlerinin olmaması), bu durumu tespit edemezsiniz. Bu nedenle, 'fwrite' veya 'fprintf' gibi fonksiyonlardan sonra dönüş değerini kontrol etmek önemlidir. Hata durumunda uygun hata mesajı verilmeli veya işlem sonlandırılmalıdır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430061"
  },
  {
    "question": "Dosyadan okunan verileri kullanarak bir hesaplama yapıyorum ama yanlış sonuç alıyorum. Neden olabilir?",
    "answer": "Okunan verilerin formatı ile değişkenlerin tipi arasında uyumsuzluk olabilir. Örneğin, dosyadan okunan veriler string olarak okunurken, bunları sayı olarak kullanmaya çalışıyorsanız, bir dönüşüm yapmalısınız. 'atoi', 'atof' gibi fonksiyonlar kullanılabilir. Ayrıca, okunan verileri kontrol etmek ve hata ayıklamak için debug yapmalısınız.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430098"
  },
  {
    "question": "Birden fazla dosya açıp işlem yapmaya çalışırken 'too many open files' hatası alıyorum. Bu durum nasıl önlenir?",
    "answer": "C dilinde, açılan dosya sayısı sistem kaynakları tarafından sınırlıdır. Bu nedenle, açtığınız dosyaları kullanmayı bitirdikten sonra 'fclose' ile kapatmalısınız. Ayrıca, ihtiyaç duyduğunuzdan fazla dosya açmamaya çalışmak ve dosya işlemlerini mümkün olduğunca kısa tutmak önemlidir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430142"
  },
  {
    "question": "Bir dosyayı yazma modunda açarken eski verilerin üzerine yazılıyor. Bunu nasıl engelleyebilirim?",
    "answer": "Dosyayı 'w' modunda açtığınızda, dosyanın içeriği silinir ve üzerine yazılır. Eğer mevcut verilerin korunması isteniyorsa 'a' (append) modunu kullanmalısınız. Bu mod, dosyanın sonuna veri ekler. Ayrıca, dosyanın var olup olmadığını kontrol etmek için önce 'r' modunda açmak ve sonrasında 'a' moduna geçmek de bir seçenektir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430170"
  },
  {
    "question": "Dosya okuma işlemi sırasında bazı karakterler yanlış okunuyor. Bunun nedeni ne olabilir?",
    "answer": "Yanlış okuma, dosyanın açılış moduna, okuma fonksiyonuna ve dosya formatına bağlı olabilir. Örneğin, metin dosyası UTF-8 formatındaysa ve ANSI modunda açıldıysa, karakterler doğru okunmayabilir. Dosyayı doğru karakter setiyle açmak ve uygun okuma fonksiyonlarını kullanmak önemlidir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:10.430197"
  },
  {
    "question": "Bir dosyayı açmaya çalışıyorum ama 'No such file or directory' hatası alıyorum. Neden olabilir?",
    "answer": "Bu hata, açmaya çalıştığınız dosyanın belirtilen yolunun yanlış olduğuna işaret eder. Dosya adını ve yolunu kontrol edin. Ayrıca, dosyanın gerçekten mevcut olduğundan ve doğru izinlere sahip olduğundan emin olun. Örneğin:\n\n```c\nFILE *file = fopen(\"/path/to/your/file.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326114"
  },
  {
    "question": "Bir dosyaya yazmak istiyorum ama verilerim dosyaya kaydedilmiyor. Neden olabilir?",
    "answer": "Eğer dosyayı yazma modunda açmadıysanız, veriler dosyaya kaydedilmeyecektir. Dosyayı \"w\" veya \"a\" modunda açmalısınız. Ayrıca, dosyanın yazma izinlerine sahip olduğunuzu kontrol edin:\n\n```c\nFILE *file = fopen(\"output.txt\", \"w\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n}\nfprintf(file, \"Merhaba Dünya!\");\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326179"
  },
  {
    "question": "Dosyayı 'r' modunda açtım ama yazmaya çalışıyorum, 'Illegal operation' hatası alıyorum. Neden?",
    "answer": "Dosyayı 'r' modunda açtığınızda sadece okuma iznine sahip olursunuz. Yazma işlemi yapabilmek için dosyayı 'w' ya da 'a' modunda açmalısınız. Örneğin:\n\n```c\nFILE *file = fopen(\"output.txt\", \"w\");\nif (file) {\n    fprintf(file, \"Bu bir yazı.\");\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326241"
  },
  {
    "question": "Dosyayı okuduktan sonra kapatmayı unuttum. Ne gibi sorunlarla karşılaşabilirim?",
    "answer": "Dosyayı kapatmadığınızda, bellek sızıntısı ve dosya yazarak kaydedilmeyen veriler gibi sorunlarla karşılaşabilirsiniz. Program sonunda dosyaları her zaman kapatmalısınız:\n\n```c\nFILE *file = fopen(\"data.txt\", \"r\");\n// Okuma işlemleri\nfclose(file); // Dosyayı kapatmayı unutmayın\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326292"
  },
  {
    "question": "Dosyadan okuduğum veriyi kaydedemiyorum. Okuma işlemi nasıl yapılmalı?",
    "answer": "Dosyadan veri okurken, okunan veriyi uygun bir değişkene atadığınızdan emin olun. Örneğin, `fscanf` veya `fgets` kullanarak veri okuyabilirsiniz:\n\n```c\nFILE *file = fopen(\"data.txt\", \"r\");\nchar buffer[100];\nif (file) {\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"Okunan: %s\", buffer);\n    }\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326339"
  },
  {
    "question": "Dosya yazma işlemi sırasında 'Disk full' hatası alıyorum. Ne yapmalıyım?",
    "answer": "Bu hata, diskinizin dolu olduğu anlamına gelir. Disk alanını kontrol edin ve gereksiz dosyaları silin. Ayrıca, dosyayı kaydettiğiniz yerin yeterli alanı olup olmadığını kontrol edin. Yazma işlemini aşağıdaki gibi gerçekleştirebilirsiniz:\n\n```c\nFILE *file = fopen(\"output.txt\", \"a\");\nif (file) {\n    fprintf(file, \"Yeni veri.\");\n    fclose(file);\n} else {\n    perror(\"Dosya açılamadı\");\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326390"
  },
  {
    "question": "Bir dosyayı okuduktan sonra tekrar açmak istiyorum ama 'file pointer' ile ilgili hata alıyorum. Neden?",
    "answer": "Eğer dosyayı okuma modunda açtıysanız, dosyayı kapatmadan tekrar açamazsınız. Bunun yerine, `fseek` kullanarak dosya işaretçisini başa döndürebilirsiniz. Örnek:\n\n```c\nFILE *file = fopen(\"data.txt\", \"r\");\nchar buffer[100];\nfgets(buffer, sizeof(buffer), file);\nfseek(file, 0, SEEK_SET); // Dosya işaretçisini başa al\nfgets(buffer, sizeof(buffer), file);\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326452"
  },
  {
    "question": "Çok büyük bir dosyayı okumaya çalışıyorum, uygulamam donuyor. Ne yapmalıyım?",
    "answer": "Büyük dosyaları okurken, verileri parça parça okumak daha mantıklıdır. `fgets` veya `fread` ile belirli boyutlarda veri okuyabilirsiniz. Bu, bellek kullanımını azaltır:\n\n```c\nFILE *file = fopen(\"largefile.txt\", \"r\");\nchar buffer[1024];\nwhile (fgets(buffer, sizeof(buffer), file)) {\n    // Veriyi işleyin\n}\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326504"
  },
  {
    "question": "Dosyaya veri yazarken 'Permission denied' hatası alıyorum. Neden?",
    "answer": "Bu hata, yazmaya çalıştığınız dosyanın veya dizinin yazma izinlerinin olmadığını gösterir. Dosyanın bulunduğu dizinin izinlerini kontrol edin ve uygun izinlere sahip olduğunuzdan emin olun. Örneğin:\n\n```c\nFILE *file = fopen(\"/restricted/output.txt\", \"w\");\nif (file == NULL) {\n    perror(\"Yazma izni yok\");\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326567"
  },
  {
    "question": "Bir dosyayı okuduktan sonra tüm verileri değiştirmek istiyorum ama dosyayı nasıl açmalıyım?",
    "answer": "Dosyayı değişiklik yapmak için 'r+' modunda açmalısınız. Bu mod, hem okuma hem de yazma yapmanıza olanak tanır:\n\n```c\nFILE *file = fopen(\"data.txt\", \"r+\");\nif (file) {\n    // Verileri okuyun ve değiştirin\n    fprintf(file, \"Yeni veri.\"); // Değişiklik yapın\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:36.326621"
  },
  {
    "question": "C dilinde bir dosyayı nasıl açarım?",
    "answer": "C dilinde bir dosyayı açmak için 'fopen' fonksiyonunu kullanırız. Bu fonksiyon dosya adını ve dosyanın açılma modunu alır. Örneğin, 'r' okuma modu, 'w' yazma modu ve 'a' ekleme modudur. Örnek: FILE *dosya; dosya = fopen('dosya.txt', 'r');",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241674"
  },
  {
    "question": "Bir dosyaya nasıl yazabilirim?",
    "answer": "Bir dosyaya yazmak için önce dosyayı 'fopen' fonksiyonu ile 'w' ya da 'a' modunda açmalısınız. Daha sonra 'fprintf' ya da 'fputs' gibi fonksiyonlar kullanarak içeriği yazabilirsiniz. Örnek: FILE *dosya; dosya = fopen('dosya.txt', 'w'); fprintf(dosya, 'Merhaba Dünya!'); fclose(dosya);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241708"
  },
  {
    "question": "Bir dosyadan nasıl veri okuyabilirim?",
    "answer": "Bir dosyadan veri okumak için dosyayı 'fopen' fonksiyonu ile 'r' modunda açmalısınız. Ardından 'fscanf' veya 'fgets' gibi fonksiyonlar ile veriyi okuyabilirsiniz. Örnek: FILE *dosya; char buffer[100]; dosya = fopen('dosya.txt', 'r'); fgets(buffer, 100, dosya); printf('%s', buffer); fclose(dosya);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241726"
  },
  {
    "question": "C dilinde dosya işlemleri sonrasında dosyayı nasıl kapatırım?",
    "answer": "Dosya işlemlerini tamamladıktan sonra dosyayı kapatmak için 'fclose' fonksiyonunu kullanırız. Bu, dosya ile yapılan işlemlerin tamamlanmasını sağlar ve bellek sızıntılarını önler. Örnek: fclose(dosya);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241749"
  },
  {
    "question": "Dosyanın başarıyla açılıp açılmadığını nasıl kontrol edebilirim?",
    "answer": "Dosya açıldıktan sonra, dosya işaretçisinin NULL olup olmadığını kontrol ederek dosyanın başarıyla açılıp açılmadığını anlayabiliriz. Eğer NULL ise, dosya açılamamıştır. Örnek: if (dosya == NULL) { printf('Dosya açılamadı.'); }",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241770"
  },
  {
    "question": "C dilinde bir dosyaya birden fazla satır nasıl yazılır?",
    "answer": "Bir dosyaya birden fazla satır yazmak için 'fprintf' veya 'fputs' fonksiyonu ile her satır için ayrı ayrı çağrı yapabilirsiniz. Örnek: fprintf(dosya, '1. Satır\n'); fprintf(dosya, '2. Satır\n');",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241791"
  },
  {
    "question": "Dosyadan okunan veriyi bir diziye nasıl saklayabilirim?",
    "answer": "Dosyadan okunan veriyi bir diziye saklamak için önce bir karakter dizisi tanımlamalı ve ardından 'fgets' ile veriyi bu diziye okumalıyız. Örnek: char dizi[100]; fgets(dizi, 100, dosya);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241810"
  },
  {
    "question": "C dilinde bir dosyanın sonuna veri eklemek için hangi modda açmalıyım?",
    "answer": "Bir dosyanın sonuna veri eklemek için dosyayı 'a' (append) modunda açmalısınız. Bu modda açılan dosyaya yazılan veriler, dosyanın mevcut içeriğinin sonuna eklenir. Örnek: dosya = fopen('dosya.txt', 'a');",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241834"
  },
  {
    "question": "C dilinde bir dosyanın içeriğini nasıl görüntüleyebilirim?",
    "answer": "Bir dosyanın içeriğini görüntülemek için dosyayı okuma modunda açmalı ve döngü ile satırları okumalısınız. Örnek: char buffer[100]; while (fgets(buffer, 100, dosya) != NULL) { printf('%s', buffer); }",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241854"
  },
  {
    "question": "C dilinde binary dosya okumak için hangi fonksiyonu kullanmalıyım?",
    "answer": "Binary dosya okumak için 'fread' fonksiyonunu kullanmalısınız. Bu fonksiyon bir bellek alanına belirli bir boyutta veri okur. Örnek: fread(&veri, sizeof(veri), 1, dosya);",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241876"
  },
  {
    "question": "C dilinde dosya okuma ve yazma işlemlerinde hata kontrolü nasıl yapılır?",
    "answer": "Dosya işlemleri sırasında hata kontrolü yapmak için dosya açma işlemi sonrası dosya işaretçisini kontrol edebilir ve 'ferror' fonksiyonu ile hata durumunu kontrol edebilirsiniz. Örnek: if (ferror(dosya)) { printf('Hata oluştu.'); }",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:46:56.241899"
  },
  {
    "question": "Bir dosyayı okumak için gerekli adımlar nelerdir?",
    "answer": "Bir dosyayı okumak için aşağıdaki adımları izlemelisiniz:\n1. Dosyayı açmak için 'fopen' fonksiyonunu kullanmalısınız. Açma modunu 'r' olarak belirleyin (okuma modu).\n2. Dosyanın içeriğini okumak için 'fgetc', 'fgets' veya 'fread' gibi fonksiyonları kullanabilirsiniz.\n3. Okuma işlemi tamamlandığında, 'fclose' fonksiyonu ile dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157116"
  },
  {
    "question": "Bir dosyaya yazmak için hangi modları kullanmalıyım?",
    "answer": "Dosyaya yazmak için 'fopen' fonksiyonunu kullanırken aşağıdaki modlardan birini seçmelisiniz:\n- 'w': Dosya yoksa oluşturur, varsa içeriğini siler ve yazmaya başlar.\n- 'a': Dosyayı açar ve içeriğin sonuna yazma işlemi yapar. Önceki verileri silmez.\nBu modlardan birini seçerek dosya açtıktan sonra 'fprintf' veya 'fputs' gibi fonksiyonlar ile yazma işlemini gerçekleştirebilirsiniz.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157168"
  },
  {
    "question": "Dosyadan bir satır okumak için hangi fonksiyonu kullanmalıyım?",
    "answer": "Bir dosyadan bir satır okumak için 'fgets' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, belirtilen boyutta bir buffer'a bir satır okur ve '\n' karakterine kadar olan verileri alır. Örneğin:\n```c\nchar buffer[100];\nfgets(buffer, sizeof(buffer), dosya);\n```\nBu kod, 'dosya' adlı dosyadan bir satır okur ve 'buffer' dizisine kaydeder.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157204"
  },
  {
    "question": "Bir dosyada belirli bir konuma nasıl gidilir?",
    "answer": "Dosyada belirli bir konuma gitmek için 'fseek' fonksiyonunu kullanabilirsiniz. Bu fonksiyon, dosya akışındaki konumu ayarlamanızı sağlar. Örnek kullanım:\n```c\nfseek(dosya, 10, SEEK_SET);\n```\nBurada, dosya akışını baştan itibaren 10. bayta götürmektedir. 'SEEK_CUR' ve 'SEEK_END' gibi diğer seçeneklerle de mevcut konumdan veya dosyanın sonundan itibaren hareket edebilirsiniz.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157235"
  },
  {
    "question": "Bir dosyadan okunan verileri nasıl işleyebilirim?",
    "answer": "Dosyadan okunan verileri işlemek için, veriyi okuduktan sonra istediğiniz türde bir işlem yapabilirsiniz. Örneğin, bir dosyadan satır satır veri okuyup her satırı bir tamsayıya dönüştürmek için 'atoi' fonksiyonunu kullanabilirsiniz:\n```c\nwhile(fgets(buffer, sizeof(buffer), dosya)) {\n    int sayi = atoi(buffer);\n    // sayi ile işlem yap\n}\n```\nBu kod, dosyadan her satırı okuyarak tamsayıya dönüştürür.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157263"
  },
  {
    "question": "Dosya okuma işlemi sırasında hata kontrolü nasıl yapılır?",
    "answer": "Dosya okuma işlemi sırasında hata kontrolü yapmak için, 'fopen' fonksiyonu sonrasında dosya pointer'ının NULL olup olmadığını kontrol edebilirsiniz. Eğer NULL ise, dosya açılamamıştır ve bir hata mesajı verebilirsiniz:\n```c\nFILE *dosya = fopen(\"dosya.txt\", \"r\");\nif (dosya == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}\n```\nBunun yanı sıra, okuma sırasında okuyucu fonksiyonların dönüş değerlerini kontrol ederek de hata kontrolü yapabilirsiniz.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157299"
  },
  {
    "question": "Binary dosya yazmak için nasıl bir yol izlemeliyim?",
    "answer": "Binary dosya yazmak için 'fopen' fonksiyonunu 'wb' modunda kullanmalısınız. Bu mod, verilerin ikili formatta yazılmasını sağlar. Örneğin:\n```c\nFILE *dosya = fopen(\"veri.bin\", \"wb\");\nif (dosya != NULL) {\n    int veri = 123;\n    fwrite(&veri, sizeof(int), 1, dosya);\n    fclose(dosya);\n}\n```\nBu kod, 'veri.bin' dosyasına bir tamsayıyı ikili formatta yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157335"
  },
  {
    "question": "Birden fazla dosya ile nasıl çalışabilirim?",
    "answer": "Birden fazla dosya ile çalışmak için, her dosya için ayrı 'FILE' pointer'ları tanımlayıp her bir dosyayı 'fopen' ile açmalısınız. Örneğin:\n```c\nFILE *dosya1 = fopen(\"dosya1.txt\", \"r\");\nFILE *dosya2 = fopen(\"dosya2.txt\", \"w\");\n// dosyalarla işlemler yap\nfclose(dosya1);\nfclose(dosya2);\n```\nHer dosya için açma ve kapama işlemlerini ayrı ayrı yapmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157363"
  },
  {
    "question": "File pointer'ı ile dosya arasında nasıl veri taşırım?",
    "answer": "File pointer kullanarak veri taşımak için 'fread' ve 'fwrite' fonksiyonları kullanılır. Bu fonksiyonlar, belirli bir byte sayısını okuma veya yazma imkanı sağlar. Örneğin:\n```c\nint veri[10];\nfread(veri, sizeof(int), 10, dosya);\n```\nBu kod, 'dosya' adlı dosyadan 10 tamsayıyı okur ve 'veri' dizisine yazar. Yazmak için ise:\n```c\nfwrite(veri, sizeof(int), 10, dosya);\n```\nşeklinde kullanılır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157395"
  },
  {
    "question": "Text dosyasını satır satır nasıl yazabilirim?",
    "answer": "Text dosyasına satır satır yazmak için 'fopen' ile dosyayı 'w' modunda açarak 'fprintf' veya 'fputs' fonksiyonunu kullanabilirsiniz. Örneğin:\n```c\nFILE *dosya = fopen(\"output.txt\", \"w\");\nif (dosya != NULL) {\n    fprintf(dosya, \"Bu bir test satırıdır.\\n\");\n    fputs(\"İkinci satır\\n\", dosya);\n    fclose(dosya);\n}\n```\nBu kod, 'output.txt' dosyasına iki satır yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:47:27.157423"
  },
  {
    "question": "C dilinde, bir dosyayı nasıl açar ve okuruz? Örnekle açıkla.",
    "answer": "C dilinde bir dosyayı açmak için 'fopen' fonksiyonu kullanılır. Dosya açma modunu belirlemek önemlidir; örneğin, 'r' okuma modu içindir. Aşağıdaki örnekte bir dosya nasıl açılır ve okunur gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[100];\n\n    file = fopen(\"ornek.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"Okunan satır: %s\", buffer);\n    }\n\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasını açar ve içeriğini satır satır okur.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946242"
  },
  {
    "question": "Bir dosyaya veri yazmak için hangi adımlar izlenmelidir? Örnekle göster.",
    "answer": "Bir dosyaya veri yazmak için de 'fopen' fonksiyonunu kullanarak dosyayı yazma modunda açmalısınız. Yazma modu 'w' veya 'a' olarak belirlenebilir; 'w' dosyayı sıfırdan yazar, 'a' ise mevcut içeriğe ekler. Aşağıda bir dosyaya veri yazma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"output.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fprintf(file, \"Bu bir test yazısıdır.\\n\"); // Dosyaya yazı yaz\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, \"output.txt\" adlı dosyayı oluşturur ve içine bir metin yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946304"
  },
  {
    "question": "Bir dosyadan okunan verinin biçimlendirilmesi nasıl yapılır? Örnek ver.",
    "answer": "Dosyadan okunan veriyi biçimlendirmek için 'fscanf' veya 'fgets' ile veriyi okuduktan sonra uygun biçimlendirme fonksiyonlarını kullanabilirsiniz. Aşağıda bir dosyadan tam sayıları okuma ve biçimlendirme örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int number;\n    file = fopen(\"numbers.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%d\", &number) != EOF) {\n        printf(\"Okunan sayı: %d\\n\", number); // Okunan sayıyı biçimlendirerek yazdır\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, \"numbers.txt\" dosyasındaki tam sayıları okur ve ekrana biçimlendirilmiş olarak yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946345"
  },
  {
    "question": "Bir dosyayı nasıl güvenli bir şekilde kapatabiliriz ve bunun önemi nedir?",
    "answer": "Bir dosyayı kapatmak için 'fclose' fonksiyonu kullanılır. Dosyayı kapatmak, bellekteki kaynakları serbest bırakmak ve verilerin diske yazılmasını sağlamak için önemlidir. Aşağıda dosyanın güvenli bir şekilde kapatılması gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"data.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fprintf(file, \"Veri yazıldı.\\n\");\n    if (fclose(file) != 0) {\n        printf(\"Dosya kapatma hatası!\\n\");\n    }\n    return 0;\n}\n```\nBu kod, dosyayı yazdıktan sonra kapatırken olası hataları kontrol eder.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946386"
  },
  {
    "question": "Bir dosyayı okuma ve yazma modunda açmanın avantajları nelerdir?",
    "answer": "Bir dosyayı okuma ve yazma modunda açmak, dosyanın içeriğini hem okuyabilmeyi hem de güncelleyebilmeyi sağlar. Bu, özellikle verilerin sürekli güncellenmesi gereken uygulamalarda yararlıdır. Aşağıda okuma ve yazma modunda dosya açma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int number;\n    file = fopen(\"data.txt\", \"r+\" ); // Okuma ve yazma modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fscanf(file, \"%d\", &number);\n    printf(\"Okunan sayı: %d\\n\", number);\n    fprintf(file, \"\\nYeni veri: %d\", number + 1); // Dosyaya yeni veri yaz\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosyadan bir sayı okur ve ardından dosyaya yeni bir veri yazar.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946422"
  },
  {
    "question": "Binary dosya okuma ve yazma işlemleri nasıl yapılır? Örnekle açıkla.",
    "answer": "Binary dosya okuma ve yazma işlemleri için 'b' modu kullanılır. Bu modda dosya, ikili veri olarak ele alınır. Aşağıda bir binary dosyaya tam sayı yazma ve okuma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int number = 12345;\n    file = fopen(\"binarydata.bin\", \"wb\"); // Binary yazma modunda aç\n    fwrite(&number, sizeof(int), 1, file); // Sayıyı yaz\n    fclose(file);\n\n    int readNumber;\n    file = fopen(\"binarydata.bin\", \"rb\"); // Binary okuma modunda aç\n    fread(&readNumber, sizeof(int), 1, file); // Sayıyı oku\n    fclose(file);\n    printf(\"Okunan sayı: %d\\n\", readNumber);\n    return 0;\n}\n```\nBu kod, \"binarydata.bin\" dosyasına bir tam sayı yazar ve ardından bu sayıyı okur.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946461"
  },
  {
    "question": "Dosya açma hatalarını nasıl kontrol edebiliriz? Pratik bir örnek ver.",
    "answer": "Dosya açma işlemi sonrası, dosya pointer'ının NULL olup olmadığını kontrol ederek hata kontrolü yapabiliriz. Aşağıda bu kontrolün nasıl yapıldığına dair bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent.txt\", \"r\"); // Var olmayan bir dosyayı açmayı dene\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\"); // Hata mesajı göster\n        return 1;\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu kod, \"nonexistent.txt\" dosyasını açmaya çalışır ve dosya açılamazsa 'perror' fonksiyonu ile sistem hata mesajını gösterir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946502"
  },
  {
    "question": "C dilinde bir dosyadan belirli bir konumdan veri okumak nasıl yapılır? Örnek ver.",
    "answer": "Bir dosyadan belirli bir konumdan veri okumak için 'fseek' fonksiyonu kullanılır. Bu fonksiyon ile dosya içindeki okuma konumunu değiştirebiliriz. Aşağıda bir dosyadan belirli bir konumdan veri okuma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fseek(file, 10, SEEK_SET); // 10. bayta git\n    char c = fgetc(file); // O konumdan bir karakter oku\n    printf(\"Okunan karakter: %c\\n\", c);\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, \"data.txt\" dosyasındaki 10. bayttan bir karakter okur.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946564"
  },
  {
    "question": "Bir dosyanın sonuna veri eklemek için hangi adımlar izlenmelidir? Örnekle açıkla.",
    "answer": "Bir dosyanın sonuna veri eklemek için dosyayı 'a' modunda açmalısınız. Bu mod, mevcut dosya içeriğini korur ve yeni verileri dosyanın sonuna ekler. Aşağıda bir dosyaya sonuna veri ekleme örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"append.txt\", \"a\"); // Dosyayı ekleme modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fprintf(file, \"Yeni veri ekleniyor.\\n\"); // Veriyi ekle\n    fclose(file);\n    return 0;\n}\n```\nBu kod, \"append.txt\" dosyasının sonuna bir metin ekler.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:48:03.946615"
  },
  {
    "question": "Bir dosyadan metin verilerini nasıl okuyabilirim?",
    "answer": "C dilinde bir dosyadan metin verilerini okumak için 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanabilirsiniz. Öncelikle dosyayı okuma modunda açmalısınız. Daha sonra 'fgets' ile satır satır okuyabilirsiniz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[255];\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    // Dosyadan satırları oku\n    while (fgets(buffer, 255, file)) {\n        printf(\"Okunan satır: %s\", buffer);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052441"
  },
  {
    "question": "Bir dosyaya nasıl veri yazabilirim?",
    "answer": "C dilinde bir dosyaya veri yazmak için 'fopen', 'fprintf' ve 'fclose' fonksiyonlarını kullanabilirsiniz. Dosyayı yazma modunda açarak verileri yazabilirsiniz. Aşağıdaki örnek, bir dosyaya basit bir metin yazmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n\n    // Dosyayı yazma modunda aç\n    file = fopen(\"cikti.txt\", \"w\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    // Dosyaya veri yaz\n    fprintf(file, \"Merhaba Dünya!\\n\");\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052475"
  },
  {
    "question": "Bir dosyanın içeriğini nasıl satır satır okuyabilirim?",
    "answer": "Bir dosyanın içeriğini satır satır okumak için yine 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanabilirsiniz. Aşağıdaki örnek, dosyayı satır satır okuma işlemini gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Satır satır oku\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"Satır: %s\", line);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052497"
  },
  {
    "question": "Bir dosyadan tam sayıları okuyup toplayabilir miyim?",
    "answer": "Evet, bir dosyadan tam sayıları okuyup toplamak için 'fscanf' fonksiyonunu kullanabilirsiniz. Dosyada her bir satırda bir tam sayı olduğunu varsayarsak, aşağıdaki kod bu işlemi gerçekleştirmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int number, sum = 0;\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"sayilar.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Sayıları oku ve topla\n    while (fscanf(file, \"%d\", &number) != EOF) {\n        sum += number;\n    }\n\n    // Toplamı yaz\n    printf(\"Toplam: %d\\n\", sum);\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052535"
  },
  {
    "question": "Binary (ikili) bir dosyayı nasıl okuyabilirim?",
    "answer": "Binary dosyaları okumak için 'fopen' fonksiyonunu 'rb' modunda kullanmalısınız. Aşağıdaki örnek, bir binary dosyadan veri okumaktadır:\n\n```c\n#include <stdio.h>\n\nstruct Data {\n    int id;\n    float value;\n};\n\nint main() {\n    FILE *file;\n    struct Data data;\n\n    // Dosyayı binary modda aç\n    file = fopen(\"veri.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Binary dosyadan veri oku\n    fread(&data, sizeof(struct Data), 1, file);\n    printf(\"ID: %d, Değer: %.2f\\n\", data.id, data.value);\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052555"
  },
  {
    "question": "Bir dosyaya bir dizi elemanlarını nasıl yazabilirim?",
    "answer": "Bir dizi elemanlarını bir dosyaya yazmak için 'fopen' ve 'fprintf' fonksiyonlarını kullanabilirsiniz. Aşağıdaki örnek, bir tam sayı dizisini bir dosyaya yazmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int dizi[] = {1, 2, 3, 4, 5};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n\n    // Dosyayı yazma modunda aç\n    file = fopen(\"dizi.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Diziyi dosyaya yaz\n    for (int i = 0; i < n; i++) {\n        fprintf(file, \"%d\\n\", dizi[i]);\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052575"
  },
  {
    "question": "Bir dosyayı kopyalamak için hangi adımları izlemeliyim?",
    "answer": "Bir dosyayı kopyalamak için önce kaynak dosyayı okuma; hedef dosyayı ise yazma modunda açmalısınız. Aşağıdaki örnek, bir dosyanın içeriğini başka bir dosyaya kopyalamaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *src, *dest;\n    char buffer[256];\n\n    // Kaynak dosyayı aç\n    src = fopen(\"kaynak.txt\", \"r\");\n    if (src == NULL) {\n        perror(\"Kaynak dosya açılamadı\");\n        return 1;\n    }\n\n    // Hedef dosyayı aç\n    dest = fopen(\"hedef.txt\", \"w\");\n    if (dest == NULL) {\n        fclose(src);\n        perror(\"Hedef dosya açılamadı\");\n        return 1;\n    }\n\n    // Kaynak dosyadan okuyup hedef dosyaya yaz\n    while (fgets(buffer, sizeof(buffer), src) != NULL) {\n        fputs(buffer, dest);\n    }\n\n    // Dosyaları kapat\n    fclose(src);\n    fclose(dest);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052595"
  },
  {
    "question": "Text dosyasındaki belirli bir kelimeyi nasıl değiştirebilirim?",
    "answer": "Bir metin dosyasındaki belirli bir kelimeyi değiştirmek için dosyayı okuyup içeriğini belleğe almalı, ardından değişiklikleri uygulayıp tekrar dosyaya yazmalısınız. Aşağıdaki örnek, bir kelimeyi değiştirmektedir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char buffer[256];\n    const char *oldWord = \"eski\";\n    const char *newWord = \"yeni\";\n    char temp[256];\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyanın içeriğini oku\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        // Kelimeyi değiştir\n        if (strstr(buffer, oldWord) != NULL) {\n            strcpy(temp, buffer);\n            char *pos = strstr(temp, oldWord);\n            strncpy(pos, newWord, strlen(newWord));\n            printf(\"Değiştirilmiş: %s\", temp);\n        }\n    }\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052616"
  },
  {
    "question": "Bir dosya içerisinde kaç satır olduğunu nasıl bulabilirim?",
    "answer": "Bir dosya içerisinde kaç satır olduğunu bulmak için dosyayı satır satır okuyarak bir sayaç kullanabilirsiniz. Aşağıdaki örnek, dosyada kaç satır olduğunu göstermektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char buffer[256];\n    int lineCount = 0;\n\n    // Dosyayı okuma modunda aç\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Satırları oku ve say\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        lineCount++;\n    }\n\n    // Satır sayısını yaz\n    printf(\"Dosyada %d satır var.\\n\", lineCount);\n\n    // Dosyayı kapat\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:16.052636"
  },
  {
    "question": "C dilinde bir metin dosyasını nasıl okuyabilirim ve içeriğini ekrana yazdırabilirim?",
    "answer": "C dilinde bir metin dosyasını okumak için 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanabiliriz. Öncelikle dosyayı 'r' modunda açmamız gerekir. Aşağıdaki kod parçasını inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n\n    file = fopen(\"ornek.txt\", \"r\"); // Dosya aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) { // Dosyadan okuma\n        printf(\"%s\", line); // Ekrana yazdır\n    }\n\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506595"
  },
  {
    "question": "C dilinde bir dosyaya nasıl veri yazabilirim?",
    "answer": "Bir dosyaya veri yazmak için 'fopen' fonksiyonu ile dosyayı 'w' modunda açmamız gerekir. Ardından 'fprintf' veya 'fputs' gibi fonksiyonlarla verimizi yazabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"yeni_dosya.txt\", \"w\"); // Yazma modunda dosyayı aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fprintf(file, \"Bu, dosyaya yazılan bir satırdır.\"); // Yaz\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506641"
  },
  {
    "question": "Bir dosyadan okunan verileri nasıl bir diziye kaydedebilirim?",
    "answer": "Dosyadan okunan verileri bir diziye kaydetmek için önce dosyayı okuyup verileri dizi elemanlarına yerleştirmemiz gerekir. Aşağıda bir örnek ile gösterilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char lines[10][256];\n    int i = 0;\n\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(lines[i], sizeof(lines[i]), file) && i < 10) { // 10 satıra kadar oku\n        i++;\n    }\n\n    fclose(file);\n\n    for (int j = 0; j < i; j++) {\n        printf(\"%s\", lines[j]); // Dizi elemanlarını yazdır\n    }\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506665"
  },
  {
    "question": "C dilinde bir dosyadaki verileri satır satır okuyup bir başka dosyaya nasıl yazabilirim?",
    "answer": "Bu işlem için kaynak dosyayı okuyup, içeriğini hedef dosyaya yazmamız gerekiyor. Aşağıdaki örnekte bu işlem gerçekleştirilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *sourceFile, *destFile;\n    char line[256];\n\n    sourceFile = fopen(\"kaynak.txt\", \"r\");\n    destFile = fopen(\"hedef.txt\", \"w\"); // Hedef dosyayı yazma modunda aç\n\n    if (sourceFile == NULL || destFile == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), sourceFile)) {\n        fputs(line, destFile); // Satırı hedef dosyaya yaz\n    }\n\n    fclose(sourceFile);\n    fclose(destFile);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506693"
  },
  {
    "question": "C dilinde dosya okuma işlemi sırasında hataları nasıl yönetebilirim?",
    "answer": "Dosya okuma sırasında hata yönetimi, dosyanın açılma işlemi sonrasında 'NULL' kontrolü yapılarak gerçekleştirilir. Ayrıca, 'perror' ile hata mesajı gösterilebilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    file = fopen(\"ornek.txt\", \"r\");\n\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506716"
  },
  {
    "question": "C dilinde binary (ikili) dosya okuma ve yazma işlemini nasıl gerçekleştiririm?",
    "answer": "Binary dosya okuma ve yazma işlemleri 'b' modu kullanılarak gerçekleştirilir. Aşağıda bir örnek ile gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int numbers[5] = {1, 2, 3, 4, 5};\n\n    file = fopen(\"sayilar.bin\", \"wb\"); // Binary yazma modunda aç\n    fwrite(numbers, sizeof(int), 5, file); // Veriyi yaz\n    fclose(file);\n\n    file = fopen(\"sayilar.bin\", \"rb\"); // Binary okuma modunda aç\n    int readNumbers[5];\n    fread(readNumbers, sizeof(int), 5, file); // Veriyi oku\n    fclose(file);\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", readNumbers[i]); // Okunan veriyi yazdır\n    }\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506742"
  },
  {
    "question": "C dilinde bir dosyanın sonuna veri eklemek için nasıl bir yöntem izlemeliyim?",
    "answer": "Dosyanın sonuna veri eklemek için dosyayı 'a' (append) modunda açarız. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"ornek.txt\", \"a\"); // Eklemek için dosyayı aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fprintf(file, \"Yeni bir satır ekleniyor.\"); // Yaz\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506768"
  },
  {
    "question": "C dilinde bir dosyadaki belirli bir satırı nasıl güncelleyebilirim?",
    "answer": "Bir dosyadaki belirli bir satırı güncellemek için dosyayı okuyup tüm satırları bir diziye kaydettikten sonra istenen satırı güncelleyip dosyayı tekrar yazmamız gerekir. Aşağıda bir örnek bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char lines[10][256];\n    int lineToEdit = 2; // Güncellenecek satır\n\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    int i = 0;\n    while (fgets(lines[i], sizeof(lines[i]), file) && i < 10) {\n        i++;\n    }\n    fclose(file);\n\n    // Güncelleme işlemi\n    snprintf(lines[lineToEdit], sizeof(lines[lineToEdit]), \"Güncellenmiş satır.\");\n\n    // Dosyaya yazma\n    file = fopen(\"ornek.txt\", \"w\");\n    for (int j = 0; j < i; j++) {\n        fputs(lines[j], file);\n    }\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506790"
  },
  {
    "question": "C dilinde karakterleri dosyadan okurken hangi yöntemleri kullanabilirim?",
    "answer": "Karakterleri dosyadan okumak için 'fgetc' fonksiyonu kullanılabilir. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch); // Karakterleri ekrana yazdır\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:49:57.506816"
  },
  {
    "question": "Bir dosyayı satır satır okuyarak içeriğini ekrana yazdıran bir C programı yazdım. Ancak programımda bellek sızıntısı olabilir mi? Kontrol etmem gereken noktalar neler?",
    "answer": "Evet, bellek sızıntısı oluşabilir. Dosyayı satır satır okurken kullanılan bellek alanının serbest bırakıldığından emin olun. Örneğin, malloc ile ayırdığınız her bellek alanını free ile serbest bırakmalısınız. Ayrıca, dosya okuma işlemi sırasında hata kontrolü yaparak, dosyanın her zaman doğru şekilde kapandığından emin olun.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char *line = malloc(256);\n    while (fgets(line, 256, file) != NULL) {\n        printf(\"%s\", line);\n    }\n    free(line);\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458467"
  },
  {
    "question": "Bir dosyaya veri yazdıktan sonra dosyanın içeriğini doğrulamak istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Veri yazdıktan sonra dosyayı tekrar açarak içeriği okuyabilir ve yazdığınız verilerle karşılaştırabilirsiniz. Bu, doğru yazılıp yazılmadığını kontrol etmek için iyi bir yöntemdir.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"w\");\n    const char *data = \"Merhaba Dünya!\";\n    fprintf(file, \"%s\", data);\n    fclose(file);\n\n    // Doğrulama\n    file = fopen(\"dosya.txt\", \"r\");\n    char buffer[256];\n    fgets(buffer, 256, file);\n    fclose(file);\n\n    if (strcmp(buffer, data) == 0) {\n        printf(\"Veri doğrulandı!\");\n    } else {\n        printf(\"Veri doğrulanamadı!\");\n    }\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458528"
  },
  {
    "question": "Aynı dosyaya aynı anda hem okuma hem yazma işlemi yapmak istiyorum. Hangi modları kullanmalıyım ve dikkat etmem gereken noktalar neler?",
    "answer": "Aynı anda hem okuma hem yazma işlemi için 'r+' veya 'w+' modlarını kullanabilirsiniz. 'r+' mevcut bir dosyayı okur ve yazma işlemini destekler, ancak dosya yoksa hata verir. 'w+' ise dosyayı sıfırlayarak açar. Dikkat etmeniz gereken nokta, dosya üzerindeki okuma ve yazma işlemlerinin doğru sırayla yapılmasıdır; aksi halde verilerin kaybolmasına neden olabilirsiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"r+\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char buffer[100];\n    fgets(buffer, 100, file);\n    printf(\"Okunan: %s\", buffer);\n    fseek(file, 0, SEEK_END);\n    fprintf(file, \"Yeni veri ekleniyor.\");\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458567"
  },
  {
    "question": "Büyük bir dosyayı okuduktan sonra bellekte fazladan yer kapladığını fark ettim. Bu durumu nasıl optimize edebilirim?",
    "answer": "Büyük dosyaları okurken, bellekte sadece gerekli sayıda veriyi tutmak için dinamik bellek yönetimi ve tamponlama tekniklerini kullanabilirsiniz. Örneğin, dosyayı parça parça okuyabilir ve her okuma işlemi sonrasında bellek alanını serbest bırakabilirsiniz. Ayrıca, dosya akışını bir tamponla okuyarak belleği daha verimli kullanabilirsiniz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"büyük_dosya.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char *buffer = malloc(1024);\n    while (fread(buffer, 1, 1024, file) > 0) {\n        // Veriyi işleyin\n    }\n    free(buffer);\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458600"
  },
  {
    "question": "Dosyayı yazma modunda açarken dosyanın içeriğinin kaybolmaması için ne yapmalıyım?",
    "answer": "Dosyayı açmadan önce içeriğini korumak için 'a' (ekleme) modunu kullanabilirsiniz. Bu mod, dosyanın mevcut içeriğini silmeden yeni verileri eklemenize olanak tanır. Ayrıca, dosyayı 'r+' moduyla açarak okuma ve yazma işlemlerini aynı anda gerçekleştirebilirsiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"a\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fprintf(file, \"Yeni veri ekleniyor.\");\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458627"
  },
  {
    "question": "Bir dosyadan belirli bir sayıda bayt okumak istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Dosya akışından belirli sayıda bayt okumak için fread fonksiyonunu kullanabilirsiniz. Bu fonksiyon, istenen bayt sayısını okur ve bu baytları bir bellek alanına yazar. Okunan bayt sayısını kontrol ederek işlemin başarısını gözlemleyebilirsiniz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char buffer[10];\n    size_t bytesRead = fread(buffer, 1, sizeof(buffer), file);\n    printf(\"Okunan bayt sayısı: %zu\\n\", bytesRead);\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458654"
  },
  {
    "question": "Bir dosyayı açarken hata kontrolü yapmadan devam etsem ne tür sorunlar yaşayabilirim?",
    "answer": "Hata kontrolü yapmadan dosyayı açmak, dosya mevcut değilse veya erişim izni yoksa programınızın beklenmeyen şekilde çalışmasına neden olabilir. Bu tür durumlar, NULL işaretçi erişimi ve programın çökmesi gibi sorunlara yol açabilir. Bu nedenle, dosya açma işlemi sonrasında NULL kontrolü yapmalı ve uygun hata mesajları vermelisiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya işlemleri\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458681"
  },
  {
    "question": "Bir dosyaya veri yazarken verilerin formatını nasıl kontrol edebilirim?",
    "answer": "Veri yazma işlemi öncesinde yazılacak verinin formatını kontrol etmek için çeşitli yollar kullanabilirsiniz. Örneğin, yazılacak verinin tipini kontrol ederek veya önceden belirlenmiş bir formatta olup olmadığını kontrol ederek başlayabilirsiniz. Yazma işlemi sırasında hata kontrolü de yaparak yazma işleminin başarıyla gerçekleşip gerçekleşmediğini görebilirsiniz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int number = 42;\n    FILE *file = fopen(\"dosya.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    if (fprintf(file, \"%d\", number) < 0) {\n        perror(\"Yazma hatası\");\n    }\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458704"
  },
  {
    "question": "Bir dosyadan tüm verileri okuyup bir diziye kaydetmek istiyorum. Bu işlemin en etkili yolu nedir?",
    "answer": "Dosyadan tüm verileri okumak için, dosyanın boyutunu öğrenip ardından bir diziye yüklemek en etkili yol olacaktır. Bu şekilde, bellekte tam boyutta bir dizi oluşturabilir ve tüm verileri bir kerede okuyabilirsiniz. Hata kontrolü yapmayı unutmayın.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"dosya.txt\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fseek(file, 0, SEEK_END);\n    long size = ftell(file);\n    rewind(file);\n\n    char *buffer = malloc(size);\n    fread(buffer, 1, size, file);\n    fclose(file);\n\n    // Veriyi kullanabilirsiniz\n    free(buffer);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:50:40.458733"
  },
  {
    "question": "C dilinde bir dosyayı okuma ve yazma işlemi nasıl gerçekleştirilir? Örnek bir kod parçası ile göster.",
    "answer": "C dilinde dosya okuma ve yazma işlemleri için stdio.h kütüphanesinde yer alan fopen, fread, fwrite ve fclose fonksiyonları kullanılır. Aşağıdaki örnekte bir dosya oluşturup, içine veri yazmayı ve ardından veriyi okumayı görebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char data[] = \"Merhaba, Dünya!\";\n\n    // Dosyayı yazma modunda açıyoruz\n    file = fopen(\"ornek.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Veriyi dosyaya yazıyoruz\n    fwrite(data, sizeof(char), sizeof(data), file);\n    fclose(file);\n\n    // Dosyayı okuma modunda açıyoruz\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char buffer[50];\n    fread(buffer, sizeof(char), sizeof(buffer), file);\n    printf(\"Dosyadan okunan veri: %s\\n\", buffer);\n    fclose(file);\n\n    return EXIT_SUCCESS;\n}\n```\nBu örnekte veriyi önce dosyaya yazıyoruz, ardından dosyayı okuyup ekrana yazdırıyoruz.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080714"
  },
  {
    "question": "Dosya açma işlemi sırasında hata yönetimi nasıl yapılmalıdır?",
    "answer": "Dosya açma işlemi sırasında, dosyanın başarıyla açılıp açılmadığını kontrol etmek önemlidir. Aşağıdaki örnekte, dosya açma işlemi sonrasında hata kontrolü yapılıyor:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Hata: Dosya açılamadı!\\n\");\n        return EXIT_FAILURE;\n    }\n    // ... dosya işlemleri ...\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, dosya açma başarısız olursa ekrana hata mesajı yazdırır ve programı sonlandırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080769"
  },
  {
    "question": "Bir dosyayı satır satır okumanın en etkili yolu nedir?",
    "answer": "Bir dosyayı satır satır okumak için fgets fonksiyonu kullanılabilir. Bu fonksiyon, her seferinde bir satırı okuyarak verir. Aşağıdaki örnekte, bir dosyadaki tüm satırları okuyup ekrana yazdıran bir kod verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char buffer[256];\n    file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu örnek, dosyadaki her satırı okuyup ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080807"
  },
  {
    "question": "Binary dosyası okuma ve yazma işlemleri nasıl yapılır? Örnek ver.",
    "answer": "Binary dosyaları okuma ve yazma işlemleri için, dosya açılırken \"b\" modifiye edicisi kullanılır. Aşağıdaki örnekte bir dizi tam sayıyı binary olarak dosyaya yazıyor ve ardından okuyoruz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    int numbers[] = {1, 2, 3, 4, 5};\n    size_t size = sizeof(numbers);\n\n    // Binary dosyaya yazma\n    file = fopen(\"sayilar.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fwrite(numbers, sizeof(int), 5, file);\n    fclose(file);\n\n    // Binary dosyadan okuma\n    int readNumbers[5];\n    file = fopen(\"sayilar.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fread(readNumbers, sizeof(int), 5, file);\n    fclose(file);\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d \", readNumbers[i]);\n    }\n    return EXIT_SUCCESS;\n}\n```\nBu kod, sayıları binary olarak yazar ve okur.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080848"
  },
  {
    "question": "Dosya yazma esnasında bir hata ile karşılaştığımızda ne yapmalıyız?",
    "answer": "Dosya yazma işlemleri esnasında hata yönetimi yapmak önemlidir. fwrite fonksiyonunun döndürdüğü değeri kontrol ederek, yazma işleminin başarılı olup olmadığını görebiliriz. Aşağıdaki örnekte, yazma işlemi sırasında hata kontrolü yapılmıştır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    char data[] = \"Merhaba!\";\n    file = fopen(\"ornek.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    size_t written = fwrite(data, sizeof(char), sizeof(data), file);\n    if (written < sizeof(data)) {\n        fprintf(stderr, \"Yazma hatası!\\n\");\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, yazma işlemi sırasında hata oluşursa bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080895"
  },
  {
    "question": "Bir dosyanın sonuna veri eklemek için hangi modda açmalıyız?",
    "answer": "Bir dosyanın sonuna veri eklemek için 'a' (append) modunu kullanmalıyız. Bu modda dosya açıldığında, yeni veriler mevcut verilerin sonuna eklenir. Aşağıdaki örnekte, bir dosyaya veri eklenmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"ornek.txt\", \"a\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fprintf(file, \"Yeni veri ekleniyor.\\n\");\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, belirtilen dosyaya yeni veri ekler.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080933"
  },
  {
    "question": "C dilinde bir dosyayı nasıl güvenli bir şekilde kapatabiliriz?",
    "answer": "Bir dosyayı güvenli bir şekilde kapatmak için fclose fonksiyonunu kullanmalıyız. Ancak, dosya açma işlemi sırasında bir hata oluştuysa, fclose fonksiyonu çağrılmamalıdır. Bu durumu kontrol etmek için, dosya pointer'ının null olup olmadığını kontrol edebiliriz. Aşağıdaki örnekte gösterilmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    // ... dosya işlemleri ...\n\n    // Dosyayı kapatma işlemi\n    if (file) {\n        fclose(file);\n    }\n    return EXIT_SUCCESS;\n}\n```\nBu kod, dosya açıldıysa fclose fonksiyonunu güvenli bir şekilde çağırır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.080972"
  },
  {
    "question": "Dosya okuma ve yazma işlemlerinde bellek yönetimi neden önemlidir?",
    "answer": "Dosya okuma ve yazma işlemlerinde bellek yönetimi, bellekte yeterli alan olup olmadığını kontrol etmek ve bellek sızıntılarını önlemek açısından önemlidir. Özellikle büyük dosyalarla çalışırken, malloc gibi dinamik bellek tahsis fonksiyonlarını kullanmak gerekebilir. Aşağıdaki örnekte, dinamik bellek kullanarak dosya okuma işlemi gösterilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long fileSize = ftell(file);\n    rewind(file);\n\n    char *buffer = (char *)malloc(fileSize + 1);\n    if (buffer == NULL) {\n        perror(\"Bellek tahsis hatası\");\n        fclose(file);\n        return EXIT_FAILURE;\n    }\n\n    fread(buffer, sizeof(char), fileSize, file);\n    buffer[fileSize] = '\\0'; // Null karakter ekle\n    printf(\"Dosyadan okunan veri: %s\\n\", buffer);\n\n    free(buffer);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, dosyanın boyutunu öğrenir, dinamik bellek tahsisi yapar ve dosyayı okuduktan sonra belleği serbest bırakır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.081012"
  },
  {
    "question": "C dilinde diziler yerine işaretçi (pointer) kullanarak dosya okuma işlemi nasıl gerçekleştirilir?",
    "answer": "Dosya okuma işlemlerinde işaretçi (pointer) kullanmak, bellek yönetimini daha esnek hale getirir. Aşağıdaki örnekte bir dosyadaki verileri işaretçi kullanarak okuma işlemi yapılmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"ornek.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Dosyanın boyutunu öğren\n    fseek(file, 0, SEEK_END);\n    long fileSize = ftell(file);\n    rewind(file);\n\n    char *buffer = (char *)malloc(fileSize + 1);\n    if (buffer == NULL) {\n        perror(\"Bellek tahsis hatası\");\n        fclose(file);\n        return EXIT_FAILURE;\n    }\n\n    fread(buffer, sizeof(char), fileSize, file);\n    buffer[fileSize] = '\\0'; // Null karakter ekle\n    printf(\"Dosyadan okunan veri: %s\\n\", buffer);\n\n    free(buffer);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu örnekte, işaretçi kullanarak bellekte dinamik bir buffer oluşturulmakta ve bu buffer ile dosyadan veri okunmaktadır.",
    "category": "file_operations",
    "topic": "file_basics",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya okuma/yazma temelleri",
    "timestamp": "2025-06-01T16:51:21.081063"
  },
  {
    "question": "Bir binary dosya açma ve okuma işlemi yapmak için kodu tamamla: FILE *fp; fp = fopen(\"dosya.bin\", \"_____);\nif (fp == NULL) {\n    printf(\"Dosya açılamadı.\");\n    return 1;\n}",
    "answer": "FILE *fp; fp = fopen(\"dosya.bin\", \"rb\");\nif (fp == NULL) {\n    printf(\"Dosya açılamadı.\");\n    return 1;\n}\n// 'rb', binary dosyayı okuma modunda açmak için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326148"
  },
  {
    "question": "Bir binary dosyaya yazma işlemi gerçekleştirecek kodu tamamla: FILE *fp; fp = fopen(\"yeni_dosya.bin\", \"_____);\nif (fp == NULL) {\n    printf(\"Dosya açılamadı.\");\n    return 1;\n}",
    "answer": "FILE *fp; fp = fopen(\"yeni_dosya.bin\", \"wb\");\nif (fp == NULL) {\n    printf(\"Dosya açılamadı.\");\n    return 1;\n}\n// 'wb', binary dosyayı yazma modunda açmak için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326220"
  },
  {
    "question": "Binary dosyadan bir integer değeri okumak için kodu tamamla: int sayi;\n fread(&sayi, sizeof(int), 1, _____);",
    "answer": "int sayi;\nfread(&sayi, sizeof(int), 1, fp);\n// fread fonksiyonu binary dosyadan belirtilen boyuttaki veriyi okumak için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326258"
  },
  {
    "question": "Binary dosyaya bir float değeri yazmak için gereken kodu tamamla: float pi = 3.14;\n fwrite(&pi, sizeof(float), 1, _____);",
    "answer": "float pi = 3.14;\nfwrite(&pi, sizeof(float), 1, fp);\n// fwrite fonksiyonu binary dosyaya belirtilen boyuttaki veriyi yazmak için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326299"
  },
  {
    "question": "Binary dosyayı kapatma işlemi için kodu tamamla: fclose(____);",
    "answer": "fclose(fp);\n// fclose fonksiyonu açılan binary dosyayı kapatmak için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326322"
  },
  {
    "question": "Bir binary dosyadan belirli bir konumdan okumak için gereken kodu tamamla: fseek(fp, _____, SEEK_SET);",
    "answer": "fseek(fp, 0, SEEK_SET);\n// fseek fonksiyonu dosya konumunu değiştirmek için kullanılır, SEEK_SET başlangıçtan itibaren konum belirler.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326359"
  },
  {
    "question": "Binary dosyada veri okuma işlemi için bir döngü yazmak istiyorum, kodu tamamla: while (fread(&sayi, sizeof(int), 1, fp) == 1) {\n    printf(\"Okunan sayı: %d\\n\", sayi);\n    // burada yapılacak işlemler\n}",
    "answer": "while (fread(&sayi, sizeof(int), 1, fp) == 1) {\n    printf(\"Okunan sayı: %d\\n\", sayi);\n    // burada yapılacak işlemler\n}\n// Bu döngü, dosyadan veriler okunurken çalışır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326423"
  },
  {
    "question": "Binary dosyaya bir dizi yazmak için gereken kodu tamamla: int dizi[5] = {1, 2, 3, 4, 5};\n fwrite(dizi, sizeof(int), _____, fp);",
    "answer": "int dizi[5] = {1, 2, 3, 4, 5};\nfwrite(dizi, sizeof(int), 5, fp);\n// Burada dizideki tüm elemanları binary dosyaya yazıyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326468"
  },
  {
    "question": "Binary dosyadan tüm verileri okumak için gereken kodu tamamla: int dizi[10];\n fread(dizi, sizeof(int), _____, fp);",
    "answer": "int dizi[10];\nfread(dizi, sizeof(int), 10, fp);\n// Bu kod, binary dosyadan 10 adet integer okur ve diziye atar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326525"
  },
  {
    "question": "Binary dosyaya veri yazdıktan sonra dosyayı kapatmayı unuttum, bu kodu tamamla: // fwrite işlemi burada yapıldı\n_____",
    "answer": "fclose(fp);\n// Dosya yazma işlemi bittikten sonra dosyanın kapatılması gerekmektedir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326561"
  },
  {
    "question": "Binary dosyayı açarken nasıl bir hata kontrolü yapmalıyım? Kodun eksik kısmını tamamla: FILE *fp = fopen(\"dosya.bin\", \"rb\");\nif (_____){\n    printf(\"Dosya açılamadı.\");\n}",
    "answer": "if (fp == NULL) {\n    printf(\"Dosya açılamadı.\");\n}\n// Dosya açılamadıysa, NULL dönecektir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:51:42.326617"
  },
  {
    "question": "Bir binary dosyayı okuyup içeriğini ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    unsigned char buffer[256];\n    size_t bytesRead;\n\n    file = fopen(\"veri.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while ((bytesRead = fread(buffer, 1, sizeof(buffer), file)) > 0) {\n        for (size_t i = 0; i < bytesRead; i++) {\n            printf(\"%02X \", buffer[i]);\n        }\n    }\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'veri.bin' adlı binary dosyasını açıp içeriğini hex formatında ekrana yazdırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559483"
  },
  {
    "question": "Kullanıcının girdiği sayıları binary dosyaya yazan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int sayi;\n\n    file = fopen(\"sayilar.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    printf(\"Yazılacak sayıyı girin (0 ile çıkış): \");\n    while (1) {\n        scanf(\"%d\", &sayi);\n        if (sayi == 0) break;\n        fwrite(&sayi, sizeof(int), 1, file);\n    }\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, kullanıcıdan alınan sayıları 'sayilar.bin' adlı binary dosyasına yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559542"
  },
  {
    "question": "Bir binary dosyadan okunan sayıların ortalamasını hesaplayan bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int sayi;\n    int toplam = 0, sayac = 0;\n\n    file = fopen(\"sayilar.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fread(&sayi, sizeof(int), 1, file) == 1) {\n        toplam += sayi;\n        sayac++;\n    }\n\n    fclose(file);\n    if (sayac > 0) {\n        printf(\"Ortalama: %.2f\\n\", (double)toplam / sayac);\n    } else {\n        printf(\"Dosya boş\\n\");\n    }\n    return 0;\n}\n\n// Bu program, 'sayilar.bin' dosyasındaki sayıların ortalamasını hesaplar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559569"
  },
  {
    "question": "Bir binary dosyaya rastgele oluşturulmuş 10 adet tam sayı yazıp ardından okuyun.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    FILE *file;\n    int sayi;\n\n    file = fopen(\"rastgele_sayilar.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    srand(time(0));\n    for (int i = 0; i < 10; i++) {\n        sayi = rand() % 100;\n        fwrite(&sayi, sizeof(int), 1, file);\n    }\n\n    fclose(file);\n\n    file = fopen(\"rastgele_sayilar.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fread(&sayi, sizeof(int), 1, file) == 1) {\n        printf(\"%d \", sayi);\n    }\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, rastgele tam sayıları 'rastgele_sayilar.bin' dosyasına yazar ve ardından okur.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559596"
  },
  {
    "question": "Bir binary dosyadan belirli bir pozisyondan veri okuma ve yazma işlemi nasıl yapılır?",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    int yeniSayi = 42;\n    int mevcutSayi;\n\n    file = fopen(\"veri.bin\", \"r+b\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(file, 0, SEEK_SET); // Başlangıca git\n    fread(&mevcutSayi, sizeof(int), 1, file);\n    printf(\"Mevcut Sayı: %d\\n\", mevcutSayi);\n\n    fseek(file, 0, SEEK_SET); // Başlangıca tekrar git\n    fwrite(&yeniSayi, sizeof(int), 1, file);\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'veri.bin' dosyasındaki ilk int değerini okur, ardından onu 42 ile günceller.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559624"
  },
  {
    "question": "Bir binary dosyadaki veriyi tersine çevirip yeni dosyaya yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *inputFile, *outputFile;\n    int sayi;\n\n    inputFile = fopen(\"veri.bin\", \"rb\");\n    if (inputFile == NULL) {\n        perror(\"Giriş dosyası açılamadı\");\n        return 1;\n    }\n\n    outputFile = fopen(\"ters_veri.bin\", \"wb\");\n    if (outputFile == NULL) {\n        perror(\"Çıkış dosyası açılamadı\");\n        fclose(inputFile);\n        return 1;\n    }\n\n    fseek(inputFile, 0, SEEK_END);\n    long dosyaBoyutu = ftell(inputFile);\n    for (long i = dosyaBoyutu - sizeof(int); i >= 0; i -= sizeof(int)) {\n        fseek(inputFile, i, SEEK_SET);\n        fread(&sayi, sizeof(int), 1, inputFile);\n        fwrite(&sayi, sizeof(int), 1, outputFile);\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n\n// Bu program, 'veri.bin' dosyasındaki sayıları ters sırayla 'ters_veri.bin' dosyasına yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559648"
  },
  {
    "question": "Bir binary dosyaya yapı (struct) verisi yazıp okuyun.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nstruct Kisi {\n    char isim[50];\n    int yas;\n};\n\nint main() {\n    FILE *file;\n    struct Kisi kişi;\n\n    file = fopen(\"kisiler.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    strcpy(kişi.isim, \"Ali\");\n    kişi.yas = 30;\n    fwrite(&kişi, sizeof(struct Kisi), 1, file);\n    fclose(file);\n\n    file = fopen(\"kisiler.bin\", \"rb\");\n    fread(&kişi, sizeof(struct Kisi), 1, file);\n    printf(\"İsim: %s, Yaş: %d\\n\", kişi.isim, kişi.yas);\n\n    fclose(file);\n    return 0;\n}\n\n// Bu program, 'kisiler.bin' dosyasına bir yapı (struct) yazar ve ardından okur.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559708"
  },
  {
    "question": "Bir binary dosyadan okunan verileri sıralayıp yeni bir dosyaya yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    FILE *file;\n    int sayilar[100];\n    size_t sayac = 0;\n\n    file = fopen(\"sayilar.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fread(&sayilar[sayac], sizeof(int), 1, file) == 1) {\n        sayac++;\n    }\n    fclose(file);\n\n    qsort(sayilar, sayac, sizeof(int), compare);\n\n    file = fopen(\"sirali_sayilar.bin\", \"wb\");\n    fwrite(sayilar, sizeof(int), sayac, file);\n    fclose(file);\n\n    return 0;\n}\n\n// Bu program, 'sayilar.bin' dosyasındaki sayıları sıralar ve 'sirali_sayilar.bin' dosyasına yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559731"
  },
  {
    "question": "Bir binary dosyayı kopyalamak için bir program yazın.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *sourceFile, *destFile;\n    char buffer[1024];\n    size_t bytesRead;\n\n    sourceFile = fopen(\"kaynak.bin\", \"rb\");\n    if (sourceFile == NULL) {\n        perror(\"Kaynak dosya açılamadı\");\n        return 1;\n    }\n\n    destFile = fopen(\"hedef.bin\", \"wb\");\n    if (destFile == NULL) {\n        perror(\"Hedef dosya açılamadı\");\n        fclose(sourceFile);\n        return 1;\n    }\n\n    while ((bytesRead = fread(buffer, 1, sizeof(buffer), sourceFile)) > 0) {\n        fwrite(buffer, 1, bytesRead, destFile);\n    }\n\n    fclose(sourceFile);\n    fclose(destFile);\n    return 0;\n}\n\n// Bu program, 'kaynak.bin' dosyasını okuyup 'hedef.bin' dosyasına kopyalar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:52:28.559751"
  },
  {
    "question": "Bir binary dosyaya yapı (struct) yazma işlemini nasıl yapabilirim? Örnek olarak bir öğrenci yapısı tanımlayıp bunu binary dosyaya yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    Student student = {1, \"Ahmet Yılmaz\", 3.5};\n    FILE *file = fopen(\"students.dat\", \"wb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fwrite(&student, sizeof(Student), 1, file);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, bir öğrenci yapısı tanımlayıp onu 'students.dat' adlı binary dosyaya yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850591"
  },
  {
    "question": "Binary dosyadan veri okuma işlemini nasıl gerçekleştirebilirim? Örnek bir yapı üzerinden göster.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    Student student;\n    FILE *file = fopen(\"students.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fread(&student, sizeof(Student), 1, file);\n    printf(\"ID: %d, İsim: %s, GPA: %.2f\\n\", student.id, student.name, student.gpa);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, daha önce yazılmış bir öğrenci yapısını 'students.dat' dosyasından okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850653"
  },
  {
    "question": "Kullanıcıdan alınan öğrenci bilgilerini binary dosyaya nasıl yazabilirim? Kullanıcıdan veri girişi almak için bir örnek yap.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    Student student;\n    printf(\"Öğrenci ID'sini girin: \");\n    scanf(\"%d\", &student.id);\n    printf(\"Öğrenci ismini girin: \");\n    scanf(\"%s\", student.name);\n    printf(\"Öğrenci GPA'sını girin: \");\n    scanf(\"%f\", &student.gpa);\n\n    FILE *file = fopen(\"students.dat\", \"ab\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    fwrite(&student, sizeof(Student), 1, file);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, kullanıcıdan öğrenci bilgilerini alır ve 'students.dat' dosyasına ekler.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850688"
  },
  {
    "question": "Binary dosyadan birden fazla öğrenci kaydı nasıl okuyabilirim? Örnek ver.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    Student students[10];\n    FILE *file = fopen(\"students.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    size_t read_count = fread(students, sizeof(Student), 10, file);\n    for (size_t i = 0; i < read_count; i++) {\n        printf(\"ID: %d, İsim: %s, GPA: %.2f\\n\", students[i].id, students[i].name, students[i].gpa);\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, 'students.dat' dosyasından birden fazla öğrenci kaydını okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850713"
  },
  {
    "question": "Binary dosyadaki verileri güncellemek için nasıl bir yol izlemeliyim? Öğrenci ID'si ile güncelleme örneği ver.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    FILE *file = fopen(\"students.dat\", \"r+b\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    int id_to_update;\n    printf(\"Güncellemek istediğiniz öğrenci ID'sini girin: \");\n    scanf(\"%d\", &id_to_update);\n    Student student;\n    while (fread(&student, sizeof(Student), 1, file) == 1) {\n        if (student.id == id_to_update) {\n            printf(\"Yeni isim girin: \");\n            scanf(\"%s\", student.name);\n            printf(\"Yeni GPA girin: \");\n            scanf(\"%f\", &student.gpa);\n            fseek(file, -sizeof(Student), SEEK_CUR);\n            fwrite(&student, sizeof(Student), 1, file);\n            break;\n        }\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, belirtilen bir öğrenci ID'sine göre kayıt günceller.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850745"
  },
  {
    "question": "Bir binary dosyayı okuduktan sonra silme işlemi nasıl yapılır? Örneği göster.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    FILE *file = fopen(\"students.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    Student student;\n    while (fread(&student, sizeof(Student), 1, file) == 1) {\n        printf(\"ID: %d, İsim: %s, GPA: %.2f\\n\", student.id, student.name, student.gpa);\n    }\n    fclose(file);\n\n    remove(\"students.dat\"); // Dosyayı silme işlemi\n    printf(\"students.dat dosyası silindi.\\n\");\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, 'students.dat' dosyasını okuyup ardından siler.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850770"
  },
  {
    "question": "Binary dosya kopyalama işlemini nasıl gerçekleştirebilirim? Örnek bir kod yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid copy_binary_file(const char *source, const char *destination) {\n    FILE *src = fopen(source, \"rb\");\n    FILE *dest = fopen(destination, \"wb\");\n    if (src == NULL || dest == NULL) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n    char buffer[1024];\n    size_t bytes;\n    while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {\n        fwrite(buffer, 1, bytes, dest);\n    }\n    fclose(src);\n    fclose(dest);\n}\n\nint main() {\n    copy_binary_file(\"students.dat\", \"students_copy.dat\");\n    printf(\"students.dat dosyası students_copy.dat olarak kopyalandı.\\n\");\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, 'students.dat' dosyasını 'students_copy.dat' adında yeni bir dosyaya kopyalar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850795"
  },
  {
    "question": "Binary dosyaya rastgele erişim (random access) nasıl yapılır? Örnek bir senaryo ile göster.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint main() {\n    FILE *file = fopen(\"students.dat\", \"r+b\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    int record_number = 1; // Güncellenecek kaydın numarası\n    fseek(file, record_number * sizeof(Student), SEEK_SET);\n    Student student;\n    fread(&student, sizeof(Student), 1, file);\n    printf(\"Güncellenmeden önce: ID: %d, İsim: %s, GPA: %.2f\\n\", student.id, student.name, student.gpa);\n    student.gpa += 0.1; // GPA'yı güncelle\n    fseek(file, record_number * sizeof(Student), SEEK_SET);\n    fwrite(&student, sizeof(Student), 1, file);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, belirli bir kayda rastgele erişerek okuma ve güncelleme işlemi yapar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850823"
  },
  {
    "question": "Binary dosya üzerinde veri sıralama işlemi nasıl yapılır? Örnek bir kod yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float gpa;\n} Student;\n\nint compare(const void *a, const void *b) {\n    return ((Student *)b)->gpa - ((Student *)a)->gpa;\n}\n\nint main() {\n    Student students[10];\n    FILE *file = fopen(\"students.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n    size_t read_count = fread(students, sizeof(Student), 10, file);\n    qsort(students, read_count, sizeof(Student), compare);\n    fclose(file);\n\n    for (size_t i = 0; i < read_count; i++) {\n        printf(\"ID: %d, İsim: %s, GPA: %.2f\\n\", students[i].id, students[i].name, students[i].gpa);\n    }\n    return EXIT_SUCCESS;\n}\n\n// Açıklama: Bu kod, 'students.dat' dosyasındaki öğrencileri GPA'larına göre sıralar ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:02.850849"
  },
  {
    "question": "Binary dosya okuma işlemi sırasında, dosyanın boş olup olmadığını kontrol etmedim. Bu durum ne gibi hatalara yol açabilir?",
    "answer": "Boş bir dosyadan okuma yapmaya çalışmak, programın beklenmedik bir şekilde çökmesine neden olabilir. `fread` veya `fgetc` gibi fonksiyonlar, dosya boşsa bir hata döndürebilir veya 0 değer döndürebilir. Bu nedenle, dosyanın içeriğini okumadan önce `ftell` veya `feof` gibi fonksiyonlarla dosyanın boş olup olmadığını kontrol etmek önemlidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606401"
  },
  {
    "question": "Binary dosyayı açarken 'rb' modunu kullanmadım. Bunun sonuçları neler olabilir?",
    "answer": "'rb' modunu kullanmamak, dosyanın içeriğini yanlış okumanıza sebep olabilir. Özellikle platform bağımlı olan dosya kodlamaları yüzünden, doğru şekilde okunmayan dosya içeriği hatalı verilere veya programınızın çökmesine yol açabilir. Her zaman dosyayı okurken uygun mod kullanmalısınız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606446"
  },
  {
    "question": "Açtığım binary dosyayı kapatmayı unuttum. Bu hata ne gibi problemler yaratır?",
    "answer": "Dosya kapatılmadığında, sistem kaynakları serbest bırakılmaz ve bellek sızıntısına yol açabilir. Ayrıca, dosya üzerinde yaptığınız değişiklikler dosyaya yazılmamışsa kaybolabilir. Her zaman dosya işlemleri tamamlandıktan sonra `fclose` fonksiyonunu kullanarak dosyayı kapatmalısınız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606473"
  },
  {
    "question": "Binary dosyaya yazma işlemi yaparken, yeterli bellek alanı kontrolü yapmadım. Bu hata neden sorun yaratır?",
    "answer": "Yeterli bellek kontrolü yapılmadığında, bellek taşması yaşanabilir ve bu durum programın çökmesine veya dosya içeriğinin bozulmasına sebep olabilir. Yazmadan önce bellekte yeterli alan olup olmadığını kontrol etmek için `malloc` veya `calloc` gibi fonksiyonlarla bellek alanı ayırmalı ve kontrol etmelisiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606522"
  },
  {
    "question": "Binary dosyadan okuduğum verileri doğrudan bir değişkene atadım. Bu uygulama hangi hatalara yol açabilir?",
    "answer": "Okunan verilerin boyutunu kontrol etmediğinizde, buffer overflow (tampon taşması) hatası ile karşılaşabilirsiniz. Okunan veri değişkenin kapasitesinden büyükse, bellek alanına yazma işlemi yapılır ve bu durum programın çökmesine neden olabilir. Okumadan önce buffer boyutunu kontrol etmeli ve güvende olmalısınız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606553"
  },
  {
    "question": "Binary dosyaları işlerken, endianness (byte sıralaması) konusunu göz ardı ettim. Bu durum ne tür hatalara yol açabilir?",
    "answer": "Endianness sorununu göz ardı etmek, veri okuma ve yazma sırasında yanlış değerlerin elde edilmesine neden olabilir. Özellikle farklı platformlarda veri alışverişi yapıyorsanız, verilerin sıralaması uyumsuz olursa, hatalı ya da beklenmedik sonuçlar elde edersiniz. Bu nedenle, platformlar arası uyumluluk için endianness dikkate alınmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606590"
  },
  {
    "question": "Bir binary dosyayı `fwrite` ile yazarken, yazma işleminin sonucunu kontrol etmedim. Neden bu hata önemli?",
    "answer": "Yazma işleminin sonucunu kontrol etmemek, dosyaya beklenen verilerin yazılmaması veya hata alındığında bunun gözden kaçmasına sebep olabilir. `fwrite` fonksiyonu, başarılı olup olmadığını kontrol etmek için dönen değeri kontrol edilmeli ve hata durumunda uygun hata yönetimi yapılmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606626"
  },
  {
    "question": "Binary dosyadan verileri okurken, okuma işlemi sırasında `fscanf` kullandım. Bu hangi hatalara yol açar?",
    "answer": "Binary dosyalar için `fscanf` kullanmak, dosyanın içeriğinin yanlış bir şekilde yorumlanmasına neden olabilir. Binary dosyalarda veriler ikili formatta saklanır ve `fscanf` gibi fonksiyonlar metin formatında çalışır. Bu nedenle, ikili dosyalar için `fread` kullanmalısınız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606659"
  },
  {
    "question": "Binary dosya yazarken, dosyanın mevcut içeriğini silmeden yazma işlemi yapmak istedim ama 'wb' modunu kullanmadım. Bu ne gibi sorunlar yaratır?",
    "answer": "Dosyayı açarken 'wb' modunu kullanmazsanız, mevcut içeriği silmeden yazmaya çalışırsınız. Bu da yazdığınız verilerin dosyada karışmasına veya beklenmedik sonuçlar elde etmenize yol açabilir. Her zaman dosyayı yazma modunda açarken içeriği silmek istiyorsanız 'wb' modunu kullanmalısınız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606699"
  },
  {
    "question": "Bir binary dosyayı okuduktan sonra verileri işlemek için bir döngü yazdım, ancak döngü koşulunu doğru ayarlamadım. Bu hata ne tür sorunlara yol açabilir?",
    "answer": "Döngü koşulunu yanlış ayarlamak, sonsuz döngüye sebep olabilir. Bu durumda programınız yanıt vermez hale gelebilir ya da beklenmedik sonuçlar ile karşılaşabilirsiniz. Döngü koşulunu doğru bir şekilde belirlemek ve döngü sırasında dosyanın sonuna ulaşmayı kontrol etmek gereklidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:26.606742"
  },
  {
    "question": "Binary dosyasını açarken 'wb' yerine 'w' kullanırsak ne olur?",
    "answer": "'w' modunda bir dosya açıldığında dosya metin modunda açılır. Bu durumda ikili veriler, metin olarak kaydedilmeye çalışılır. Özellikle ikili veriler (örneğin resimler veya ses dosyaları) bozulur çünkü her bir byte'ı metin karakterleri gibi yorumlanır. Doğru mod 'wb' (write binary) kullanmak olmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144350"
  },
  {
    "question": "Bir binary dosyayı açarken fopen() fonksiyonu NULL dönerse hangi durumlar olabilir?",
    "answer": "fopen() fonksiyonu NULL dönerse, dosya açılamadı demektir. Bunun sebebi dosyanın mevcut olmaması, yanlış bir yol verilmesi veya dosyanın izinlerinin yetersiz olması olabilir. Dosya yolu doğru mu, dosya var mı ve gerekli izinlere sahip miyiz kontrol edilmelidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144416"
  },
  {
    "question": "Bir binary dosyadan okumada fread() fonksiyonu ile buffer boyutu yanlış verilirse ne olur?",
    "answer": "fread() fonksiyonuna verilen buffer boyutu yanlışsa, birden fazla durum ortaya çıkabilir. Eğer buffer boyutu dosyadan okunabilecek boyuttan büyükse, bellek sızıntısına sebep olabilir. Eğer buffer boyutu daha küçükse, eksik veri okunur. Bu durumda okunan verinin bütünlüğü kaybolur ve veri işleme hataları oluşabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144467"
  },
  {
    "question": "Binary dosyadan okunan veriyi doğru bir şekilde yazmak için neye dikkat etmeliyiz?",
    "answer": "Binary dosyadan okunan veriyi yazarken, verinin boyutunun ve tipinin doğru olduğundan emin olmalıyız. Ayrıca yazacağımız dosyayı 'wb' modunda açmalıyız. Veriyi okurken ve yazarken her zaman doğru türdeki pointer'ı kullanmak önemlidir; örneğin, bir struct'ı yazarken struct'ın boyutunu bilmek gereklidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144537"
  },
  {
    "question": "fseek() fonksiyonu kullanarak bir binary dosyada yanlış bir offset verilirse ne olur?",
    "answer": "fseek() fonksiyonu ile yanlış bir offset verilirse, dosya akışı beklenmedik bir konuma yerleşir. Bu durum, okuma ve yazma işlemleri sırasında hatalara sebep olabilir. Örneğin, mevcut dosya boyutunun dışına çıkılmaya çalışılırsa, bu bir hata mesajına veya 'EOF' (End of File) durumuna yol açar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144587"
  },
  {
    "question": "Binary dosyadan okuma yaparken veri bütünlüğünü kontrol etmek için ne yapmalıyız?",
    "answer": "Veri bütünlüğünü kontrol etmek için okunan veri miktarını kontrol etmeliyiz. fread() fonksiyonu, okunan veri miktarını döner. Eğer beklediğimizden daha az veri okunduysa, bu bir hata olduğunu gösterir. Ayrıca, dosya sonunu kontrol etmek için feof() fonksiyonunu kullanabiliriz. Okunan verinin doğru formatta olduğundan emin olmak için de kontrol mekanizmaları eklemeliyiz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144629"
  },
  {
    "question": "Dosya kapatılmadan önce fclose() çağrılmadığında ne gibi sorunlar meydana gelir?",
    "answer": "fclose() çağrılmadığında, dosya sisteminde dosyanın tam olarak yazılmaması ve açık dosya tanımlayıcılarının sistem kaynaklarını tüketmesi gibi sorunlar ortaya çıkar. Bu durum, veri kaybına veya sistemin dosya sayısının dolmasına yol açabilir. Bu nedenle, dosya işlemleri tamamlandıktan sonra her zaman fclose() çağrılmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144675"
  },
  {
    "question": "Binary dosyaya yazma işlemi sırasında disk alanı dolarsa ne olur?",
    "answer": "Disk alanı dolduğunda, yazma işlemi başarısız olur ve fwrite() veya fprintf() fonksiyonları sıfırdan farklı bir değer dönebilir. Bu durumda, yazma işlemi durur ve veri kaybı yaşanabilir. Bu tür durumları göz önünde bulundurarak disk alanını kontrol etmek ve yeterli alan olduğundan emin olmak önemlidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144715"
  },
  {
    "question": "Binary dosyaya veri yazıp sonra doğru bir şekilde okuyamazsak, sebebi ne olabilir?",
    "answer": "Binary dosyaya veri yazdıktan sonra okuyamıyorsak, bunun birkaç sebebi olabilir. Yazma işlemi sırasında dosyanın kapatılmaması, dosya modunun yanlış seçilmesi ('w' yerine 'wb' gibi) veya yazma ve okuma işlemleri sırasında yanlış buffer kullanımı gibi durumlar olabilir. Yazma işleminin ardından dosyanın kapatıldığından ve okuma işlemi için doğru dosya modunun kullanıldığından emin olmalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144760"
  },
  {
    "question": "fread() fonksiyonu ile büyük bir dosyadan okuma yaparken performansı artırmak için ne yapmalıyız?",
    "answer": "Büyük bir dosyadan okuma yaparken performansı artırmak için, okuma işlemini daha büyük bloklar halinde yapmak önemlidir. Küçük boyutlarda okuma yapmak yerine, örneğin 1024 byte yerine 4096 byte veya daha büyük bir boyut belirlemek, I/O işlemlerini azaltır ve performansı artırır. Ayrıca, dosya ön belleği kullanarak okuma işlemi de hızlandırılabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:53:48.144811"
  },
  {
    "question": "Bir binary dosyası açarken 'fopen' fonksiyonu kullanılmasına rağmen dosya açılamıyor. Neden olabilir?",
    "answer": "Dosyanın yolu yanlış veya dosya mevcut değil olabilir. Ayrıca, dosya izinleri de bir sorun yaratabilir. Dosyanın yolu doğru olduğundan ve gerekli izinlere sahip olduğundan emin olun. Kullanıcı, dosya açma modunu (örneğin 'rb' veya 'wb') doğru seçtiğinden emin olmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633358"
  },
  {
    "question": "Bir binary dosyası yazarken 'fwrite' fonksiyonu kullanıldığında, yazılan veriler okunamıyor. Sorun nerede olabilir?",
    "answer": "Bu durumda, 'fwrite' fonksiyonunun doğru sayıda bayt yazıp yazmadığına dikkat etmek gerekir. Ayrıca, yazma işlemi tamamlandıktan sonra dosyanın kapatıldığından emin olunmalıdır. Eğer dosya kapatılmazsa, tamponlanmış veriler dosyaya yazılmayabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633422"
  },
  {
    "question": "Binary dosyadan veri okurken 'fread' fonksiyonu çağrıldığında beklenmeyen bir sonuç alıyorum. Hata nerede olabilir?",
    "answer": "Okunan verilerin boyutu ve okuma işleminin doğru sayıda baytı okuyup okumadığı kontrol edilmelidir. Ayrıca, dosya işaretçisinin (file pointer) uygun konumda olduğundan emin olun. Eğer dosyanın sonuna gelinmişse, 'fread' sıfır bayt döndürebilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633492"
  },
  {
    "question": "Dosyaya yazma işlemi sırasında 'fwrite' fonksiyonu kullanıldığında 'errno' değişkeni 'EIO' hatasını veriyor. Bu ne anlama geliyor?",
    "answer": "'EIO' hatası, girdi/çıktı hatası anlamına gelir. Bu genellikle diskte yeterli alan olmaması, diskin okunamaması veya dosya sisteminin bozulması gibi nedenlerle ortaya çıkar. Disk alanını kontrol edin ve dosya sisteminin sağlam olduğundan emin olun.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633547"
  },
  {
    "question": "Binary dosyayı okumak için kullanılan kodda, 'fread' fonksiyonu beklenen bayt sayısının daha azını okuyor. Olası nedenler nelerdir?",
    "answer": "'fread' fonksiyonu, dosyanın sonuna ulaşmış olabilir. Bu durumda, okunan bayt sayısının kontrol edilmesi önemlidir. Ayrıca, dosya açma modunun doğru seçildiğinden emin olun. Eğer dosya yanlış bir modda açıldıysa, yeterli veri okunamayabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633594"
  },
  {
    "question": "Bir binary dosyası açıldıktan sonra dosya kapanmadan önce program bitiyor, bu ne tür bir sorun yaratır?",
    "answer": "Eğer dosya kapanmadan program bitiyorsa, yazılan veriler diske aktarılmayabilir ve bellek sızıntısına neden olabilir. 'fclose' fonksiyonunu kullanarak dosya kapatılmalı ve böylece kaynaklar düzgün bir şekilde serbest bırakılmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633632"
  },
  {
    "question": "Binary dosyası okunduktan sonra verileri bir yapı içinde saklamak istiyorum. Ancak veri kaybı yaşıyorum. Neden?",
    "answer": "Yapılan okuma işleminin, yapının boyutuyla tam olarak örtüşmediğinden kaynaklanıyor olabilir. Yapının boyutunu 'sizeof' operatörü ile kontrol edin. Ayrıca, 'fread' fonksiyonu ile okunan bayt sayısının, yapının boyutuna eşit olup olmadığını kontrol edin.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633664"
  },
  {
    "question": "Binary dosyadan okunan veriler, yazıldıkları sırayla geri okunmuyor. Neden bu durum oluşuyor?",
    "answer": "Verilerin sıralı bir şekilde yazılıp yazılmadığını kontrol edin. Ayrıca, yazma ve okuma sırasında dosya işaretçisinin konumu dikkatlice yönetilmelidir. 'fseek' veya 'rewind' fonksiyonları kullanılarak dosya işaretçisinin doğru konuma getirilmesi gerekebilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633692"
  },
  {
    "question": "Farklı platformlar arasında binary dosyası okuyup yazarken, veri uyumsuzluğu yaşıyorum. Bu durumu nasıl çözebilirim?",
    "answer": "Farklı platformların veri yapılarındaki boyutları ve byte sıralamaları (endianness) farklılık gösterebilir. Bu durumda, veriyi yazarken belirli bir formatta (örneğin, ağ sıralaması) yazmak ve okurken de bu formatı dikkate almak önemlidir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633724"
  },
  {
    "question": "Binary dosyanın içeriğini değiştirdikten sonra, dosyayı kaydettiğimde beklenmeyen bir hata alıyorum. Sorun nerede olabilir?",
    "answer": "Dosyayı yazma modunda açmadığınızdan veya dosya işaretçisinin uygun konumda olmadığından kaynaklanıyor olabilir. Dosyayı 'wb' modunda açarak, yazma işlemi için uygun konumu kontrol edin. Ayrıca, 'ferror' fonksiyonunu kullanarak hata kontrolü yapabilirsiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633757"
  },
  {
    "question": "Bir binary dosyasını okudum, ancak okunan veriler beklenenden daha az veya hatalı çıkıyor. Olası nedenler nelerdir?",
    "answer": "Öncelikle, dosyanın doğru bir şekilde açıldığından ve okuma işleminin doğru modda yapıldığından emin olun. 'fread' fonksiyonunun döndürdüğü değer kontrol edilmelidir. Ayrıca, dosyanın içeriğinin bozulmuş olup olmadığını kontrol edin.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:16.633789"
  },
  {
    "question": "Binary dosya nedir ve neden kullanılır?",
    "answer": "Binary dosya, verilerin ikili (binary) formatta saklandığı bir dosya türüdür. Metin dosyalarının aksine, binary dosyalar doğrudan okunamaz; bu nedenle genellikle resimler, sesler ve diğer medya dosyaları gibi daha karmaşık veri türleri için kullanılır. Binary dosyalar, verilerin daha verimli bir şekilde depolanmasını ve iletilmesini sağlar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401727"
  },
  {
    "question": "C dilinde bir binary dosya nasıl açılır?",
    "answer": "C dilinde bir binary dosya açmak için 'fopen' fonksiyonu kullanılır. Örneğin: FILE *dosya = fopen(\"veriler.bin\", \"wb\"); burada 'wb' yazma modunda açılacağını belirtir. Bu, dosyanın yoksa oluşturulmasını sağlar ve ikili veri yazmaya hazır hale getirir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401778"
  },
  {
    "question": "Bir binary dosyaya veri yazmak için hangi fonksiyonlar kullanılır?",
    "answer": "Binary dosyaya veri yazmak için 'fwrite' fonksiyonu kullanılır. Örneğin: fwrite(&deger, sizeof(deger), 1, dosya); burada 'deger' yazmak istediğiniz veridir. Bu fonksiyon, 'deger'in bellek adresini, boyutunu ve kaç tane yazılacağını belirterek dosyaya yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401820"
  },
  {
    "question": "Binary dosyadan veri okumak için hangi fonksiyon kullanılır?",
    "answer": "Binary dosyadan veri okumak için 'fread' fonksiyonu kullanılabilir. Örneğin: fread(&deger, sizeof(deger), 1, dosya); bu komut, dosyadan 'deger' değişkeninin boyutunda bir veri okuyarak onu değişkene atar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401866"
  },
  {
    "question": "Binary dosyaların kapatılması neden önemlidir?",
    "answer": "Binary dosyaların kapatılması, dosyanın düzgün bir şekilde kaydedilmesi ve sistem kaynaklarının serbest bırakılması için önemlidir. Dosya işlemleri tamamlandığında 'fclose(dosya);' komutunu kullanarak dosyayı kapatmalıyız. Aksi takdirde, veri kaybı yaşanabilir veya bellek sızıntısına neden olabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401898"
  },
  {
    "question": "Bir binary dosyayı okumadan önce nasıl kontrol edilir?",
    "answer": "Bir binary dosyanın açılıp açılmadığını kontrol etmek için 'fopen' fonksiyonunun dönüş değeri kontrol edilmelidir. Örneğin: FILE *dosya = fopen(\"veriler.bin\", \"rb\"); if (dosya == NULL) { printf(\"Dosya açılamadı!\"); } şeklinde bir kontrol yaparak dosyanın varlığını ve erişilebilirliğini test edebilirsiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401935"
  },
  {
    "question": "Bir binary dosyadan okunan verilerin nasıl yazdırılacağı gösterilebilir mi?",
    "answer": "Evet, okunmuş verileri yazdırmak için, öncelikle veriyi okuduktan sonra 'printf' fonksiyonu kullanılabilir. Örneğin: int deger; fread(&deger, sizeof(deger), 1, dosya); printf(\"Okunan deger: %d\n\", deger); bu şekilde binary dosyadan okunan sayısal veriyi ekrana yazdırabilirsiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.401979"
  },
  {
    "question": "Bir binary dosyaya nasıl dizi yazılır?",
    "answer": "Bir dizi verisini binary dosyaya yazmak için 'fwrite' fonksiyonu dizinin başlangıç adresi ile kullanılabilir. Örneğin: int dizi[] = {1, 2, 3, 4}; fwrite(dizi, sizeof(int), 4, dosya); burada 4, dizideki eleman sayısını belirtir ve tüm dizi verilerini dosyaya yazar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.402009"
  },
  {
    "question": "Binary dosyadan bir dizi nasıl okunur?",
    "answer": "Binary dosyadan dizi okumak için 'fread' fonksiyonu kullanılabilir. Örneğin: int dizi[4]; fread(dizi, sizeof(int), 4, dosya); bu komut, dosyadan 4 tane 'int' türündeki veriyi okuyarak 'dizi' adlı diziye atar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.402038"
  },
  {
    "question": "Binary dosya işlemlerinde hata ayıklama nasıl yapılır?",
    "answer": "Hata ayıklama işlemleri, dosya açma, okuma ve yazma işlemlerinin dönüş değerlerini kontrol ederek yapılabilir. Örneğin, 'fread' veya 'fwrite' fonksiyonlarının dönüş değerleri, okunan veya yazılan eleman sayısını döndürür. Eğer bu değer beklenenden azsa, bir hata olmuş demektir. Ayrıca, 'ferror' fonksiyonu kullanılarak dosya üzerinde bir hata olup olmadığı kontrol edilebilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.402072"
  },
  {
    "question": "Binary dosyaları kullanarak basit bir yapı dosyası nasıl oluşturulur?",
    "answer": "Basit bir yapı dosyası oluşturmak için önce bir yapı tanımlanmalı, ardından bu yapıdan örnekler oluşturularak döngü içinde binary dosyaya yazılmalıdır. Örneğin: typedef struct { int id; char isim[20]; } Kisi; struct Kisi kisi1 = {1, \"Ali\"}; fwrite(&kisi1, sizeof(Kisi), 1, dosya); bu şekilde 'Kisi' adlı bir yapı tanımlayıp bir örneğini binary dosyaya yazabiliriz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:54:38.402112"
  },
  {
    "question": "Binary dosya nasıl açılır ve yazılır?",
    "answer": "C dilinde bir binary dosya açmak için 'fopen' fonksiyonunu kullanırız. Örneğin, bir dosyaya yazmak için 'wb' modunu kullanabiliriz. Aşağıdaki örnekte bir tamsayı dizisini binary dosyasına yazıyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[] = {1, 2, 3, 4, 5};\n    dosya = fopen(\"sayi.dat\", \"wb\"); // Binary dosyayı aç\n    fwrite(sayilar, sizeof(int), 5, dosya); // Dizi yazma\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBurada 'fwrite' fonksiyonu kullanılarak dizinin içeriği binary formatta dosyaya yazıldı.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663409"
  },
  {
    "question": "Binary dosyasında verileri nasıl okunur?",
    "answer": "Bir binary dosyasındaki verileri okumak için 'fread' fonksiyonunu kullanırız. Aşağıdaki örnekte daha önce yazdığımız dosyadan tamsayı dizisini okuyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[5];\n    dosya = fopen(\"sayi.dat\", \"rb\"); // Binary dosyayı aç\n    fread(sayilar, sizeof(int), 5, dosya); // Dizi okuma\n    fclose(dosya); // Dosyayı kapat\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \\n\", sayilar[i]); // Verileri yazdır\n    }\n    return 0;\n}\n```\nBurada 'fread' fonksiyonu, dosyadan verileri okuyarak dizinin her bir elemanını hafızaya aktarır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663465"
  },
  {
    "question": "Binary dosyasında belirli bir konumdan veri okumak veya yazmak mümkün mü?",
    "answer": "Evet, binary dosyasında belirli bir konumdan veri okumak veya yazmak için 'fseek' fonksiyonu kullanılır. Örneğin, dosyanın ortasındaki bir veriyi güncellemek için:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int yeniSayi = 10;\n    dosya = fopen(\"sayi.dat\", \"r+b\"); // Hem okuma hem yazma modunda aç\n    fseek(dosya, sizeof(int) * 2, SEEK_SET); // 3. elemanın konumuna git\n    fwrite(&yeniSayi, sizeof(int), 1, dosya); // Yeni değer yaz\n    fclose(dosya);\n    return 0;\n}\n```\nBurada 'fseek' ile 3. elemanın konumuna gidiyoruz ve 'fwrite' ile yeni değeri yazıyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663492"
  },
  {
    "question": "Binary dosyasında veri okuma işlemi sırasında hata kontrolü nasıl yapılır?",
    "answer": "Veri okuma işlemi sonrası hata kontrolü yapmak için 'fread' fonksiyonunun döndürdüğü değeri kontrol edebiliriz. Aşağıdaki örnekte bunu nasıl yapacağımızı gösteriyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayilar[5];\n    dosya = fopen(\"sayi.dat\", \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    size_t okunan = fread(sayilar, sizeof(int), 5, dosya);\n    if (okunan < 5) {\n        printf(\"Yetersiz veri okundu!\\n\");\n    }\n    fclose(dosya);\n    return 0;\n}\n```\nBu kodda dosya açılamıyorsa bir hata mesajı gösteriyoruz ve okunan veri sayısını kontrol ederek yeterli veri okundu mu diye kontrol ediyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663535"
  },
  {
    "question": "Binary dosyalarında veri boyutunu nasıl hesaplayabiliriz?",
    "answer": "Bir binary dosyasındaki veri boyutunu hesaplamak için 'fseek' ve 'ftell' fonksiyonlarını kullanabiliriz. Aşağıdaki örnekte bir binary dosyasının boyutunu hesaplıyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"sayi.dat\", \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fseek(dosya, 0, SEEK_END); // Dosyanın sonuna git\n    long boyut = ftell(dosya); // Dosya boyutunu al\n    fclose(dosya);\n    printf(\"Dosya boyutu: %ld bayt\\n\", boyut);\n    return 0;\n}\n```\nBurada 'fseek' ile dosyanın sonuna gidiyoruz, ardından 'ftell' ile o konumdaki byte sayısını alıyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663555"
  },
  {
    "question": "C dilinde bir binary dosyasındaki tüm verileri silmek için ne yapılır?",
    "answer": "C dilinde bir binary dosyasındaki tüm verileri silmek için dosyayı 'wb' modunda açarak yazma işlemi yapabiliriz. Bu, dosyanın içeriğini sıfırlar. Aşağıdaki örnekte bunu gösteriyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    dosya = fopen(\"sayi.dat\", \"wb\"); // Dosyayı yazma modunda açarak içeriği sil\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, dosyanın içeriğini siler ve dosyayı kapatır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663581"
  },
  {
    "question": "Binary dosyasında yapılan yazma işlemi sonrasında dosya nasıl kontrol edilir?",
    "answer": "Yazma işlemi sonrası dosyanın başarılı bir şekilde yazılıp yazılmadığını kontrol etmek için 'ferror' fonksiyonunu kullanabiliriz. Aşağıdaki örnekte bunu nasıl yapacağımızı gösteriyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayi = 100;\n    dosya = fopen(\"sayi.dat\", \"wb\");\n    if (fwrite(&sayi, sizeof(int), 1, dosya) != 1) {\n        printf(\"Yazma hatası!\\n\");\n    }\n    fclose(dosya);\n    return 0;\n}\n```\nBu kodda yazma işlemi sonrası 'fwrite' geri dönen değeri kontrol ederek yazma hatası olup olmadığını kontrol ediyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663606"
  },
  {
    "question": "Binary dosyasına veri eklemek için nasıl bir yöntem izlenir?",
    "answer": "Binary dosyasına veri eklemek için dosyayı 'ab' modunda açmak gerekir. Aşağıdaki örnekte bir diziye yeni tamsayılar ekliyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int yeniSayilar[] = {6, 7, 8};\n    dosya = fopen(\"sayi.dat\", \"ab\"); // Dosyayı ekleme modunda aç\n    fwrite(yeniSayilar, sizeof(int), 3, dosya); // Yeni verileri ekle\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, var olan dosyaya yeni verileri eklemek için kullanılır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663640"
  },
  {
    "question": "Binary dosyasında veri güncelleme işlemi nasıl yapılır?",
    "answer": "Binary dosyasında veri güncelleme işlemi, dosyanın doğru konumuna giderek yapılır. Aşağıdaki örnekte bir binary dosyasındaki veriyi güncelliyoruz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int yeniSayi = 20;\n    dosya = fopen(\"sayi.dat\", \"r+b\"); // Güncelleme için okuma/yazma modunu aç\n    fseek(dosya, sizeof(int) * 1, SEEK_SET); // 2. elemanın konumuna git\n    fwrite(&yeniSayi, sizeof(int), 1, dosya); // Yeni değer yaz\n    fclose(dosya);\n    return 0;\n}\n```\nBu kodda, 'fseek' ile ikinci elemanın konumuna gidiyoruz ve 'fwrite' ile yeni değeri güncelliyoruz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:13.663673"
  },
  {
    "question": "C dilinde bir binary dosyayı nasıl açarız ve okuyabiliriz?",
    "answer": "C dilinde bir binary dosyayı açmak ve okumak için 'fopen' fonksiyonunu kullanırız. Örneğin: 'FILE *fp = fopen(\"dosya.bin\", \"rb\");'. 'rb' parametresi dosyayı binary (ikilik) modda okumak için açar. Daha sonra 'fread' fonksiyonu ile dosyadan veri okuyabiliriz. Örnek: 'fread(buffer, sizeof(int), 10, fp);' burada 10 adet int verisini buffer'a okur. İşlem tamamlandıktan sonra 'fclose(fp);' ile dosyayı kapatmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132457"
  },
  {
    "question": "Binary dosyaya veri yazmanın en etkili yolu nedir?",
    "answer": "Binary dosyaya veri yazmak için yine 'fopen' fonksiyonunu kullanırız ancak bu sefer 'wb' modunu kullanmalıyız. Örneğin: 'FILE *fp = fopen(\"dosya.bin\", \"wb\");'. Daha sonra 'fwrite' fonksiyonu ile veri yazabiliriz. Örnek: 'fwrite(data, sizeof(int), num_elements, fp);' burada data içindeki num_elements kadar int verisini dosyaya yazar. İşlemler bittiğinde 'fclose(fp);' ile dosyayı kapatmayı ihmal etmemeliyiz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132494"
  },
  {
    "question": "Binary dosyada mevcut veriyi güncellemenin adımları nelerdir?",
    "answer": "Binary dosyada mevcut veriyi güncellemek için öncelikle dosyayı 'rb+' modunda açmalıyız. Örnek: 'FILE *fp = fopen(\"dosya.bin\", \"rb+\");'. Bu mod hem okuma hem de yazma işlemlerine izin verir. Daha sonra 'fseek' fonksiyonu ile güncellemek istediğimiz verinin pozisyonuna gidebiliriz. Örnek: 'fseek(fp, offset, SEEK_SET);'. Ardından 'fwrite' fonksiyonu ile güncelleyebiliriz. İşlemler sonunda 'fclose(fp);' kullanarak dosyayı kapatmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132535"
  },
  {
    "question": "Binary dosyayı okurken veri bütünlüğünü nasıl kontrol edebilirim?",
    "answer": "Binary dosyayı okurken veri bütünlüğünü kontrol etmek için okunan verinin boyutunu kontrol edebiliriz. Örneğin, 'fread' fonksiyonu çağrıldığında dönen değeri kontrol edebiliriz. Eğer beklenen boyuttan farklı bir değer dönerse, dosyadan okuma sırasında bir hata oluşmuş demektir. Aynı zamanda, dosyanın sonuna ulaşıp ulaşmadığımızı kontrol etmek için 'feof(fp)' fonksiyonunu kullanabiliriz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132558"
  },
  {
    "question": "C dilinde çok boyutlu bir diziyi binary dosyaya nasıl yazabiliriz?",
    "answer": "Çok boyutlu bir diziyi binary dosyaya yazarken dizinin boyutunu bilmemiz gerekir. Öncelikle dosyayı 'wb' modunda açmalıyız. Örnek: 'FILE *fp = fopen(\"matris.bin\", \"wb\");'. Daha sonra 'fwrite' fonksiyonu ile diziyi yazabiliriz. Örnek: 'fwrite(matris, sizeof(int), ROWS * COLS, fp);' burada ROWS ve COLS dizinin boyutlarını temsil eder. İşlemler tamamlandığında 'fclose(fp);' ile dosyayı kapatmalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132580"
  },
  {
    "question": "Binary dosyadan yapısal verileri nasıl okuyabiliriz?",
    "answer": "Binary dosyadan yapısal verileri okumak için, öncelikle yapının tanımını yapmalıyız. Örneğin: 'typedef struct { int id; char name[50]; } Record;'. Daha sonra dosyayı 'rb' modunda açarak 'fread' ile yapısal verileri okuyabiliriz. Örnek: 'Record r; fread(&r, sizeof(Record), 1, fp);' bu, dosyadan bir kayıt okur. İşlemler bittiğinde 'fclose(fp);' ile dosyayı kapatmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132600"
  },
  {
    "question": "Binary dosyayı belirli bir yerden okumak için nasıl bir yöntem izlemeliyiz?",
    "answer": "Binary dosyayı belirli bir yerden okumak için öncelikle dosyayı 'rb' modunda açmalıyız. Daha sonra 'fseek' fonksiyonunu kullanarak istediğimiz pozisyona atlayabiliriz. Örneğin: 'fseek(fp, position, SEEK_SET);' burada position okuma yapmak istediğimiz bayt konumudur. Ardından 'fread' ile veriyi okuyabiliriz. Unutmayın ki, işlemler sonunda 'fclose(fp);' ile dosyayı kapatmalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132626"
  },
  {
    "question": "Binary dosyadan okunan verilerin bellekte nasıl saklanacağını belirlemek için hangi yöntemleri kullanabiliriz?",
    "answer": "Binary dosyadan okunan verilerin bellekte saklanması için dinamik belleği kullanabiliriz. Örneğin, okuduğumuz veri sayısını bilmeden önce bir buffer tanımlayıp sonrasında 'malloc' ile ihtiyaç duyduğumuz boyutu ayırabiliriz. Örnek: 'int *buffer = (int*)malloc(number_of_elements * sizeof(int));'. Daha sonra 'fread(buffer, sizeof(int), number_of_elements, fp);' ile dosyadan verileri okuruz. İşlemler sonunda 'free(buffer);' ile belleği serbest bırakmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132666"
  },
  {
    "question": "Binary dosya açma ve kapama hatalarını nasıl yönetebiliriz?",
    "answer": "Binary dosya açma ve kapama hatalarını yönetmek için 'fopen' ve 'fclose' işlemlerinin dönüş değerlerini kontrol etmeliyiz. 'fopen' fonksiyonu 'NULL' dönerse, dosya açılamamıştır ve bu durumu bir hata mesajı ile kullanıcıya bildirmeliyiz. Örnek: 'if (fp == NULL) { perror(\"Dosya açılamadı\"); return 1; }'. Ayrıca 'fclose' işleminden sonra dosyanın kapandığını kontrol etmek için benzer bir hata kontrolü yapabiliriz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132688"
  },
  {
    "question": "Binary dosyalarla çalışırken performansı artırmak için hangi teknikleri kullanabiliriz?",
    "answer": "Binary dosyalarla çalışırken performansı artırmak için, dosya okuma/yazma işlemlerini bloklar halinde gerçekleştirmek faydalıdır. Bu, sürekli okuma ve yazma işlemlerinden kaçınmamızı sağlar. Örneğin, belirli bir byte sayısını okuyup yazmak yerine bütün veriyi bir defada okuyup işleyebiliriz. Ayrıca, 'buffer' kullanarak verileri bellekte toplamak ve toplu bir şekilde yazmak da performansı artırır. Örnek: 'fwrite(buffer, sizeof(char), total_size, fp);' ile tek seferde büyük veriler yazılabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:55:46.132713"
  },
  {
    "question": "Bir binary dosyasına yazma işlemi nasıl gerçekleştirilir?",
    "answer": "C dilinde bir binary dosyasına yazma işlemi yapmak için 'fopen' fonksiyonu ile dosyayı 'wb' modunda açmak gerekmektedir. Aşağıdaki örnekte, bir dizi tam sayıyı binary dosyasına yazma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int numbers[] = {1, 2, 3, 4, 5};\n    int n = sizeof(numbers) / sizeof(numbers[0]);\n\n    fp = fopen(\"output.dat\", \"wb\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fwrite(numbers, sizeof(int), n, fp);\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.822951"
  },
  {
    "question": "Binary dosyasından veri okuma işlemi nasıl yapılır?",
    "answer": "Binary dosyasından veri okumak için dosya 'rb' modunda açılmalıdır. Aşağıda bir binary dosyasından tam sayıları okuma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int numbers[5];\n\n    fp = fopen(\"output.dat\", \"rb\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fread(numbers, sizeof(int), 5, fp);\n    fclose(fp);\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.822987"
  },
  {
    "question": "Binary dosyasında belirli bir konumdan veri yazmanın yolu nedir?",
    "answer": "Belirli bir konuma veri yazmak için 'fseek' fonksiyonu kullanılabilir. Aşağıda, 2. tam sayıyı güncelleyen bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int number = 99;\n\n    fp = fopen(\"output.dat\", \"r+b\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(fp, sizeof(int) * 1, SEEK_SET); // 2. sayıya git\n    fwrite(&number, sizeof(int), 1, fp);\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823011"
  },
  {
    "question": "Binary dosyasında kaç byte veri olduğunu nasıl öğrenebilirim?",
    "answer": "Dosyanın boyutunu öğrenmek için 'fseek' ve 'ftell' fonksiyonları kullanılabilir. Aşağıda bir dosyanın boyutunu bulma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    long size;\n\n    fp = fopen(\"output.dat\", \"rb\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(fp, 0, SEEK_END); // Dosyanın sonuna git\n    size = ftell(fp); // Konumu al\n    fclose(fp);\n\n    printf(\"Dosya boyutu: %ld byte\\n\", size);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823033"
  },
  {
    "question": "Binary dosyasındaki verinin üzerine yazmaya karar verdim; hangi modda açmalıyım?",
    "answer": "'r+b' modunda açmalısınız. Bu, dosyayı hem okuma hem de yazma modunda açar. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int number = 10;\n\n    fp = fopen(\"output.dat\", \"r+b\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fwrite(&number, sizeof(int), 1, fp);\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823059"
  },
  {
    "question": "Binary dosyasında birden fazla veri okuma işlemi nasıl yapılır?",
    "answer": "Birden fazla veriyi okumak için 'fread' fonksiyonu kullanılabilir. Aşağıda bir binary dosyasından 5 tam sayıyı okuma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int numbers[5];\n\n    fp = fopen(\"output.dat\", \"rb\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    size_t read = fread(numbers, sizeof(int), 5, fp);\n    printf(\"Okunan sayı: %zu\\n\", read);\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823088"
  },
  {
    "question": "Binary dosyasını açarken hata kontrolü nasıl yapılır?",
    "answer": "Dosya açılırken hata kontrolü yapmak için 'fopen' fonksiyonunun dönüş değeri kontrol edilmelidir. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    fp = fopen(\"output.dat\", \"rb\");\n    if (fp == NULL) {\n        fprintf(stderr, \"Dosya açılamadı: %s\\n\", strerror(errno));\n        return 1;\n    }\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823108"
  },
  {
    "question": "Binary dosyasını silmek için hangi fonksiyon kullanılır?",
    "answer": "Dosyayı silmek için 'remove' fonksiyonu kullanılabilir. Aşağıda bir dosyanın silinmesi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    const char *filename = \"output.dat\";\n    if (remove(filename) == 0) {\n        printf(\"%s başarıyla silindi.\\n\", filename);\n    } else {\n        perror(\"Silme hatası\");\n    }\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823127"
  },
  {
    "question": "Binary dosyasında veri yazma işlemi sırasında buffer kullanmanın avantajları nelerdir?",
    "answer": "Buffer kullanmak, dosya yazma işlemlerini hızlandırır çünkü veriler hafızada birikir ve topluca yazılır. Aşağıda buffer ile dosya yazma işlemi gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int buffer[5] = {1, 2, 3, 4, 5};\n\n    fp = fopen(\"output.dat\", \"wb\");\n    if (fp == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fwrite(buffer, sizeof(int), 5, fp);\n    fflush(fp); // Buffered veriyi zorla yaz\n    fclose(fp);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:56:32.823153"
  },
  {
    "question": "İkili bir dosyadan bir dizi tam sayı okuyup, bu sayıları sıralayıp tekrar dosyaya yazmak için bir algoritma yazın.",
    "answer": "Aşağıda verilen kod, ikili bir dosyadan tam sayıları okuyup, bunları sıraladıktan sonra aynı dosyaya yazmaktadır. Öncelikle dosyayı açıyoruz, sayıları okuyoruz, sıralıyoruz ve tekrar yazıyoruz. Bu işlem için qsort fonksiyonunu kullanarak sıralama işlemini gerçekleştiriyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Karşılaştırma fonksiyonu\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    FILE *file = fopen(\"numbers.bin\", \"rb+\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return -1;\n    }\n\n    // Dosyadan sayıları oku\n    fseek(file, 0, SEEK_END);\n    long fileSize = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    int count = fileSize / sizeof(int);\n    int *numbers = malloc(fileSize);\n    fread(numbers, sizeof(int), count, file);\n\n    // Sayıları sırala\n    qsort(numbers, count, sizeof(int), compare);\n\n    // Dosyaya yaz\n    fseek(file, 0, SEEK_SET);\n    fwrite(numbers, sizeof(int), count, file);\n\n    free(numbers);\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.469756"
  },
  {
    "question": "Bir ikili dosyadan yapısal verileri (struct) okuma ve yazma işlemi gerçekleştiren bir program yazın.",
    "answer": "Bu örnekte, bir 'Öğrenci' yapısı tanımlıyoruz ve bu yapıyı bir dosyadan okuyup yazıyoruz. Yapıyı ikili formatta depolamak için fread ve fwrite fonksiyonlarını kullanıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float grade;\n} Student;\n\nint main() {\n    FILE *file = fopen(\"students.bin\", \"wb+\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return -1;\n    }\n\n    // Öğrenci verilerini yaz\n    Student s1 = {1, \"Ali\", 85.5};\n    fwrite(&s1, sizeof(Student), 1, file);\n\n    // Dosyayı tekrar oku\n    fseek(file, 0, SEEK_SET);\n    Student s2;\n    fread(&s2, sizeof(Student), 1, file);\n\n    printf(\"ID: %d, Name: %s, Grade: %.2f\\n\", s2.id, s2.name, s2.grade);\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.469827"
  },
  {
    "question": "Bir ikili dosyadaki verileri tersine çevirmek için bir program yazın. Dosya boyutu dinamik olarak belirlenmelidir.",
    "answer": "Bu kod örneği, bir ikili dosyadaki verileri okur, bunları tersine çevirir ve tekrar dosyaya yazar. Dosya boyutunu dinamik olarak belirlemek için fseek ve ftell kullanıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.bin\", \"rb+\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return -1;\n    }\n\n    // Dosya boyutunu belirle\n    fseek(file, 0, SEEK_END);\n    long fileSize = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    // Verileri oku\n    char *buffer = malloc(fileSize);\n    fread(buffer, 1, fileSize, file);\n\n    // Verileri tersine çevir\n    for (long i = 0; i < fileSize / 2; i++) {\n        char temp = buffer[i];\n        buffer[i] = buffer[fileSize - 1 - i];\n        buffer[fileSize - 1 - i] = temp;\n    }\n\n    // Tersine çevrilmiş verileri dosyaya yaz\n    fseek(file, 0, SEEK_SET);\n    fwrite(buffer, 1, fileSize, file);\n\n    free(buffer);\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.469886"
  },
  {
    "question": "Bir ikili dosyaya rastgele erişim sağlayarak kayıt eklemek için bir program yazın.",
    "answer": "Bu kod örneği, bir ikili dosyaya rastgele erişim ile yeni bir kayıt eklemektedir. Kullanıcıdan alınan veriler, dosyanın sonuna eklenmektedir. Dosyaya ekleme yaparken 'rb+' modunu kullanıyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Record;\n\nint main() {\n    FILE *file = fopen(\"records.bin\", \"rb+\");\n    if (!file) {\n        file = fopen(\"records.bin\", \"wb+\");\n    }\n\n    Record r;\n    printf(\"ID girin: \");\n    scanf(\"%d\", &r.id);\n    printf(\"İsim girin: \");\n    scanf(\"%s\", r.name);\n\n    // Dosyanın sonuna ekle\n    fseek(file, 0, SEEK_END);\n    fwrite(&r, sizeof(Record), 1, file);\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.469931"
  },
  {
    "question": "Bir ikili dosyadan belirli bir kayıt numarasındaki veriyi güncelleyen bir program yazın.",
    "answer": "Bu kod, belirli bir kayıt numarasındaki veriyi güncellemektedir. Kullanıcıdan yeni verileri alır ve belirtilen kayıt konumuna yazar.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Record;\n\nint main() {\n    FILE *file = fopen(\"records.bin\", \"rb+\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return -1;\n    }\n\n    int recordNumber;\n    printf(\"Güncellemek istediğiniz kayıt numarasını girin: \");\n    scanf(\"%d\", &recordNumber);\n\n    Record r;\n    fseek(file, recordNumber * sizeof(Record), SEEK_SET);\n    fread(&r, sizeof(Record), 1, file);\n    printf(\"Mevcut kayıt - ID: %d, İsim: %s\\n\", r.id, r.name);\n\n    printf(\"Yeni isim girin: \");\n    scanf(\"%s\", r.name);\n    fseek(file, recordNumber * sizeof(Record), SEEK_SET);\n    fwrite(&r, sizeof(Record), 1, file);\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.469975"
  },
  {
    "question": "İkili dosyada belirli koşullara göre kayıtları filtreleyen ve yeni bir dosyaya yazan bir program yazın.",
    "answer": "Aşağıdaki kod, bir ikili dosyadan belirli bir koşula uyan kayıtları okur ve başka bir dosyaya yazar. Örneğin, 50'den büyük olan öğrencileri filtrelemekteyiz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float grade;\n} Student;\n\nint main() {\n    FILE *inputFile = fopen(\"students.bin\", \"rb\");\n    FILE *outputFile = fopen(\"filtered_students.bin\", \"wb\");\n    if (!inputFile || !outputFile) {\n        perror(\"Dosyalar açılamadı\");\n        return -1;\n    }\n\n    Student s;\n    while (fread(&s, sizeof(Student), 1, inputFile)) {\n        if (s.grade > 50.0) {\n            fwrite(&s, sizeof(Student), 1, outputFile);\n        }\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.470026"
  },
  {
    "question": "Bir metin dosyasını ikili formata çeviren bir program yazın.",
    "answer": "Bu kod, bir metin dosyasını okur ve içeriğini ikili bir dosyaya yazar. Her karakteri bir byte olarak kaydediyoruz.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *textFile = fopen(\"input.txt\", \"r\");\n    FILE *binaryFile = fopen(\"output.bin\", \"wb\");\n    if (!textFile || !binaryFile) {\n        perror(\"Dosyalar açılamadı\");\n        return -1;\n    }\n\n    char c;\n    while ((c = fgetc(textFile)) != EOF) {\n        fwrite(&c, sizeof(char), 1, binaryFile);\n    }\n\n    fclose(textFile);\n    fclose(binaryFile);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.470063"
  },
  {
    "question": "İkili dosyadan birden fazla yapı okuyan ve bunları listeleyen bir program yazın.",
    "answer": "Aşağıda, ikili bir dosyadan birden fazla 'Öğrenci' yapısı okuyan ve bu verileri listeleyen bir program yer alıyor. Dosyadan okunan her öğrencinin bilgisi ekrana yazdırılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float grade;\n} Student;\n\nint main() {\n    FILE *file = fopen(\"students.bin\", \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return -1;\n    }\n\n    Student s;\n    while (fread(&s, sizeof(Student), 1, file)) {\n        printf(\"ID: %d, Name: %s, Grade: %.2f\\n\", s.id, s.name, s.grade);\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:18.470107"
  },
  {
    "question": "Binary dosyası açarken hangi modları kullanmalıyım ve bunların farkları nelerdir?",
    "answer": "Binary dosyası açarken genellikle 'rb' (okuma için) ve 'wb' (yazma için) modları kullanılır. 'rb' modunda dosya, ikili formatta okunur. 'wb' modunda ise dosya, ikili formatta yazılır. Eğer dosya yoksa bu mod yeni bir dosya oluşturur. Ayrıca, 'ab' (ekleme için) ve 'rb+' (okuma ve yazma için) modları da bulunmaktadır. 'ab' ile mevcut bir dosyaya ekleme yapabilirsiniz. 'rb+' ise hem okuma hem de yazma yetkisi sağlar ancak dosyanın başlangıcından itibaren yazma işlemi yapar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671330"
  },
  {
    "question": "Binary dosyası yazarken veri kaybını önlemek için hangi önlemleri almalıyım?",
    "answer": "Veri kaybını önlemek için öncelikle dosyayı açmadan önce yeterli alanın mevcut olduğundan emin olmalısınız. Ayrıca, 'fwrite' gibi yazma fonksiyonunu kullandıktan sonra dönüş değerini kontrol ederek, yazma işleminin başarıyla gerçekleşip gerçekleşmediğini doğrulamalısınız. Dosyanın kapatılmadan önce tüm verilerin yazıldığından emin olmak için 'fflush' fonksiyonu kullanılabilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671372"
  },
  {
    "question": "Binary dosyası okurken hata kontrolü nasıl yapılır?",
    "answer": "Binary dosyası okurken, dosyanın açılıp açılmadığını kontrol etmek önemlidir. 'fopen' fonksiyonu ile dosya açıldıktan sonra 'fread' fonksiyonunun döndüğü değeri kontrol ederek okunan veri miktarını gözlemlemelisiniz. Eğer beklenen miktardan daha az veri okunmuşsa, bu bir hata veya dosyanın sonuna gelindiği anlamına gelebilir. Ayrıca, dosya kapatılmadan önce 'fclose' çağrılarak dosyanın düzgün bir şekilde kapatıldığını kontrol etmelisiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671393"
  },
  {
    "question": "Binary dosyası kullanarak bir yapı (struct) nasıl okunur ve yazılır?",
    "answer": "Bir yapı (struct) okuma ve yazma işlemi için öncelikle yapı tanımınızı yapmalısınız. Ardından, 'fwrite' ile yapıyı dosyaya yazabilir ve 'fread' ile dosyadan okuyabilirsiniz. Aşağıda bir örnek verilmiştir: \n\n```c\nstruct Data {\n    int id;\n    float value;\n};\n\nstruct Data d = {1, 3.14};\n\nFILE *file = fopen(\"data.bin\", \"wb\");\nfwrite(&d, sizeof(struct Data), 1, file);\nfclose(file);\n```\n\nVeriyi okumak için:\n```c\nstruct Data d;\nFILE *file = fopen(\"data.bin\", \"rb\");\nfread(&d, sizeof(struct Data), 1, file);\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671418"
  },
  {
    "question": "Binary dosyası yazma işlemi sırasında bellek taşmasını nasıl önlerim?",
    "answer": "Bellek taşmasını önlemek için yazma işlemi sırasında yazılacak verinin boyutunun dosyanın mevcut boyutunu geçmediğinden emin olmalısınız. Ayrıca, dosyaya yazmadan önce verinin büyüklüğünü kontrol edin ve gerektiğinde dinamik bellek ayırma (malloc) gibi yöntemler kullanıp verinin boyutunu yazmadan önce ayarlayın. Bu sayede performansı artırabilir ve taşmaları engelleyebilirsiniz.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671442"
  },
  {
    "question": "Binary dosyası ile büyük verileri işlerken hangi teknikleri kullanmalıyım?",
    "answer": "Büyük verileri işlerken, dosyaları parça parça işlemeniz önerilir. 'fread' ve 'fwrite' fonksiyonları ile bir seferde büyük bir veri parçası yerine daha küçük parçalar halinde veri okuyup yazmak, bellek kullanımını optimize eder. Örneğin, 1024 byte'lık bir buffer kullanarak dosyadan veri okuyup yazabilirsiniz. Bu sayede bellek verimliliğini artırmış olursunuz.\n\n```c\nchar buffer[1024];\nsize_t bytes;\nwhile ((bytes = fread(buffer, 1, sizeof(buffer), file)) > 0) {\n    fwrite(buffer, 1, bytes, outputFile);\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671465"
  },
  {
    "question": "Binary dosyası okuma ve yazma işlemlerinde performansı artırmak için ne yapabilirim?",
    "answer": "Performansı artırmak için dosya okuma ve yazma işlemlerini buffer ile yapmalısınız. 'setvbuf' fonksiyonunu kullanarak, dosya için bir bellek buffer'ı tanımlayabilirsiniz. Bu, dosya üzerinde yapılan her I/O işleminin sistem çağrılarıyla değil, bellek üzerinden gerçekleştirilmesini sağlar. Böylece, performansı önemli ölçüde artırabilirsiniz. Örneğin:\n```c\nFILE *file = fopen(\"data.bin\", \"wb\");\nchar buffer[BUFSIZ];\nsetvbuf(file, buffer, _IOFBF, sizeof(buffer));\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671490"
  },
  {
    "question": "Binary dosyasını açarken ve kapatırken dikkat edilmesi gereken noktalar nelerdir?",
    "answer": "Dosyayı açarken, dosya adının doğru yazıldığından, dosyanın mevcut olduğundan ve dosya açma modunun ihtiyaca uygun olduğundan emin olmalısınız. Kapama işlemi sırasında ise 'fclose' çağrıldığında dosyanın düzgün bir şekilde kapandığını ve bellek sızıntısı olmadığını kontrol edin. Ayrıca, dosya kapatmadan önce tüm verilerin yazıldığından emin olmak iyi bir uygulamadır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671533"
  },
  {
    "question": "Binary dosyası ile veri parçalarını nasıl yönetebilirim?",
    "answer": "Veri parçalarını yönetmek için, dosyayı okuma ve yazma sırasında her bir parçanın boyutunu ve konumunu takip etmelisiniz. 'ftell' ve 'fseek' fonksiyonları ile dosya konumunu kontrol edebilir ve belirli bir konumdan veri okumak ya da yazmak için dosya göstericisini (file pointer) ayarlayabilirsiniz. Örneğin:\n```c\nfseek(file, offset, SEEK_SET);\nfread(buffer, sizeof(char), size, file);\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671554"
  },
  {
    "question": "Binary dosyası hata ayıklama sürecinde ne gibi loglama yöntemleri kullanmalıyım?",
    "answer": "Hata ayıklama sürecinde, dosya işlemleri sırasında önemli olayları kaydetmek için loglama mekanizmaları kullanmalısınız. Her dosya açma, kapama, okuma ve yazma işlemi için durum mesajları yazabilirsiniz. Bu sayede, hangi noktada hatalar oluştuğunu daha kolay analiz edebilirsiniz. Örnek bir loglama:\n```c\nif (file == NULL) {\n    fprintf(stderr, \"Dosya açılamadı: %s\\n\", strerror(errno));\n}\n```",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:57:45.671579"
  },
  {
    "question": "Binary dosyası okuma işlemini nasıl daha verimli hale getirebiliriz?",
    "answer": "Binary dosyası okuma işlemi için, dosyayı satır satır okumak yerine, belirli bir boyutta buffer kullanarak okumak performansı artırabilir. Örnek olarak, şu şekilde bir uygulama yapılabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define BUFFER_SIZE 1024\n\nvoid read_binary_file(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    unsigned char buffer[BUFFER_SIZE];\n    size_t bytesRead;\n\n    while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {\n        // Buffer ile işleme yapılabilir\n    }\n\n    fclose(file);\n}\n```\nBu yöntem, disk IO işlemlerini minimize ederek okunabilirliği ve işlem süresini artırır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442606"
  },
  {
    "question": "Binary dosyasında veri yazarken hata kontrolü nasıl yapılır?",
    "answer": "Binary dosyasına veri yazarken, her yazma işleminin sonucunu kontrol etmek önemlidir. Aşağıdaki örnek, yazma işlemi sırasında hata kontrolü yapmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid write_binary_file(const char *filename, const void *data, size_t dataSize) {\n    FILE *file = fopen(filename, \"wb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    size_t written = fwrite(data, 1, dataSize, file);\n    if (written != dataSize) {\n        perror(\"Yazma hatası\");\n    }\n\n    fclose(file);\n}\n```\nBu kodda, yazma işlemi sonucunda kaç byte yazıldığı kontrol edilir ve bir hata oluşursa kullanıcı bilgilendirilir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442645"
  },
  {
    "question": "Binary dosyası verilerinin yapısını nasıl tanımlayıp okuyabiliriz?",
    "answer": "Binary dosyasında belirli bir veri yapısına sahip verileri okumak için yapıyı tanımlayıp, `fread` fonksiyonu ile okumak gereklidir. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} Data;\n\nvoid read_structured_binary_file(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    Data data;\n    while (fread(&data, sizeof(Data), 1, file) == 1) {\n        // data.id ve data.value ile işlem yap\n    }\n\n    fclose(file);\n}\n```\nBu kod, her bir `Data` yapısını binary dosyasından okur ve işleme alır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442669"
  },
  {
    "question": "Binary dosyasını okurken bellek yönetimini nasıl optimize edebiliriz?",
    "answer": "Binary dosyası okurken bellek yönetimini optimize etmek için, okunacak veriyi dinamik olarak allocate etmek ve okuma işlemi sonrasında serbest bırakmak önemlidir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_dynamic_binary_file(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long fileSize = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    unsigned char *buffer = malloc(fileSize);\n    if (!buffer) {\n        perror(\"Bellek tahsis hatası\");\n        fclose(file);\n        return;\n    }\n\n    fread(buffer, 1, fileSize, file);\n    // buffer ile işleme yapılabilir\n\n    free(buffer);\n    fclose(file);\n}\n```\nBu yöntem, belleği etkili bir şekilde yönetir ve okunan verilerin boyutuna göre dinamik alan tahsis eder.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442692"
  },
  {
    "question": "Binary dosyasına veri yazarken dosya boyutu kontrolü nasıl yapılır?",
    "answer": "Binary dosyasına veri yazmadan önce, dosya boyutunu kontrol etmek ve belirli bir boyut sınırına bağlı kalmak için aşağıdaki yöntem kullanılabilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FILE_SIZE 1024 * 1024 // 1MB\n\nvoid write_limited_binary_file(const char *filename, const void *data, size_t dataSize) {\n    FILE *file = fopen(filename, \"ab\"); // Append mode\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long currentSize = ftell(file);\n    if (currentSize + dataSize > MAX_FILE_SIZE) {\n        fprintf(stderr, \"Dosya boyutu aşıldı\");\n        fclose(file);\n        return;\n    }\n\n    fwrite(data, 1, dataSize, file);\n    fclose(file);\n}\n```\nBu kodda, dosyanın mevcut boyutu kontrol edilerek yazılacak verinin boyutu ile birlikte toplam boyut sınırını aşmaması sağlanır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442714"
  },
  {
    "question": "Binary dosyası okuma sırasında veri kaybını önlemek için ne yapmalıyız?",
    "answer": "Okuma sırasında veri kaybını önlemek için, okunan byte sayısını ve beklenen veriyi kontrol etmek önemlidir. Ayrıca, okuma işlemi sırasında `fread` fonksiyonunun döndürdüğü değeri kontrol etmek gerekmektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_with_error_check(const char *filename, size_t expectedSize) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    void *buffer = malloc(expectedSize);\n    if (!buffer) {\n        perror(\"Bellek tahsis hatası\");\n        fclose(file);\n        return;\n    }\n\n    size_t bytesRead = fread(buffer, 1, expectedSize, file);\n    if (bytesRead < expectedSize) {\n        fprintf(stderr, \"Veri kaybı: Okunan byte sayısı: %zu, Beklenen: %zu\\n\", bytesRead, expectedSize);\n    }\n\n    free(buffer);\n    fclose(file);\n}\n```\nBu kod, okunan byte sayısını kontrol eder ve beklenen boyut ile karşılaştırarak veri kaybını raporlar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442739"
  },
  {
    "question": "Binary dosyasında birden fazla veri kaydetmek için nasıl bir yöntem izlemeliyiz?",
    "answer": "Birden fazla veri kaydetmek için, verileri yapılandırmak ve toplu halde yazmak en iyi yöntemdir. Aşağıdaki örnekte, bir dizi `Data` yapısı binary dosyasına yazılmaktadır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} Data;\n\nvoid write_multiple_structs(const char *filename, Data *dataArray, size_t count) {\n    FILE *file = fopen(filename, \"wb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    fwrite(dataArray, sizeof(Data), count, file);\n    fclose(file);\n}\n```\nBu yöntem, birden fazla `Data` yapısını tek seferde dosyaya yazmayı sağlar.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442771"
  },
  {
    "question": "Binary dosyasındaki verilerin okunması sırasında çoklu iş parçacığı kullanmanın avantajları ve dezavantajları nelerdir?",
    "answer": "Binary dosyasındaki verilerin okunması sırasında çoklu iş parçacığı kullanmak, okuma sürelerini azaltabilir ve veri işleme sürecini hızlandırabilir. Ancak, dosya okuma işlemleri genellikle IO-bound olduğundan, çoklu thread kullanımı bazı durumlarda faydalı olmayabilir. Ayrıca, dosya erişimi sırasında senkronizasyon sorunları ortaya çıkabilir. Aşağıda basit bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvoid *read_file_part(void *arg) {\n    // Belirli bir dosya parçasını okuma işlemi\n}\n\nint main() {\n    pthread_t threads[4];\n    for (int i = 0; i < 4; i++) {\n        pthread_create(&threads[i], NULL, read_file_part, (void *)(intptr_t)i);\n    }\n    for (int i = 0; i < 4; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}\n```\nBu kod, dosya okuma işini dört iş parçacığına dağıtmaktadır. Ancak, senkronizasyon ve veri bütünlüğü sağlamak için dikkatli olunmalıdır.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442802"
  },
  {
    "question": "Binary dosyasına yazarken veri bütünlüğünü sağlamak için nelere dikkat etmeliyiz?",
    "answer": "Binary dosyasına yazarken veri bütünlüğünü sağlamak için, yazma işlemlerinden önce ve sonra dosya boyutunu kontrol etmek, yazılacak veri için bir kontrol toplamı (checksum) eklemek önemli olabilir. İşte basit bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid write_with_checksum(const char *filename, const void *data, size_t dataSize) {\n    FILE *file = fopen(filename, \"wb\");\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return;\n    }\n\n    unsigned int checksum = 0;\n    for (size_t i = 0; i < dataSize; i++) {\n        checksum += ((unsigned char *)data)[i];\n    }\n\n    fwrite(data, 1, dataSize, file);\n    fwrite(&checksum, sizeof(checksum), 1, file);\n    fclose(file);\n}\n```\nBu kod, yazma işlemi sırasında veri bütünlüğünü sağlamak için bir kontrol toplamı hesaplamakta ve onu dosyaya eklemektedir.",
    "category": "file_operations",
    "topic": "binary_files",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Binary dosya işlemleri",
    "timestamp": "2025-06-01T16:58:24.442826"
  },
  {
    "question": "Kullanıcının girdiği metni bir dosyaya yazmak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Kullanıcıdan metin al\n    printf(\"Metni girin: \");\n    fgets(metin, sizeof(metin), stdin);\n\n    // Dosyayı aç ve yaz\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya != NULL) {\n        fprintf(dosya, \"%s\", metin);\n        fclose(dosya);\n        printf(\"Metin dosyaya yazıldı.\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan bir metin alır ve 'metin.txt' adında bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724419"
  },
  {
    "question": "Bir dosyadan metni okumak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya != NULL) {\n        // Dosyadan metni oku\n        while (fgets(metin, sizeof(metin), dosya)) {\n            printf(\"Okunan metin: %s\", metin);\n        }\n        fclose(dosya);\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasından metin okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724458"
  },
  {
    "question": "Bir dosyaya birkaç satır yazmak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"w\");\n    if (dosya != NULL) {\n        // Birkaç satır yaz\n        fprintf(dosya, \"1. Satır: Merhaba, Dünya!\\n\");\n        fprintf(dosya, \"2. Satır: C programlamaya hoş geldiniz.\\n\");\n        fclose(dosya);\n        printf(\"Satırlar dosyaya yazıldı.\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasına iki satır metin yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724482"
  },
  {
    "question": "Bir dosyadan satır satır okuyup her satırı ekrana yazdırmak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya != NULL) {\n        // Satır satır oku ve yazdır\n        while (fgets(satir, sizeof(satir), dosya)) {\n            printf(\"Satır: %s\", satir);\n        }\n        fclose(dosya);\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasındaki her satırı oku ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724529"
  },
  {
    "question": "Bir dosyaya kullanıcıdan alınan bir dizi yazmak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char dizi[5][100];\n\n    // Kullanıcıdan dizi al\n    for (int i = 0; i < 5; i++) {\n        printf(\"Dizi elemanını girin: \");\n        fgets(dizi[i], sizeof(dizi[i]), stdin);\n    }\n\n    // Dosyayı aç ve yaz\n    dosya = fopen(\"dizi.txt\", \"w\");\n    if (dosya != NULL) {\n        for (int i = 0; i < 5; i++) {\n            fprintf(dosya, \"%s\", dizi[i]);\n        }\n        fclose(dosya);\n        printf(\"Dizi dosyaya yazıldı.\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, kullanıcıdan alınan 5 elemanı 'dizi.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724553"
  },
  {
    "question": "Bir dosyadaki metni tersine çevirmek için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya != NULL) {\n        fgets(metin, sizeof(metin), dosya);\n        fclose(dosya);\n\n        // Metni tersine çevir\n        int uzunluk = strlen(metin);\n        for (int i = uzunluk - 1; i >= 0; i--) {\n            printf(\"%c\", metin[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasındaki metni okur ve tersine çevirerek ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724576"
  },
  {
    "question": "Bir dosyayı satır sayısına göre okumak ve toplam satır sayısını ekrana yazdırmak için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n    int satirSayisi = 0;\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya != NULL) {\n        while (fgets(satir, sizeof(satir), dosya)) {\n            satirSayisi++;\n        }\n        fclose(dosya);\n        printf(\"Toplam satır sayısı: %d\\n\", satirSayisi);\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasındaki toplam satır sayısını hesaplar ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724607"
  },
  {
    "question": "Dosyadan okunan metni büyük harflere çevirmek için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *dosya;\n    char metin[100];\n\n    // Dosyayı aç\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya != NULL) {\n        fgets(metin, sizeof(metin), dosya);\n        fclose(dosya);\n\n        // Metni büyük harflere çevir ve yazdır\n        for (int i = 0; metin[i] != '\\0'; i++) {\n            putchar(toupper(metin[i]));\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, 'metin.txt' dosyasındaki metni okur ve büyük harflere çevirerek ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724641"
  },
  {
    "question": "Bir dosyaya tarih ve saat eklemek için gerekli kodu tamamla.",
    "answer": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    FILE *dosya;\n    time_t t;\n    struct tm *tm;\n\n    // Geçerli tarihi al\n    time(&t);\n    tm = localtime(&t);\n\n    // Dosyayı aç ve tarihi yaz\n    dosya = fopen(\"tarih.txt\", \"w\");\n    if (dosya != NULL) {\n        fprintf(dosya, \"Tarih: %02d-%02d-%04d\\n\", tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900);\n        fprintf(dosya, \"Saat: %02d:%02d:%02d\\n\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n        fclose(dosya);\n        printf(\"Tarih ve saat dosyaya yazıldı.\\n\");\n    } else {\n        printf(\"Dosya açılamadı.\\n\");\n    }\n    return 0;\n}\n\n// Bu kod, geçerli tarihi ve saati 'tarih.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:58:55.724663"
  },
  {
    "question": "Bir metin dosyasındaki tüm kelimelerin sayısını hesaplayacak bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int count = 0;\n    int inWord = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch == ' ' || ch == '\\n' || ch == '\\t') {\n            inWord = 0;\n        } else if (inWord == 0) {\n            inWord = 1;\n            count++;\n        }\n    }\n\n    fclose(file);\n    printf(\"Toplam kelime sayısı: %d\\n\", count);\n    return 0;\n}\n\n// Bu program, metin.txt dosyasını açar, içeriğini okur ve boşluk veya yeni satır karakterlerine dayanarak kelimeleri sayar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802724"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırların uzunluğunu hesaplayıp, en uzun satırı bulacak bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    char longestLine[256];\n    int longestLength = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        int length = strlen(line);\n        if (length > longestLength) {\n            longestLength = length;\n            strcpy(longestLine, line);\n        }\n    }\n\n    fclose(file);\n    printf(\"En uzun satır: %s\", longestLine);\n    return 0;\n}\n\n// Bu program, metin.txt dosyasını açar ve her satırı okuyarak en uzun satırı bulur.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802771"
  },
  {
    "question": "Bir metin dosyasındaki tüm karakterleri büyük harfe çeviren bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file, *outputFile;\n    char ch;\n\n    file = fopen(\"metin.txt\", \"r\");\n    outputFile = fopen(\"buyuk_harf.txt\", \"w\");\n    if (file == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        fputc(toupper(ch), outputFile);\n    }\n\n    fclose(file);\n    fclose(outputFile);\n    printf(\"Karakterler büyük harfe çevrildi ve buyuk_harf.txt dosyasına yazıldı.\");\n    return 0;\n}\n\n// Bu program, metin.txt dosyasındaki tüm karakterleri büyük harfe çevirir ve yeni bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802798"
  },
  {
    "question": "Bir metin dosyasını okuyarak, her kelimenin tekrar sayısını sayacak bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_WORDS 100\n#define MAX_WORD_LENGTH 20\n\nint main() {\n    FILE *file;\n    char word[MAX_WORD_LENGTH];\n    char *words[MAX_WORDS];\n    int counts[MAX_WORDS] = {0};\n    int wordCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%s\", word) != EOF) {\n        // Kelimeyi kontrol et\n        int found = 0;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i], word) == 0) {\n                counts[i]++;\n                found = 1;\n                break;\n            }\n        }\n        // Eğer kelime yeni ise ekle\n        if (!found) {\n            words[wordCount] = strdup(word);\n            counts[wordCount] = 1;\n            wordCount++;\n        }\n    }\n\n    fclose(file);\n\n    for (int i = 0; i < wordCount; i++) {\n        printf(\"%s: %d\\n\", words[i], counts[i]);\n        free(words[i]);\n    }\n    return 0;\n}\n\n// Bu program metin.txt dosyasındaki her kelimenin sayısını bulur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802826"
  },
  {
    "question": "Bir metin dosyasındaki satırları tersine çevirip yeni bir dosyaya yazacak bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 100\n#define MAX_LINE_LENGTH 256\n\nint main() {\n    FILE *file, *outputFile;\n    char lines[MAX_LINES][MAX_LINE_LENGTH];\n    int lineCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    outputFile = fopen(\"ters_satlar.txt\", \"w\");\n    if (file == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(lines[lineCount], sizeof(lines[lineCount]), file) && lineCount < MAX_LINES) {\n        lineCount++;\n    }\n\n    for (int i = lineCount - 1; i >= 0; i--) {\n        fputs(lines[i], outputFile);\n    }\n\n    fclose(file);\n    fclose(outputFile);\n    printf(\"Satırlar tersine çevrildi ve ters_satlar.txt dosyasına yazıldı.\");\n    return 0;\n}\n\n// Bu program, metin.txt dosyasındaki satırları okur ve ters sırada ters_satlar.txt dosyasına yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802876"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi arayan ve bulursa kullanıcıya bildiren bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    char keyword[50];\n\n    printf(\"Aranacak kelimeyi girin: \");\n    scanf(\"%s\", keyword);\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    int found = 0;\n    while (fgets(line, sizeof(line), file)) {\n        if (strstr(line, keyword) != NULL) {\n            found = 1;\n            break;\n        }\n    }\n\n    fclose(file);\n\n    if (found) {\n        printf(\"'%s' kelimesi dosyada bulundu.\\n\", keyword);\n    } else {\n        printf(\"'%s' kelimesi dosyada bulunamadı.\\n\", keyword);\n    }\n    return 0;\n}\n\n// Bu program, kullanıcıdan bir kelime alır ve metin.txt dosyasında bu kelimeyi arar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802906"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları küçük harfe çeviren bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file, *outputFile;\n    char ch;\n\n    file = fopen(\"metin.txt\", \"r\");\n    outputFile = fopen(\"kucuk_harf.txt\", \"w\");\n    if (file == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        fputc(tolower(ch), outputFile);\n    }\n\n    fclose(file);\n    fclose(outputFile);\n    printf(\"Karakterler küçük harfe çevrildi ve kucuk_harf.txt dosyasına yazıldı.\");\n    return 0;\n}\n\n// Bu program, metin.txt dosyasındaki tüm karakterleri küçük harfe çevirir ve yeni bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802932"
  },
  {
    "question": "Bir metin dosyasındaki tüm boşlukları kaldıracak bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file, *outputFile;\n    char ch;\n\n    file = fopen(\"metin.txt\", \"r\");\n    outputFile = fopen(\"bosluk_kaldir.txt\", \"w\");\n    if (file == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch != ' ') {\n            fputc(ch, outputFile);\n        }\n    }\n\n    fclose(file);\n    fclose(outputFile);\n    printf(\"Boşluklar kaldırıldı ve bosluk_kaldir.txt dosyasına yazıldı.\");\n    return 0;\n}\n\n// Bu program, metin.txt dosyasındaki tüm boşluk karakterlerini kaldırır ve sonucu yeni bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802966"
  },
  {
    "question": "Bir metin dosyasındaki her satırın başına satır numarası ekleyecek bir C programı yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file, *outputFile;\n    char line[256];\n    int lineNumber = 1;\n\n    file = fopen(\"metin.txt\", \"r\");\n    outputFile = fopen(\"numarali_satlar.txt\", \"w\");\n    if (file == NULL || outputFile == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        fprintf(outputFile, \"%d: %s\", lineNumber++, line);\n    }\n\n    fclose(file);\n    fclose(outputFile);\n    printf(\"Satır numaraları eklendi ve numarali_satlar.txt dosyasına yazıldı.\");\n    return 0;\n}\n\n// Bu program, metin.txt dosyasındaki her satırın başına satır numarası ekler ve sonuçları yeni bir dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T16:59:38.802992"
  },
  {
    "question": "Bir metin dosyasındaki tüm kelimeleri sayan bir C programı eksik. 'count_words' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint count_words(FILE *file) {\n    int count = 0;\n    char ch;\n    int in_word = 0;\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (isspace(ch)) {\n            in_word = 0;\n        } else if (in_word == 0) {\n            in_word = 1;\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return 1;\n    }\n\n    int word_count = count_words(file);\n    printf(\"Kelime sayısı: %d\\n\", word_count);\n    fclose(file);\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki kelimeleri sayar. 'count_words' fonksiyonu, dosyadan okunan karakterleri inceler ve boşluklar arasındaki kelime geçişlerini tespit ederek toplam kelime sayısını döndürür.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067552"
  },
  {
    "question": "Bir metin dosyasının satırlarını tersine çeviren bir C programı eksik. 'reverse_lines' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 256\n\nvoid reverse_lines(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char *lines[100];\n    char buffer[MAX_LINE_LENGTH];\n    int line_count = 0;\n\n    while (fgets(buffer, MAX_LINE_LENGTH, file) != NULL && line_count < 100) {\n        lines[line_count] = strdup(buffer);\n        line_count++;\n    }\n\n    for (int i = line_count - 1; i >= 0; i--) {\n        printf(\"%s\", lines[i]);\n        free(lines[i]);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    reverse_lines(\"metin.txt\");\n    return 0;\n}\n\n// Bu program, belirtilen bir metin dosyasındaki satırları okur ve onları ters sırayla ekrana yazdırır. 'reverse_lines' fonksiyonu, dosyadan okunan her satırı bir diziye kaydeder ve ardından diziyi tersinden gezerek satırları yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067617"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi arayan ve kaç kez geçtiğini sayan bir C programının 'count_occurrences' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_occurrences(const char *filename, const char *word) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return -1;\n    }\n\n    char buffer[256];\n    int count = 0;\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        char *ptr = buffer;\n        while ((ptr = strstr(ptr, word)) != NULL) {\n            count++;\n            ptr += strlen(word);\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    const char *word = \"kelime\";\n    int occurrences = count_occurrences(\"metin.txt\", word);\n    printf(\"'%s' kelimesinin sayısı: %d\\n\", word, occurrences);\n    return 0;\n}\n\n// Bu program, bir metin dosyasında belirli bir kelimenin kaç kez geçtiğini sayar. 'count_occurrences' fonksiyonu, dosyayı satır satır okur ve her satırda kelimeyi arar, bulduğu her seferde sayacı artırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067664"
  },
  {
    "question": "Bir metin dosyasını belirli bir kelime ile değiştiren bir C programı eksik. 'replace_word' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid replace_word(const char *filename, const char *old_word, const char *new_word) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char buffer[1024];\n    char *result = NULL;\n    size_t new_length = strlen(new_word);\n    size_t old_length = strlen(old_word);\n    size_t result_length = 0;\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        char *pos = buffer;\n        while ((pos = strstr(pos, old_word)) != NULL) {\n            result_length += new_length;\n            result = realloc(result, result_length + 1);\n            strncat(result, buffer, pos - buffer);\n            strcat(result, new_word);\n            pos += old_length;\n            buffer = pos;\n        }\n        strcat(result, buffer);\n    }\n\n    fclose(file);\n    printf(\"Sonuç: %s\\n\", result);\n    free(result);\n}\n\nint main() {\n    replace_word(\"metin.txt\", \"eski_kelime\", \"yeni_kelime\");\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki belirli bir kelimeyi başka bir kelime ile değiştirecek şekilde çalışır. 'replace_word' fonksiyonu, dosyayı okur ve her bulduğu eski kelimeyi yeni kelime ile değiştirerek sonucu oluşturur.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067698"
  },
  {
    "question": "Bir metin dosyasındaki satır sayılarını ve kelime sayılarını yazdıran bir C programı eksik. 'print_line_word_count' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nvoid print_line_word_count(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char buffer[256];\n    int line_number = 0;\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        line_number++;\n        int word_count = 0;\n        char *ptr = buffer;\n\n        while (*ptr) {\n            while (isspace(*ptr)) ptr++;\n            if (*ptr) {\n                word_count++;\n                while (!isspace(*ptr) && *ptr) ptr++;\n            }\n        }\n        printf(\"Satır %d: %d kelime\\n\", line_number, word_count);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    print_line_word_count(\"metin.txt\");\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki her satırın kaç kelime içerdiğini ve satır numarasını yazdırır. 'print_line_word_count' fonksiyonu, her satırı okur, kelime sayısını hesaplar ve sonuçları gösterir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067734"
  },
  {
    "question": "Bir metin dosyasındaki tüm harfleri büyük harfe çeviren bir C programı eksik. 'to_uppercase' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nvoid to_uppercase(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(toupper(ch));\n    }\n\n    fclose(file);\n}\n\nint main() {\n    to_uppercase(\"metin.txt\");\n    return 0;\n}\n\n// Bu program, belirtilen bir metin dosyasındaki tüm harfleri büyük harfe dönüştürerek ekrana yazdırır. 'to_uppercase' fonksiyonu, dosyadan bir karakter okur ve 'toupper' fonksiyonu ile büyük harfe çevirerek yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067766"
  },
  {
    "question": "Bir metin dosyasındaki en uzun kelimeyi bulan C programındaki 'find_longest_word' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid find_longest_word(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char buffer[256];\n    char longest_word[256] = \"\";\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        char *word = strtok(buffer, \" \\n\");\n        while (word != NULL) {\n            if (strlen(word) > strlen(longest_word)) {\n                strcpy(longest_word, word);\n            }\n            word = strtok(NULL, \" \\n\");\n        }\n    }\n\n    printf(\"En uzun kelime: %s\\n\", longest_word);\n    fclose(file);\n}\n\nint main() {\n    find_longest_word(\"metin.txt\");\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki en uzun kelimeyi bulur. 'find_longest_word' fonksiyonu, dosyayı satır satır okur, her kelimeyi ayırır ve en uzun kelimeyi kaydeder.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067796"
  },
  {
    "question": "Bir metin dosyasını okuyan ve içindeki tüm sayıları toplayan bir C programı eksik. 'sum_numbers' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint sum_numbers(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return 0;\n    }\n\n    int sum = 0;\n    char buffer[256];\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        char *ptr = buffer;\n        while (*ptr) {\n            if (isdigit(*ptr)) {\n                sum += atoi(ptr);\n                while (isdigit(*ptr)) ptr++;\n            } else {\n                ptr++;\n            }\n        }\n    }\n\n    fclose(file);\n    return sum;\n}\n\nint main() {\n    int total = sum_numbers(\"metin.txt\");\n    printf(\"Toplam: %d\\n\", total);\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki tüm sayıları toplar. 'sum_numbers' fonksiyonu, dosyayı satır satır okur, her sayıyı bulur ve toplamını hesaplar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067830"
  },
  {
    "question": "Bir metin dosyasındaki her satırın başına satır numarası ekleyen bir C programı eksik. 'add_line_numbers' fonksiyonunu tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid add_line_numbers(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı\");\n        return;\n    }\n\n    char buffer[256];\n    int line_number = 1;\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"%d: %s\", line_number, buffer);\n        line_number++;\n    }\n\n    fclose(file);\n}\n\nint main() {\n    add_line_numbers(\"metin.txt\");\n    return 0;\n}\n\n// Bu program, bir metin dosyasındaki her satırın başına bir satır numarası ekler. 'add_line_numbers' fonksiyonu, dosyayı satır satır okur ve her satırın başına satır numarasını ekleyerek yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:29.067870"
  },
  {
    "question": "Bir metin dosyasını açarken 'fopen' fonksiyonu ile dosya açılıyor ancak dosya açılırken NULL dönüyor. Bu ne anlama geliyor?",
    "answer": "NULL dönmesi, dosyanın açılamadığı anlamına gelir. Bunun nedeni, dosyanın belirtilen yolda bulunmaması, dosya adının yanlış yazılması, veya dosya izinlerinin yetersiz olması olabilir. Bu durumu kontrol etmek için 'perror' fonksiyonunu kullanarak hata mesajı alabilirsiniz. Örneğin: 'perror(\"Dosya açılamadı\");' kodu ile hatayı görebilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.863817"
  },
  {
    "question": "Bir metin dosyasına yazma işlemi yaparken 'fprintf' fonksiyonu kullanılıyor, fakat dosya boş kalıyor. Neden olabilir?",
    "answer": "'fprintf' ile yazma işlemi gerçekleştirilirken, dosyanın açık olduğundan emin olmalısınız. Ayrıca, 'fclose' fonksiyonu ile dosyayı kapatmayı unutmayın. Eğer 'fclose' çağrılmıyorsa, tampon bellek dolmaz ve dosyaya veri yazılmaz. Örnek: 'fclose(dosya);' çağrısını eklemeyi unutmayın.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.863878"
  },
  {
    "question": "Bir dosyadan okunan veriler 'fgets' ile okunuyor, fakat sonucun içinde beklenmeyen karakterler var. Neden böyle oluyor?",
    "answer": "'fgets' fonksiyonu, satır sonu karakterini de okur ve bu karakteri sonuç stringinin sonuna ekler. Eğer bu karakteri istemiyorsanız, dizinin sonundaki yeni satır karakterini ('\n') silmek için 'strcspn' fonksiyonunu kullanarak temizleyebilirsiniz. Örneğin: 'line[strcspn(line, \"\\n\")] = 0;' ile yeni satır karakterini kaldırabilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.863919"
  },
  {
    "question": "'fscanf' ile dosyadan veri okurken 'EOF' hatası alıyorum. Bu ne anlama geliyor?",
    "answer": "EOF (End of File), dosyanın sonuna gelindiği anlamına gelir. 'fscanf' fonksiyonu, verilerin sonunu bulduğunda EOF döner. Eğer dosyada beklediğinizden daha az veri varsa bu hatayı alabilirsiniz. Dosyanın sonuna nasıl geldiğinizi kontrol ederek bu durumu yönetebilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.863951"
  },
  {
    "question": "Dosyaya yazılan veriyi okuduktan sonra, beklenen değer ile okunan değer arasında fark var. Neden böyle olabilir?",
    "answer": "Bu durum, yazma işlemi sırasında dosya kapanmadan veya verilerin tam olarak yazılmadan okumaya geçilmesinden kaynaklanabilir. 'fflush' fonksiyonu, tampon belleği temizleyerek verilerin hemen dosyaya yazılmasını sağlar. Örnek: 'fflush(dosya);' ile yazma sonrası verilerin kaydedildiğinden emin olabilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.863986"
  },
  {
    "question": "Bir dosyadan okunan verilerle işlem yapıyorum ancak bellekte 'segmentation fault' hatası alıyorum. Bunun nedeni ne olabilir?",
    "answer": "Segmentation fault genellikle bir işaretçiyi yanlış bir bellek bölgesine yönlendirdiğinizde oluşur. Dosyadan okunan verilerin doğru bir şekilde bellekte ayrıldığından emin olun. Ayrıca, okunan veri boyutunun uygun olup olmadığını kontrol edin. Yeterli bellek ayırmadıysanız bu hatayı alırsınız.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864026"
  },
  {
    "question": "'fopen' ile açılan dosya kapatılmadan program bitiyor. Bu durumda ne olur?",
    "answer": "Eğer dosya kapatılmadan program bitiyorsa, dosya ile ilgili kaynaklar serbest bırakılmaz. Bu, bellek sızıntısına ve dosya sisteminde tutarsızlıklara yol açabilir. Her zaman 'fclose' kullanarak açtığınız dosyaları kapatmayı unutmayın. Bu, kaynak yönetimi için iyi bir uygulamadır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864061"
  },
  {
    "question": "Bir dosyadan çoklu satır okumak istiyorum ancak 'fgets' kullanarak sadece ilk satırı alabiliyorum. Neden?",
    "answer": "'fgets' fonksiyonu sadece bir satır okur. Çoklu satır okumak için bir döngü kullanmalısınız. Örnek: 'while (fgets(line, sizeof(line), dosya) != NULL) { /* işlemler */ }' ile dosya sonuna kadar okuyabilirsiniz.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864106"
  },
  {
    "question": "Bir metin dosyası okunduktan sonra bu dosyayı düzenlemek istiyorum. Ancak dosya yazma modunda açılınca içindeki veriler siliniyor. Neden?",
    "answer": "Dosyayı yazma modunda ('w') açarsanız, dosyanın içeriği silinir. Dosyayı ekleme modunda ('a') açmanız gerekir. Böylece, mevcut verileri koruyarak yeni verileri ekleyebilirsiniz. Örnek: 'fopen(\"dosya.txt\", \"a\");' biçiminde açmalısınız.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864144"
  },
  {
    "question": "Okunan verileri bir diziye kaydettim, ancak dizinin boyutu yetersiz. Bu durumda ne olur?",
    "answer": "Dizinin boyutu yetersizse, bellek taşması (buffer overflow) meydana gelir ve bu durum programın çökmesine veya beklenmedik davranışlara yol açar. Verilerinizi depolamak için yeterli boyut ayırdığınızdan emin olun ya da dinamik bellek ayırma (malloc) kullanarak esnek bir dizi oluşturun.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864170"
  },
  {
    "question": "Metin dosyasındaki verileri sıralamak istiyorum ama sıralama işlemi sonrası çıktı boş. Neden?",
    "answer": "Sıralama işlemini gerçekleştirmeden önce verilerinizi doğru bir şekilde okuduğunuzdan emin olun. Sıralama algoritmanızın doğru çalıştığından emin olun ve sonuçları ekrana yazdırmayı unutmayın. Örneğin: 'printf(\"%s\", veriler[i]);' ile sıralanmış verileri ekrana yazdırın.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:00:54.864199"
  },
  {
    "question": "Bir metin dosyasını okumak için fopen ve fclose fonksiyonları doğru kullanılıyor mu?",
    "answer": "Kodda fopen ile dosya açılmasına rağmen fclose çağrısı yapılmadığında, dosya kapatılmamış olur. Bu, bellek sızıntısına neden olabilir. Dosyayı okuduktan sonra fclose fonksiyonunun çağrılması gerektiğini unutmayın. Örnek düzeltme: `fclose(dosya);` çağrısını ekleyin.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.648966"
  },
  {
    "question": "Dosyadan okunan veriler hatalıysa sebebi ne olabilir?",
    "answer": "Dosya okuma işlemlerinde, satır sonu karakterleri veya boş satırlar nedeniyle okunan veriler beklenmedik bir biçimde olabilir. Örneğin, fgets kullanırken, satır sonu karakterlerini düzgün bir şekilde temizlemek önemlidir. `strtok` veya `trim` fonksiyonu kullanılabilir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649008"
  },
  {
    "question": "Bir metin dosyasına yazarken, yazma işlemi başarılı mı kontrol edilmediğinde ne olur?",
    "answer": "Eğer yazma işlemi sırasında dosya dolu veya yazma izinleri yoksa, hata oluşur ama program bunu kontrol etmezse, beklenmedik sonuçlar ortaya çıkabilir. `fprintf` veya `fwrite` işlemi sonrasında dönen değerin kontrol edilmesi gerekir. Örnek: `if (fprintf(dosya, ... ) < 0) { perror(\"Yazma hatası.\"); }`",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649040"
  },
  {
    "question": "Dosya okuma hatası alıyorum, sebebi ne olabilir?",
    "answer": "Dosya mevcut olmayabilir veya okunabilir izni olmayabilir. `fopen` fonksiyonu sonrası dönen işaretçi kontrol edilmelidir. Örnek düzeltme: `if (dosya == NULL) { perror(\"Dosya açılamadı.\"); return 1; }`",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649065"
  },
  {
    "question": "Bir dosyayı okurken buffer overflow hatası alıyorum, nedeni nedir?",
    "answer": "Buffer overflow, okunan verinin buffer alanını aşması nedeniyle olur. Örneğin, `char buffer[10];` ile tanımlı bir buffer'a 20 karakterlik veri yazmaya çalışmak bu hatayı oluşturur. Çözüm, buffer boyutunu yeterince büyük yapmak veya okunan veriyi sınırlandırmaktır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649092"
  },
  {
    "question": "Aynı dosyayı birden fazla kez açarken sorun yaşıyorum, çözüm nedir?",
    "answer": "Bir dosyayı birden fazla kez açmak, kaynak sızıntısına veya veri tutarsızlığına yol açabilir. Dosyayı açmadan önce mevcut bir işaretçi olup olmadığını kontrol etmek ve her açılış sonrasında `fclose` çağrısını yapmak gereklidir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649127"
  },
  {
    "question": "Dosyadaki tüm satırları okuduktan sonra belleği serbest bırakmayı unuttum, sonuçları ne olur?",
    "answer": "Bellek sızıntısı oluşur. Eğer dinamik bellek kullanarak satırları okuduysanız, her bir satır için `free()` fonksiyonunu çağırmayı unutmayın. Her allocation sonrası `free(buffer);` ile belleği temizleyin.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649159"
  },
  {
    "question": "Dosyadan okunan verilerde özel karakterler sorun yaratıyor, nasıl başa çıkabilirim?",
    "answer": "Özel karakterler (örneğin, yeni satır veya tablo karakterleri) dosya formatına göre hatalara yol açabilir. `fgets` ile okunan veriler üzerinde `str_replace` veya özel karakterleri temizleyen bir fonksiyon kullanılabilir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649189"
  },
  {
    "question": "Bir metin dosyasındaki verileri sıralamak istiyorum, hangi yöntemleri kullanmalıyım?",
    "answer": "Öncelikle dosyadaki verileri bir diziye veya listeye okumanız gerekir. Daha sonra, bu diziyi `qsort` gibi bir sıralama algoritması ile sıralayabilirsiniz. Örnek: `qsort(veri, boyut, sizeof(char*), kucuktenBuyuge);`",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649217"
  },
  {
    "question": "Dosya yazma işlemi sırasında, işaretçi konumunu kontrol etmemek sorun yaratır mı?",
    "answer": "Evet, işaretçi konumunu kontrol etmemek, dosyanın beklenmedik bir yerinde yazma yapmanıza sebep olabilir. `ftell` fonksiyonu ile mevcut konumu kontrol edin ve gerektiğinde `fseek` ile doğru konuma gidin.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649248"
  },
  {
    "question": "Birden fazla dosyayı aynı anda nasıl güvenle açabilirim?",
    "answer": "Birden fazla dosyayı açarken, her bir `FILE*` işaretçisi için ayrı bir kontrol yapmalısınız. Her dosya açıldıktan sonra hata kontrolü yaparak işlemleri güvence altına alın. Örnek: `FILE* dosya1 = fopen(...); if (dosya1 == NULL) { perror(\"Hata\"); }`",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:15.649273"
  },
  {
    "question": "Aşağıdaki kod, bir metin dosyasını satır satır okurken hata veriyor. Hatanın nedeni nedir ve nasıl düzeltilir? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod, \"data.txt\" dosyasını açarken hata alıyor olabilir. Bunun nedeni dosyanın mevcut olmaması veya yanlış bir yolda olmasıdır. Dosya açılmadan önce kontrol edilmelidir. Düzeltme için şu şekilde kontrol eklenmelidir:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056334"
  },
  {
    "question": "Aşağıdaki kod, bir metin dosyasına yazarken beklenmedik bir çıktı veriyor. Hatanın nedeni nedir ve nasıl düzeltilebilir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    fprintf(file, \"Hello, World!\");\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod, dosya açma işlemi başarısız olursa çıktı vermemekte. Dosyanın yazılabilir olduğundan emin olunmalı ve dosya açma işleminden sonra kontrol eklenmelidir:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056442"
  },
  {
    "question": "Aşağıdaki kod, bir metin dosyasının boyutunu hesaplarken yanlış sonuç veriyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    fseek(file, 0, SEEK_END);\n    long size = ftell(file);\n    fclose(file);\n    printf(\"Boyut: %ld\\n\", size);\n    return 0;\n}",
    "answer": "Kod, dosya açılmadan önce kontrol edilmediği için bir hata meydana gelebilir. Ayrıca, dosya okuma modunda açıldığında kaydırma işlemlerinin doğru çalışması için dosyanın mevcut olup olmadığını kontrol etmek gerekir. 'fopen' sonrası kontrol eklenmelidir. Düzeltme:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056572"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadan kelimeleri sayarken yanlış sonuç veriyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"text.txt\", \"r\");\n    char word[100];\n    int count = 0;\n    while (fscanf(file, \"%s\", word) != EOF) {\n        count++;\n    }\n    fclose(file);\n    printf(\"Kelime sayısı: %d\\n\", count);\n    return 0;\n}",
    "answer": "Kod, dosyayı açmadan önce dosyanın kontrolünü yapmadığı için hata verebilir. Ayrıca, 'fscanf' işlemi başarısız olursa sonsuz döngüye girebilir. Dosyanın mevcut olup olmadığını kontrol etmeli ve fscanf'tan sonraki kontrolü sağlamalısınız. Düzeltme:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056693"
  },
  {
    "question": "Aşağıdaki kod, bir metin dosyasını okurken bellekte taşma hatası alıyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char line[5]; // Çok küçük bir boyut\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Kodun 'line' değişkeninin boyutu çok küçük olduğu için bellekte taşma hatası alıyorsunuz. 'line' değişkeninin boyutunu artırarak bu hatayı çözebilirsiniz. Örneğin:\n\nchar line[256]; // Yeterli boyut",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056804"
  },
  {
    "question": "Aşağıdaki kod, bir dosyayı yazarken önceki içeriklerin silinmesini istemiyor ama hâlâ dosya içeriği siliniyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"a\"); // Ekleme modu\n    fprintf(file, \"Yeni içerik\\n\");\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod doğru şekilde ekleme modunda açıyor ama dosya açma işlemi başarısız olursa 'file' NULL olur. Bu durumda dosya açılmadığı için hata meydana gelir. 'fopen' sonrası kontrol eklemek önemlidir:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056888"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadaki tüm verileri okuduktan sonra dosyayı kapatmayı unuttuğu için bellek sızıntısı sorunu yaşıyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n    // fclose(file); // Dosya kapatılmıyor\n    return 0;\n}",
    "answer": "Kodda dosya kapatma işlemi yapılmadığı için bellek sızıntısı riski var. 'fclose' fonksiyonu eklenmeli. Düzeltme için:\n\nfclose(file); // Dosya kapatılmalı",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.056988"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadan okunan verileri tam olarak okumuyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n        // Burada bir hata olabilir\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod, dosya okuma işlemi sırasında karakterler okunurken hata oluşabilir. 'fgetc' ile okunan karakter 'EOF' değilse işlem yapılmalıdır. 'if' kontrolü eklenmelidir:\n\nif (ch != EOF) {\n    putchar(ch);\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.057071"
  },
  {
    "question": "Aşağıdaki kod, bir dosyada belirtilen bir kelimeyi ararken yanlış sonuç veriyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"text.txt\", \"r\");\n    char line[256];\n    char *key = \"searchWord\";\n    while (fgets(line, sizeof(line), file)) {\n        if (strstr(line, key) != NULL) {\n            printf(\"Kelime bulundu: %s\", line);\n        }\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod, dosya açıldıktan sonra kontrol edilmediği için hatalar oluşabilir. Ayrıca, 'strstr' kullanılarak kelime bulunamadığında bir mesaj vermek yararlı olabilir. Düzeltme:\n\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.057184"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadan okunan verileri tersine yazarken yanlış sonuç veriyor. Hatanın nedeni nedir? \n\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        for (int i = strlen(line) - 1; i >= 0; i--) {\n            putchar(line[i]);\n        }\n    }\n    fclose(file);\n    return 0;\n}",
    "answer": "Kod, 'fgets' ile okunan satır sonundaki yeni satır karakterini de tersine çeviriyor. Bunu önlemek için satır sonundaki yeni satır karakterini kontrol etmelisiniz:\n\nif (line[strlen(line) - 1] == '\\n') {\n    line[strlen(line) - 1] = '\\0'; // Yeni satır karakterini kaldır\n}",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:01:58.057286"
  },
  {
    "question": "Bir metin dosyasını nasıl açabilirim?",
    "answer": "C dilinde bir metin dosyasını açmak için 'fopen' fonksiyonunu kullanırız. Örneğin:\n\n```c\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\n```\nBurada 'ornek.txt' dosyası 'okuma' ('r') modunda açılır. Dosya başarıyla açılınca, 'dosya' değişkeni işaretçi olarak dosyayı tutar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946127"
  },
  {
    "question": "Dosyaya nasıl veri yazabilirim?",
    "answer": "Bir metin dosyasına veri yazmak için yine 'fopen' fonksiyonunu kullanarak dosyayı yazma ('w') modunda açmalıyız. Örneğin:\n\n```c\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"w\");\nfputs(\"Merhaba, Dünya!\", dosya);\nfclose(dosya);\n```\nBurada 'fputs' ile dosyaya metin yazıyoruz ve işlemin sonunda dosyayı kapatmayı unutmamalıyız.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946172"
  },
  {
    "question": "Dosyadaki tüm verileri nasıl okuyabilirim?",
    "answer": "Tüm dosyayı okumak için bir döngü kullanabiliriz. Örnek:\n\n```c\nchar line[100];\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\nwhile (fgets(line, sizeof(line), dosya)) {\n    printf(\"%s\", line);\n}\nfclose(dosya);\n```\nBu kod, dosyadaki her bir satırı okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946216"
  },
  {
    "question": "Bir dosyadaki belirli bir satıra nasıl erişebilirim?",
    "answer": "Belirli bir satıra erişmek için, dosyayı satır satır okuyup bir sayaç kullanabiliriz. Örnek:\n\n```c\nchar line[100];\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\nint satir_numarasi = 3;\nfor (int i = 1; i <= satir_numarasi; i++) {\n    fgets(line, sizeof(line), dosya);\n}\nprintf(\"%s\", line);\nfclose(dosya);\n```\nBu kod, 3. satırı okuyup ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946252"
  },
  {
    "question": "Dosyanın sonuna nasıl veri ekleyebilirim?",
    "answer": "Bir dosyanın sonuna veri eklemek için dosyayı ekleme ('a') modunda açmalıyız. Örnek:\n\n```c\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"a\");\nfputs(\"Yeni veri ekleniyor!\\n\", dosya);\nfclose(dosya);\n```\nBu kod, dosyanın sonuna yeni bir veri ekler.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946281"
  },
  {
    "question": "Bir dosyayı nasıl kapatabilirim?",
    "answer": "Açılmış bir dosyayı kapatmak için 'fclose' fonksiyonunu kullanırız. Örneğin:\n\n```c\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\n// Dosya ile işlemler...\nfclose(dosya);\n```\nBu, dosyanın kaynaklarını serbest bırakır ve işlemleri bitirir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946307"
  },
  {
    "question": "Dosya açılırken bir hata olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Dosya açılırken bir hata olup olmadığını kontrol etmek için 'fopen' sonucunu kontrol edebiliriz. Örnek:\n\n```c\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\nif (dosya == NULL) {\n    printf(\"Dosya açılamadı!\");\n} else {\n    // Dosya ile işlemler...\nfclose(dosya);\n}\n```\nBu kod, dosyanın açılamaması durumunda bir hata mesajı gösterir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946346"
  },
  {
    "question": "Bir dosyadaki belirli bir kelimeyi nasıl değiştirebilirim?",
    "answer": "Bir dosyadaki kelimeyi değiştirmek için dosyayı okuyup içeriği geçici bir dosyaya yazmamız gerekir. Örnek:\n\n```c\nFILE *dosya, *temp;\nchar line[100];\ndosya = fopen(\"ornek.txt\", \"r\");\ntemp = fopen(\"temp.txt\", \"w\");\nwhile (fgets(line, sizeof(line), dosya)) {\n    if (strstr(line, \"eski_kelime\") != NULL) {\n        str_replace(line, \"eski_kelime\", \"yeni_kelime\");\n    }\n    fputs(line, temp);\n}\nfclose(dosya);\nfclose(temp);\nremove(\"ornek.txt\");\nrename(\"temp.txt\", \"ornek.txt\");\n```\nBu kod, 'ornek.txt' dosyasındaki 'eski_kelime' kelimesini 'yeni_kelime' ile değiştirir.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946381"
  },
  {
    "question": "Dosyadan okunan verileri nasıl bir diziye kaydedebilirim?",
    "answer": "Dosyadan okunan verileri bir diziye kaydetmek için bir döngü kullanabiliriz. Örnek:\n\n```c\nchar lines[100][100];\nFILE *dosya;\ndosya = fopen(\"ornek.txt\", \"r\");\nint i = 0;\nwhile (fgets(lines[i], sizeof(lines[i]), dosya)) {\n    i++;\n}\nfclose(dosya);\n```\nBu kod, 'ornek.txt' dosyasındaki her satırı 'lines' dizisine kaydeder ve her bir satır için bir indeks kullanır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:02:26.946415"
  },
  {
    "question": "Bir metin dosyasını nasıl okuyabilirim ve içeriğini ekrana yazdırabilirim?",
    "answer": "Bir metin dosyasını okumak için 'fopen' fonksiyonunu kullanarak dosyayı açarız. Ardından 'fgets' veya 'fread' fonksiyonları ile dosya içeriğini okuyup ekrana yazdırabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n\n    file = fopen(\"example.txt\", \"r\"); // Dosyayı oku modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line); // Her satırı yazdır\n    }\n\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasını okur ve içeriğini ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472262"
  },
  {
    "question": "Bir metin dosyasına nasıl veri yazabilirim?",
    "answer": "Veri yazmak için 'fopen' fonksiyonunu kullanarak dosyayı yazma modunda açarız. Ardından 'fprintf' veya 'fputc' fonksiyonları ile veri yazabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n\n    file = fopen(\"output.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    fprintf(file, \"Merhaba, dünya!\"); // Dosyaya yaz\n    fclose(file); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, 'output.txt' dosyasına \"Merhaba, dünya!\" metnini yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472297"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi nasıl arayıp bulabilirim?",
    "answer": "Dosyayı okuduktan sonra her satırı kontrol ederek belirli bir kelimeyi arayabiliriz. Eğer kelime bulunursa gerekli işlemi yapabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n    const char *keyword = \"arama\";\n    int found = 0;\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        if (strstr(line, keyword) != NULL) {\n            printf(\"Kelime bulundu: %s\", line);\n            found = 1;\n        }\n    }\n\n    if (!found) {\n        printf(\"Kelime bulunamadı.\");\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasını okuyarak \"arama\" kelimesini arar ve bulunduğu satırları yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472321"
  },
  {
    "question": "Bir dosyadan okunan verilerin sayısını nasıl hesaplayabilirim?",
    "answer": "Dosyayı okurken her okunan satırı sayarak toplam satır sayısını elde edebiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n    int lineCount = 0;\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        lineCount++; // Her okunan satır için sayacı artır\n    }\n\n    printf(\"Toplam satır sayısı: %d\\n\", lineCount);\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasındaki toplam satır sayısını hesaplar ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472342"
  },
  {
    "question": "Bir metin dosyasını satır satır okuyup belirli bir koşula göre filtreleyerek yeni bir dosyaya nasıl yazabilirim?",
    "answer": "Bir dosyayı okurken her satırı belirli bir koşula göre kontrol ederiz. Koşulu sağlayan satırları yeni bir dosyaya yazarız. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *inputFile, *outputFile;\n    char line[100];\n\n    inputFile = fopen(\"input.txt\", \"r\");\n    if (inputFile == NULL) {\n        printf(\"Girdi dosyası açılamadı.\");\n        return 1;\n    }\n\n    outputFile = fopen(\"output.txt\", \"w\");\n    if (outputFile == NULL) {\n        printf(\"Çıktı dosyası açılamadı.\");\n        fclose(inputFile);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), inputFile)) {\n        if (strstr(line, \"Filtre\") != NULL) {\n            fputs(line, outputFile); // Koşulu sağlayan satırı yaz\n        }\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n```\nBu kod, 'input.txt' dosyasını okuyarak \"Filtre\" kelimesini içeren satırları 'output.txt' dosyasına yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472381"
  },
  {
    "question": "Bir metin dosyasını belirli bir karakter ile ayırarak nasıl parçalayabilirim?",
    "answer": "Dosyadan okunan satırı 'strtok' fonksiyonu ile belirli bir ayırıcı karaktere göre parçalayabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n    char *token;\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        token = strtok(line, \",\"); // Virgülle ayır\n        while (token != NULL) {\n            printf(\"Parça: %s\\n\", token);\n            token = strtok(NULL, \",\");\n        }\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasındaki her satırı virgülle ayırarak parçalar ve her parçayı ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472452"
  },
  {
    "question": "Bir metin dosyasının içeriğini ters sırayla nasıl yazdırabilirim?",
    "answer": "Dosyadan okuduğumuz satırları bir diziye alarak diziyi ters sırada yazdırabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#define MAX_LINES 100\n\nint main() {\n    FILE *file;\n    char *lines[MAX_LINES];\n    char line[100];\n    int lineCount = 0;\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file) && lineCount < MAX_LINES) {\n        lines[lineCount] = strdup(line); // Satırları diziye kopyala\n        lineCount++;\n    }\n\n    for (int i = lineCount - 1; i >= 0; i--) {\n        printf(\"%s\", lines[i]); // Ters sırada yaz\n        free(lines[i]); // Bellek temizle\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasındaki satırları ters sırada yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472477"
  },
  {
    "question": "Bir metin dosyasındaki boş satırları nasıl tespit edebilirim?",
    "answer": "Dosyayı okurken her satırı kontrol ederek boş olanları tespit edebiliriz. Eğer bir satır sadece yeni satır karakteri içeriyorsa, o satır boştur. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n    int emptyCount = 0;\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        if (strcmp(line, \"\\n\") == 0) {\n            emptyCount++; // Boş satır sayısını artır\n        }\n    }\n\n    printf(\"Boş satır sayısı: %d\\n\", emptyCount);\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasındaki boş satırların sayısını hesaplar ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472498"
  },
  {
    "question": "Bir metin dosyasını okuduktan sonra her satırın uzunluğunu nasıl yazdırabilirim?",
    "answer": "Dosyayı okurken her satırı kontrol ederek satır uzunluğunu 'strlen' fonksiyonu ile hesaplayabiliriz. Örnek kod:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[100];\n\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"Satır uzunluğu: %lu\\n\", strlen(line)); // Uzunluğu yaz\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, 'example.txt' dosyasındaki her satırın uzunluğunu ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:03:10.472544"
  },
  {
    "question": "C ile bir metin dosyasını satır satır okuyup ekrana yazmayı nasıl yapabilirim?",
    "answer": "C ile bir metin dosyasını satır satır okumak için 'fgets' fonksiyonunu kullanabilirsiniz. Öncelikle dosyayı 'fopen' ile açmalı ve ardından 'fgets' ile her satırı okumalı, son olarak dosyayı kapatmalısınız. Aşağıdaki örneğe bakın:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256]; // Her satır için bir buffer\n\n    dosya = fopen(\"metin.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        printf(\"%s\", satir); // Okunan satırı ekrana yaz\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232793"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimenin kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Metin dosyasında belirli bir kelimenin kaç kez geçtiğini bulmak için dosyayı satır satır okuyarak her satırı kontrol edebilir ve kelimenin sayısını artırabilirsiniz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256];\n    const char *kelime = \"örnek\";\n    int sayac = 0;\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        char *ptr = satir;\n        while ((ptr = strstr(ptr, kelime))) {\n            sayac++; // Kelime bulundu, sayacı artır\n            ptr++; // Aramaya devam et\n        }\n    }\n\n    printf(\"'%s' kelimesi %d kez bulundu.\\n\", kelime, sayac);\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232836"
  },
  {
    "question": "C ile bir metin dosyasını okuyup yeni bir dosyaya ters sırada yazmak için ne yapmalıyım?",
    "answer": "Bir dosyayı okuyup içeriğini ters sırada yazmak için önce dosyanın tüm içeriğini belleğe almanız ve ardından ters sırada yazmanız gerekecek. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya, *yeniDosya;\n    char **satirlar;\n    int satirSayisi = 0;\n    char satir[256];\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    // Dosyadaki satırları say\n    while (fgets(satir, sizeof(satir), dosya)) {\n        satirSayisi++;\n    }\n    rewind(dosya); // Dosya konumunu başa al\n\n    // Bellekten satırları tutmak için yer ayır\n    satirlar = malloc(satirSayisi * sizeof(char *));\n    for (int i = 0; i < satirSayisi; i++) {\n        satirlar[i] = malloc(256 * sizeof(char));\n        fgets(satirlar[i], 256, dosya); // Satırları oku\n    }\n\n    fclose(dosya); // İlk dosyayı kapat\n    yeniDosya = fopen(\"ters_metin.txt\", \"w\"); // Yeni dosyayı yazma modunda aç\n\n    // Satırları ters sırada yaz\n    for (int i = satirSayisi - 1; i >= 0; i--) {\n        fprintf(yeniDosya, \"%s\", satirlar[i]);\n    }\n\n    fclose(yeniDosya); // Yeni dosyayı kapat\n\n    // Belleği temizle\n    for (int i = 0; i < satirSayisi; i++) {\n        free(satirlar[i]);\n    }\n    free(satirlar);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232873"
  },
  {
    "question": "Bir metin dosyasını okuyup, her satırın uzunluğunu hesaplamak için bir program yazın.",
    "answer": "Her satırın uzunluğunu hesaplamak için dosyayı satır satır okuyarak, 'strlen' fonksiyonunu kullanabilirsiniz. Örnek kod aşağıda verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256];\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        int uzunluk = strlen(satir);\n        printf(\"Bu satırın uzunluğu: %d\\n\", uzunluk);\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232901"
  },
  {
    "question": "Bir metin dosyasındaki her satırın başına satır numarası ekleyerek yeni bir dosyaya yazmak için nasıl bir yol izlemeliyim?",
    "answer": "Her satırın başına satır numarası eklemek için dosyayı okuyarak her satırı numaralandırabilir ve yeni bir dosyaya yazabilirsiniz. Kod örneği aşağıdadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya, *yeniDosya;\n    char satir[256];\n    int satirNo = 1;\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    yeniDosya = fopen(\"numarali_metin.txt\", \"w\"); // Yeni dosyayı yazma modunda aç\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        fprintf(yeniDosya, \"%d: %s\", satirNo++, satir); // Satır numarasını yaz\n    }\n\n    fclose(dosya);\n    fclose(yeniDosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232935"
  },
  {
    "question": "Metin dosyasındaki boş satırları nasıl tespit edip silerim?",
    "answer": "Boş satırları tespit etmek için dosyayı okuyarak her satırın içeriğini kontrol edebilir ve sadece dolu satırları yeni bir dosyaya yazabilirsiniz. Aşağıda örnek bir program verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya, *yeniDosya;\n    char satir[256];\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    yeniDosya = fopen(\"temiz_metin.txt\", \"w\"); // Yeni dosyayı yazma modunda aç\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        if (strcmp(satir, \"\\n\") != 0) {\n            fprintf(yeniDosya, \"%s\", satir); // Boş satır değilse yaz\n        }\n    }\n\n    fclose(dosya);\n    fclose(yeniDosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.232974"
  },
  {
    "question": "Bir metin dosyasındaki tüm harfleri büyük harfe çevirmek için bir program nasıl yazılır?",
    "answer": "Bir dosyadaki tüm harfleri büyük harfe çevirmek için dosyayı okuyarak her karakterin 'toupper' fonksiyonu ile kontrol edilip büyük harfe çevrilebilir. İşte bir örnek:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *dosya, *yeniDosya;\n    char satir[256];\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    yeniDosya = fopen(\"buyuk_harfli_metin.txt\", \"w\");\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        for (int i = 0; satir[i]; i++) {\n            fputc(toupper(satir[i]), yeniDosya); // Her karakteri büyük harfe çevirip yaz\n        }\n    }\n\n    fclose(dosya);\n    fclose(yeniDosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.233006"
  },
  {
    "question": "Bir metin dosyasının içeriğini tersine çevirip mevcut dosyayı güncellemek için nasıl bir yöntem izlenir?",
    "answer": "Bir dosyanın içeriğini tersine çevirmek ve mevcut dosyayı güncellemek için önce içeriği okuyup tersine çevirdikten sonra aynı dosyaya yazmanız gerekecek. Aşağıda bu işlemi gerçekleştiren bir örnek kod verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dosya;\n    long dosyaBoyutu;\n    char *icerik;\n\n    dosya = fopen(\"metin.txt\", \"r+\"); // Okuma ve yazma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fseek(dosya, 0, SEEK_END); // Dosyanın sonuna git\n    dosyaBoyutu = ftell(dosya); // Dosya boyutunu al\n    rewind(dosya); // Dosyayı başa al\n\n    icerik = (char *)malloc(dosyaBoyutu + 1);\n    fread(icerik, 1, dosyaBoyutu, dosya); // Dosya içeriğini oku\n    icerik[dosyaBoyutu] = '\\0'; // Sonlandırıcı ekle\n\n    // İçeriği ters çevir\n    for (long i = 0; i < dosyaBoyutu / 2; i++) {\n        char temp = icerik[i];\n        icerik[i] = icerik[dosyaBoyutu - i - 1];\n        icerik[dosyaBoyutu - i - 1] = temp;\n    }\n\n    rewind(dosya); // Dosyayı başa al\n    fwrite(icerik, 1, dosyaBoyutu, dosya); // Ters çevrilmiş içeriği yaz\n    fflush(dosya); // Dosyayı güncelle\n\n    free(icerik);\n    fclose(dosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.233037"
  },
  {
    "question": "Metin dosyasındaki belirli bir kelimeyi başka bir kelime ile değiştiren bir program yazın.",
    "answer": "Belirli bir kelimeyi değiştirmek için dosyayı okuyarak her satırı kontrol edebilir ve 'strstr' ile kelimeyi bulup değiştirebilirsiniz. Aşağıda örnek bir program verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya, *yeniDosya;\n    char satir[256];\n    const char *eskiKelime = \"eski\";\n    const char *yeniKelime = \"yeni\";\n\n    dosya = fopen(\"metin.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    yeniDosya = fopen(\"degistirilmis_metin.txt\", \"w\");\n\n    while (fgets(satir, sizeof(satir), dosya)) {\n        char *ptr = strstr(satir, eskiKelime);\n        if (ptr) {\n            *ptr = '\\0'; // Bulunan kelimeyi sonlandır\n            fprintf(yeniDosya, \"%s%s%s\", satir, yeniKelime, ptr + strlen(eskiKelime));\n        } else {\n            fprintf(yeniDosya, \"%s\", satir); // Eğer kelime yoksa satırı olduğu gibi yaz\n        }\n    }\n\n    fclose(dosya);\n    fclose(yeniDosya);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:04:09.233064"
  },
  {
    "question": "Bir metin dosyasındaki satır sayısını nasıl sayabilirim?",
    "answer": "Bir metin dosyasındaki satır sayısını saymak için dosyayı satır satır okuyarak bir sayaç tutabiliriz. Örnek bir C kodu aşağıdadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    char ch;\n    int lineCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch == '\\n') {\n            lineCount++;\n        }\n    }\n    fclose(file);\n    printf(\"Satır sayısı: %d\\n\", lineCount);\n    return 0;\n}\n```\nBu kod, dosyayı açar, karakterleri okur ve her yeni satır karakteri ile sayaç artırılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843733"
  },
  {
    "question": "Bir metin dosyasındaki kelimeleri nasıl sayabilirim?",
    "answer": "Kelime sayısını bulmak için dosyayı satır satır okuyup her satırı boşluk karakterlerine göre bölebiliriz. İşte bir C örneği:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    int wordCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \t\\n\");\n        while (token != NULL) {\n            wordCount++;\n            token = strtok(NULL, \" \t\\n\");\n        }\n    }\n    fclose(file);\n    printf(\"Kelime sayısı: %d\\n\", wordCount);\n    return 0;\n}\n```\nBu kod, her satırı okur ve kelimeleri boşluklara göre ayırarak toplam kelime sayısını hesaplar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843768"
  },
  {
    "question": "Bir metin dosyasının içeriğini tersine çevirmek için ne yapmalıyım?",
    "answer": "Bir metin dosyasının içeriğini tersine çevirmek için önce dosyayı okuyup içeriği bir diziye alabiliriz. Sonra diziyi ters çevirebiliriz. Aşağıdaki örnek bunu yapar:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char content[1000];\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    fread(content, sizeof(char), 1000, file);\n    fclose(file);\n\n    int len = strlen(content);\n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", content[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu kod, dosyanın içeriğini okuyup ters sırayla ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843793"
  },
  {
    "question": "Bir metin dosyasındaki tüm büyük harfleri küçük harfe dönüştürmek için hangi adımları izlemeliyim?",
    "answer": "Büyük harfleri küçük harfe dönüştürmek için dosyayı okuyup her karakteri kontrol edebiliriz. İşte bunu yapan bir C kodu:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file;\n    char ch;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(tolower(ch));\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosyadaki her karakteri küçük harfe çevirir ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843834"
  },
  {
    "question": "Bir metin dosyasını kopyalamak için nasıl bir program yazabilirim?",
    "answer": "Bir metin dosyasını başka bir dosyaya kopyalamak için iki dosya açıp, bir dosyayı okurken diğerine yazabiliriz. Aşağıdaki C kodu bunu gösterir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *sourceFile, *destFile;\n    char ch;\n\n    sourceFile = fopen(\"kaynak.txt\", \"r\");\n    if (sourceFile == NULL) {\n        printf(\"Kaynak dosya açılamadı.\");\n        return 1;\n    }\n\n    destFile = fopen(\"hedef.txt\", \"w\");\n    if (destFile == NULL) {\n        printf(\"Hedef dosya açılamadı.\");\n        fclose(sourceFile);\n        return 1;\n    }\n\n    while ((ch = fgetc(sourceFile)) != EOF) {\n        fputc(ch, destFile);\n    }\n    fclose(sourceFile);\n    fclose(destFile);\n    printf(\"Dosya başarıyla kopyalandı.\");\n    return 0;\n}\n```\nBu kod, kaynak dosyadan okur ve hedef dosyaya yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843857"
  },
  {
    "question": "Bir metin dosyasındaki tüm benzersiz kelimeleri nasıl bulabilirim?",
    "answer": "Benzersiz kelimeleri bulmak için dosyayı okuyup kelimeleri bir diziye alabilir, ardından bu dizideki tekrar eden kelimeleri filtreleyebiliriz. Aşağıdaki C örneği bunu yapar:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_WORDS 1000\n#define MAX_LENGTH 50\n\nint main() {\n    FILE *file;\n    char line[256];\n    char *words[MAX_WORDS];\n    int wordCount = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \\t\\n\");\n        while (token != NULL) {\n            int unique = 1;\n            for (int i = 0; i < wordCount; i++) {\n                if (strcmp(words[i], token) == 0) {\n                    unique = 0;\n                    break;\n                }\n            }\n            if (unique) {\n                words[wordCount] = malloc(strlen(token) + 1);\n                strcpy(words[wordCount], token);\n                wordCount++;\n            }\n            token = strtok(NULL, \" \\t\\n\");\n        }\n    }\n    fclose(file);\n\n    printf(\"Benzersiz kelimeler:\\n\");\n    for (int i = 0; i < wordCount; i++) {\n        printf(\"%s\\n\", words[i]);\n        free(words[i]);\n    }\n    return 0;\n}\n```\nBu kod, dosyadaki benzersiz kelimeleri bulur ve yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843878"
  },
  {
    "question": "Bir metin dosyasındaki en uzun kelimeyi nasıl bulabilirim?",
    "answer": "En uzun kelimeyi bulmak için dosyayı okuyup her kelimenin uzunluğunu kontrol edebiliriz. Aşağıdaki C örneği bu işlemi gerçekleştirir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    char longestWord[50];\n    int maxLength = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \\t\\n\");\n        while (token != NULL) {\n            int length = strlen(token);\n            if (length > maxLength) {\n                maxLength = length;\n                strcpy(longestWord, token);\n            }\n            token = strtok(NULL, \" \\t\\n\");\n        }\n    }\n    fclose(file);\n\n    printf(\"En uzun kelime: %s (Uzunluk: %d)\\n\", longestWord, maxLength);\n    return 0;\n}\n```\nBu kod, dosyadaki en uzun kelimeyi bulur ve yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843898"
  },
  {
    "question": "Bir metin dosyasındaki tüm sayıları toplamını nasıl bulabilirim?",
    "answer": "Bir metin dosyasındaki sayıları toplamak için dosyayı okuyup sayıları ayıklayarak bir toplam değişkenine ekleyebiliriz. İşte bunu yapan bir C kodu:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char line[256];\n    int totalSum = 0;\n\n    file = fopen(\"metin.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), file)) {\n        char *token = strtok(line, \" \t\\n\");\n        while (token != NULL) {\n            if (isdigit(token[0])) {\n                totalSum += atoi(token);\n            }\n            token = strtok(NULL, \" \t\\n\");\n        }\n    }\n    fclose(file);\n\n    printf(\"Toplam: %d\\n\", totalSum);\n    return 0;\n}\n```\nBu kod, dosyadaki sayıları toplar ve sonuç olarak toplamı ekrana yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:05:42.843926"
  },
  {
    "question": "Bir metin dosyasındaki kelimelerin frekansını hesaplayan bir C programı nasıl yazılır?",
    "answer": "Aşağıda verilen program, bir metin dosyasındaki kelimelerin frekansını hesaplar. İlk olarak dosya okunur, kelimeler ayrıştırılır ve her kelimenin sayısı kaydedilir. Kullanıcıdan bir dosya adı alarak işlemi başlatır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_WORDS 1000\n#define MAX_LENGTH 100\n\ntypedef struct {\n    char word[MAX_LENGTH];\n    int count;\n} WordCount;\n\nint main() {\n    FILE *file;\n    char filename[100];\n    char word[MAX_LENGTH];\n    WordCount wordCounts[MAX_WORDS];\n    int totalWords = 0;\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%s\", word) != EOF) {\n        // Kelimenin büyük/küçük harf duyarlılığını kaldırmak için\n        for (int i = 0; word[i]; i++) {\n            word[i] = tolower(word[i]);\n        }\n\n        int found = 0;\n        for (int i = 0; i < totalWords; i++) {\n            if (strcmp(wordCounts[i].word, word) == 0) {\n                wordCounts[i].count++;\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found && totalWords < MAX_WORDS) {\n            strcpy(wordCounts[totalWords].word, word);\n            wordCounts[totalWords].count = 1;\n            totalWords++;\n        }\n    }\n\n    fclose(file);\n\n    printf(\"Kelime Frekansları:\\n\");\n    for (int i = 0; i < totalWords; i++) {\n        printf(\"%s: %d\\n\", wordCounts[i].word, wordCounts[i].count);\n    }\n\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786664"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları ters sırada yazdıran bir C programı nasıl yazılır?",
    "answer": "Aşağıda, kullanıcıdan bir dosyanın adını alarak dosyadaki tüm satırları ters sırada yazdıran bir program örneği bulunmaktadır. Bu program, satırları bir diziye okuyarak daha sonra ters çevirmektedir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 100\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file;\n    char filename[100];\n    char lines[MAX_LINES][MAX_LENGTH];\n    int lineCount = 0;\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(lines[lineCount], MAX_LENGTH, file) && lineCount < MAX_LINES) {\n        lineCount++;\n    }\n\n    fclose(file);\n\n    printf(\"Satırlar ters sırada:\\n\");\n    for (int i = lineCount - 1; i >= 0; i--) {\n        printf(\"%s\", lines[i]);\n    }\n\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786741"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi başka bir kelime ile değiştiren bir C programı nasıl yazılır?",
    "answer": "Verilen program, bir metin dosyasındaki belirli bir kelimeyi başka bir kelime ile değiştirmektedir. Kullanıcıdan dosya adı ve kelimeler alınarak işlem gerçekleştirilir.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file, *tempFile;\n    char filename[100], tempFilename[] = \"temp.txt\";\n    char wordToReplace[MAX_LENGTH], replacementWord[MAX_LENGTH];\n    char buffer[MAX_LENGTH];\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n    printf(\"Değiştirilecek kelimeyi girin: \");\n    scanf(\"%s\", wordToReplace);\n    printf(\"Yeni kelimeyi girin: \");\n    scanf(\"%s\", replacementWord);\n\n    file = fopen(filename, \"r\");\n    tempFile = fopen(tempFilename, \"w\");\n    if (file == NULL || tempFile == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(buffer, MAX_LENGTH, file) != NULL) {\n        char *pos;\n        while ((pos = strstr(buffer, wordToReplace)) != NULL) {\n            // Bulunan kelimeyi yazdırmadan önce yerine yeni kelimeyi yerleştir\n            *pos = '\\0';  // Sonlandırıcı ekle\n            fprintf(tempFile, \"%s%s\", buffer, replacementWord);\n            buffer[pos - buffer] = '\\0';\n            strcpy(buffer, pos + strlen(wordToReplace));\n        }\n        fprintf(tempFile, \"%s\", buffer);\n    }\n\n    fclose(file);\n    fclose(tempFile);\n\n    // Orijinal dosyayı sil ve geçici dosyayı yeniden adlandır\n    remove(filename);\n    rename(tempFilename, filename);\n\n    printf(\"Kelime başarıyla değiştirildi.\\n\");\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786788"
  },
  {
    "question": "Bir metin dosyasındaki satırları belirli bir kelimeye göre filtreleyen bir C programı nasıl yazılır?",
    "answer": "Aşağıda verilen program, kullanıcıdan bir kelime alarak metin dosyasındaki satırları bu kelimeye göre filtreler. Eğer satırda bu kelime bulunuyorsa satır yazdırılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file;\n    char filename[100], filterWord[MAX_LENGTH];\n    char buffer[MAX_LENGTH];\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n    printf(\"Filtrelemek istediğiniz kelimeyi girin: \");\n    scanf(\"%s\", filterWord);\n\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"Filtrelenen satırlar:\\n\");\n    while (fgets(buffer, MAX_LENGTH, file) != NULL) {\n        if (strstr(buffer, filterWord) != NULL) {\n            printf(\"%s\", buffer);\n        }\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786817"
  },
  {
    "question": "Bir metin dosyasında belirli bir satırı silen bir C programı nasıl yazılır?",
    "answer": "Bu program, kullanıcıdan bir metin dosyası adı ve silinmek istenen satır numarasını alır. Belirtilen satırı silmek için dosyayı okur ve geçici bir dosyaya yazar. Sonra orijinal dosya silinir ve geçici dosya yeniden adlandırılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file, *tempFile;\n    char filename[100], tempFilename[] = \"temp.txt\";\n    char buffer[MAX_LENGTH];\n    int lineToDelete, lineCount = 0;\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n    printf(\"Silmek istediğiniz satır numarasını girin: \");\n    scanf(\"%d\", &lineToDelete);\n\n    file = fopen(filename, \"r\");\n    tempFile = fopen(tempFilename, \"w\");\n    if (file == NULL || tempFile == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(buffer, MAX_LENGTH, file) != NULL) {\n        lineCount++;\n        if (lineCount != lineToDelete) {\n            fprintf(tempFile, \"%s\", buffer);\n        }\n    }\n\n    fclose(file);\n    fclose(tempFile);\n\n    remove(filename);\n    rename(tempFilename, filename);\n\n    printf(\"Satır başarıyla silindi.\\n\");\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786842"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları büyük harfle yazdıran bir C programı nasıl yazılır?",
    "answer": "Aşağıda verilen program, bir metin dosyasındaki tüm satırları okur ve her satırı büyük harflerle yazdırır. Bu işlem sırasında 'toupper' fonksiyonu kullanılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file;\n    char filename[100];\n    char buffer[MAX_LENGTH];\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    printf(\"Büyük harfle yazdırılan satırlar:\\n\");\n    while (fgets(buffer, MAX_LENGTH, file) != NULL) {\n        for (int i = 0; buffer[i]; i++) {\n            putchar(toupper(buffer[i]));\n        }\n    }\n\n    fclose(file);\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786870"
  },
  {
    "question": "Bir metin dosyasındaki boş satırları silen bir C programı nasıl yazılır?",
    "answer": "Bu program, bir metin dosyasındaki tüm boş satırları siler ve sonuçları yeni bir dosyaya kaydeder. Boş satır kontrolü 'strlen' fonksiyonu ile yapılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file, *tempFile;\n    char filename[100], tempFilename[] = \"temp.txt\";\n    char buffer[MAX_LENGTH];\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    tempFile = fopen(tempFilename, \"w\");\n    if (file == NULL || tempFile == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(buffer, MAX_LENGTH, file) != NULL) {\n        if (strlen(buffer) > 1) {\n            fprintf(tempFile, \"%s\", buffer);\n        }\n    }\n\n    fclose(file);\n    fclose(tempFile);\n\n    remove(filename);\n    rename(tempFilename, filename);\n\n    printf(\"Boş satırlar başarıyla silindi.\\n\");\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786897"
  },
  {
    "question": "Bir metin dosyasından rastgele bir satırı seçen ve yazdıran bir C programı nasıl yazılır?",
    "answer": "Aşağıda verilen program, bir metin dosyasındaki satırları okur ve rastgele bir satırı seçip yazdırır. Rastgele sayı üretimi için 'rand' fonksiyonu kullanılır.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define MAX_LINES 100\n#define MAX_LENGTH 256\n\nint main() {\n    FILE *file;\n    char filename[100];\n    char lines[MAX_LINES][MAX_LENGTH];\n    int lineCount = 0;\n\n    printf(\"Dosya adını girin: \");\n    scanf(\"%s\", filename);\n\n    file = fopen(filename, \"r\");\n    if (file == NULL) {\n        fprintf(stderr, \"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(lines[lineCount], MAX_LENGTH, file) && lineCount < MAX_LINES) {\n        lineCount++;\n    }\n\n    fclose(file);\n\n    srand(time(NULL)); // Rastgele sayı üretimi için tohum\n    int randomIndex = rand() % lineCount;\n\n    printf(\"Rastgele seçilen satır: %s\", lines[randomIndex]);\n\n    return 0;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:06:31.786925"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları ters sırada yazdırmamı sağlayacak bir fonksiyon nasıl optimize edebilirim?",
    "answer": "Başlangıçta, dosyayı satır satır okuyup bir diziye kaydediyoruz. Ardından diziyi ters çevirip yazdırıyoruz. Ancak bu işlemi daha az bellek kullanarak yapmak için dosyayı okuyup hemen yazdırabiliriz. Örnek: \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reverse_print_lines(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return;\n    fseek(file, 0, SEEK_END);\n    long pos = ftell(file);\n    while (pos) {\n        fseek(file, --pos, SEEK_SET);\n        if (fgetc(file) == '\\n') {\n            char buffer[1024];\n            fgets(buffer, sizeof(buffer), file);\n            printf(\"%s\", buffer);\n        }\n    }\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422068"
  },
  {
    "question": "Bir metin dosyasındaki kelime sayısını etkili bir şekilde nasıl hesaplayabilirim?",
    "answer": "Mevcut yöntem, her kelimeyi kontrol etmek için döngü kullanmaktır. Bunun yerine, dosyayı bir seferde okuyup boşlukları sayarak kelime sayısını hesaplayabiliriz. Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint count_words(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return -1;\n    int count = 0;\n    char ch;\n    int in_word = 0;\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch == ' ' || ch == '\\n' || ch == '\\t') {\n            if (in_word) {\n                count++;\n                in_word = 0;\n            }\n        } else {\n            in_word = 1;\n        }\n    }\n    if (in_word) count++;\n    fclose(file);\n    return count;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422109"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir kelimeyi bulmak için daha verimli bir algoritma nasıl yazabilirim?",
    "answer": "Doğrudan dosyayı okurken her karakteri kontrol etmek yerine, dosyayı satır satır okuyup `strstr` fonksiyonunu kullanarak arama yapabilirsiniz. Bu, daha az bellek kullanır. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid find_word_in_file(const char *filename, const char *word) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return;\n    char line[256];\n    int line_number = 0;\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, word)) {\n            printf(\"Kelime %d. satırda bulundu: %s\", line_number, line);\n        }\n    }\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422140"
  },
  {
    "question": "Büyük metin dosyalarındaki verimliliği artırmak için hangi yöntemleri kullanabilirim?",
    "answer": "Bellek kullanımını en aza indirmek için dosyayı satır satır okumak yerine, bloklar halinde okumayı tercih edebilirsiniz. Bu, özellikle büyük dosyalar için performansı artırır. Örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid process_large_file(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) return;\n    char buffer[4096];\n    while (fread(buffer, 1, sizeof(buffer), file) > 0) {\n        // Buffer üzerinde işlem yap\n    }\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422166"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları benzersiz hale getirmek için etkili bir yöntem nedir?",
    "answer": "Bir set veri yapısı kullanarak tekrar eden satırları kontrol edebilirsiniz. Bunun için dinamik bir dizi veya hash tablosu kullanabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 1000\n\nint unique_lines(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return -1;\n    char *lines[MAX_LINES];\n    int count = 0;\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), file)) {\n        int is_unique = 1;\n        for (int i = 0; i < count; i++) {\n            if (strcmp(lines[i], buffer) == 0) {\n                is_unique = 0;\n                break;\n            }\n        }\n        if (is_unique) {\n            lines[count] = strdup(buffer);\n            count++;\n        }\n    }\n    fclose(file);\n    return count;\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422193"
  },
  {
    "question": "Bir metin dosyasındaki tüm büyük harfleri küçük harfe dönüştüren bir fonksiyon nasıl yazılır?",
    "answer": "Dosya okuma ve yazma işlemlerini ayrı ayrı yaparak, her bir karakteri kontrol edebilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid convert_to_lowercase(const char *input_filename, const char *output_filename) {\n    FILE *input_file = fopen(input_filename, \"r\");\n    FILE *output_file = fopen(output_filename, \"w\");\n    if (!input_file || !output_file) return;\n    char ch;\n    while ((ch = fgetc(input_file)) != EOF) {\n        fputc(tolower(ch), output_file);\n    }\n    fclose(input_file);\n    fclose(output_file);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422223"
  },
  {
    "question": "Bir metin dosyasındaki belirli bir satırı silmek için nasıl bir yöntem izlemeliyim?",
    "answer": "Dosyayı satır satır okuyarak silinecek satırı atlayabilir ve kalan satırları yeni bir dosyaya yazabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid delete_line(const char *filename, int line_to_delete) {\n    FILE *file = fopen(filename, \"r\");\n    FILE *temp_file = fopen(\"temp.txt\", \"w\");\n    if (!file || !temp_file) return;\n    char buffer[256];\n    int line_number = 0;\n    while (fgets(buffer, sizeof(buffer), file)) {\n        line_number++;\n        if (line_number != line_to_delete) {\n            fputs(buffer, temp_file);\n        }\n    }\n    fclose(file);\n    fclose(temp_file);\n    remove(filename);\n    rename(\"temp.txt\", filename);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422250"
  },
  {
    "question": "Bir metin dosyasındaki tüm boşlukları kaldıran bir fonksiyon nasıl yazılır?",
    "answer": "Her karakteri kontrol ederek boşlukları atlayabilir ve yeni bir dosyaya yazabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n\nvoid remove_spaces(const char *input_filename, const char *output_filename) {\n    FILE *input_file = fopen(input_filename, \"r\");\n    FILE *output_file = fopen(output_filename, \"w\");\n    if (!input_file || !output_file) return;\n    char ch;\n    while ((ch = fgetc(input_file)) != EOF) {\n        if (ch != ' ') {\n            fputc(ch, output_file);\n        }\n    }\n    fclose(input_file);\n    fclose(output_file);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422273"
  },
  {
    "question": "Bir metin dosyasındaki en uzun satırı nasıl bulabilirim?",
    "answer": "Dosyayı satır satır okuyarak her satırın uzunluğunu kontrol edebilir ve en uzun olanı saklayabilirsiniz. Örnek:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid find_longest_line(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return;\n    char longest_line[256] = {0};\n    char buffer[256];\n    while (fgets(buffer, sizeof(buffer), file)) {\n        if (strlen(buffer) > strlen(longest_line)) {\n            strcpy(longest_line, buffer);\n        }\n    }\n    fclose(file);\n    printf(\"En uzun satır: %s\", longest_line);\n}\n```",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:08.422293"
  },
  {
    "question": "Bir metin dosyasından belirli kelimeleri sayan bir C programını optimize etmek için hangi yöntemleri kullanabilirim?",
    "answer": "Öncelikle, dosya okuma işlemlerini daha verimli hale getirmek için buffered I/O kullanabilirsiniz. Örneğin, 'fgets' yerine 'fread' kullanarak dosyayı bir seferde okuyup, bellekte aramak daha hızlı olacaktır. Ayrıca, kelimeleri sayma işlemi için bir kelime sayacı dizisi kullanarak daha az tekrar eden işlemler yapmalısınız. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char *buffer;\n    size_t size;\n    size_t wordCount = 0;\n    FILE *file = fopen(\"metin.txt\", \"rb\");\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(file, 0, SEEK_END);\n    size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    buffer = malloc(size + 1);\n    fread(buffer, 1, size, file);\n    buffer[size] = '\\0';\n\n    char *token = strtok(buffer, \" \\n\");\n    while (token) {\n        wordCount++;\n        token = strtok(NULL, \" \\n\");\n    }\n\n    free(buffer);\n    fclose(file);\n\n    printf(\"Kelime Sayısı: %zu\\n\", wordCount);\n    return 0;\n}\n```\nBu kod, dosyayı bir kerede okur ve ardından kelimeleri sayar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.091890"
  },
  {
    "question": "Metin dosyasındaki satırları ters çevirmek için en etkili yöntem nedir?",
    "answer": "Bir dosyadaki satırları ters çevirmek için, ilk olarak dosyanın tüm içeriğini belleğe almanız gerekebilir. Ancak bellek verimliliği açısından, satırları okurken hemen ters çevirmek daha iyidir. Bir dizi veya bağlı liste kullanarak satırları depolayıp, daha sonra dizinin veya listenin sonundan itibaren yazabilirsiniz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 256\n\nint main() {\n    char *lines[100];\n    int count = 0;\n    char buffer[MAX_LINE_LENGTH];\n    FILE *file = fopen(\"metin.txt\", \"r\");\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, MAX_LINE_LENGTH, file)) {\n        lines[count] = strdup(buffer);\n        count++;\n    }\n    fclose(file);\n\n    for (int i = count - 1; i >= 0; i--) {\n        printf(\"%s\", lines[i]);\n        free(lines[i]);\n    }\n\n    return 0;\n}\n```\nBu kod, bellek kullanımını optimize ederken satırları okur ve ters sırayla yazar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.091936"
  },
  {
    "question": "Dosyadan okunan metinlerdeki özel karakterleri temizlemek için ne yapmalıyım?",
    "answer": "Özel karakterleri temizlemek için metni okuduktan sonra bir filtreleme işlemi yapmalısınız. Bu işlem, her karakteri okurken, izin verilen karakterleri kontrol etmek ve yalnızca bu karakterleri yeni bir buffer'a yazmak şeklinde gerçekleştirilir. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    char buffer[1024];\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        for (int i = 0; buffer[i]; i++) {\n            if (isalnum(buffer[i]) || isspace(buffer[i])) {\n                putchar(buffer[i]);\n            }\n        }\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu örnekte, yalnızca alfanümerik ve boşluk karakterleri yazdırılır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.091962"
  },
  {
    "question": "Bir metin dosyasındaki tüm büyük harfleri küçük harfe dönüştürmek istiyorum, en etkili yöntem nedir?",
    "answer": "Bunu yapmak için dosyayı okurken her karakteri kontrol edip, büyük harfleri küçük harfe dönüştürmek için 'tolower' fonksiyonunu kullanabilirsiniz. Aşağıda bunun için bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    char buffer[1024];\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        for (int i = 0; buffer[i]; i++) {\n            putchar(tolower(buffer[i]));\n        }\n    }\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosyayı satır satır okur ve her karakterin küçük harf karşılığını yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.091995"
  },
  {
    "question": "Metin dosyasında en sık geçen kelimeyi bulmak için hangi veri yapısını kullanmalıyım?",
    "answer": "En sık geçen kelimeyi bulmak için bir hash tablosu (veya bir kelime sayıcı) kullanmak en etkili çözümdür. Kelimeleri ve onların tekrar sayılarını depolamak için bir hash tablosu kurarak, dosyayı okurken kelimeleri sayabilir ve en son olarak en yüksek sayıyı bulabilirsiniz. Aşağıda basit bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define HASH_TABLE_SIZE 1000\n\ntypedef struct Node {\n    char *word;\n    int count;\n    struct Node *next;\n} Node;\n\nNode *hashTable[HASH_TABLE_SIZE];\n\nunsigned int hash(char *word) {\n    unsigned int hashval = 0;\n    while (*word) {\n        hashval = (hashval << 5) + *word++;\n    }\n    return hashval % HASH_TABLE_SIZE;\n}\n\nvoid insert(char *word) {\n    unsigned int index = hash(word);\n    Node *node = hashTable[index];\n    while (node) {\n        if (strcmp(node->word, word) == 0) {\n            node->count++;\n            return;\n        }\n        node = node->next;\n    }\n    node = malloc(sizeof(Node));\n    node->word = strdup(word);\n    node->count = 1;\n    node->next = hashTable[index];\n    hashTable[index] = node;\n}\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    char buffer[256];\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fscanf(file, \"%255s\", buffer) != EOF) {\n        insert(buffer);\n    }\n    fclose(file);\n\n    // En sık geçen kelimeyi bulma kısmı burada...\n\n    return 0;\n}\n```\nBu örnekte, kelimeleri depolamak için bir hash tablosu kullanılıyor.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.092026"
  },
  {
    "question": "Bir metin dosyasındaki tüm satırları okuduktan sonra, bellekte depolamak yerine doğrudan dosyaya yazmak için nasıl bir yapı kullanabilirim?",
    "answer": "Bellekte depolamadan doğrudan yazmak için dosya okuma ve yazma işlemlerini birleştirebilirsiniz. Bu yöntemle, her satırı okuduktan sonra hemen başka bir dosyaya yazabilirsiniz. Aşağıda bu yöntemi gösteren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *inputFile = fopen(\"metin.txt\", \"r\");\n    FILE *outputFile = fopen(\"cikti.txt\", \"w\");\n    char buffer[256];\n\n    if (!inputFile || !outputFile) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, sizeof(buffer), inputFile)) {\n        // Burada istediğiniz değişiklikleri yapabilirsiniz.\n        fputs(buffer, outputFile);\n    }\n\n    fclose(inputFile);\n    fclose(outputFile);\n    return 0;\n}\n```\nBu örnekte, her satır okunduktan sonra hemen çıktı dosyasına yazılmaktadır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.092074"
  },
  {
    "question": "Büyük bir metin dosyasını okurken bellek kullanımını minimumda tutmak için ne tür bir yaklaşım izlemeliyim?",
    "answer": "Büyük dosyaları işlerken belleği optimize etmek için, dosyayı satır satır veya blok blok okumak en etkili yöntemdir. Örneğin, bir buffer kullanarak belirli bir boyutta verileri okuyabilir ve işleyebilirsiniz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define BUFFER_SIZE 512\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    char buffer[BUFFER_SIZE];\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, BUFFER_SIZE, file)) {\n        // Her satırı burada işleyin.\n        printf(\"Okunan Satır: %s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu yaklaşım, belleği minimumda tutarken veri okuma işlemlerinin daha hızlı olmasını sağlar.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.092105"
  },
  {
    "question": "Bir metin dosyasındaki her satırın başına satır numarası eklemek için ne yapmalıyım?",
    "answer": "Her satırı okurken, okunacak satır sayısını takip ederek başına satır numarasını ekleyebilirsiniz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"metin.txt\", \"r\");\n    char buffer[256];\n    int lineNum = 1;\n\n    if (!file) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"%d: %s\", lineNum++, buffer);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, her satırın başına bir satır numarası ekleyerek yazdırır.",
    "category": "file_operations",
    "topic": "text_processing",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Metin dosyası işleme",
    "timestamp": "2025-06-01T17:07:47.092134"
  },
  {
    "question": "Bir dosyayı okuma işlemi için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"veri.txt\", \"r\"); // dosya okuma kodu",
    "answer": "fopen() fonksiyonu ile dosyayı açtık. Şimdi dosyanın içeriğini okumak için bir buffer tanımlamalıyız. char buffer[100]; while (fgets(buffer, 100, dosya) != NULL) { printf(\"%s\", buffer); } fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175379"
  },
  {
    "question": "Kullanıcının girdiği verileri bir dosyaya yazmak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"girdi.txt\", \"w\"); // veri yazma kodu",
    "answer": "fopen() ile dosyayı yazma modunda açtık. Kullanıcıdan veri almak için char veri[100]; printf(\"Bir veri girin: \"); fgets(veri, 100, stdin); fprintf(dosya, \"%s\", veri); fclose(dosya); // Dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175472"
  },
  {
    "question": "Bir dosyadan belirli bir karakteri bulmak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"metin.txt\", \"r\"); // karakter bulma kodu",
    "answer": "fopen() ile dosyayı okuma modunda açtık. char ch; while ((ch = fgetc(dosya)) != EOF) { if (ch == 'A') { printf(\"'A' bulundu!\"); break; } } fclose(dosya); // Dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175560"
  },
  {
    "question": "Bir dosyayı satır satır okumak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"veri.txt\", \"r\"); // satır okuma kodu",
    "answer": "fopen() ile dosyayı açtık. char satir[256]; while (fgets(satir, sizeof(satir), dosya)) { printf(\"%s\", satir); } fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175637"
  },
  {
    "question": "Bir dosyaya ikili veri yazmak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"veri.bin\", \"wb\"); // ikili veri yazma kodu",
    "answer": "fopen() ile dosyayı ikili yazma modunda açtık. int sayi = 123; fwrite(&sayi, sizeof(int), 1, dosya); fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175703"
  },
  {
    "question": "Bir dosyadan ikili veri okumak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"veri.bin\", \"rb\"); // ikili veri okuma kodu",
    "answer": "fopen() ile dosyayı ikili okuma modunda açtık. int sayi; fread(&sayi, sizeof(int), 1, dosya); printf(\"Okunan sayı: %d\", sayi); fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175764"
  },
  {
    "question": "Bir dosyayı kontrol etmek için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"kontrol.txt\", \"r\"); // dosya kontrol kodu",
    "answer": "fopen() ile dosyayı açıyoruz. if (dosya == NULL) { printf(\"Dosya açılamadı!\"); return 1; } fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175828"
  },
  {
    "question": "Bir dosyayı baştan sona okumak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"veri.txt\", \"r\"); // baştan sona okuma kodu",
    "answer": "fopen() ile dosyayı açtık. char ch; while ((ch = fgetc(dosya)) != EOF) { putchar(ch); } fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175894"
  },
  {
    "question": "Bir dosyanın sonuna veri eklemek için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"ekle.txt\", \"a\"); // sonuna veri ekleme kodu",
    "answer": "fopen() ile dosyayı ekleme modunda açtık. char veri[100]; printf(\"Eklemek için bir veri girin: \"); fgets(veri, 100, stdin); fprintf(dosya, \"%s\", veri); fclose(dosya); // Dosyayı kapatmayı unutmayın.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.175957"
  },
  {
    "question": "Bir dosyadaki tüm sayıları okuyup toplamak için eksik kodu tamamla: FILE *dosya; dosya = fopen(\"sayilar.txt\", \"r\"); // toplam hesaplama kodu",
    "answer": "fopen() ile dosyayı açtık. int sayi, toplam = 0; while (fscanf(dosya, \"%d\", &sayi) == 1) { toplam += sayi; } printf(\"Toplam: %d\", toplam); fclose(dosya); // Dosyayı kapatmayı unutmayalım.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.176031"
  },
  {
    "question": "Bir dosyayı silmek için eksik kodu tamamla: const char* dosya_adi = \"sil.txt\"; // dosyayı silme kodu",
    "answer": "remove(dosya_adi); // remove() fonksiyonu ile belirtilen dosyayı sileriz. Kontrol için if (remove(dosya_adi) == 0) { printf(\"Dosya silindi.\"); } else { printf(\"Dosya silinemedi.\"); }",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:08:13.176087"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayarak bir dosyadan okuma işlemi yap. Dosya adı 'veriler.txt' ve her satırı ekrana yazdır.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256];\n\n    // Dosyayı aç\n    dosya = fopen(\"veriler.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Satırları oku ve ekrana yazdır\n    while (fgets(satir, sizeof(satir), dosya)) {\n        printf(\"%s\", satir);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369359"
  },
  {
    "question": "Aşağıdaki kodda bir dosyaya veri yazma işlemi eksik. 'output.txt' dosyasına 'Merhaba Dünya' yazacak şekilde tamamla.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    // Dosyayı aç\n    dosya = fopen(\"output.txt\", \"w\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyaya yaz\n    fprintf(dosya, \"Merhaba Dünya\\n\");\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369412"
  },
  {
    "question": "Aşağıdaki kodda bir dosyadan okuma işlemi yapılırken, dosya sonunda EOF kontrolü eksik. Bunu doğru bir şekilde ekleyin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int ch;\n\n    // Dosyayı aç\n    dosya = fopen(\"veriler.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyadan karakter karakter oku\n    while ((ch = fgetc(dosya)) != EOF) {\n        putchar(ch);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369448"
  },
  {
    "question": "Aşağıdaki kodda, bir dosyaya birden fazla satır yazmak için eksik kısımları tamamlayın. 'veri.txt' dosyasına '1', '2', '3' yazılacak.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    // Dosyayı aç\n    dosya = fopen(\"veri.txt\", \"w\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyaya yaz\n    for (int i = 1; i <= 3; i++) {\n        fprintf(dosya, \"%d\\n\", i);\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369492"
  },
  {
    "question": "Aşağıdaki kod, bir dosyadaki tüm verileri ters sırayla yazmak için eksik. 'veri.txt' dosyası okunduğunda, veriler ters sırayla 'output.txt' dosyasına yazılacak.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SATIR 100\n\nint main() {\n    FILE *dosya, *cikti;\n    char *satir[MAX_SATIR];\n    int sayac = 0;\n\n    // Dosyayı aç\n    dosya = fopen(\"veri.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Satırları oku\n    while (fgets(satir[sayac], sizeof(satir[sayac]), dosya) && sayac < MAX_SATIR) {\n        sayac++;\n    }\n\n    fclose(dosya);\n\n    // Çıktı dosyasını aç\n    cikti = fopen(\"output.txt\", \"w\");\n    if (cikti == NULL) {\n        perror(\"Çıktı dosyası açılamadı\");\n        return 1;\n    }\n\n    // Ters sırayla yaz\n    for (int i = sayac - 1; i >= 0; i--) {\n        fprintf(cikti, \"%s\", satir[i]);\n    }\n\n    fclose(cikti);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369555"
  },
  {
    "question": "Aşağıdaki kodda, bir dosyaya yapı yazma işlemi eksik. 'Kisi' yapısını tanımlayıp, 'kisi.txt' dosyasına bir 'Kisi' objesi yazın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char isim[50];\n    int yas;\n} Kisi;\n\nint main() {\n    FILE *dosya;\n    Kisi kisi = {\"Ahmet\", 30};\n\n    // Dosyayı aç\n    dosya = fopen(\"kisi.txt\", \"w\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Yapıyı yaz\n    fwrite(&kisi, sizeof(Kisi), 1, dosya);\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369596"
  },
  {
    "question": "Aşağıdaki kodda, bir binary dosyadan yapıyı okuma işlemi eksik. 'Kisi' yapısını okuyup ekrana yazdır.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char isim[50];\n    int yas;\n} Kisi;\n\nint main() {\n    FILE *dosya;\n    Kisi kisi;\n\n    // Dosyayı aç\n    dosya = fopen(\"kisi.txt\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Yapıyı oku\n    fread(&kisi, sizeof(Kisi), 1, dosya);\n\n    // Ekrana yazdır\n    printf(\"İsim: %s, Yaş: %d\\n\", kisi.isim, kisi.yas);\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369627"
  },
  {
    "question": "Aşağıdaki kodda, dosya okuma ve yazma işlemleri arasında hata kontrolü eksik. Hata kontrolü ekleyin ve uygun mesajlar gösterin.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[256];\n\n    // Dosyayı aç\n    dosya = fopen(\"veriler.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Satırları oku ve ekrana yazdır\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir);\n    }\n\n    if (ferror(dosya)) {\n        perror(\"Okuma hatası\");\n    }\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369663"
  },
  {
    "question": "Aşağıdaki kodu tamamlayarak 'data.txt' dosyasının sonuna 'Yeni Veri' ekleyin. Dosya eklenecek modda açılmalıdır.",
    "answer": "#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    // Dosyayı ekleme modunda aç\n    dosya = fopen(\"data.txt\", \"a\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // Dosyaya veri ekle\n    fprintf(dosya, \"Yeni Veri\\n\");\n\n    // Dosyayı kapat\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:18.369706"
  },
  {
    "question": "Dosyayı açmaya çalıştığımda 'No such file or directory' hatası alıyorum. Sorun ne olabilir?",
    "answer": "Bu hata, açmaya çalıştığınız dosyanın belirtilen dizinde bulunmadığını gösterir. Dosyanın adını ve yolunu kontrol edin. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n}\n```\nYukarıdaki kodda, 'dosya.txt' dosyasının mevcut dizinde olduğundan emin olun.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225415"
  },
  {
    "question": "fopen ile açtığım dosyayı fclose ile kapatmadığımda ne olur?",
    "answer": "Dosyayı kapatmadan bırakmak, bellek sızıntılarına ve dosya sisteminde potansiyel hatalara yol açabilir. Her zaman dosyayı kullandıktan sonra kapatmalısınız. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"a\");\n// dosya ile işlemler\nfclose(file);\n```\nBu, dosyanın düzgün bir şekilde kapatılmasını sağlar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225455"
  },
  {
    "question": "fscanf ile bir dosyadan veri okurken 'Input mismatch' hatası alıyorum. Neden?",
    "answer": "Bu hata, dosyadaki verinin beklediğiniz formatla uyuşmadığı anlamına gelir. Örneğin, sayısal bir veri bekliyorsanız ancak dosyada bir dize varsa bu hatayı alırsınız. Kodunuzu kontrol edin ve dosya içeriğini inceleyin. Örneğin:\n\n```c\nint a;\nfscanf(file, \"%d\", &a);\n```\nDosyada gerçekten bir tamsayı olduğundan emin olun.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225484"
  },
  {
    "question": "Dosyayı yazma modunda açtığım halde 'permission denied' hatası alıyorum. Ne yapmalıyım?",
    "answer": "Bu hata, dosyanın yazma iznine sahip olmadığı anlamına gelebilir. Dosyanın bulunduğu dizine yazma izniniz olduğundan emin olun. Ayrıca, dosya var ise ve yalnızca okuma iznine sahip ise, yazma modunda açıldığında bu hatayı alabilirsiniz. Örneğin, dosyayı açarken kontrol edin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"w\");\nif (file == NULL) {\n    perror(\"Yazma hatası\");\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225536"
  },
  {
    "question": "fwrite ile yazdığım verileri dosyada göremiyorum. Neden olabilir?",
    "answer": "Bu durum, dosyanın yazma işlemi sonrasında kapatılmadığı için olabilir. fwrite işlemi, verileri belleğe yazar; ancak dosyaya yazılması için fclose çağrılmalıdır. Örneğin:\n\n```c\nint veriler[] = {1, 2, 3};\nfwrite(veriler, sizeof(int), 3, file);\nfclose(file);\n```\nBurada fclose çağrılmadıysa, veri dosyaya yazılmamış olabilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225559"
  },
  {
    "question": "fgets ile okuduğum veride sonlandırıcı karakter '\n' yok. Neden?",
    "answer": "Bu durum, dosyanın sonundaki yeni satır karakterinin olmaması veya fgetc ile okunan bir karakterin sona ulaşması nedeniyle olabilir. fgets, yeni satır karakterini okuduğunda durur. Örneğin:\n\n```c\nchar buffer[100];\nfgets(buffer, sizeof(buffer), file);\n``` \nDosyada bir yeni satır yoksa buffer'da bu karakter yer almayacaktır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225583"
  },
  {
    "question": "fopen ile açtığım dosya okuma modunda neden boş döndü?",
    "answer": "Bu durum, dosyanın içinin boş olması veya dosyanın bulunamaması nedeniyle olabilir. Dosyanın mevcut ve okunabilir olduğundan emin olun. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nchar buffer[100];\nfgets(buffer, sizeof(buffer), file);\nif (buffer[0] == '\\0') {\n    printf(\"Dosya boş\\n\");\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225605"
  },
  {
    "question": "Dosyadan veri okuduktan sonra bellekte hafıza sızıntısı olmaması için ne yapmalıyım?",
    "answer": "Bellek sızıntısını önlemek için kullandığınız dinamik bellek için ayırdığınız alanları serbest bırakmalısınız. Ancak dosya işlemlerinde, fopen ile açtığınız dosyayı fclose ile kapatmayı unutmayın. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file != NULL) {\n    // dosya işlemleri\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225632"
  },
  {
    "question": "fprintf ile bir dosyaya yazdığım veriler beklediğim gibi formatlanmadı. Neden?",
    "answer": "fprintf fonksiyonu, format belirteçlerini doğru kullanmadığınızda beklenmedik çıktılar verebilir. Format belirteçlerini doğru kullandığınızdan emin olun. Örneğin:\n\n```c\nint sayi = 42;\nfprintf(file, \"Sayı: %d\\n\", sayi);\n```\nFormat belirteçlerinin doğru olduğundan emin olun.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225656"
  },
  {
    "question": "Bir dosyayı okuduktan sonra dosya işaretçisi neden sonuna gitmiş durumda?",
    "answer": "Bu durum, dosyanın sonuna kadar okunduğunuzda otomatik olarak dosya işaretçisinin sonuna gitmesinden kaynaklanır. Dosyadan daha fazla okuma yapmadan önce işaretçiyi geri almanız gerekebilir. Örneğin:\n\n```c\nfseek(file, 0, SEEK_SET);\n``` \nBu, dosya işaretçisini başa alır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:09:46.225680"
  },
  {
    "question": "Bir dosyayı okumaya çalışıyorum ve dosyanın açılmadığını belirten bir hata alıyorum. Dosya yolunu doğru yazdım ama yine de hata alıyorum. Neden olabilir?",
    "answer": "Dosya yolu doğru görünüyor olsa bile, dosyanın bulunduğu dizinde gerekli okuma izinlerine sahip olmayabilirsiniz. Ayrıca, dosyanın gerçekten var olduğundan emin olun. Ayrıca, dosya açma işlemi sırasında kullanılan modun doğru olup olmadığını kontrol edin. Örneğin, 'r' modunu kullanarak açılmadıysa, 'rb' modunu deneyin. İşte bir örnek:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}\n```\nBurada 'perror' fonksiyonu, hatanın nedenini açıklayarak debug sürecinizi kolaylaştırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914642"
  },
  {
    "question": "Bir dosyaya verileri yazarken, yazmam gereken verinin bazen kaybolduğunu fark ettim. Kodumun bu kısmı neden böyle çalışıyor?",
    "answer": "Yazma işlemlerinde dosyanın buffer'lanması nedeniyle bazı veriler kaybolmuş olabilir. Eğer dosya kapatılmadan önce buffer'ı temizlemezseniz, bazı veriler diske yazılmayabilir. Bu durumu engellemek için 'fflush' fonksiyonunu kullanarak buffer'ı temizlemeniz önerilir:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"w\");\nfwrite(data, sizeof(char), length, file);\nfflush(file);\nfclose(file);\n```\n'fflush', açık dosya akışındaki verileri diske yazar, böylece verilerin kaybolma riski azalır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914701"
  },
  {
    "question": "Bir dosyayı okuduktan sonra, dosya akışının konumunu kontrol ediyorum ama beklediğimden farklı bir konumda çıkıyor. Neden?",
    "answer": "Dosya akışının konumunu kontrol ettiğinizde, okuma işlemleri sırasında dosya konumunun değiştiğini unutmamanız gerekir. Her okuma işlemi, dosya konumunu günceller. Eğer dosya konumunu kontrol etmeden önce bir okuma işlemi yaptıysanız, beklediğinizden farklı bir konumda olabilirsiniz. Konumu kontrol etmeden önce 'fseek' ile dosya konumunu ayarlamayı düşünebilirsiniz:\n\n```c\nfseek(file, 0, SEEK_SET);\n```\nBu ifade, dosyanın başına geri döner ve ardından konumu kontrol edebilirsiniz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914736"
  },
  {
    "question": "Benim dosya açma işlemim \"fopen\" ile çalışıyor ama çıktıda hiçbir şey göremiyorum. Neden bu böyle?",
    "answer": "Bu durum, dosya açma işleminin başarılı olmamasından kaynaklanıyor olabilir. 'fopen' fonksiyonu, dosyayı açamadığında NULL döner. Bu durumu kontrol etmeden yazma veya okuma işlemlerini gerçekleştirmeye çalışırsanız, beklenen çıktıyı alamazsınız. 'fopen' sonrası NULL kontrolü yapmalısınız:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"w\");\nif (file == NULL) {\n    fprintf(stderr, \"Dosya açılamadı: %s\\n\", strerror(errno));\n}\n```\nBurada 'strerror' fonksiyonu, hata mesajını daha anlamlı hale getirir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914770"
  },
  {
    "question": "Bir dosyadan okuduğum verileri bir diziye kaydetmek istiyorum, fakat okuma işlemi sırasında bellek hatası alıyorum. Neden?",
    "answer": "Bu durum, okunan verilerin diziye kaydedilmesi sırasında yeterli bellek tahsis edilmemesinden kaynaklanabilir. Dizi boyutunu doğru şekilde ayarladığınızdan emin olun. Ayrıca, çok fazla veri okuma girişiminde bulunuyorsanız, sınırları aşma riski bulunur. Dinamik bellek yönetimi kullanarak bu durumu önleyebilirsiniz:\n\n```c\nchar *buffer = malloc(bufferSize);\nif (buffer == NULL) { /* Hata kontrolü */ }\nsize_t bytesRead = fread(buffer, 1, bufferSize, file);\n```\nBu şekilde, okunan veri miktarını kontrol edebilir ve bellek hatalarından kaçınabilirsiniz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914804"
  },
  {
    "question": "Farklı dosya akışlarını aynı anda kullanmaya çalışıyorum ama bazı dosyalardan okunan veriler karışıyor. Bu sorunu nasıl çözebilirim?",
    "answer": "Birden fazla dosya akışını aynı anda kullanırken, her dosya akışı için ayrı bir dosya işaretçisi kullanmalısınız. Dosyaların açılışlarını ve kapatmalarını belirgin bir şekilde yaparak, akışlar arasında karışıklığı önleyebilirsiniz. Örneğin:\n\n```c\nFILE *file1 = fopen(\"dosya1.txt\", \"r\");\nFILE *file2 = fopen(\"dosya2.txt\", \"r\");\n\n// Verileri okurken her dosya akışını ayrı yönetmelisiniz.\n```\nHer dosya üzerinde işlem yaparken hangi akışta olduğunuzu net bir şekilde belirtin.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914859"
  },
  {
    "question": "Yazdığım program, dosyaya veri yazdıktan sonra hemen dosyayı kapatıyor ama veriler diske kaydedilmiyor. Neden?",
    "answer": "Dosyayı kapatmadan önce verilerin diske yazıldığından emin olmalısınız. Bunun için 'fflush' fonksiyonunu kullanabilirsiniz. Ayrıca, dosyayı kapatmadan önce buffer'ı temizlemek, veri kaybını önler。\n\n```c\nfwrite(data, sizeof(char), length, file);\nfflush(file);\nfclose(file);\n```\nEğer 'fflush' kullanmazsanız ve dosya kapandıysa, yazılan veriler kaybolabilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914892"
  },
  {
    "question": "Bir dosyadan okuduğum verileri başka bir dosyaya kopyalamaya çalışıyorum ama sonuçta dosya boş çıkıyor. Neden?",
    "answer": "Bu durum, dosyaların açılış modlarıyla ilgili olabilir. Kopyalama işlemi sırasında hedef dosyanın 'w' modunda açıldığından emin olmalısınız. Eğer hedef dosya açılmadan önce içerik yazdıysanız ve sonra 'w' modunda açarsanız, içeriği silinir. Aşağıda örnek bir kopyalama işlemi verilmiştir:\n\n```c\nFILE *source = fopen(\"kaynak.txt\", \"r\");\nFILE *destination = fopen(\"hedef.txt\", \"w\");\n\nchar buffer[256];\nwhile (fgets(buffer, sizeof(buffer), source)) {\n    fputs(buffer, destination);\n}\n```\nBu örnekte, kaynak dosyadan satır satır okuyup hedef dosyaya yazıyoruz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914924"
  },
  {
    "question": "Dosya yazma işlemi yaparken, her seferinde aynı verinin üzerine yazılıyor. Bu durumu nasıl çözebilirim?",
    "answer": "Eğer her seferinde aynı veriyi üzerine yazıyorsanız, dosyayı 'w' modunda açıyorsunuz demektir. Bu mod, dosyayı açtığınızda içeriği siler. Bunun yerine 'a' modunu kullanarak dosyayı ekleme modunda açabilir ve mevcut verilere ekleme yapabilirsiniz:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"a\");\nfputs(\"Yeni veri\\n\", file);\nfclose(file);\n```\nBu şekilde, dosyanın mevcut içeriğini korumuş olursunuz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914959"
  },
  {
    "question": "Bir dosyayı okuduktan sonra dosya konumunu sıfırlamak istiyorum ama 'fseek' kullanırken beklediğim sonucu alamıyorum. Neden?",
    "answer": "Eğer 'fseek' kullanıyorsanız, dosya akışının başına geri dönerken doğru modda açıldığından emin olmalısınız. Ayrıca, 'fseek' fonksiyonu sonrasında dosya konumunu kontrol etmek için 'ftell' kullanmalısınız. Örnek:\n\n```c\nfseek(file, 0, SEEK_SET);\nlong position = ftell(file);\nif (position != 0) {\n    fprintf(stderr, \"Dosya konumu sıfırlanmadı\\n\");\n}\n```\nBu şekilde, dosya konumunun sıfırlanıp sıfırlanmadığını kontrol edebilirsiniz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:10:55.914994"
  },
  {
    "question": "C dilinde bir dosyayı nasıl açabilirim?",
    "answer": "C dilinde bir dosyayı açmak için 'fopen' fonksiyonunu kullanırız. Örneğin, 'fopen(\"dosya.txt\", \"r\")' ifadesi, 'dosya.txt' adlı dosyayı okuma ('r') modunda açar. Eğer dosya başarıyla açılırsa, bir FILE göstergesi döndürülür. Bu gösterge daha sonra dosya üzerinde işlem yapmak için kullanılır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156175"
  },
  {
    "question": "Dosya okuma işlemi nasıl gerçekleştirilir?",
    "answer": "Dosya okuma işlemi için 'fgets' veya 'fscanf' gibi fonksiyonlar kullanabiliriz. Örneğin, bir dosyadan satır satır veri okumak için şu kodu kullanabiliriz:\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nchar buffer[100];\nwhile (fgets(buffer, sizeof(buffer), file) != NULL) {\n    printf(\"Okunan: %s\", buffer);\n}\nfclose(file);\n```\nBu kod, 'dosya.txt' dosyasını açar, her seferinde bir satırı okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156209"
  },
  {
    "question": "Dosya kapatma işlemi neden önemlidir?",
    "answer": "Dosya kapatma işlemi, 'fclose' fonksiyonu ile yapılır ve bellek yönetimi açısından önemlidir. Aksi taktirde, açılan dosyalar açık kalabilir ve sistem kaynakları tükenebilir. Örneğin, yukarıdaki yazma işleminin sonunda 'fclose(file);' ile dosyayı kapatmak, tüm verilerin diske yazılmasını ve kaynakların serbest bırakılmasını sağlar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156236"
  },
  {
    "question": "Bir dosyada hata kontrolü nasıl yapılır?",
    "answer": "Dosya işlemleri sırasında hata kontrolü yapmak için 'fopen' fonksiyonunun dönüş değeri kontrol edilmelidir. Eğer dosya açılamazsa, NULL döner. Örnek:\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n}\n```\nBu kod, dosya açılamazsa hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156254"
  },
  {
    "question": "Dosyadan veri okurken hangi veri türlerini kullanabilirim?",
    "answer": "Dosyadan veri okurken birçok veri türü kullanabiliriz. Örneğin, sayıları okumak için 'fscanf' fonksiyonu kullanılabilir:\n```c\nint sayi;\nFILE *file = fopen(\"sayilar.txt\", \"r\");\nfscanf(file, \"%d\", &sayi);\nprintf(\"Okunan sayı: %d\", sayi);\nfclose(file);\n```\nBu kod, 'sayilar.txt' dosyasından bir tam sayıyı okur.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156278"
  },
  {
    "question": "Dosya okuma ve yazma işlemlerini birlikte nasıl yapabilirim?",
    "answer": "Bir dosyayı hem okuyup hem yazmak için 'r+' modunu kullanabiliriz. Bu modda dosya açılınca mevcut veriler korunur ve dosyaya yeni veriler ekleyebilirsiniz:\n```c\nFILE *file = fopen(\"dosya.txt\", \"r+\");\nchar buffer[100];\nfgets(buffer, sizeof(buffer), file);\nprintf(\"Okunan: %s\", buffer);\nfprintf(file, \"Yeni veri ekleniyor!\");\nfclose(file);\n```\nBu kod, dosyayı okur ve ardından dosyanın sonuna veri ekler.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156300"
  },
  {
    "question": "Bir dosyadan tüm verileri nasıl okuyabilirim?",
    "answer": "Bir dosyadan tüm verileri okumak için 'fread' fonksiyonu kullanılabilir. Örneğin, bir ikili dosyadan tam sayı dizisi okumak için:\n```c\nint dizi[100];\nFILE *file = fopen(\"veri.bin\", \"rb\");\nfread(dizi, sizeof(int), 100, file);\nfclose(file);\n```\nBu kod, 'veri.bin' dosyasından 100 tam sayıyı okur.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156318"
  },
  {
    "question": "Bir dosyayı nasıl silerim?",
    "answer": "Bir dosyayı silmek için 'remove' fonksiyonu kullanabiliriz. Örneğin:\n```c\nif (remove(\"dosya.txt\") == 0) {\n    printf(\"Dosya silindi.\");\n} else {\n    perror(\"Dosya silme hatası\");\n}\n```\nBu kod, 'dosya.txt' dosyasını silmeyi dener ve başarılı olursa ekrana mesaj yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156333"
  },
  {
    "question": "Dosya kopyalama işlemini nasıl yapabilirim?",
    "answer": "Dosya kopyalama işlemi, bir dosyayı açıp içeriğini başka bir dosyaya yazmakla yapılır. Örneğin:\n```c\nFILE *src = fopen(\"kaynak.txt\", \"r\");\nFILE *dest = fopen(\"hedef.txt\", \"w\");\nchar buffer[100];\nwhile (fgets(buffer, sizeof(buffer), src) != NULL) {\n    fputs(buffer, dest);\n}\nfclose(src);\nfclose(dest);\n```\nBu kod, 'kaynak.txt' dosyasını okuyarak 'hedef.txt' dosyasına kopyalar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:20.156350"
  },
  {
    "question": "C dilinde dosya açmak için hangi fonksiyonu kullanmalıyım ve bu fonksiyonun parametreleri nedir?",
    "answer": "C dilinde dosya açmak için 'fopen' fonksiyonu kullanılır. Bu fonksiyonun iki temel parametresi vardır: birincisi açmak istediğiniz dosyanın ismi (char pointer olarak), ikincisi ise dosyanın hangi modda açılacağını belirten bir string (örn: \"r\" okuma, \"w\" yazma, \"a\" ekleme için). Örneğin, bir dosyayı okuma modunda açmak için şöyle yazabilirsiniz: FILE *file = fopen(\"dosya.txt\", \"r\");",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273281"
  },
  {
    "question": "Bir dosyadan veri okuma işlemini nasıl gerçekleştirebilirim?",
    "answer": "Dosyadan veri okumak için 'fgets' veya 'fscanf' fonksiyonlarını kullanabilirsiniz. 'fgets' ile bir satır okurken 'fscanf' belirli formatta veri okumanıza olanak tanır. Örneğin, bir dosyadan bir satırı okumak için şu şekilde yapabilirsiniz: char buffer[100]; fgets(buffer, sizeof(buffer), file); bu, 'file' dosyasından bir satırı 'buffer' değişkenine aktarır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273333"
  },
  {
    "question": "C dilinde dosyaya yazma işlemi nasıl yapılır?",
    "answer": "Dosyaya yazma işlemi yapmak için 'fprintf' veya 'fputs' fonksiyonlarını kullanabilirsiniz. 'fprintf' formatlı yazım yaparken 'fputs' ise sadece bir string yazar. Örneğin, bir dosyaya metin yazmak için şu kodu kullanabilirsiniz: FILE *file = fopen(\"output.txt\", \"w\"); fprintf(file, \"Merhaba Dünya!\"); fclose(file); bu kod 'output.txt' dosyasına 'Merhaba Dünya!' yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273353"
  },
  {
    "question": "Bir dosyadan okuduğum verileri nasıl bir diziye atabilirim?",
    "answer": "Bir dosyadan okunan verileri bir diziye atmak için önce dizinin uygun boyutunu belirlemeniz gerekir. Ardından 'fgets' veya 'fscanf' kullanarak verileri dizi elemanlarına aktarabilirsiniz. Örneğin: char buffer[10][100]; for (int i = 0; i < 10; i++) { fgets(buffer[i], sizeof(buffer[i]), file); } bu kod, dosyadan 10 satır okur ve her satırı 'buffer' dizisinin ilgili elemanına yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273376"
  },
  {
    "question": "C dilinde dosya okuma hatalarını nasıl kontrol edebilirim?",
    "answer": "Dosya okuma hatalarını kontrol etmek için 'feof' ve 'ferror' fonksiyonlarını kullanabilirsiniz. 'feof', dosyanın sonuna ulaşıp ulaşmadığınızı kontrol ederken, 'ferror' okuma işlemi sırasında bir hata olup olmadığını kontrol eder. Örneğin: if (feof(file)) { printf(\"Dosya sonuna ulaşıldı.\"); } if (ferror(file)) { printf(\"Okuma hatası oluştu.\"); }",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273396"
  },
  {
    "question": "C dilinde bir dosyayı nasıl kapatmalıyım ve neden bu önemlidir?",
    "answer": "Bir dosyayı kapatmak için 'fclose' fonksiyonunu kullanmalısınız. Dosyayı kapatmak, yazdığınız verilerin diske kaydedilmesini sağlar ve sistem kaynaklarını serbest bırakır. Örneğin: fclose(file); dosya kapatıldığında bellek sızıntısı ve veri kaybı riskini azaltmış olursunuz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273420"
  },
  {
    "question": "C dilinde ikili dosya okuma ve yazma işlemleri nasıl yapılır?",
    "answer": "İkili dosya okumak ve yazmak için 'fopen' fonksiyonunda 'rb' (okuma) ve 'wb' (yazma) modlarını kullanmalısınız. İkili veri yazmak için 'fwrite', okumak için 'fread' fonksiyonları kullanılır. Örneğin: int data = 123; FILE *binFile = fopen(\"data.bin\", \"wb\"); fwrite(&data, sizeof(int), 1, binFile); fclose(binFile); bu kod, 'data.bin' dosyasına bir tamsayı yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273443"
  },
  {
    "question": "C dilinde bir dosyayı satır satır nasıl okuyabilirim?",
    "answer": "Bir dosyayı satır satır okumak için 'fgets' fonksiyonunu kullanabilirsiniz. Bir döngü oluşturup her seferinde bir satırı okuyarak devam edebilirsiniz. Örneğin: while (fgets(buffer, sizeof(buffer), file)) { printf(\"%s\", buffer); } bu kod, dosya sonuna kadar her satırı ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273479"
  },
  {
    "question": "C dilinde dosya açarken dosyanın var olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Dosyayı açmadan önce 'access' fonksiyonunu kullanarak dosyanın varlığını kontrol edebilirsiniz. Örneğin: if (access(\"dosya.txt\", F_OK) != -1) { printf(\"Dosya mevcut.\"); } bu kod, 'dosya.txt' dosyasının var olup olmadığını kontrol eder.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273523"
  },
  {
    "question": "C dilinde dosya stream'lerini kullanarak bir programda hata yönetimi nasıl yapılır?",
    "answer": "Hata yönetimi için dosya stream'lerini kontrol etmek önemlidir. 'fopen' sonrası dosya pointer'ını kontrol ederek açılıp açılmadığını kontrol edebilirsiniz. Ayrıca 'errno' değişkenini kullanarak hata kodları hakkında bilgi alabilirsiniz. Örneğin: FILE *file = fopen(\"dosya.txt\", \"r\"); if (file == NULL) { perror(\"Dosya açılamadı\"); }",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:11:46.273565"
  },
  {
    "question": "C dilinde bir dosyayı nasıl açar ve okuma işlemi yapabilirim?",
    "answer": "C dilinde bir dosyayı açmak için 'fopen' fonksiyonunu kullanırız. 'fopen' fonksiyonu iki argüman alır: dosya adı ve mod. Örneğin, bir dosyayı okuma modunda açmak için şu kodu kullanabiliriz:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}\n```\nBu kodda, dosya açılmazsa NULL döner ve hata mesajı verir. Dosya açıldıktan sonra 'fgetc', 'fgets' veya 'fread' gibi fonksiyonlarla okuma yapabiliriz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001533"
  },
  {
    "question": "Bir dosyadan belirli bir miktarda veri okumak için hangi yöntemleri kullanabilirim?",
    "answer": "Bir dosyadan belirli bir miktarda veri okumak için 'fread' fonksiyonunu kullanabiliriz. 'fread' fonksiyonu, okunan veri miktarını ve verinin tipini belirlememize olanak tanır. Örnek kullanım:\n\n```c\nchar buffer[100];\nsize_t bytesRead = fread(buffer, sizeof(char), 100, file);\n```\nBu kodda, 'buffer' dizisine dosyadan 100 bayt veri okunur. 'bytesRead' değişkeni, kaç bayt okunduğunu gösterir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001608"
  },
  {
    "question": "C dilinde dosya stream'leri ile binar dosyaları nasıl işleyebilirim?",
    "answer": "Binar dosyaları işlemek için 'fopen' fonksiyonunu 'rb' modunda kullanmalıyız. Örneğin:\n\n```c\nFILE *binaryFile = fopen(\"veri.bin\", \"rb\");\n```\nBinar dosyadan okumak için 'fread' fonksiyonunu kullanabiliriz. Yazmak için ise 'fwrite' fonksiyonunu kullanarak binary verileri yazabiliriz:\n\n```c\nfwrite(data, sizeof(DataType), count, binaryFile);\n```\nBurada 'data', yazılacak veriyi, 'DataType' yazılacak verinin tipini ve 'count' yazılacak veri sayısını belirtir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001640"
  },
  {
    "question": "C dilinde bir dosyayı kapatmanın önemi nedir ve nasıl yapılır?",
    "answer": "Bir dosyayı kapatmak, sistem kaynaklarını serbest bırakmak için önemlidir. 'fclose' fonksiyonu kullanılarak dosya kapatılabilir:\n\n```c\nfclose(file);\n```\nEğer dosya kapatılmazsa, dosya kaydedilmediğinde veri kaybı yaşanabilir ve bellek sızıntılarına yol açabilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001674"
  },
  {
    "question": "C dilinde dosya stream'leri kullanarak hata yönetimini nasıl yapabilirim?",
    "answer": "Hata yönetimi için dosya açmadan önce ve işlem yaptıktan sonra kontrol mekanizmaları eklemeliyiz. Örneğin:\n\n```c\nif (file == NULL) {\n    fprintf(stderr, \"Hata: Dosya açılamadı.\");\n    return EXIT_FAILURE;\n}\n```\nHerhangi bir okuma veya yazma işlemi sonrası da geri dönüş değerlerini kontrol etmeli ve hataları uygun şekilde yönetmeliyiz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001718"
  },
  {
    "question": "C dilinde dosya stream'leri ile birden fazla dosya nasıl açabiliriz?",
    "answer": "Birden fazla dosya açmak için birden fazla 'FILE' pointer'ı tanımlayarak her biri için 'fopen' fonksiyonunu kullanabiliriz. Örneğin:\n\n```c\nFILE *file1 = fopen(\"dosya1.txt\", \"r\");\nFILE *file2 = fopen(\"dosya2.txt\", \"r\");\n```\nHer dosya için ayrı okuma ve yazma işlemleri gerçekleştirebiliriz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001745"
  },
  {
    "question": "C dilinde bir dosyadan satır satır okuma işlemi nasıl yapılır?",
    "answer": "Satır satır okuma için 'fgets' fonksiyonunu kullanabiliriz. Örnek:\n\n```c\nchar line[256];\nwhile (fgets(line, sizeof(line), file) != NULL) {\n    printf(\"%s\", line);\n}\n```\nBu kod, dosyadan her bir satırı okur ve ekrana yazdırır. 'fgets' fonksiyonu, dosyanın sonuna ulaşana kadar çalışır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001771"
  },
  {
    "question": "C dilinde dosya konumunu nasıl değiştirebiliriz?",
    "answer": "Dosya konumunu değiştirmek için 'fseek' fonksiyonunu kullanırız. Örneğin, dosyanın başına dönmek için:\n\n```c\nfseek(file, 0, SEEK_SET);\n```\n'SEEK_SET', dosya başından itibaren belirtilen bayt sayısına gitmemizi sağlar. 'SEEK_CUR' ve 'SEEK_END' ile de mevcut konumdan veya dosya sonundan konum değiştirebiliriz.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001793"
  },
  {
    "question": "C dilinde bir dosyaya veri yazarken mevcut veriyi nasıl koruyabilirim?",
    "answer": "Mevcut veriyi koruyarak yazmak için dosyayı 'a' (append) modunda açmalıyız. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"a\");\n```\nBu modda açılan dosyaya yazılan veriler, mevcut verilerin sonuna eklenir. Böylece mevcut veriler silinmez.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001820"
  },
  {
    "question": "C dilinde dosya yazma işlemi sırasında verilerin doğru bir şekilde kaydedilip kaydedilmediğini nasıl kontrol edebilirim?",
    "answer": "Dosya yazma işlemi sonrasında 'ferror' fonksiyonunu kullanarak herhangi bir hata olup olmadığını kontrol edebiliriz. Örneğin:\n\n```c\nif (ferror(file)) {\n    fprintf(stderr, \"Yazma hatası oluştu.\");\n}\n```\nBu kod, yazma işlemi sırasında bir hata olup olmadığını kontrol eder ve hata durumunda uygun bir mesaj verir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001858"
  },
  {
    "question": "C dilinde dosya stream'leri kullanarak bir log dosyası oluşturmak için örnek bir kod yazın.",
    "answer": "Log dosyası oluşturmak için dosyayı 'a' modunda açarak log kayıtları ekleyebiliriz. Örnek:\n\n```c\nFILE *logFile = fopen(\"log.txt\", \"a\");\nif (logFile != NULL) {\n    fprintf(logFile, \"Log kaydı: %s\\n\", \"Program çalıştı.\");\n    fclose(logFile);\n} else {\n    fprintf(stderr, \"Log dosyası açılamadı.\");\n}\n```\nBu kod, \"log.txt\" dosyasına belirtilen log kaydını ekler ve dosyayı kapatır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:14.001905"
  },
  {
    "question": "Bir dosyayı okuma işlemi nasıl yapılır?",
    "answer": "C dilinde bir dosyayı okumak için öncelikle dosyayı açmamız gerekiyor. Bunun için 'fopen' fonksiyonunu kullanabiliriz. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    dosya = fopen(\"ornek.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    while ((ch = fgetc(dosya)) != EOF) { // Dosyadan karakter okuma\n        putchar(ch); // Okunan karakteri ekrana yaz\n    }\n\n    fclose(dosya); // Dosyayı kapatma\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.894887"
  },
  {
    "question": "Bir dosyaya yazma işlemi nasıl yapılır?",
    "answer": "Bir dosyaya veri yazmak için yine 'fopen' fonksiyonunu kullanarak dosyayı açmamız gerekiyor. Yazma işlemi için 'w' modunu kullanırız. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    dosya = fopen(\"yeni_dosya.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\");\n        return 1;\n    }\n\n    fprintf(dosya, \"Merhaba, dünya!\"); // Dosyaya yazma işlemi\n    fclose(dosya); // Dosyayı kapatma\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.894937"
  },
  {
    "question": "Dosya akışında hata kontrolü nasıl yapılır?",
    "answer": "Dosya işlemlerinde hata kontrolü yapmak için 'ferror' ve 'feof' fonksiyonlarını kullanabiliriz. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while ((ch = fgetc(dosya)) != EOF) {\n        if (ferror(dosya)) {\n            perror(\"Okuma hatası\");\n            break;\n        }\n        putchar(ch);\n    }\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.894968"
  },
  {
    "question": "Bir dosyadan satır satır nasıl okuma yapılır?",
    "answer": "Bir dosyadan satır satır okumak için 'fgets' fonksiyonunu kullanırız. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir); // Satırı ekrana yaz\n    }\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895006"
  },
  {
    "question": "Dosyadaki veriyi güncellemek için hangi mod kullanılmalıdır?",
    "answer": "Dosyadaki veriyi güncellemek için 'r+' modunu kullanmalıyız. Bu mod, dosyayı hem okuma hem de yazma için açmamızı sağlar. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char yeniVeri[] = \"Güncellenmiş veri\\n\";\n\n    dosya = fopen(\"ornek.txt\", \"r+\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(dosya, 0, SEEK_END); // Dosyanın sonuna git\n    fputs(yeniVeri, dosya); // Yeni veriyi yaz\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895042"
  },
  {
    "question": "Binary dosya açma ve okuma nasıl yapılır?",
    "answer": "Binary dosyayı açmak için 'b' harfini kullanmalıyız. Binary modda dosyayı açarken 'rb' veya 'wb' kullanırız. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int veri;\n\n    dosya = fopen(\"veri.bin\", \"rb\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fread(&veri, sizeof(int), 1, dosya); // Binary olarak okuma\n    printf(\"Okunan veri: %d\\n\", veri);\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895071"
  },
  {
    "question": "Dosya boyutunu nasıl öğrenebiliriz?",
    "answer": "Bir dosyanın boyutunu öğrenmek için 'fseek' ve 'ftell' fonksiyonlarını kullanabiliriz. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    long boyut;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    fseek(dosya, 0, SEEK_END); // Dosyanın sonuna git\n    boyut = ftell(dosya); // Boyutu öğren\n    printf(\"Dosya boyutu: %ld byte\\n\", boyut);\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895112"
  },
  {
    "question": "Dosyayı kapatmanın önemi nedir?",
    "answer": "Bir dosyayı kapatmak, sistem kaynaklarını serbest bırakmak için önemlidir. Eğer dosyayı kapatmazsak, bellek sızıntısı ve dosya bozulması gibi sorunlar yaşayabiliriz. Her dosya açma işlemi sonrası 'fclose' fonksiyonu ile dosyanın kapatılması gereklidir. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    // İşlemler...\n\n    fclose(dosya); // Dosyayı kapatma\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895139"
  },
  {
    "question": "Dosyayı okurken belirtilen bir karakterden sonra okumayı durdurma işlemi nasıl yapılır?",
    "answer": "Dosyayı okurken belirli bir karakterden sonra okumayı durdurmak için döngü içinde 'fgetc' ile karakterleri okuyabiliriz. Örnek: \n\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char ch;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    while ((ch = fgetc(dosya)) != EOF) {\n        if (ch == 'x') break; // 'x' karakterine ulaşınca dur\n        putchar(ch);\n    }\n\n    fclose(dosya);\n    return 0;\n}",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:12:43.895180"
  },
  {
    "question": "C dilinde bir dosyayı okuma ve içeriğini ekrana yazdırma işlemini nasıl yapabilirim?",
    "answer": "C dilinde bir dosyayı okumak için 'fopen', 'fgets' ve 'fclose' fonksiyonlarını kullanabiliriz. Aşağıda bir dosyayı okuma ve içeriğini ekrana yazdırma örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n\n    dosya = fopen(\"ornek.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        printf(\"%s\", satir); // Her bir satırı ekrana yazdır\n    }\n\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasını okur ve içeriği satır satır ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212015"
  },
  {
    "question": "Bir dosyaya yazma işlemi nasıl yapılır ve hata kontrolü nasıl eklenir?",
    "answer": "Bir dosyaya yazmak için 'fopen' ve 'fprintf' fonksiyonlarını kullanabiliriz. Ayrıca, dosya açma işlemini kontrol ederek hata kontrolü ekleyebiliriz. Aşağıdaki örnekte bir dosyaya veri yazma işlemi gösterilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n\n    dosya = fopen(\"yazilan.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    fprintf(dosya, \"Merhaba, Dünya!\\n\"); // Dosyaya yaz\n    fclose(dosya); // Dosyayı kapat\n    return 0;\n}\n```\nBu kod, \"yazilan.txt\" adında bir dosya oluşturur ve içine \"Merhaba, Dünya!\" yazısını yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212053"
  },
  {
    "question": "C dilinde bir dosyadan veri okuduktan sonra bu verileri nasıl bir diziye atabilirim?",
    "answer": "Bir dosyadan okunan verileri bir diziye atamak için 'fgets' fonksiyonu ile satırları okuyup bir diziye saklayabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SATIR 100\n#define MAX_UZUNLUK 100\n\nint main() {\n    FILE *dosya;\n    char satir[MAX_UZUNLUK];\n    char dizi[MAX_SATIR][MAX_UZUNLUK];\n    int i = 0;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL && i < MAX_SATIR) {\n        strcpy(dizi[i], satir); // Satırı diziye kopyala\n        i++;\n    }\n\n    fclose(dosya);\n\n    // Diziyi ekrana yazdır\n    for (int j = 0; j < i; j++) {\n        printf(\"%s\", dizi[j]);\n    }\n\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasındaki satırları bir diziye atar ve dizi içeriğini ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212079"
  },
  {
    "question": "C dilinde binary dosyaları nasıl okuyup yazabilirim?",
    "answer": "Binary dosyalar ile çalışmak için 'fopen' fonksiyonunu 'rb' ve 'wb' modları ile kullanmalıyız. Aşağıda bir binary dosyaya veri yazma ve okuma örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    int sayi = 12345;\n\n    // Binary dosyaya yazma\n    dosya = fopen(\"binary.dat\", \"wb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fwrite(&sayi, sizeof(int), 1, dosya);\n    fclose(dosya);\n\n    // Binary dosyadan okuma\n    int okunan;\n    dosya = fopen(\"binary.dat\", \"rb\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n    fread(&okunan, sizeof(int), 1, dosya);\n    printf(\"Okunan sayı: %d\\n\", okunan);\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, \"binary.dat\" adında bir binary dosyaya bir tam sayı yazar ve daha sonra bu sayıyı okuyarak ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212098"
  },
  {
    "question": "C dilinde dosya açma ve kapama işlemlerini nasıl güvenli bir şekilde yapabilirim?",
    "answer": "Dosya açma ve kapama işlemlerinde güvenlik amaçlı hata kontrolü yapmak önemlidir. Dosya açma başarısız olursa programın çökmesini önlemek için kontrol eklemeliyiz. Aşağıda güvenli dosya açma ve kapama örneği verilmiştir:\n\n```c\n#include <stdio.h>\n\nvoid dosyaIslemleri() {\n    FILE *dosya;\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\"); // Hata mesajı yazdır\n        return;\n    }\n    // Dosya okuma işlemleri\n    fclose(dosya); // Dosyayı kapat\n}\n\nint main() {\n    dosyaIslemleri();\n    return 0;\n}\n```\nBu kod, dosya açma işlemi sırasında hata oluşursa bir hata mesajı gösterir ve dosya kapama işlemini güvenli bir şekilde gerçekleştirir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212124"
  },
  {
    "question": "C dilinde bir dosyadan okunan verileri ters sırada ekrana yazdırmanın bir yolunu göster!",
    "answer": "Bir dosyadan okunan verileri ters sırada yazdırmak için, önce okunan verileri bir diziye saklayabilir ve ardından diziyi ters sırada ekrana yazdırabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SATIR 100\n#define MAX_UZUNLUK 100\n\nint main() {\n    FILE *dosya;\n    char satir[MAX_UZUNLUK];\n    char dizi[MAX_SATIR][MAX_UZUNLUK];\n    int i = 0;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL && i < MAX_SATIR) {\n        strcpy(dizi[i], satir);\n        i++;\n    }\n\n    fclose(dosya);\n\n    // Diziyi ters sırada yazdır\n    for (int j = i - 1; j >= 0; j--) {\n        printf(\"%s\", dizi[j]);\n    }\n\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasından satırları okur, bunları bir diziye atar ve daha sonra ters sırada ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212151"
  },
  {
    "question": "C dilinde bir metin dosyasına çoklu satır yazmanın en etkili yolunu nasıl yapabilirim?",
    "answer": "Birkaç satırlık metni bir dosyaya yazmak için 'fprintf' fonksiyonunu bir döngü içinde kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    const char *satirlar[] = {\"Birinci satır.\\n\", \"İkinci satır.\\n\", \"Üçüncü satır.\\n\"};\n\n    dosya = fopen(\"çoklu_satir.txt\", \"w\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i < 3; i++) {\n        fprintf(dosya, \"%s\", satirlar[i]); // Her bir satırı dosyaya yaz\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, \"çoklu_satir.txt\" adında bir dosya oluşturur ve üç farklı satırı bu dosyaya yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212176"
  },
  {
    "question": "C dilinde bir dosya içinde belirli bir kelimeyi arayıp bulduğunda ne yapmalıyım?",
    "answer": "Bir dosyadaki belirli bir kelimeyi bulmak için dosyayı satır satır okuyabilir ve her satırda kelimeyi kontrol edebiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n    const char *aramaKelimesi = \"C programlama\";\n    int bulundu = 0;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        if (strstr(satir, aramaKelimesi) != NULL) {\n            printf(\"Kelime bulundu: %s\", satir);\n            bulundu = 1;\n            break;\n        }\n    }\n\n    if (!bulundu) {\n        printf(\"Kelime bulunamadı.\\n\");\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasında \"C programlama\" kelimesini arar ve bulursa o satırı ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212201"
  },
  {
    "question": "C dilinde bir dosyayı satır sayısına göre nasıl okuyabilirim? Belirli bir satır numarasını okumak istiyorum.",
    "answer": "Belirli bir satır numarasını okumak için döngü ile satırları geçip aradığımız satıra ulaşabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *dosya;\n    char satir[100];\n    int aranacakSatir = 3; // Üçüncü satırı okumak istiyoruz\n    int mevcutSatir = 0;\n\n    dosya = fopen(\"ornek.txt\", \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı!\\n\");\n        return 1;\n    }\n\n    while (fgets(satir, sizeof(satir), dosya) != NULL) {\n        mevcutSatir++;\n        if (mevcutSatir == aranacakSatir) {\n            printf(\"Okunan satır: %s\", satir);\n            break;\n        }\n    }\n\n    fclose(dosya);\n    return 0;\n}\n```\nBu kod, \"ornek.txt\" dosyasındaki üçüncü satırı okur ve ekrana yazdırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:13:26.212231"
  },
  {
    "question": "Bir dosyadan satır satır okuma işlemini nasıl yapabilirsiniz? Örnek kod ve açıklama verin.",
    "answer": "Dosyadan satır satır okumak için, genellikle 'fgets' fonksiyonu kullanılır. Aşağıda bir dosyadan satır satır okuma işlemini gerçekleştiren bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char line[256]; // Her satır için bir buffer\n    while (fgets(line, sizeof(line), file)) { // Satır satır oku\n        printf(\"Okunan satır: %s\", line);\n    }\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'example.txt' dosyasını okur ve her satırı ekrana yazdırır. Eğer dosya açılamazsa, bir hata mesajı verir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265293"
  },
  {
    "question": "Bir dosyaya veri yazarken buffer kullanmanın avantajları nelerdir? Örnek kod ile açıklayın.",
    "answer": "Buffer kullanmanın avantajı, disk erişimini azaltarak performansı artırmaktır. 'fwrite' fonksiyonu ile birlikte bir buffer kullanarak dosyaya veri yazmak için aşağıdaki kodu inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\"); // Dosyayı yazma modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char *data = \"Bu bir test yazısıdır.\";\n    size_t len = strlen(data);\n    size_t written = fwrite(data, sizeof(char), len, file); // Veriyi buffer ile yaz\n\n    if (written != len) {\n        perror(\"Tüm veri yazılamadı\");\n    }\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'output.txt' dosyasına bir yazı yazar. Buffer kullanarak yazım işlemi, performansı artırır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265337"
  },
  {
    "question": "Büyük bir dosyayı parçalara ayırarak nasıl okuyabilirsiniz? Örnekle açıklayın.",
    "answer": "Büyük dosyaları parçalara ayırarak okuma işlemi, bellek yönetimi açısından önemlidir. Aşağıda gösterilen örnek, büyük bir dosyayı belirli boyutta okumayı gösterir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"largefile.dat\", \"rb\"); // Dosyayı ikili modda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    size_t bufferSize = 1024; // 1KB boyutunda bir buffer\n    char *buffer = malloc(bufferSize);\n    if (buffer == NULL) {\n        perror(\"Bellek tahsis edilemedi\");\n        fclose(file);\n        return EXIT_FAILURE;\n    }\n\n    size_t bytesRead;\n    while ((bytesRead = fread(buffer, 1, bufferSize, file)) > 0) {\n        // Burada buffer'daki veriler işlenebilir\n        printf(\"Okunan bayt: %zu\\n\", bytesRead);\n    }\n\n    free(buffer);\n    fclose(file);\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'largefile.dat' dosyasını 1KB'lık parçalara ayırarak okur.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265363"
  },
  {
    "question": "Bir dosyayı hem okuma hem de yazma modunda açmanın yollarını ve dikkat edilmesi gerekenleri açıklayın.",
    "answer": "Bir dosyayı hem okuma hem yazma modunda açmak için 'fopen' fonksiyonunda \"r+\" ya da \"w+\" modları kullanılabilir. İşte bu modlarla açmanın örneği:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r+\"); // Dosyayı okuma ve yazma modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // Veri okuma\n    char line[256];\n    fgets(line, sizeof(line), file);\n    printf(\"Okunan: %s\", line);\n\n    // Yazma işlemi\n    fseek(file, 0, SEEK_SET); // Başlangıca dön\n    fputs(\"Yeni veri.\", file);\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'data.txt' dosyasını okuma ve yazma modunda açar. Dikkat edilmesi gereken, dosyanın konumunu değiştirmek için 'fseek' fonksiyonunu kullanmaktır.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265394"
  },
  {
    "question": "Bir dosyanın sonuna veri eklemek için hangi yöntemleri kullanabilirsiniz? Örnek kod ile açıklayın.",
    "answer": "Bir dosyanın sonuna veri eklemek için 'a' veya 'a+' modları kullanılır. Bu modlar, dosya açıldığında sonuna ekleme yapar. Aşağıdaki örnek, bir dosyaya veri eklemeyi göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"append.txt\", \"a\"); // Dosyayı ekleme modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    fputs(\"Yeni satır ekleniyor.\\n\", file); // Dosyanın sonuna ekle\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'append.txt' dosyasının sonuna bir satır ekler.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265422"
  },
  {
    "question": "Bir dosyadan okunan veriyi nasıl güncelleyebilirsiniz? Örnek kod ile açıklayın.",
    "answer": "Bir dosyadan okunan veriyi güncellemek için, genellikle dosyayı okuma ve yazma modunda açmak gerekir. Aşağıdaki örnek, bir dosyadaki satırı güncellemeyi gösterir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"update.txt\", \"r+\" ); // Dosyayı okuma ve yazma modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    // İlk satırı oku\n    char line[256];\n    fgets(line, sizeof(line), file);\n    printf(\"Okunan: %s\", line);\n\n    // Güncelleme işlemi\n    fseek(file, 0, SEEK_SET); // Başlangıca dön\n    fputs(\"Güncellenmiş veri.\\n\", file);\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'update.txt' dosyasındaki ilk satırı okur ve günceller.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265446"
  },
  {
    "question": "Bir dosyayı ikili modda nasıl açıp veri yazabilirsiniz? Örnek kod ile açıklayın.",
    "answer": "İkili modda dosya açmak, veriyi byte olarak okumak ve yazmak için kullanılır. 'wb' modunu kullanarak bir dosyaya veri yazabilirsiniz. Aşağıdaki örnek, ikili modda veri yazmayı göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Record;\n\nint main() {\n    FILE *file = fopen(\"records.dat\", \"wb\"); // İkili modda dosya aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    Record record = {1, \"John Doe\"};\n    fwrite(&record, sizeof(Record), 1, file); // Veriyi yaz\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'records.dat' dosyasına bir 'Record' yapısını ikili formatta yazar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265471"
  },
  {
    "question": "Dosyadan okunan verilerin hata kontrolü nasıl yapılır? Örnek kod ile açıklayın.",
    "answer": "Dosyadan okunan verilerin hata kontrolü yapmak için, 'fgets' veya 'fread' fonksiyonlarının dönüş değerleri kontrol edilmelidir. Aşağıdaki örnek, dosyadan okuma sırasında hata kontrolü yapmayı göstermektedir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\"); // Dosyayı okuma modunda aç\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    char line[256];\n    if (fgets(line, sizeof(line), file) != NULL) {\n        printf(\"Okunan: %s\", line);\n    } else {\n        perror(\"Satır okunamadı\");\n    }\n\n    fclose(file); // Dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'data.txt' dosyasından bir satır okur ve hata durumunu kontrol eder.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265495"
  },
  {
    "question": "Bir dosyayı kopyalamak için nasıl bir algoritma izleyebilirsiniz? Örnek kod ile açıklayın.",
    "answer": "Dosya kopyalamak için, kaynak dosyayı okuma modunda açıp, hedef dosyayı yazma modunda açarak verileri kopyalayabilirsiniz. İşte örnek:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *src = fopen(\"source.txt\", \"rb\"); // Kaynak dosyayı aç\n    if (src == NULL) {\n        perror(\"Kaynak dosya açılamadı\");\n        return EXIT_FAILURE;\n    }\n\n    FILE *dest = fopen(\"destination.txt\", \"wb\"); // Hedef dosyayı aç\n    if (dest == NULL) {\n        perror(\"Hedef dosya açılamadı\");\n        fclose(src);\n        return EXIT_FAILURE;\n    }\n\n    char buffer[1024];\n    size_t bytesRead;\n    while ((bytesRead = fread(buffer, sizeof(char), sizeof(buffer), src)) > 0) {\n        fwrite(buffer, sizeof(char), bytesRead, dest); // Verileri kopyala\n    }\n\n    fclose(src); // Kaynak dosyayı kapat\n    fclose(dest); // Hedef dosyayı kapat\n    return EXIT_SUCCESS;\n}\n```\nBu kod, 'source.txt' dosyasını okur ve 'destination.txt' dosyasına kopyalar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:16.265540"
  },
  {
    "question": "Bir dosyayı okurken fgetc yerine fread kullanmanın avantajları nelerdir?",
    "answer": "fread, bir dosyadan daha büyük veri blokları okumak için optimize edilmiştir, bu da okuma işlemlerini hızlandırır. Örneğin, bir dosyayı satır satır okumak yerine, belirli bir boyutta bir buffer tanımlayıp fread ile okumak, I/O işlemlerinin sayısını azaltarak performansı artırabilir. Ek olarak, fread ile okunan veriler üzerinde doğrudan işlem yapma imkanı sunar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374354"
  },
  {
    "question": "fopen ile dosya açarken hata kontrolü yapmanın önemi nedir?",
    "answer": "fopen ile dosya açarken hata kontrolü yapmak, programın beklenmedik şekilde çökmesini önler. Dosyanın mevcut olmaması, izin sorunları veya başka I/O hataları gibi durumlarla karşılaşabilirsiniz. Örneğin: \n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (file == NULL) {\n    perror(\"Dosya açılamadı\");\n    return -1;\n}\n``` Bu şekilde hata durumu yönetilebilir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374393"
  },
  {
    "question": "Dosya stream'ini kapatmadan önce stream üzerinde buffered I/O kullanmanın olası etkileri nelerdir?",
    "answer": "Dosya stream'i kapatılmadan önce buffered I/O kullanmak, verilerin kaybolmasına neden olabilir. Örneğin, fwrite ile yazılan veriler buffer'da kalır ve flush edilmezse dosyaya yazılmaz. Bu nedenle, dosya stream'ini kapatmadan önce fflush fonksiyonu ile buffer'ı temizlemek önemlidir. Örnek: \n```c\nfflush(file);\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374425"
  },
  {
    "question": "Bir dosyanın içeriğini satır satır okumak için en uygun yöntem nedir?",
    "answer": "Dosya içeriğini satır satır okumak için fgets fonksiyonunu kullanmak en uygunudur. fgets, her defasında bir satırı okur ve buffer'da saklar. Örnek kullanım: \n```c\nchar buffer[100];\nwhile (fgets(buffer, sizeof(buffer), file) != NULL) {\n    printf(\"%s\", buffer);\n}\n``` Bu yöntem, büyük dosyaları yönetirken bellek verimliliği sağlar.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374450"
  },
  {
    "question": "Binary dosya okuma ve yazma ile metin dosyası okuma ve yazma arasındaki farklar nelerdir?",
    "answer": "Binary dosyada veriler doğrudan ikili formatta saklanırken, metin dosyasında veriler okunabilir karakterlerle saklanır. Binary dosyalar, dosya boyutunu azaltabilir ve okuma/yazma işlemlerinde daha hızlı olabilir. Yazım sırasında, binary modda açmak için 'b' eklemek gerekir, örneğin: `fopen(\"dosya.bin\", \"wb\");`.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374477"
  },
  {
    "question": "Bir dosyayı yazma modunda açarken mevcut dosya içeriğini silmenin en iyi yolu nedir?",
    "answer": "Yazma modunda (\"w\") dosya açıldığında mevcut dosya içeriği otomatik olarak silinir. Ancak, mevcut içeriği korumak istiyorsanız, append modunu (\"a\") kullanmalısınız. Örneğin: \n```c\nFILE *file = fopen(\"dosya.txt\", \"w\");\n``` ile dosyayı açmak, varsayılan olarak içeriği temizleyecektir.",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374519"
  },
  {
    "question": "fgets kullanırken buffer taşması olasılığını nasıl önleyebiliriz?",
    "answer": "fgets kullanırken buffer'ın boyutunu doğru bir şekilde ayarlamak ve her zaman buffer'a yazılacak maksimum karakter sayısını belirtmek önemlidir. Ayrıca, buffer'ı kontrol ederek okunan karakter sayısını takip etmek de iyi bir uygulamadır. Örnek: \n```c\nchar buffer[50];\nfgets(buffer, sizeof(buffer), file);\nif (strlen(buffer) == sizeof(buffer) - 1 && buffer[sizeof(buffer) - 2] != '\\n') {\n    printf(\"Buffer taşması riski var!\");\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374542"
  },
  {
    "question": "Dosya okumada hata yönetimi nasıl yapılmalıdır?",
    "answer": "Dosya okuma işlemleri sırasında hata yönetimi için, her okuma işlemi sonrası errno kontrol edilmelidir. Örneğin, fread veya fgets ile okunan veriler NULL dönerse, errno kontrol edilerek hata mesajı oluşturulabilir. Örnek: \n```c\nif (fgets(buffer, sizeof(buffer), file) == NULL) {\n    if (feof(file)) {\n        printf(\"Dosya sonuna ulaşıldı.\");\n    } else {\n        perror(\"Okuma hatası\");\n    }\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374561"
  },
  {
    "question": "fwrite ile yazma işlemi yaparken, kaç byte yazıldığını kontrol etmek neden önemlidir?",
    "answer": "fwrite ile yazma işlemi yapıldığında, yazılan byte sayısını kontrol etmek, beklenen verilerin dosyaya doğru bir şekilde yazıldığını doğrulamak için önemlidir. Eğer beklenenden az byte yazılmışsa, bir hata durumu olabilir. Örneğin: \n```c\nsize_t bytes_written = fwrite(data, sizeof(char), data_size, file);\nif (bytes_written < data_size) {\n    perror(\"Yazma hatası\");\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374589"
  },
  {
    "question": "Bir dosyanın sonuna ekleme yaparken hangi mod kullanılmalıdır?",
    "answer": "Bir dosyanın sonuna ekleme yapmak için append modunu (\"a\") kullanmalısınız. Bu modda dosya açıldığında mevcut içeriğe zarar verilmez ve yeni veriler dosyanın sonuna eklenir. Örnek: \n```c\nFILE *file = fopen(\"dosya.txt\", \"a\");\nfwrite(new_data, sizeof(char), data_size, file);\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:14:42.374611"
  },
  {
    "question": "C dilinde dosya stream'leri ile bir dosyayı okumak için en iyi yöntem nedir?",
    "answer": "Dosya okumak için genellikle 'fopen', 'fgets' ve 'fclose' fonksiyonları kullanılır. Aşağıdaki yöntemler önerilir: İlk olarak, dosyayı açmadan önce dosya yolunun geçerliliğini kontrol edin. Dosya açıldıktan sonra, okuma işlemi yaparken bir hata ile karşılaşırsanız hemen çıkış yapın. Örneğin:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (!file) {\n    perror(\"Dosya açılamadı\");\n    return 1;\n}\nchar buffer[256];\nwhile (fgets(buffer, sizeof(buffer), file)) {\n    // buffer üzerinde işlem yap\n}\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547454"
  },
  {
    "question": "Dosya stream'inde bellek yönetimini nasıl optimize edersiniz?",
    "answer": "Bellek yönetimini optimize etmek için dosya okuma ve yazma işlemlerini tampon bellekte biriktirerek gerçekleştirebilirsiniz. Bunu yaparken, uygun bellek boyutunu seçmek önemlidir. 'fread' ve 'fwrite' fonksiyonları ile tampon belleği kullanarak performansı artırabilirsiniz. Örnek: \n\n```c\nsize_t read_size;\nchar buffer[1024];\nFILE *file = fopen(\"dosya.bin\", \"rb\");\nif (file) {\n    while ((read_size = fread(buffer, 1, sizeof(buffer), file)) > 0) {\n        // buffer üzerinde işlem yap\n    }\nfclose(file);\n}```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547494"
  },
  {
    "question": "Bir dosyaya yazarken 'fwrite' yerine 'fprintf' kullanmak ne kadar mantıklı?",
    "answer": "'fwrite', ikili verileri yazmak için kullanılırken; 'fprintf' formatlı metin yazmak için kullanılır. Eğer yazılacak veriler metin değilse, 'fwrite' daha hızlıdır. Ancak formatlı veri gerekiyorsa 'fprintf' kullanmalısınız. Örnek:\n\n```c\nint number = 42;\nFILE *file = fopen(\"output.txt\", \"w\");\nif (file) {\n    fprintf(file, \"Sayı: %d\\n\", number);\n    fclose(file);\n}```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547560"
  },
  {
    "question": "Dosya stream'lerinde hata kontrolü nasıl yapılmalıdır?",
    "answer": "Her dosya işlemi sonrası hata kontrolü yapmak önemlidir. 'fopen', 'fgets' ve 'fwrite' gibi fonksiyonların dönüş değerlerini kontrol ederek hata durumunu tespit edebilirsiniz. Örnek:\n\n```c\nFILE *file = fopen(\"dosya.txt\", \"r\");\nif (!file) {\n    fprintf(stderr, \"Dosya açılamadı: %s\\n\", strerror(errno));\n    return 1;\n}\n// okuma işlemi\nif (ferror(file)) {\n    fprintf(stderr, \"Okuma sırasında hata oluştu\\n\");\n}\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547585"
  },
  {
    "question": "Çoklu dosya stream'leri kullanmanın avantajları nelerdir?",
    "answer": "Çoklu dosya stream'leri kullanmak, paralel işlemler yapmanıza olanak tanır. Örneğin, birden fazla dosyadan veri okuyabilir veya birden fazla dosyaya veri yazabilirsiniz. Bu, özellikle büyük veri setleriyle çalışırken performansı artırır. Örnek:\n\n```c\nFILE *file1 = fopen(\"dosya1.txt\", \"r\");\nFILE *file2 = fopen(\"dosya2.txt\", \"r\");\nif (file1 && file2) {\n    // her iki dosyadan okuma işlemi\n}\nfclose(file1);\nfclose(file2);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547612"
  },
  {
    "question": "Dosya stream'lerini kapatmanın en iyi uygulamaları nelerdir?",
    "answer": "Dosya stream'lerini kapatırken 'fclose' fonksiyonu kullanılmalıdır ve kapatma işlemi her zaman kontrol edilmelidir. Ayrıca, her dosya açma işlemi için bir 'fclose' çağrısı yapılmalıdır. Örnek:\n\n```c\nFILE *file = fopen(\"output.txt\", \"w\");\nif (file) {\n    // yazma işlemleri\n    if (fclose(file) != 0) {\n        perror(\"Dosya kapatılamadı\");\n    }\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547636"
  },
  {
    "question": "File stream'leri ile çoklu thread kullanımı nasıl yönetilir?",
    "answer": "Çoklu thread kullanırken, dosya stream'lerini senkronize etmek için mutex kullanmanız önerilir. Bu, aynı dosya üzerinde birden fazla thread'in aynı anda işlem yapmasını önler. Örnek:\n\n```c\npthread_mutex_t lock;\nvoid *thread_func(void *arg) {\n    pthread_mutex_lock(&lock);\n    FILE *file = fopen(\"output.txt\", \"a\");\n    // yazma işlemleri\n    fclose(file);\n    pthread_mutex_unlock(&lock);\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547658"
  },
  {
    "question": "Büyük dosyaların okunması ve yazılması sırasında performansı artırmak için hangi yöntemleri kullanmalıyız?",
    "answer": "Büyük dosyaları işlerken, alternatif tampon boyutları kullanarak 'fread' ve 'fwrite' gibi fonksiyonları tercih edin. Ayrıca dosyayı parçalara bölerken uygun boyutlar seçmek ve bellekle ilgili işlemleri minimize etmek önemlidir. Örnek:\n\n```c\n#define BUFFER_SIZE 4096\nchar buffer[BUFFER_SIZE];\nFILE *file = fopen(\"largefile.dat\", \"rb\");\nsize_t bytes;\nif (file) {\n    while ((bytes = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {\n        // buffer üzerinde işlem yap\n    }\nfclose(file);\n}```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547696"
  },
  {
    "question": "DOSYA_MODE parametrelerinin doğru kullanımı hakkında bilgi verir misiniz?",
    "answer": "Dosya açma modları, dosyanın nasıl kullanılacağını belirler. Örneğin, \"r\" okuma, \"w\" yazma ve \"a\" ekleme modlarını ifade eder. Belirlenen mod, dosya üzerindeki izinleri etkiler. Yanlış mod seçimi verilerin kaybolmasına neden olabilir. Örnek:\n\n```c\nFILE *file = fopen(\"output.txt\", \"w+\"); // hem okuma hem yazma\nif (file) {\n    // yazma ve okuma işlemleri\n}\nfclose(file);\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547719"
  },
  {
    "question": "Buffer overflow hatalarını önlemek için dosya stream'lerinde hangi yöntemleri uygulamalıyız?",
    "answer": "Buffer overflow hatalarını önlemek için, okuma ve yazma işlemlerinde her zaman tam boyut kontrolü yapmalısınız. 'fgets' veya 'fread' gibi fonksiyonları kullanırken, tampon boyutunu aşmamaya dikkat edin. Örnek:\n\n```c\nchar buffer[256];\nFILE *file = fopen(\"input.txt\", \"r\");\nif (file) {\n    if (fgets(buffer, sizeof(buffer), file) == NULL) {\n        perror(\"Okuma hatası\");\n    }\n    fclose(file);\n}\n```",
    "category": "file_operations",
    "topic": "file_streams",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Dosya stream'leri",
    "timestamp": "2025-06-01T17:15:08.547746"
  },
  {
    "question": "Bir öğrencinin adını, yaşını ve notunu tutmak için bir struct yapısı oluşturun ve bir örnek öğrenci tanımlayıp bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Ogrenci {\n    char ad[50];\n    int yas;\n    float not;\n};\n\nint main() {\n    struct Ogrenci ogrenci1 = {\"Ahmet\", 20, 85.5};\n    printf(\"Öğrenci Adı: %s\\n\", ogrenci1.ad);\n    printf(\"Yaşı: %d\\n\", ogrenci1.yas);\n    printf(\"Notu: %.2f\\n\", ogrenci1.not);\n    return 0;\n}\n\n// Bu kod, bir öğrencinin bilgilerini saklamak için bir struct tanımlamakta ve örnek bir öğrenci oluşturmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812181"
  },
  {
    "question": "Bir kitabın başlığını, yazarını ve sayfa sayısını tutan bir struct oluşturun ve bu struct ile bir kitap tanımlayıp bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Kitap {\n    char baslik[100];\n    char yazar[50];\n    int sayfaSayisi;\n};\n\nint main() {\n    struct Kitap kitap1 = {\"Savaş ve Barış\", \"Lev Tolstoy\", 1200};\n    printf(\"Kitap Başlığı: %s\\n\", kitap1.baslik);\n    printf(\"Yazarı: %s\\n\", kitap1.yazar);\n    printf(\"Sayfa Sayısı: %d\\n\", kitap1.sayfaSayisi);\n    return 0;\n}\n\n// Bu örnek, bir kitabın bilgilerini tutan bir struct yapısını içermektedir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812244"
  },
  {
    "question": "Bir aracın markasını, modelini ve üretim yılını saklamak için bir struct tanımlayın ve bir araç oluşturup bilgilerini ekrana yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Arac {\n    char marka[50];\n    char model[50];\n    int uretimYili;\n};\n\nint main() {\n    struct Arac arac1 = {\"Toyota\", \"Corolla\", 2020};\n    printf(\"Araç Markası: %s\\n\", arac1.marka);\n    printf(\"Modeli: %s\\n\", arac1.model);\n    printf(\"Üretim Yılı: %d\\n\", arac1.uretimYili);\n    return 0;\n}\n\n// Bu kod, bir aracın bilgilerini tutmak için bir struct kullanmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812282"
  },
  {
    "question": "Bir çalışan için ad, soyad ve maaş bilgilerini tutan bir struct tanımlayın, bir çalışan oluşturup bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Calisan {\n    char ad[50];\n    char soyad[50];\n    float maas;\n};\n\nint main() {\n    struct Calisan calisan1 = {\"Ayşe\", \"Yılmaz\", 5000.0};\n    printf(\"Çalışan Adı: %s\\n\", calisan1.ad);\n    printf(\"Soyadı: %s\\n\", calisan1.soyad);\n    printf(\"Maaşı: %.2f\\n\", calisan1.maas);\n    return 0;\n}\n\n// Bu örnek, bir çalışanın bilgilerini tutmak için bir struct yapısı oluşturmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812316"
  },
  {
    "question": "Bir film için başlık, yönetmen ve yıl bilgilerini tutan bir struct oluşturun ve bir film örneği tanımlayıp bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Film {\n    char baslik[100];\n    char yonetmen[50];\n    int yil;\n};\n\nint main() {\n    struct Film film1 = {\"Inception\", \"Christopher Nolan\", 2010};\n    printf(\"Film Başlığı: %s\\n\", film1.baslik);\n    printf(\"Yönetmeni: %s\\n\", film1.yonetmen);\n    printf(\"Yılı: %d\\n\", film1.yil);\n    return 0;\n}\n\n// Bu kod, bir filmin bilgilerini saklamak için bir struct tanımlamaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812351"
  },
  {
    "question": "Bir müzik albümü için ad, sanatçı ve yıl bilgilerini saklayan bir struct oluşturun ve bir albüm örneği tanımlayıp bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Albüm {\n    char ad[100];\n    char sanatci[50];\n    int yil;\n};\n\nint main() {\n    struct Albüm album1 = {\"Thriller\", \"Michael Jackson\", 1982};\n    printf(\"Albüm Adı: %s\\n\", album1.ad);\n    printf(\"Sanatçı: %s\\n\", album1.sanatci);\n    printf(\"Yılı: %d\\n\", album1.yil);\n    return 0;\n}\n\n// Bu örnek, bir müzik albümünün bilgilerini tutan bir struct yapısını içermektedir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812388"
  },
  {
    "question": "Bir telefon numarası ve e-posta adresini tutan bir struct tanımlayın ve bir iletişim bilgisi örneği oluşturarak bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Iletisim {\n    char telefon[15];\n    char email[50];\n};\n\nint main() {\n    struct Iletisim kisi1 = {\"+90 555 555 55 55\", \"example@example.com\"};\n    printf(\"Telefon: %s\\n\", kisi1.telefon);\n    printf(\"E-posta: %s\\n\", kisi1.email);\n    return 0;\n}\n\n// Bu kod, bir kişinin iletişim bilgilerini saklamak için bir struct tanımlamaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812423"
  },
  {
    "question": "Bir bilgisayar için marka, model ve RAM miktarını tutan bir struct oluşturun ve bir bilgisayar tanımlayıp bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Bilgisayar {\n    char marka[50];\n    char model[50];\n    int ram;\n};\n\nint main() {\n    struct Bilgisayar pc1 = {\"Lenovo\", \"Legion 5\", 16};\n    printf(\"Bilgisayar Markası: %s\\n\", pc1.marka);\n    printf(\"Modeli: %s\\n\", pc1.model);\n    printf(\"RAM Miktarı: %d GB\\n\", pc1.ram);\n    return 0;\n}\n\n// Bu örnek, bir bilgisayarın bilgilerini tutmak için bir struct oluşturmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812461"
  },
  {
    "question": "Bir hayvan için adı, türü ve yaşı bilgilerini tutan bir struct tanımlayın ve bir hayvan örneği oluşturarak bilgilerini yazdırın.",
    "answer": "#include <stdio.h>\n\nstruct Hayvan {\n    char ad[50];\n    char tur[50];\n    int yas;\n};\n\nint main() {\n    struct Hayvan hayvan1 = {\"Karabaş\", \"Köpek\", 5};\n    printf(\"Hayvan Adı: %s\\n\", hayvan1.ad);\n    printf(\"Türü: %s\\n\", hayvan1.tur);\n    printf(\"Yaşı: %d\\n\", hayvan1.yas);\n    return 0;\n}\n\n// Bu kod, bir hayvanın bilgilerini saklamak için bir struct yapısını içermektedir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:15:42.812496"
  },
  {
    "question": "Bir öğrenci bilgisini tutan bir struct tanımlayın ve bu struct kullanarak bir öğrencinin bilgilerini ekrana yazdıran bir fonksiyon oluşturun. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Ogrenci {\n    char isim[50];\n    int numara;\n    float notOrtalamasi;\n};\n\nvoid ogrenciBilgileriniYazdir(struct Ogrenci og) {\n    printf(\"Öğrenci İsmi: %s\\n\", og.isim);\n    printf(\"Öğrenci Numarası: %d\\n\", og.numara);\n    printf(\"Not Ortalaması: %.2f\\n\", og.notOrtalamasi);\n}\n\nint main() {\n    struct Ogrenci ogr;\n    // Eksik kısım: Öğrenci bilgilerini giriyoruz\n    printf(\"Öğrenci ismini girin: \");\n    scanf(\"%s\", ogr.isim);\n    printf(\"Öğrenci numarasını girin: \");\n    scanf(\"%d\", &ogr.numara);\n    printf(\"Not ortalamasını girin: \");\n    scanf(\"%f\", &ogr.notOrtalamasi);\n\n    ogrenciBilgileriniYazdir(ogr);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705450"
  },
  {
    "question": "Bir kitap bilgilerini tutan bir struct tanımlayın ve bir dizi kitap oluşturun. Daha sonra bu kitapların bilgilerini ekrana yazdırın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Kitap {\n    char baslik[100];\n    char yazar[50];\n    int sayfaSayisi;\n};\n\nvoid kitapBilgileriniYazdir(struct Kitap kitap) {\n    printf(\"Kitap Başlığı: %s\\n\", kitap.baslik);\n    printf(\"Yazar: %s\\n\", kitap.yazar);\n    printf(\"Sayfa Sayısı: %d\\n\", kitap.sayfaSayisi);\n}\n\nint main() {\n    struct Kitap kitaplar[3];\n    // Eksik kısım: Kitap bilgilerini alıyoruz\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d. Kitap Başlığını girin: \", i + 1);\n        scanf(\"%s\", kitaplar[i].baslik);\n        printf(\"%d. Yazar ismini girin: \", i + 1);\n        scanf(\"%s\", kitaplar[i].yazar);\n        printf(\"%d. Sayfa sayısını girin: \", i + 1);\n        scanf(\"%d\", &kitaplar[i].sayfaSayisi);\n    }\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"\\nKitap %d Bilgileri:\\n\", i + 1);\n        kitapBilgileriniYazdir(kitaplar[i]);\n    }\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705558"
  },
  {
    "question": "Bir otomobil bilgilerini tutan bir struct tanımlayın ve bu struct içindeki bilgileri güncelleyen bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Otomobil {\n    char marka[50];\n    char model[50];\n    int yil;\n};\n\nvoid otomobilBilgileriniGuncelle(struct Otomobil *oto, char *yeniMarka, char *yeniModel, int yeniYil) {\n    // Eksik kısım: Bilgileri güncelleyelim\n    strcpy(oto->marka, yeniMarka);\n    strcpy(oto->model, yeniModel);\n    oto->yil = yeniYil;\n}\n\nint main() {\n    struct Otomobil oto;\n    strcpy(oto.marka, \"Ford\");\n    strcpy(oto.model, \"Focus\");\n    oto.yil = 2015;\n\n    printf(\"Otomobil Bilgileri:\\n\");\n    printf(\"Marka: %s, Model: %s, Yıl: %d\\n\", oto.marka, oto.model, oto.yil);\n\n    otomobilBilgileriniGuncelle(&oto, \"Toyota\", \"Corolla\", 2020);\n    printf(\"Güncellenmiş Otomobil Bilgileri:\\n\");\n    printf(\"Marka: %s, Model: %s, Yıl: %d\\n\", oto.marka, oto.model, oto.yil);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705644"
  },
  {
    "question": "Bir çalışan bilgilerini tutan bir struct tanımlayın ve bu çalışanların toplam maaşını hesaplayan bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Calisan {\n    char isim[50];\n    float maas;\n};\n\nfloat toplamMaas(struct Calisan calisanlar[], int sayi) {\n    float toplam = 0;\n    for (int i = 0; i < sayi; i++) {\n        toplam += calisanlar[i].maas;\n    }\n    return toplam;\n}\n\nint main() {\n    struct Calisan calisanlar[3];\n    // Eksik kısım: Çalışan bilgilerini alıyoruz\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d. Çalışan ismini girin: \", i + 1);\n        scanf(\"%s\", calisanlar[i].isim);\n        printf(\"%d. Maaşını girin: \", i + 1);\n        scanf(\"%f\", &calisanlar[i].maas);\n    }\n\n    printf(\"Toplam Maaş: %.2f\\n\", toplamMaas(calisanlar, 3));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705709"
  },
  {
    "question": "Bir ürün bilgilerini tutan bir struct tanımlayın ve bu ürünlerin fiyatlarını listeleyen bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Urun {\n    char isim[50];\n    float fiyat;\n};\n\nvoid urunFiyatlariniListele(struct Urun urunler[], int sayi) {\n    for (int i = 0; i < sayi; i++) {\n        printf(\"Ürün: %s, Fiyat: %.2f\\n\", urunler[i].isim, urunler[i].fiyat);\n    }\n}\n\nint main() {\n    struct Urun urunler[3];\n    // Eksik kısım: Ürün bilgilerini alıyoruz\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d. Ürün ismini girin: \", i + 1);\n        scanf(\"%s\", urunler[i].isim);\n        printf(\"%d. Fiyatını girin: \", i + 1);\n        scanf(\"%f\", &urunler[i].fiyat);\n    }\n\n    printf(\"Ürün Fiyatları:\\n\");\n    urunFiyatlariniListele(urunler, 3);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705772"
  },
  {
    "question": "Bir film bilgilerini tutan bir struct tanımlayın ve bu filmlerin ortalama puanını hesaplayan bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Film {\n    char ad[100];\n    float puan;\n};\n\nfloat ortalamaPuan(struct Film filmler[], int sayi) {\n    float toplam = 0;\n    for (int i = 0; i < sayi; i++) {\n        toplam += filmler[i].puan;\n    }\n    return toplam / sayi;\n}\n\nint main() {\n    struct Film filmler[3];\n    // Eksik kısım: Film bilgilerini alıyoruz\n    for (int i = 0; i < 3; i++) {\n        printf(\"%d. Film adını girin: \", i + 1);\n        scanf(\"%s\", filmler[i].ad);\n        printf(\"%d. Puanını girin: \", i + 1);\n        scanf(\"%f\", &filmler[i].puan);\n    }\n\n    printf(\"Ortalama Puan: %.2f\\n\", ortalamaPuan(filmler, 3));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705838"
  },
  {
    "question": "Bir öğrenci kaydını tutan bir struct tanımlayın ve bu kaydı dosyaya yazan bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Ogrenci {\n    char isim[50];\n    int numara;\n    float notOrtalamasi;\n};\n\nvoid dosyayaYaz(struct Ogrenci og) {\n    FILE *dosya = fopen(\"ogrenci.txt\", \"a\");\n    // Eksik kısım: Öğrenci bilgilerini dosyaya yazıyoruz\n    fprintf(dosya, \"İsim: %s, Numara: %d, Not Ortalaması: %.2f\\n\", og.isim, og.numara, og.notOrtalamasi);\n    fclose(dosya);\n}\n\nint main() {\n    struct Ogrenci ogr;\n    printf(\"Öğrenci ismini girin: \");\n    scanf(\"%s\", ogr.isim);\n    printf(\"Öğrenci numarasını girin: \");\n    scanf(\"%d\", &ogr.numara);\n    printf(\"Not ortalamasını girin: \");\n    scanf(\"%f\", &ogr.notOrtalamasi);\n\n    dosyayaYaz(ogr);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705899"
  },
  {
    "question": "Bir adres bilgilerini tutan bir struct tanımlayın ve bu adresleri karşılaştıran bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nstruct Adres {\n    char sokak[100];\n    char sehir[50];\n    int postaKodu;\n};\n\nint adresiKarsilastir(struct Adres a1, struct Adres a2) {\n    // Eksik kısım: Adresleri karşılaştırıyoruz\n    return strcmp(a1.sokak, a2.sokak) == 0 && strcmp(a1.sehir, a2.sehir) == 0 && a1.postaKodu == a2.postaKodu;\n}\n\nint main() {\n    struct Adres adres1, adres2;\n    printf(\"1. Adresi girin (sokak, sehir, posta kodu): \");\n    scanf(\"%s %s %d\", adres1.sokak, adres1.sehir, &adres1.postaKodu);\n    printf(\"2. Adresi girin (sokak, sehir, posta kodu): \");\n    scanf(\"%s %s %d\", adres2.sokak, adres2.sehir, &adres2.postaKodu);\n\n    if (adresiKarsilastir(adres1, adres2)) {\n        printf(\"Adresler aynıdır.\\n\");\n    } else {\n        printf(\"Adresler farklıdır.\\n\");\n    }\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.705960"
  },
  {
    "question": "Bir öğrenci notlarını tutan bir struct tanımlayın ve en yüksek notu bulan bir fonksiyon yazın. Eksik olan kısmı tamamlayın.",
    "answer": "#include <stdio.h>\n\nstruct Ogrenci {\n    char isim[50];\n    float notlar[5];\n};\n\nfloat enYuksekNot(struct Ogrenci og) {\n    float max = og.notlar[0];\n    for (int i = 1; i < 5; i++) {\n        // Eksik kısım: En yüksek notu buluyoruz\n        if (og.notlar[i] > max) {\n            max = og.notlar[i];\n        }\n    }\n    return max;\n}\n\nint main() {\n    struct Ogrenci ogr;\n    printf(\"Öğrenci ismini girin: \");\n    scanf(\"%s\", ogr.isim);\n    for (int i = 0; i < 5; i++) {\n        printf(\"Not %d'i girin: \", i + 1);\n        scanf(\"%f\", &ogr.notlar[i]);\n    }\n\n    printf(\"En yüksek not: %.2f\\n\", enYuksekNot(ogr));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:16:39.706020"
  },
  {
    "question": "Bir kitaplık uygulaması için kitapları temsil eden bir struct tanımlayın. Kitap struct'ı yazar, başlık, yayın yılı ve ISBN numarası içermelidir. Ardından, bu struct'ı kullanarak bir kitap nesnesi oluşturun.",
    "answer": "```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Kitap {\n    char yazar[50];\n    char baslik[100];\n    int yayinYili;\n    char isbn[20];\n};\n\nint main() {\n    struct Kitap kitap1;\n    strcpy(kitap1.yazar, \"George Orwell\");\n    strcpy(kitap1.baslik, \"1984\");\n    kitap1.yayinYili = 1949;\n    strcpy(kitap1.isbn, \"978-0451524935\");\n    printf(\"Kitap: %s, Yazar: %s, Yıl: %d, ISBN: %s\\n\", kitap1.baslik, kitap1.yazar, kitap1.yayinYili, kitap1.isbn);\n    return 0;\n}\n``` Bu örnekte, kitap bilgilerini tutan bir struct tanımladık ve ardından bu struct'tan bir nesne oluşturup bilgilerini yazdırdık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.440758"
  },
  {
    "question": "Bir otomobil veritabanı oluşturmak için bir otomobil struct'ı tanımlayın. Bu struct, marka, model, yıl ve motor hacmi gibi bilgileri içermelidir. Ardından bu bilgileri tutan bir dizi oluşturun.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Otomobil {\n    char marka[30];\n    char model[30];\n    int yil;\n    float motorHacmi;\n};\n\nint main() {\n    struct Otomobil arabalar[3];\n\n    // İlk otomobili tanımlıyoruz\n    strcpy(arabalar[0].marka, \"Toyota\");\n    strcpy(arabalar[0].model, \"Corolla\");\n    arabalar[0].yil = 2020;\n    arabalar[0].motorHacmi = 1.8;\n\n    // İkinci otomobili tanımlıyoruz\n    strcpy(arabalar[1].marka, \"Ford\");\n    strcpy(arabalar[1].model, \"Focus\");\n    arabalar[1].yil = 2019;\n    arabalar[1].motorHacmi = 1.5;\n\n    // Üçüncü otomobili tanımlıyoruz\n    strcpy(arabalar[2].marka, \"Volkswagen\");\n    strcpy(arabalar[2].model, \"Golf\");\n    arabalar[2].yil = 2021;\n    arabalar[2].motorHacmi = 2.0;\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"%s %s - Yıl: %d, Motor Hacmi: %.1f\\n\", arabalar[i].marka, arabalar[i].model, arabalar[i].yil, arabalar[i].motorHacmi);\n    }\n    return 0;\n}\n``` Bu örnekte, üç otomobil hakkında bilgi tutan bir dizi oluşturarak veritabanı benzeri bir yapı oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.440827"
  },
  {
    "question": "Bir öğrenci not takip sistemi için öğrenci struct'ı oluşturun. Bu struct, öğrencinin adı, soyadı, öğrenci numarası ve notlar dizisini içermelidir. Ayrıca, bir fonksiyon ile öğrencinin not ortalamasını hesaplayın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Ogrenci {\n    char ad[30];\n    char soyad[30];\n    int ogrenciNo;\n    float notlar[5];\n};\n\nfloat notOrtalamasi(struct Ogrenci o) {\n    float toplam = 0;\n    for (int i = 0; i < 5; i++) {\n        toplam += o.notlar[i];\n    }\n    return toplam / 5;\n}\n\nint main() {\n    struct Ogrenci ogrenci1;\n    strcpy(ogrenci1.ad, \"Ali\");\n    strcpy(ogrenci1.soyad, \"Veli\");\n    ogrenci1.ogrenciNo = 123;\n    ogrenci1.notlar[0] = 85;\n    ogrenci1.notlar[1] = 90;\n    ogrenci1.notlar[2] = 78;\n    ogrenci1.notlar[3] = 92;\n    ogrenci1.notlar[4] = 88;\n\n    printf(\"Öğrenci: %s %s, No: %d, Not Ortalaması: %.2f\\n\", ogrenci1.ad, ogrenci1.soyad, ogrenci1.ogrenciNo, notOrtalamasi(ogrenci1));\n    return 0;\n}\n``` Bu örnekte, bir öğrencinin bilgilerini tutan bir struct tanımladık ve not ortalamasını hesaplayan bir fonksiyon oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.440910"
  },
  {
    "question": "Bir alışveriş uygulaması için ürünleri temsil eden bir struct oluşturun. Ürün struct'ı ad, fiyat ve stok miktarını içermelidir. Ayrıca, ürünleri listeleyen bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Urun {\n    char ad[50];\n    float fiyat;\n    int stokMiktari;\n};\n\nvoid urunListele(struct Urun u) {\n    printf(\"Ürün: %s, Fiyat: %.2f, Stok: %d\\n\", u.ad, u.fiyat, u.stokMiktari);\n}\n\nint main() {\n    struct Urun urun1;\n    strcpy(urun1.ad, \"Laptop\");\n    urun1.fiyat = 7500.00;\n    urun1.stokMiktari = 10;\n\n    struct Urun urun2;\n    strcpy(urun2.ad, \"Akıllı Telefon\");\n    urun2.fiyat = 3000.00;\n    urun2.stokMiktari = 15;\n\n    urunListele(urun1);\n    urunListele(urun2);\n    return 0;\n}\n``` Bu örnekte, ürün bilgilerini tutan bir struct oluşturduk ve bir fonksiyon ile ürünleri listeledik.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.440959"
  },
  {
    "question": "Bir oyun uygulaması için karakterleri temsil eden bir struct oluşturun. Bu struct, karakter adı, sağlık, güç ve seviye gibi bilgileri içermelidir. Karakterin bilgilerini güncelleyen bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Karakter {\n    char ad[50];\n    int saglik;\n    int guc;\n    int seviye;\n};\n\nvoid karakterGuncelle(struct Karakter *k, int saglik, int guc) {\n    k->saglik = saglik;\n    k->guc = guc;\n}\n\nint main() {\n    struct Karakter karakter1;\n    strcpy(karakter1.ad, \"Warrior\");\n    karakter1.saglik = 100;\n    karakter1.guc = 15;\n    karakter1.seviye = 1;\n\n    printf(\"Karakter: %s, Sağlık: %d, Güç: %d, Seviye: %d\\n\", karakter1.ad, karakter1.saglik, karakter1.guc, karakter1.seviye);\n\n    // Karakter bilgilerini güncelle\n    karakterGuncelle(&karakter1, 90, 20);\n    printf(\"Güncellenmiş - Karakter: %s, Sağlık: %d, Güç: %d, Seviye: %d\\n\", karakter1.ad, karakter1.saglik, karakter1.guc, karakter1.seviye);\n    return 0;\n}\n``` Bu örnekte, bir karakterin bilgilerini tutan bir struct tanımladık ve karakterin bilgilerini güncelleyen bir fonksiyon yazdık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.441014"
  },
  {
    "question": "Bir sosyal medya uygulaması için kullanıcıları temsil eden bir struct oluşturun. Kullanıcı struct'ı ad, soyad ve takipçi sayısını içermelidir. Takipçi sayısını artıran bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Kullanici {\n    char ad[30];\n    char soyad[30];\n    int takipciSayisi;\n};\n\nvoid takipciEkle(struct Kullanici *k) {\n    k->takipciSayisi++;\n}\n\nint main() {\n    struct Kullanici kullanici1;\n    strcpy(kullanici1.ad, \"Ayşe\");\n    strcpy(kullanici1.soyad, \"Yılmaz\");\n    kullanici1.takipciSayisi = 100;\n\n    printf(\"Kullanıcı: %s %s, Takipçi Sayısı: %d\\n\", kullanici1.ad, kullanici1.soyad, kullanici1.takipciSayisi);\n\n    // Takipçi ekle\n    takipciEkle(&kullanici1);\n    printf(\"Güncellenmiş Takipçi Sayısı: %d\\n\", kullanici1.takipciSayisi);\n    return 0;\n}\n``` Bu örnekte, kullanıcı bilgilerini tutan bir struct tanımladık ve takipçi sayısını artıran bir fonksiyon oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.441068"
  },
  {
    "question": "Bir hava durumu uygulaması için hava durumu verilerini temsil eden bir struct oluşturun. Bu struct, sıcaklık, nem ve rüzgar hızı gibi bilgileri içermelidir. Ayrıca, hava durumu bilgisini yazdıran bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct HavaDurumu {\n    float sicaklik;\n    int nem;\n    float ruzgarHizi;\n};\n\nvoid havaDurumuYazdir(struct HavaDurumu h) {\n    printf(\"Sıcaklık: %.2f °C, Nem: %d%%, Rüzgar Hızı: %.2f m/s\\n\", h.sicaklik, h.nem, h.ruzgarHizi);\n}\n\nint main() {\n    struct HavaDurumu bugun;\n    bugun.sicaklik = 25.5;\n    bugun.nem = 60;\n    bugun.ruzgarHizi = 5.0;\n\n    printf(\"Bugünkü Hava Durumu:\\n\");\n    havaDurumuYazdir(bugun);\n    return 0;\n}\n``` Bu örnekte, hava durumu bilgilerini tutan bir struct tanımladık ve hava durumu bilgisini yazdıran bir fonksiyon oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.441123"
  },
  {
    "question": "Bir bankacılık uygulaması için müşteri bilgilerini temsil eden bir struct oluşturun. Bu struct, müşteri adı, hesap bakiyesi ve hesap numarasını içermelidir. Müşterinin hesap bakiyesini güncelleyen bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Musteri {\n    char ad[50];\n    float hesapBakiyesi;\n    int hesapNo;\n};\n\nvoid hesapBakiyesiGuncelle(struct Musteri *m, float miktar) {\n    m->hesapBakiyesi += miktar;\n}\n\nint main() {\n    struct Musteri musteri1;\n    strcpy(musteri1.ad, \"Ahmet\");\n    musteri1.hesapBakiyesi = 1000.00;\n    musteri1.hesapNo = 123456;\n\n    printf(\"Müşteri: %s, Hesap No: %d, Bakiyesi: %.2f\\n\", musteri1.ad, musteri1.hesapNo, musteri1.hesapBakiyesi);\n\n    // Bakiyeyi güncelle\n    hesapBakiyesiGuncelle(&musteri1, 200.50);\n    printf(\"Güncellenmiş Bakiye: %.2f\\n\", musteri1.hesapBakiyesi);\n    return 0;\n}\n``` Bu örnekte, müşteri bilgilerini tutan bir struct tanımladık ve hesap bakiyesini güncelleyen bir fonksiyon oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.441190"
  },
  {
    "question": "Bir film veritabanı uygulaması için filmleri temsil eden bir struct oluşturun. Film struct'ı adı, yılı ve türü içermelidir. Belirli bir yılın filmlerini listeleyen bir fonksiyon yazın.",
    "answer": "```c\n#include <stdio.h>\n\nstruct Film {\n    char ad[100];\n    int yil;\n    char tur[30];\n};\n\nvoid filmListele(struct Film f) {\n    printf(\"Film: %s, Yıl: %d, Tür: %s\\n\", f.ad, f.yil, f.tur);\n}\n\nint main() {\n    struct Film filmler[3];\n\n    // Filmleri tanımlıyoruz\n    strcpy(filmler[0].ad, \"Inception\");\n    filmler[0].yil = 2010;\n    strcpy(filmler[0].tur, \"Bilim Kurgu\");\n\n    strcpy(filmler[1].ad, \"The Godfather\");\n    filmler[1].yil = 1972;\n    strcpy(filmler[1].tur, \"Suç\");\n\n    strcpy(filmler[2].ad, \"The Dark Knight\");\n    filmler[2].yil = 2008;\n    strcpy(filmler[2].tur, \"Aksiyon\");\n\n    printf(\"2008 Yılı Filmleri:\\n\");\n    for (int i = 0; i < 3; i++) {\n        if (filmler[i].yil == 2008) {\n            filmListele(filmler[i]);\n        }\n    }\n    return 0;\n}\n``` Bu örnekte, film bilgilerini tutan bir struct tanımladık ve belirli bir yılın filmlerini listeleyen bir fonksiyon oluşturduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:17:39.441238"
  },
  {
    "question": "Bir 'Person' yapısı tanımladım ama 'age' alanını atadığımda programım hata veriyor. Neden?",
    "answer": "Muhtemelen 'age' alanını tanımlarken ya da atama yaparken yanlış bir tür kullanıyorsunuz. 'age' alanını int olarak tanımladıysanız, int değer atamanız gerekir. Örnek: 'struct Person { char name[50]; int age; };' şeklinde tanımlayın ve 'p.age = 25;' gibi bir atama yapın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397698"
  },
  {
    "question": "'Book' yapısında 'title' ve 'author' alanlarını tanımladım ama bellekte karşılaştığım sorunlar var. Ne yapmalıyım?",
    "answer": "'title' ve 'author' için yeterince bellek ayırdığınızdan emin olun. Eğer char dizisi kullanıyorsanız, yeterli boyutta bir dizi tanımladığınızdan emin olun. Örnek: 'struct Book { char title[100]; char author[50]; };' şeklinde yeterli boyutta diziler tanımlayın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397752"
  },
  {
    "question": "'Car' yapımı için 'model' ve 'year' alanlarını yapı içerisinde tanımladım. Ancak 'year' alanını atarken hata alıyorum. Neden?",
    "answer": "'year' alanını tanımlarken int olarak tanımladığınızdan emin olun. Eğer yanlışlıkla bir karakter dizisi (char array) tanımladıysanız, bu durumda int değer atamaya çalışırken hata alırsınız. Doğru tanım: 'struct Car { char model[50]; int year; };' olmalıdır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397795"
  },
  {
    "question": "'Student' yapımda 'grades' alanım var ama bu alanı nasıl düzenleyeceğim hakkında bir fikrim yok. Hata veriyor.",
    "answer": "'grades' alanını uygun bir türde tanımlamalısınız. Eğer notları bir dizi olarak saklayacaksanız, 'float grades[5];' şeklinde bir dizi tanımlayabilirsiniz. Örnek: 'struct Student { char name[50]; float grades[5]; };'.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397830"
  },
  {
    "question": "'Employee' yapısında bir fonksiyonla çalışanları kaydetmeye çalışıyorum ama her seferinde aynı çalışanı kaydediyor. Sebebi ne olabilir?",
    "answer": "Muhtemelen yapının bir örneği üzerinde sürekli aynı adresi kullanıyorsunuz. Her yeni çalışanı kaydetmeden önce yeni bir 'Employee' yapısı oluşturmalısınız. Örneğin 'struct Employee e1, e2;' şeklinde tanımlayıp her birine farklı değerler atayın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397867"
  },
  {
    "question": "'Rectangle' yapımda 'length' ve 'width' alanları var ama bu alanların toplamını alırken yanlış sonuç alıyorum. Hata nerede?",
    "answer": "Muhtemelen 'length' ve 'width' alanlarını int olarak tanımladıysanız ve onları bir float değişkenine atıyorsanız, tam sayı kesirli bir değere dönüşebilir. Her iki alanı da float olarak tanımlayın: 'struct Rectangle { float length; float width; };'.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397940"
  },
  {
    "question": "'Musician' yapısında 'instruments' alanım var ama onu nasıl tanımlayacağımı bilemiyorum. Bellek hatası alıyorum.",
    "answer": "'instruments' alanı için bir dizi tanımlamanız gerekebilir. Örneğin, bir müzisyenin çaldığı enstrüman sayısını saklamak için 'char instruments[5][30];' şeklinde çok boyutlu bir dizi tanımlayabilirsiniz. Böylece bir müzisyenin birden fazla enstrümanı olabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.397973"
  },
  {
    "question": "'Movie' yapısında 'rating' alanı için float kullanmak istiyorum fakat atama yaparken hata alıyorum. Neden?",
    "answer": "'rating' alanını doğru bir şekilde tanımlamış olsanız bile, ona atama yaparken bir int veya char değeri atıyorsanız hata alırsınız. Doğru atama yapmalısınız: 'struct Movie { char title[100]; float rating; };' ve 'm.rating = 8.5;' şeklinde bir atama yapmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.398005"
  },
  {
    "question": "'Computer' yapımda 'RAM' ve 'storage' alanları var fakat bu alanlara erişim sağlayamıyorum. Hata neden kaynaklanıyor?",
    "answer": "Muhtemelen 'Computer' yapısının örneğini oluşturmadınız ya da yanlış bir şekilde erişim sağlıyorsunuz. Öncelikle bir 'Computer' örneği oluşturun: 'struct Computer myComputer; myComputer.RAM = 16;' gibi bir atama yapın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.398040"
  },
  {
    "question": "'Address' yapısı tanımladım ama 'city' alanını güncellerken programım çöküyor. Neden?",
    "answer": "Muhtemelen 'city' alanını bir char dizisi olarak tanımladığınızda, dizinin boyutunu belirtmeyi unuttunuz. Doğru bir tanım yapmalısınız: 'struct Address { char city[50]; };' şeklinde olmalıdır. Daha sonra 'strcpy(address.city, \"Istanbul\");' kullanarak güncelleme yapmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.398069"
  },
  {
    "question": "'Course' yapısında 'students' isimli bir dizi tanımladım ama onu nasıl kullanacağım hakkında bir fikrim yok. Hata alıyorum.",
    "answer": "'students' dizisini kullanırken, yapının boyutunu doğru ayarladığınızdan emin olun. Örneğin, 'struct Course { char name[50]; struct Student students[30]; };' şeklinde tanımlayabilirsiniz. Sonrasında her bir öğrenciyi erişmek için 'course.students[i]' şeklinde kullanın.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:00.398105"
  },
  {
    "question": "Bir 'Student' yapısı tanımladım, ancak bir nesne oluşturduğumda 'name' alanını nasıl atayacağımı bulamıyorum.",
    "answer": "Student yapısını tanımlarken, 'name' alanını bir string olarak belirlemelisiniz. Nesne oluşturduğunuzda, noktaya erişim operatörünü kullanarak alanı atayabilirsiniz. Örneğin: `struct Student { char name[50]; int age; };` ardından `struct Student student1; strcpy(student1.name, \"Ahmet\");` ile isim ataması yapabilirsiniz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.811983"
  },
  {
    "question": "Bir 'Book' yapısı içinde 'author' alanını kullanırken hata alıyorum. Nedenini bulamadım.",
    "answer": "Eğer author alanı bir string olarak tanımlanmadıysa veya yeterli bellek ayrılmadıysa hata alırsınız. Örneğin, `struct Book { char title[100]; char author[100]; };` şeklinde tanımlayıp bellek ayırdığınızdan emin olun. Ayrıca, `strcpy(book.author, \"Orhan Pamuk\");` şeklinde kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812027"
  },
  {
    "question": "Bir 'Car' yapısı oluşturduğumda, motor gücünü ve hızını atarken beklenmedik sonuçlar alıyorum.",
    "answer": "Motor gücü ve hız gibi alanlar için uygun veri türlerini kullanmalısınız. Örneğin, `struct Car { float horsepower; float speed; };` tanımlayıp değer atarken `car1.horsepower = 150.0; car1.speed = 200.0;` şeklinde kullanmalısınız. Eğer int yerine float kullanmazsanız değerler yanlış hesaplanabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812058"
  },
  {
    "question": "Bir 'Employee' yapısı içinde bir 'Date' yapısı kullanıyorum. İç içe yapı kullanırken nasıl erişim sağlanır?",
    "answer": "İç içe yapılar tanımlamak için önce 'Date' yapısını tanımlayıp ardından 'Employee' yapısında bunu kullanabilirsiniz. Örneğin: `struct Date { int day; int month; int year; }; struct Employee { char name[50]; struct Date hireDate; };` Erişim sağlarken `employee.hireDate.day = 15;` şeklinde kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812095"
  },
  {
    "question": "Struct içindeki bir dizi alanına nasıl erişeceğimi bulamıyorum. Örnek verir misin?",
    "answer": "Struct içinde dizi tanımlamak için diziyi struct içinde normal bir değişken gibi tanımlayın. Örneğin: `struct Classroom { char students[30][50]; int numStudents; };`. Diziye erişmek için `strcpy(classroom.students[0], \"Ali\");` şeklinde kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812123"
  },
  {
    "question": "Bir 'Rectangle' yapısı tanımladım ama alanı hesaplamak için fonksiyon yazarken erişim sorunları yaşıyorum.",
    "answer": "Eğer fonksiyon struct'ı parametre olarak alıyorsa, bu parametreyi doğru tanımlamak önemlidir. Örneğin: `struct Rectangle { float width; float height; }; float area(struct Rectangle rect) { return rect.width * rect.height; }`. Fonksiyonu çağırırken `float a = area(rectangle1);` olarak kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812153"
  },
  {
    "question": "Struct üzerinde bir fonksiyonla veri güncelleyemiyorum. Neden?",
    "answer": "Eğer struct'ı bir değer olarak geçiriyorsanız, fonksiyonda yapılan değişiklikler ana yapıyı etkilemez. Bunu çözmek için struct'ı referans (işaretçi) olarak geçirmelisiniz. Örneğin: `void updateAge(struct Student *s, int newAge) { s->age = newAge; }` şeklinde tanımlayıp `updateAge(&student1, 22);` şeklinde çağırmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812179"
  },
  {
    "question": "Birden fazla 'Point' yapısı kullanarak bir üçgen tanımladım ama alan hesaplamasında hata alıyorum.",
    "answer": "Üçgenin alanını hesaplamak için doğru formülü kullanmanız gerekir. Örneğin, üçgenin köşe noktalarını kullanarak: `float area(struct Point p1, struct Point p2, struct Point p3) { return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0); }` şeklinde tanımlayıp kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812209"
  },
  {
    "question": "Yapım sırasında bir 'Player' yapısının bir alanını sıfırlamak istiyorum, ancak bu işlem istediğim gibi çalışmıyor.",
    "answer": "Bir yapının tüm alanlarını sıfırlamak için `memset(player, 0, sizeof(struct Player));` kullanabilirsiniz. Bu, yapının bellekteki tüm alanlarını sıfırlar ve beklenen davranışı sağlar. Eğer sadece bir alanı sıfırlamak istiyorsanız, doğrudan `player.score = 0;` şeklinde yapmalısınız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812243"
  },
  {
    "question": "Bir 'Library' yapısı içinde 'Book' yapısını bir dizi olarak tanımladım ama kitap sayısını güncelleyemiyorum.",
    "answer": "Kitap sayısını güncelleyebilmek için dizinin boyutunu ve güncelleme işlemini doğru yapmalısınız. Örneğin: `struct Book { char title[100]; char author[100]; }; struct Library { struct Book books[100]; int bookCount; };` Kitap eklerken `library.bookCount++;` şeklinde güncelleyebilirsiniz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:22.812289"
  },
  {
    "question": "Bir struct tanımladıktan sonra bir üyesine erişirken 'incompatible pointer type' hatası alıyorum. Nedenini açıklayın ve nasıl düzeltebilirim.",
    "answer": "Bu hata genellikle struct üyesine yanlış bir tür ile erişmeye çalıştığınızda ortaya çıkar. Örneğin, struct içinde bir 'int' ve ona erişirken bir 'float' türü kullanıyorsanız, bu hata ile karşılaşırsınız. Düzeltmek için üyenizin tanımını ve erişim şeklinizi kontrol edin. Aşağıdaki gibi bir örnek düşünelim:\n\n```c\nstruct Person {\n    int age;\n    char name[50];\n};\n\nstruct Person p;\nfloat *ptr = &p.age; // Bu hatalıdır\n```\n\nHatanın çözümü için:\n\n```c\nint *ptr = &p.age; // Doğru erişim\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.027981"
  },
  {
    "question": "Struct'ımda dinamik bellek tahsisi kullanırken 'segmentation fault' hatası alıyorum. Bu hata neden ortaya çıkıyor?",
    "answer": "Segmentation fault hatası, genellikle bellek üzerinde geçersiz bir erişim yapıldığında ortaya çıkar. Örneğin, struct'ı tanımlarken bellek ayırmazsanız ve ona erişmeye çalışırsanız bu hatayı alırsınız. Düzeltmek için mutlaka struct'ı dinamik olarak tahsis edin:\n\n```c\nstruct Person {\n    int age;\n};\nstruct Person *p = malloc(sizeof(struct Person)); // Dinamik bellek tahsisi\nif (p == NULL) {\n    // Hata kontrolü\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028057"
  },
  {
    "question": "Bir struct'ın içinde başka bir struct tanımladım ama derleyici 'unknown type name' hatası veriyor. Neden?",
    "answer": "Bu hata, kullandığınız iç struct'ın daha önce tanımlanmamış olmasından kaynaklanır. İç içe struct'lar kullanırken, dış struct'ın içinde kullanacağınız iç struct'ın tanımlandığından emin olmalısınız. Örneğin:\n\n```c\nstruct Address {\n    char city[50];\n};\nstruct Person {\n    struct Address addr; // Bu noktada Address tanımlı olmalı\n};\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028114"
  },
  {
    "question": "Bir struct’a bir dizi atamaya çalıştığımda 'array type has incomplete element type' hatası alıyorum. Bunun sebebi nedir?",
    "answer": "Bu hata, struct içinde dizi tanımlarken boyutunu belirtmediğinizde ortaya çıkar. Struct içinde dizi kullanabilmek için boyut belirtmelisiniz. Aşağıdaki örneği inceleyelim:\n\n```c\nstruct Person {\n    char friends[10][50]; // Dizi boyutu belirtilmeli\n};\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028176"
  },
  {
    "question": "Struct'ımda pointer kullanarak bir üye değiştirirken 'dereferencing pointer to incomplete type' hatası alıyorum. Neden?",
    "answer": "Bu hata, struct tanımının tam olarak derleyiciye verilmediği durumlarda ortaya çıkar. Eğer bir pointer tanımlıyorsanız, ilgili struct'ın tam tanımı önceden yapılmalıdır. Örneğin:\n\n```c\nstruct Person;\nstruct Person *p;\n// Burada Person'ın tanımı eksik\n``` \n\nÇözüm için:\n\n```c\nstruct Person {\n    int age;\n};\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028233"
  },
  {
    "question": "Bir struct içerisine başka bir struct ve dizi eklediğimde bellek sızıntısı yaşıyorum, çözümü nedir?",
    "answer": "Bellek sızıntısı, dinamik olarak tahsis ettiğiniz belleği serbest bırakmadığınızda ortaya çıkar. Struct içinde dinamik bellek kullandığınızda, bellek tahsisinden sonra, kullanımı bitince free() ile belleği serbest bırakmalısınız. Örnek:\n\n```c\nstruct Person {\n    int *ages;\n};\nstruct Person *p = malloc(sizeof(struct Person));\np->ages = malloc(10 * sizeof(int));\n// Kullanım...\nfree(p->ages); // Belleği serbest bırak\nfree(p);\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028285"
  },
  {
    "question": "Struct'ımın bir üyesini sıfırlamaya çalışırken 'incompatible types' hatası alıyorum. Bu hatanın sebebi nedir?",
    "answer": "Bu hata, struct üyesinin türü ile sıfırlamaya çalıştığınız değerin uyumsuz olmasından kaynaklanır. Örneğin, bir 'char' üyesine 'int' ile değer atamaya çalışıyorsanız bu hata ortaya çıkar. Aşağıdaki gibi bir örnek düşünelim:\n\n```c\nstruct Person {\n    char name[50];\n};\nstruct Person p;\np.name = 0; // Hatalıdır\n``` \n\nÇözüm için:\n\n```c\nstrcpy(p.name, \"\"); // Doğru kullanım\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028340"
  },
  {
    "question": "Struct üyeleri arasında atama yaparken 'cannot convert to' hatası alıyorum. Bu hatanın nedeni nedir?",
    "answer": "Bu hata genellikle struct üyeleri arasında tür uyumsuzluğundan kaynaklanır. Örneğin, bir 'double' üyesine 'int' atamaya çalışmanız durumunda bu hatayı alırsınız. Kontrol edip düzeltmeniz gerekir:\n\n```c\nstruct Person {\n    double height;\n};\nstruct Person p;\np.height = 180; // Hatalıdır\n``` \n\nDüzeltmek için:\n\n```c\np.height = 180.0; // Doğru atama\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028392"
  },
  {
    "question": "Struct'ımın bir dizisini döngü içinde kullanırken 'index out of bounds' hatası alıyorum. Bu hatanın sebebi nedir?",
    "answer": "Bu hata, dizinin sınırlarını aşmaya çalıştığınızda oluşur. Dizinin boyutunu aşan bir indeks kullanıyorsanız, bu hata ile karşılaşırsınız. Aşağıdaki gibi bir örnek üzerinde düşünelim:\n\n```c\nstruct Data {\n    int values[5];\n};\nstruct Data d;\nfor (int i = 0; i <= 5; i++) {\n    d.values[i] = i; // Hatalıdır, 5. indeks geçersiz\n}\n``` \n\nDüzeltmek için:\n\n```c\nfor (int i = 0; i < 5; i++) { // Doğru sınır\n    d.values[i] = i;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028449"
  },
  {
    "question": "Struct içinde bir fonksiyonu referans alıkoymaya çalışırken 'incomplete type' hatası ile karşılaşıyorum. Bunun nedeni nedir?",
    "answer": "Bu hata, struct içinde bir fonksiyon tanımaya çalıştığınızda ve fonksiyonun tanımını henüz yapmadığınızda oluşur. Struct içinde fonksiyonun tanımının doğru yapılması gerekmektedir. Örneğin:\n\n```c\nstruct Person {\n    void (*func)(); // Hatalıdır, func tanımlı değil\n};\n``` \n\nÇözüm için:\n\n```c\nvoid myFunction() {}\nstruct Person {\n    void (*func)();\n};\nstruct Person p;\np.func = myFunction; // Doğru kullanım\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:18:56.028520"
  },
  {
    "question": "Struct yapısı nedir ve ne amaçla kullanılır?",
    "answer": "Struct, C dilinde bir veri yapısıdır. Birden fazla farklı türde veriyi bir arada tutmak için kullanılır. Örneğin, bir öğrencinin bilgilerini tutmak istiyorsak ad, soyad ve yaş gibi farklı türde değişkenleri bir arada saklamak için struct yapısını kullanabiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.058964"
  },
  {
    "question": "Struct tanımlaması nasıl yapılır?",
    "answer": "Struct tanımlaması, 'struct' anahtar kelimesi ile başlar. Örneğin: 'struct Ogrenci { char ad[50]; char soyad[50]; int yas; };' şeklinde bir öğrenci yapısı tanımlayabiliriz. Bu yapı içinde ad, soyad ve yaş bilgilerini tutabiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.058996"
  },
  {
    "question": "Struct değişkeni nasıl oluşturulur?",
    "answer": "Struct değişkeni, tanımlanan yapının adını kullanarak oluşturulur. Örneğin, 'struct Ogrenci ogr1;' ifadesi, Ogrenci yapısından bir ogr1 isimli değişken oluşturarak bu değişkende öğrenci bilgilerini saklamamıza olanak tanır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059013"
  },
  {
    "question": "Struct değişkenlerine nasıl veri atanır?",
    "answer": "Struct değişkenlerine veri atarken, yapının değişkenlerine nokta (.) operatörü ile erişiriz. Örneğin: 'ogr1.yas = 20; strcpy(ogr1.ad, \"Ali\");' ile ogr1 değişkeninin içindeki ad ve yaş bilgilerini atayabiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059031"
  },
  {
    "question": "Struct yapılarının dizileri nasıl oluşturulur?",
    "answer": "Struct yapılarının dizileri, normal diziler gibi tanımlanabilir. Örneğin: 'struct Ogrenci ogrenciler[10];' ifadesi ile 10 öğrenciyi tutacak bir dizi oluşturmuş oluruz. Bu dizi üzerinden her bir öğrencinin bilgilerine erişebiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059056"
  },
  {
    "question": "Struct içinde başka bir struct nasıl tanımlanır?",
    "answer": "Bir struct içinde başka bir struct tanımlamak mümkündür. Örneğin, bir 'Ders' struct'ı içinde 'Ogrenci' struct'ını tanımlayabiliriz. 'struct Ders { char dersAdi[50]; struct Ogrenci ogrenciler[30]; };' şeklindeki bir tanım ile bu yapılabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059077"
  },
  {
    "question": "Struct yapısının bellek üzerindeki yerleşimi nasıldır?",
    "answer": "Struct yapıları, içindeki değişkenlerin türlerine göre bellekte sıralı bir şekilde yer kaplar. Bu, değişkenlerin bellek adreslerinin ardışık olacağı anlamına gelir. Ancak, farklı türdeki değişkenlerin boyutları nedeniyle bellek hizalama (alignment) sorunları yaşanabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059096"
  },
  {
    "question": "Struct kullanarak bir kitap bilgisi nasıl saklanır?",
    "answer": "Bir kitap bilgisi saklamak için öncelikle bir struct tanımlamak gerekir. Örneğin: 'struct Kitap { char isim[100]; char yazar[50]; int sayfaSayisi; };' ile bir kitap yapısı oluşturabiliriz. Daha sonra bu yapı üzerinden kitap bilgilerini saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059123"
  },
  {
    "question": "Struct yapısının fonksiyonlara nasıl parametre olarak geçildiği anlatılabilir mi?",
    "answer": "Struct yapısını fonksiyonlara parametre olarak geçirebilmek için yapıyı fonksiyon parametresi olarak tanımlamak yeterlidir. Örneğin: 'void ogrenciBilgileriniYaz(struct Ogrenci ogr) { printf(\"Ad: %s, Yaş: %d\", ogr.ad, ogr.yas); }' şeklinde bir fonksiyon tanımlanabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059157"
  },
  {
    "question": "Struct yapısını kullanarak bir öğrenci listesi oluşturmanın avantajları nelerdir?",
    "answer": "Struct kullanarak bir öğrenci listesi oluşturmanın avantajları arasında verilerin düzenli bir şekilde saklanması, farklı türdeki bilgilerin bir arada tutulması ve kodun daha okunabilir hale gelmesi sayılabilir. Bu sayede öğrencilerin bilgilerini yönetmek daha kolay hale gelir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059181"
  },
  {
    "question": "Struct yapısından bir kopya nasıl oluşturulur?",
    "answer": "Struct yapısından bir kopya oluşturmak için atama işlemi yapılabilir. Örneğin: 'struct Ogrenci ogr2 = ogr1;' ifadesi, ogr1 struct'ının içeriğini ogr2'ye kopyalar. Böylece iki farklı struct aynı verilere sahip olur.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:11.059198"
  },
  {
    "question": "C dilinde bir struct yapısı nedir ve nerelerde kullanılır?",
    "answer": "Struct, birden fazla farklı türde veriyi bir arada tutmak için kullanılan bir veri yapısıdır. Örneğin, bir 'Öğrenci' yapısı oluşturduğumuzda, öğrencinin adı, yaşı ve not ortalaması gibi farklı türde verileri bir arada barındırabiliriz. Struct'lar genellikle veri gruplarını düzenli bir şekilde tutmak ve ilişkili verileri bir arada yönetmek için kullanılır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352456"
  },
  {
    "question": "Bir struct yapısı nasıl tanımlanır ve kullanılır? Örnek veriniz.",
    "answer": "Struct tanımlamak için 'struct' anahtar kelimesini kullanırız. Örneğin:\n\n```c\nstruct Ogrenci {\n    char isim[50];\n    int yas;\n    float notOrt;\n};\n```\nBu yapıyı kullanmak için bir değişken oluşturabiliriz:\n\n```c\nstruct Ogrenci ogr1;\nstrcpy(ogr1.isim, \"Ali\");\nogr1.yas = 20;\nogr1.notOrt = 3.5;\n```\nBu şekilde 'ogr1' değişkeni artık bir öğrencinin bilgilerini tutabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352501"
  },
  {
    "question": "Bir struct'ı nasıl bir fonksiyona parametre olarak geçirebiliriz?",
    "answer": "Struct'ı fonksiyona parametre olarak geçirebilmek için, yapının kendisini veya bir işaretçisini kullanabiliriz. Örnek:\n\n```c\nvoid yazdir(struct Ogrenci ogr) {\n    printf(\"İsim: %s, Yaş: %d, Not Ortalaması: %.2f\\n\", ogr.isim, ogr.yas, ogr.notOrt);\n}\n```\nBu fonksiyonda 'ogr' parametresi bir 'Ogrenci' struct'ını alır ve içindeki bilgileri yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352544"
  },
  {
    "question": "Struct içindeki bir değişkenin nasıl güncelleneceğini gösterin.",
    "answer": "Struct içindeki bir değişkeni güncellemek için önce yapının bir örneğini oluşturup erişim sağlarız. Aşağıda bir örnek ile gösterilmektedir:\n\n```c\nstruct Ogrenci ogr1;\nogr1.yas = 20;\n// Yaşı güncelleme\nogr1.yas = 21; // Artık yaş 21 oldu\n```\nBu örnekte 'ogr1' struct'ının 'yas' değişkenine yeni bir değer atadık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352566"
  },
  {
    "question": "Struct'ların bellekte nasıl yer kapladığını nasıl öğrenebiliriz?",
    "answer": "Struct'ların bellekte kapladığı alanı öğrenmek için 'sizeof' operatörünü kullanabiliriz. Örnek:\n\n```c\nprintf(\"Ogrenci struct'ının boyutu: %zu bytes\\n\", sizeof(struct Ogrenci));\n```\nBu kod, 'Ogrenci' struct'ının bellekte kapladığı bayt sayısını yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352709"
  },
  {
    "question": "Struct yapısında diziler kullanabilir miyiz? Bir örnek veriniz.",
    "answer": "Evet, struct içinde dizi kullanabiliriz. Örneğin, bir öğrencinin aldığı derslerin isimlerini tutan bir dizi oluşturalım:\n\n```c\nstruct Ogrenci {\n    char isim[50];\n    char dersler[5][30]; // 5 ders için dizi\n};\n```\nBu şekilde bir öğrencinin 5 adet ders ismini tutacak bir dizi oluşturmuş olduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352736"
  },
  {
    "question": "Struct'ların eşitliğini nasıl kontrol edebiliriz?",
    "answer": "C dilinde struct'ların doğrudan karşılaştırılması mümkün değildir. Bunun yerine her bir elemanını tek tek karşılaştırmalıyız. Örnek:\n\n```c\nint esitMi(struct Ogrenci ogr1, struct Ogrenci ogr2) {\n    return (strcmp(ogr1.isim, ogr2.isim) == 0 &&\n            ogr1.yas == ogr2.yas &&\n            ogr1.notOrt == ogr2.notOrt);\n}\n```\nBu fonksiyon iki 'Ogrenci' struct'ını karşılaştırır ve eşit olup olmadıklarını döner.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352755"
  },
  {
    "question": "Struct yapıları üzerinde döngü kullanarak nasıl işlem yapabiliriz?",
    "answer": "Struct dizileri oluşturarak döngülerle işlem yapabiliriz. Örnek:\n\n```c\nstruct Ogrenci ogrenciListesi[3];\nfor (int i = 0; i < 3; i++) {\n    printf(\"Öğrenci %d için ismi giriniz: \", i+1);\n    scanf(\"%s\", ogrenciListesi[i].isim);\n}\n```\nBu döngü, 3 öğrencinin isimlerini kullanıcıdan alarak 'ogrenciListesi' dizisindeki her bir 'Ogrenci' struct'ına kaydeder.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352777"
  },
  {
    "question": "Struct içinde fonksiyonlar tanımlanabilir mi? Açıklayınız.",
    "answer": "C dilinde doğrudan struct içinde fonksiyon tanımlamak mümkün değildir. Ancak struct'ların bir işlevselliğini elde etmek için fonksiyonları struct ile birlikte kullanabiliriz. Örneğin, bir struct'ı temsil eden bir fonksiyon ve onu kullanan bir yapı oluşturabiliriz:\n\n```c\nstruct Ogrenci {\n    char isim[50];\n    int yas;\n};\n\nvoid ogrenciYazdir(struct Ogrenci ogr) {\n    printf(\"İsim: %s, Yaş: %d\\n\", ogr.isim, ogr.yas);\n}\n```\nBu yapıda 'Ogrenci' struct'ının yanında bir yazdırma fonksiyonu tanımlamış olduk.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:34.352798"
  },
  {
    "question": "C dilinde bir struct yapısı tanımlamak için gerekli adımlar nelerdir?",
    "answer": "C dilinde bir struct tanımlamak için önce 'struct' anahtar kelimesi kullanılarak bir yapı tanımı yapılır. Daha sonra yapı içinde kullanılacak değişkenler belirtilir. Örneğin, bir 'Araba' yapısı tanımlamak için aşağıdaki gibi bir kod yazabiliriz:\n\n```c\nstruct Araba {\n    char marka[20];\n    char model[20];\n    int yil;\n};\n```\nBu yapıda 'marka', 'model' ve 'yil' adında üç üye bulunmaktadır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949706"
  },
  {
    "question": "C dilinde struct yapısını kullanarak bir dizi oluşturmanın avantajları nelerdir?",
    "answer": "Struct kullanarak dizi oluşturmanın en büyük avantajı, birden fazla değişkeni tek bir yapı altında toplamak ve bu yapıları bir dizi halinde saklayarak işlemleri daha düzenli hale getirmektir. Örneğin, bir öğrenci için bir struct tanımladıktan sonra, bu öğrencilerin bilgilerini içeren bir dizi oluşturabiliriz:\n\n```c\nstruct Ogrenci {\n    char isim[30];\n    int numara;\n};\n\nstruct Ogrenci ogrenciler[100];\n```\nBu sayede her öğrencinin bilgilerini daha kolay yönetebiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949749"
  },
  {
    "question": "C dilinde struct içinde başka bir struct kullanmak mümkün müdür? Bir örnek ile açıklayın.",
    "answer": "Evet, C dilinde struct içinde başka bir struct kullanmak mümkündür. Bu, karmaşık verileri daha düzenli bir şekilde saklamamıza olanak tanır. Örneğin, bir 'Adres' yapısını 'Kişi' yapısının içinde kullanabiliriz:\n\n```c\nstruct Adres {\n    char sokak[50];\n    char sehir[20];\n};\n\nstruct Kisi {\n    char isim[30];\n    struct Adres adres;\n};\n```\nBu yapıda, 'Kisi' yapısı bir 'Adres' yapısını içermektedir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949780"
  },
  {
    "question": "C dilinde struct ile fonksiyonları birlikte kullanmanın yolları nelerdir?",
    "answer": "C dilinde struct yapısını fonksiyonlarla kullanmanın birkaç yolu vardır. Yapıyı fonksiyon parametresi olarak geçirebiliriz veya fonksiyonun dönüş tipi olarak tanımlayabiliriz. Örneğin, bir 'Araba' yapısını bir fonksiyon aracılığıyla alarak bilgilerinin ekrana yazdırılması:\n\n```c\nvoid arabaBilgileriniYazdir(struct Araba a) {\n    printf(\"Marka: %s, Model: %s, Yıl: %d\\n\", a.marka, a.model, a.yil);\n}\n```\nBu fonksiyon, bir 'Araba' yapısını alır ve bilgilerini yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949803"
  },
  {
    "question": "Struct yapısında birden fazla değişkeni aynı anda nasıl atayabiliriz?",
    "answer": "C dilinde struct yapısında birden fazla değişkeni aynı anda atamak için yapının elemanlarını bireysel olarak atamak yerine yapı oluştururken bir başlangıç listesi kullanabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\nstruct Araba a = {\"Toyota\", \"Corolla\", 2020};\n```\nBu kod ile 'a' adlı 'Araba' yapısının tüm üyeleri aynı anda atanmış olur.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949826"
  },
  {
    "question": "Struct yapılarında bit alanları (bit fields) nasıl kullanılır ve ne amaçla kullanılır?",
    "answer": "C dilinde bit alanları, struct içindeki değişkenlerin bellek alanını daha verimli kullanmak için kullanılır. Özellikle, bir veya birkaç bit kullanarak bir değişken tanımlamak istediğimizde faydalıdır. Örneğin:\n\n```c\nstruct Renk {\n    unsigned int kirmizi : 1;\n    unsigned int yesil : 1;\n    unsigned int mavi : 1;\n};\n```\nBurada, her renk bileşeni sadece 1 bit yer kaplar ve toplamda 3 bit ile bir renk temsil edilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949856"
  },
  {
    "question": "Struct yapılarında typedef kullanmanın avantajları nelerdir?",
    "answer": "typedef, struct yapısının daha kısa ve okunabilir bir isimle kullanılmasını sağlar. Bu, kodunuzu daha düzenli hale getirir. Örneğin:\n\n```c\ntypedef struct {\n    char isim[30];\n    int yas;\n} Kisi;\n```\nBu kod ile 'Kisi' ismi, yeni bir veri tipi olarak tanımlanmış oldu. Artık 'Kisi' olarak kullanabiliriz:\n\n```c\nKisi k1;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949875"
  },
  {
    "question": "Bir struct yapısının elemanlarının sırasının değiştirilmesi performansı nasıl etkiler?",
    "answer": "Bir struct yapısının elemanlarının sırası, bellek hizalamasını etkileyebilir. Bellek hizalaması, işlemci ve bellek erişim hızını etkileyebilir. Örneğin, bir struct yapısında büyük veritipleri (int, double) öncelikli olarak tanımlanırsa, bellek hizalaması daha etkin hale gelir ve performans artışı sağlar. Örnek:\n\n```c\nstruct Veri {\n    double d;\n    int i;\n};\n```\nBurada 'double' tipi, 'int' tipinden önce geldiği için daha iyi hizalanır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949901"
  },
  {
    "question": "Struct yapılarında dinamik bellek yönetimi nasıl gerçekleştirilir?",
    "answer": "Struct yapılarında dinamik bellek yönetimi için 'malloc' ve 'free' fonksiyonları kullanılır. Önce bir struct için bellek ayırılır, ardından bu bellek kullanılabilir. Örnek:\n\n```c\nstruct Araba *arabaPtr;\n\narabaPtr = (struct Araba*)malloc(sizeof(struct Araba));\nif (arabaPtr != NULL) {\n    strcpy(arabaPtr->marka, \"Ford\");\n}\n\nfree(arabaPtr);\n```\nBurada 'malloc' ile bellek ayırdık ve kullanımdan sonra 'free' ile serbest bıraktık.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949932"
  },
  {
    "question": "C dilinde struct yapıları ile enum yapıları nasıl entegre edilir?",
    "answer": "Struct yapıları ile enum yapıları, belirli bir durum veya değer kümesini temsil etmek için birlikte kullanılabilir. Örneğin, bir aracın durumunu bir enum ile tanımlayıp, bu durumu bir struct içinde saklayabiliriz:\n\n```c\ntypedef enum {\n    DURUM_HAZIR,\n    DURUM_BEKLEME,\n    DURUM_HAREKET\n} AracDurumu;\n\nstruct Araba {\n    char model[20];\n    AracDurumu durum;\n};\n```\nBu şekilde, 'Araba' yapısı içinde durum bilgisi de saklanmış olur.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:19:58.949954"
  },
  {
    "question": "Bir öğrenci bilgilerini tutan bir struct oluşturun ve bu bilgileri yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Student' adında struct tanımlayalım. Bu struct içinde öğrenci adı, numarası ve not ortalaması gibi bilgileri tutalım. Ardından bu bilgileri yazdıracak bir fonksiyon yazalım.\n\n```c\n#include <stdio.h>\n\nstruct Student {\n    char name[50];\n    int id;\n    float grade;\n};\n\nvoid printStudent(struct Student student) {\n    printf(\"Öğrenci Adı: %s\\n\", student.name);\n    printf(\"Öğrenci No: %d\\n\", student.id);\n    printf(\"Not Ortalaması: %.2f\\n\", student.grade);\n}\n\nint main() {\n    struct Student student1 = {\"Ali Veli\", 12345, 3.5};\n    printStudent(student1);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605764"
  },
  {
    "question": "Bir kitap bilgilerini tutan bir struct oluşturun ve belirli bir kitaba erişip bilgilerini yazdırın.",
    "answer": "Şimdi bir 'Book' adında struct oluşturalım ve bu struct, kitabın adı, yazarı ve sayfa sayısını içersin. Kitap bilgilerini yazdıran bir fonksiyon da ekleyelim.\n\n```c\n#include <stdio.h>\n\nstruct Book {\n    char title[100];\n    char author[50];\n    int pages;\n};\n\nvoid printBook(struct Book book) {\n    printf(\"Kitap Adı: %s\\n\", book.title);\n    printf(\"Yazar: %s\\n\", book.author);\n    printf(\"Sayfa Sayısı: %d\\n\", book.pages);\n}\n\nint main() {\n    struct Book book1 = {\"C Programlama Dili\", \"Brian W. Kernighan\", 272};\n    printBook(book1);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605808"
  },
  {
    "question": "Bir araba bilgilerini tutan bir struct oluşturun ve birkaç araba nesnesi oluşturarak bilgilerini yazdırın.",
    "answer": "Araba bilgilerini tutacak bir 'Car' struct'ı oluşturalım. Bu struct, marka, model ve yıl gibi bilgileri içerecek. Ardından birkaç araba oluşturup bilgilerini yazdıralım.\n\n```c\n#include <stdio.h>\n\nstruct Car {\n    char brand[50];\n    char model[50];\n    int year;\n};\n\nvoid printCar(struct Car car) {\n    printf(\"Marka: %s\\n\", car.brand);\n    printf(\"Model: %s\\n\", car.model);\n    printf(\"Yıl: %d\\n\", car.year);\n}\n\nint main() {\n    struct Car car1 = {\"Toyota\", \"Corolla\", 2020};\n    struct Car car2 = {\"Honda\", \"Civic\", 2019};\n    printCar(car1);\n    printCar(car2);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605838"
  },
  {
    "question": "Bir çalışan bilgilerini tutan bir struct oluşturun ve çalışan sayısını hesaplayın.",
    "answer": "Çalışan bilgilerini tutan bir 'Employee' struct'ı oluşturacağız. İçinde ad, soyad ve çalıştığı departman bilgilerini tutalım. Birden fazla çalışan oluşturup toplam çalışan sayısını hesaplayalım.\n\n```c\n#include <stdio.h>\n\nstruct Employee {\n    char firstName[50];\n    char lastName[50];\n    char department[50];\n};\n\nint main() {\n    struct Employee employees[3] = {\n        {\"Ahmet\", \"Yılmaz\", \"IT\"},\n        {\"Mehmet\", \"Demir\", \"HR\"},\n        {\"Ayşe\", \"Kara\", \"Finance\"}\n    };\n    printf(\"Toplam Çalışan Sayısı: %d\\n\", sizeof(employees) / sizeof(employees[0]));\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605864"
  },
  {
    "question": "Bir film bilgilerini tutan bir struct oluşturun ve en yüksek puana sahip filmi bulun.",
    "answer": "Bir 'Movie' struct'ı oluşturalım. Bu struct, film adı, yönetmen ve puan gibi bilgileri içersin. Ardından birkaç film oluşturup en yüksek puana sahip olanı bulalım.\n\n```c\n#include <stdio.h>\n\nstruct Movie {\n    char title[100];\n    char director[50];\n    float rating;\n};\n\nint main() {\n    struct Movie movies[3] = {\n        {\"Inception\", \"Christopher Nolan\", 8.8},\n        {\"The Godfather\", \"Francis Ford Coppola\", 9.2},\n        {\"The Dark Knight\", \"Christopher Nolan\", 9.0}\n    };\n    float maxRating = 0;\n    for(int i = 0; i < 3; i++) {\n        if(movies[i].rating > maxRating) {\n            maxRating = movies[i].rating;\n        }\n    }\n    printf(\"En Yüksek Puan: %.1f\\n\", maxRating);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605891"
  },
  {
    "question": "Bir ders bilgilerini tutan bir struct oluşturun ve bir derse öğrencileri ekleyin.",
    "answer": "Bir 'Course' struct'ı oluşturalım. Bu struct, ders adı ve dersin kodunu tutacak. Ardından öğrenci isimleri için bir dizi ekleyelim ve bu diziyi dolduralım.\n\n```c\n#include <stdio.h>\n\nstruct Course {\n    char name[50];\n    char code[10];\n    char students[5][50]; // Maksimum 5 öğrenci\n};\n\nint main() {\n    struct Course course = {\"Veri Yapıları\", \"CS101\"};\n    snprintf(course.students[0], 50, \"Ali\");\n    snprintf(course.students[1], 50, \"Ayşe\");\n    snprintf(course.students[2], 50, \"Mehmet\");\n\n    printf(\"Ders Adı: %s\\n\", course.name);\n    printf(\"Ders Kodu: %s\\n\", course.code);\n    printf(\"Öğrenciler:\\n\");\n    for(int i = 0; i < 3; i++) {\n        printf(\"- %s\\n\", course.students[i]);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605916"
  },
  {
    "question": "Bir ürün bilgilerini tutan bir struct oluşturun ve ürün listesini yazdırın.",
    "answer": "Bir 'Product' struct'ı oluşturalım. Bu struct, ürün adı, fiyat ve stok miktarını tutacak. Ardından birkaç ürün oluşturup bunların listesini yazdıralım.\n\n```c\n#include <stdio.h>\n\nstruct Product {\n    char name[50];\n    float price;\n    int stock;\n};\n\nvoid printProduct(struct Product product) {\n    printf(\"Ürün Adı: %s\\n\", product.name);\n    printf(\"Fiyat: %.2f\\n\", product.price);\n    printf(\"Stok: %d\\n\", product.stock);\n}\n\nint main() {\n    struct Product products[2] = {\n        {\"Laptop\", 12000.00, 5},\n        {\"Telefon\", 3000.00, 10}\n    };\n    for(int i = 0; i < 2; i++) {\n        printProduct(products[i]);\n        printf(\"---\\n\");\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605940"
  },
  {
    "question": "Bir müzik albümü bilgilerini tutan bir struct oluşturun ve en sevilen parçayı belirleyin.",
    "answer": "Bir 'Album' struct'ı oluşturalım. Bu struct, albüm adı, sanatçı ve parça sayısını tutacak. Parça isimlerini de tutalım ve en sevilen parçayı bulalım.\n\n```c\n#include <stdio.h>\n\nstruct Album {\n    char title[100];\n    char artist[50];\n    char tracks[5][50]; // Maksimum 5 parça\n};\n\nint main() {\n    struct Album album = {\"21\", \"Adele\"};\n    snprintf(album.tracks[0], 50, \"Rolling in the Deep\");\n    snprintf(album.tracks[1], 50, \"Someone Like You\");\n    snprintf(album.tracks[2], 50, \"Set Fire to the Rain\");\n\n    printf(\"Albüm: %s\\nSanatçı: %s\\nEn Sevilen Parça: %s\\n\", album.title, album.artist, album.tracks[1]);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605966"
  },
  {
    "question": "Bir hastane bilgilerini tutan bir struct oluşturun ve hasta kayıt işlemi yapın.",
    "answer": "Hastane bilgilerini tutan bir 'Hospital' struct'ı oluşturalım. Bu struct, hastane adı, adresi ve kayıtlı hasta sayısını tutacak. Ardından bir hasta ekleyerek güncel hasta sayısını yazdıralım.\n\n```c\n#include <stdio.h>\n\nstruct Hospital {\n    char name[100];\n    char address[100];\n    int registeredPatients;\n};\n\nint main() {\n    struct Hospital hospital = {\"Şehir Hastanesi\", \"Merkez Mah. No:1\", 0};\n    hospital.registeredPatients++;\n    printf(\"Hastane Adı: %s\\n\", hospital.name);\n    printf(\"Adres: %s\\n\", hospital.address);\n    printf(\"Kayıtlı Hasta Sayısı: %d\\n\", hospital.registeredPatients);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:20:43.605991"
  },
  {
    "question": "Bir öğrenci bilgilerini tutacak bir struct oluşturun. Ad, soyad, yaş ve not ortalaması gibi alanları içermelidir. Öğrenci bilgilerini ekrana yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Öğrenci' adında struct tanımlayalım. Ardından bilgileri ekrana yazdıracak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Ogrenci {\n    char ad[50];\n    char soyad[50];\n    int yas;\n    float notOrtalamasi;\n};\n\nvoid ogrenciBilgileriniYazdir(struct Ogrenci ogrenci) {\n    printf(\"Ad: %s\\n\", ogrenci.ad);\n    printf(\"Soyad: %s\\n\", ogrenci.soyad);\n    printf(\"Yaş: %d\\n\", ogrenci.yas);\n    printf(\"Not Ortalaması: %.2f\\n\", ogrenci.notOrtalamasi);\n}\n\nint main() {\n    struct Ogrenci ogr;\n    strcpy(ogr.ad, \"Ali\");\n    strcpy(ogr.soyad, \"Yılmaz\");\n    ogr.yas = 20;\n    ogr.notOrtalamasi = 3.5;\n\n    ogrenciBilgileriniYazdir(ogr);\n    return 0;\n}\n```\nBu kod, bir öğrencinin bilgilerini tutar ve bu bilgileri ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535594"
  },
  {
    "question": "Bir kitap bilgilerini tutacak bir struct oluşturun. Kitap adı, yazar adı, sayfa sayısı ve yayınevi gibi alanları içermelidir. Bir kitap listesini ekrana yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Kitap' adında struct tanımlayalım. Kitap listesini yazdıracak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Kitap {\n    char kitapAdi[100];\n    char yazarAdi[100];\n    int sayfaSayisi;\n    char yayinevi[100];\n};\n\nvoid kitapBilgileriniYazdir(struct Kitap kitap) {\n    printf(\"Kitap Adı: %s\\n\", kitap.kitapAdi);\n    printf(\"Yazar Adı: %s\\n\", kitap.yazarAdi);\n    printf(\"Sayfa Sayısı: %d\\n\", kitap.sayfaSayisi);\n    printf(\"Yayınevi: %s\\n\", kitap.yayinevi);\n}\n\nint main() {\n    struct Kitap kitap1;\n    strcpy(kitap1.kitapAdi, \"Sefiller\");\n    strcpy(kitap1.yazarAdi, \"Victor Hugo\");\n    kitap1.sayfaSayisi = 500;\n    strcpy(kitap1.yayinevi, \"Can Yayınları\");\n\n    kitapBilgileriniYazdir(kitap1);\n    return 0;\n}\n```\nBu kod, bir kitabın bilgilerini tutar ve bu bilgileri ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535670"
  },
  {
    "question": "Bir otomobil bilgilerini tutacak bir struct oluşturun. Marka, model, yıl ve motor hacmi gibi alanları içermelidir. Bir otomobilin bilgilerini ekrana yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Otomobil' adında struct tanımlayalım. Otomobil bilgilerini yazdıracak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Otomobil {\n    char marka[50];\n    char model[50];\n    int yil;\n    float motorHacmi;\n};\n\nvoid otomobilBilgileriniYazdir(struct Otomobil otomobil) {\n    printf(\"Marka: %s\\n\", otomobil.marka);\n    printf(\"Model: %s\\n\", otomobil.model);\n    printf(\"Yıl: %d\\n\", otomobil.yil);\n    printf(\"Motor Hacmi: %.1fL\\n\", otomobil.motorHacmi);\n}\n\nint main() {\n    struct Otomobil auto;\n    strcpy(auto.marka, \"Toyota\");\n    strcpy(auto.model, \"Corolla\");\n    auto.yil = 2020;\n    auto.motorHacmi = 1.8;\n\n    otomobilBilgileriniYazdir(auto);\n    return 0;\n}\n```\nBu kod, bir otomobilin bilgilerini tutar ve bu bilgileri ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535718"
  },
  {
    "question": "Bir çalışan bilgilerini tutacak bir struct oluşturun. Ad, soyad, pozisyon ve maaş gibi alanları içermelidir. Çalışanların maaşlarını hesaplayan bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Calisan' adında struct tanımlayalım. Çalışanların maaşını hesaplayacak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Calisan {\n    char ad[50];\n    char soyad[50];\n    char pozisyon[50];\n    float maas;\n};\n\nfloat maasHesapla(struct Calisan calisan) {\n    return calisan.maas * 1.1; // %10 zam\n}\n\nvoid calisanBilgileriniYazdir(struct Calisan calisan) {\n    printf(\"Ad: %s\\n\", calisan.ad);\n    printf(\"Soyad: %s\\n\", calisan.soyad);\n    printf(\"Pozisyon: %s\\n\", calisan.pozisyon);\n    printf(\"Maaş: %.2f\\n\", calisan.maas);\n    printf(\"Yeni Maaş: %.2f\\n\", maasHesapla(calisan));\n}\n\nint main() {\n    struct Calisan calisan1;\n    strcpy(calisan1.ad, \"Ahmet\");\n    strcpy(calisan1.soyad, \"Demir\");\n    strcpy(calisan1.pozisyon, \"Mühendis\");\n    calisan1.maas = 5000;\n\n    calisanBilgileriniYazdir(calisan1);\n    return 0;\n}\n```\nBu kod, bir çalışanın bilgilerini tutar ve maaşına %10 zam yaparak yeni maaşını hesaplar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535762"
  },
  {
    "question": "Bir telefon bilgilerini tutacak bir struct oluşturun. Marka, model, hafıza ve batarya kapasitesi gibi alanları içermelidir. Telefon bilgilerini karşılaştıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Telefon' adında struct tanımlayalım. Telefon bilgilerini karşılaştıracak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Telefon {\n    char marka[50];\n    char model[50];\n    int hafiza; // GB cinsinden\n    int bataryaKapasitesi; // mAh cinsinden\n};\n\nvoid telefonKarsilastir(struct Telefon t1, struct Telefon t2) {\n    if (t1.bataryaKapasitesi > t2.bataryaKapasitesi) {\n        printf(\"%s %s daha uzun süre gidebilir.\\n\", t1.marka, t1.model);\n    } else if (t1.bataryaKapasitesi < t2.bataryaKapasitesi) {\n        printf(\"%s %s daha uzun süre gidebilir.\\n\", t2.marka, t2.model);\n    } else {\n        printf(\"Her iki telefonun batarya kapasitesi eşit.\\n\");\n    }\n}\n\nint main() {\n    struct Telefon telefon1, telefon2;\n    strcpy(telefon1.marka, \"Apple\");\n    strcpy(telefon1.model, \"iPhone 13\");\n    telefon1.hafiza = 128;\n    telefon1.bataryaKapasitesi = 3095;\n\n    strcpy(telefon2.marka, \"Samsung\");\n    strcpy(telefon2.model, \"Galaxy S21\");\n    telefon2.hafiza = 256;\n    telefon2.bataryaKapasitesi = 4000;\n\n    telefonKarsilastir(telefon1, telefon2);\n    return 0;\n}\n```\nBu kod, iki telefonun batarya kapasitelerini karşılaştırarak hangisinin daha uzun süre gideceğini belirtir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535810"
  },
  {
    "question": "Bir film bilgilerini tutacak bir struct oluşturun. Film adı, yönetmen, yıl ve tür gibi alanları içermelidir. Film listesini ekrana yazdıran bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Film' adında struct tanımlayalım. Film listesini yazdıracak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Film {\n    char filmAdi[100];\n    char yonetmen[100];\n    int yil;\n    char tur[50];\n};\n\nvoid filmBilgileriniYazdir(struct Film film) {\n    printf(\"Film Adı: %s\\n\", film.filmAdi);\n    printf(\"Yönetmen: %s\\n\", film.yonetmen);\n    printf(\"Yıl: %d\\n\", film.yil);\n    printf(\"Tür: %s\\n\", film.tur);\n}\n\nint main() {\n    struct Film film1;\n    strcpy(film1.filmAdi, \"Inception\");\n    strcpy(film1.yonetmen, \"Christopher Nolan\");\n    film1.yil = 2010;\n    strcpy(film1.tur, \"Bilim Kurgu\");\n\n    filmBilgileriniYazdir(film1);\n    return 0;\n}\n```\nBu kod, bir filmin bilgilerini tutar ve bu bilgileri ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535854"
  },
  {
    "question": "Bir öğrenci sınav sonuçlarını tutacak bir struct oluşturun. Öğrenci adı, ders adı ve not gibi alanları içermelidir. Not ortalamasını hesaplayan bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'SinavSonucu' adında struct tanımlayalım. Not ortalamasını hesaplayacak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct SinavSonucu {\n    char ogrenciAdi[50];\n    char dersAdi[50];\n    float not;\n};\n\nfloat notOrtalamasiHesapla(struct SinavSonucu sonuclar[], int adet) {\n    float toplam = 0;\n    for (int i = 0; i < adet; i++) {\n        toplam += sonuclar[i].not;\n    }\n    return toplam / adet;\n}\n\nint main() {\n    struct SinavSonucu sonuclar[3];\n    strcpy(sonuclar[0].ogrenciAdi, \"Ali\");\n    strcpy(sonuclar[0].dersAdi, \"Matematik\");\n    sonuclar[0].not = 85;\n\n    strcpy(sonuclar[1].ogrenciAdi, \"Ali\");\n    strcpy(sonuclar[1].dersAdi, \"Fizik\");\n    sonuclar[1].not = 90;\n\n    strcpy(sonuclar[2].ogrenciAdi, \"Ali\");\n    strcpy(sonuclar[2].dersAdi, \"Kimya\");\n    sonuclar[2].not = 80;\n\n    float ortalama = notOrtalamasiHesapla(sonuclar, 3);\n    printf(\"Ali'nin Not Ortalaması: %.2f\\n\", ortalama);\n    return 0;\n}\n```\nBu kod, bir öğrencinin sınav sonuçlarını tutar ve not ortalamasını hesaplar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535900"
  },
  {
    "question": "Bir oyun karakteri bilgilerini tutacak bir struct oluşturun. Karakter adı, seviyeyi, sağlık puanı ve saldırı gücü gibi alanları içermelidir. Karakterin güçlülüğünü hesaplayan bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Karakter' adında struct tanımlayalım. Karakterin güçlülüğünü hesaplayacak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Karakter {\n    char karakterAdi[50];\n    int seviye;\n    int saglikPuani;\n    int saldiriGucu;\n};\n\nint karakterGucuHesapla(struct Karakter karakter) {\n    return karakter.seviye * karakter.saldiriGucu;\n}\n\nint main() {\n    struct Karakter karakter1;\n    strcpy(karakter1.karakterAdi, \"Warrior\");\n    karakter1.seviye = 10;\n    karakter1.saglikPuani = 100;\n    karakter1.saldiriGucu = 15;\n\n    int guc = karakterGucuHesapla(karakter1);\n    printf(\"Karakter: %s, Güç: %d\\n\", karakter1.karakterAdi, guc);\n    return 0;\n}\n```\nBu kod, bir oyun karakterinin bilgilerini tutar ve karakterin gücünü hesaplar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535949"
  },
  {
    "question": "Bir alışveriş sepetindeki ürünleri tutacak bir struct oluşturun. Ürün adı, fiyatı ve miktarı gibi alanları içermelidir. Sepetteki toplam fiyatı hesaplayan bir fonksiyon yazın.",
    "answer": "Öncelikle bir 'Urun' adında struct tanımlayalım. Sepetteki toplam fiyatı hesaplayacak bir fonksiyon yazalım:\n\n```c\n#include <stdio.h>\n\nstruct Urun {\n    char urunAdi[100];\n    float fiyat;\n    int miktar;\n};\n\nfloat toplamFiyatHesapla(struct Urun urunler[], int adet) {\n    float toplam = 0;\n    for (int i = 0; i < adet; i++) {\n        toplam += urunler[i].fiyat * urunler[i].miktar;\n    }\n    return toplam;\n}\n\nint main() {\n    struct Urun sepet[3];\n    strcpy(sepet[0].urunAdi, \"Elma\");\n    sepet[0].fiyat = 2.5;\n    sepet[0].miktar = 4;\n\n    strcpy(sepet[1].urunAdi, \"Armut\");\n    sepet[1].fiyat = 3.0;\n    sepet[1].miktar = 3;\n\n    strcpy(sepet[2].urunAdi, \"Muz\");\n    sepet[2].fiyat = 1.5;\n    sepet[2].miktar = 6;\n\n    float toplamFiyat = toplamFiyatHesapla(sepet, 3);\n    printf(\"Toplam Fiyat: %.2f\\n\", toplamFiyat);\n    return 0;\n}\n```\nBu kod, bir alışveriş sepetindeki ürünlerin toplam fiyatını hesaplar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:21:38.535994"
  },
  {
    "question": "Bir kitap veri yapısını tanımlayın ve bir kitap listesi oluşturan bir fonksiyon yazın.",
    "answer": "Kitap bilgilerini tutacak bir yapı tanımlıyoruz: 'title', 'author', 'year' ve 'pages'. Ardından, bir dizi kitap oluşturup bu diziyi dolduracak bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Book {\n    char title[100];\n    char author[100];\n    int year;\n    int pages;\n};\n\nvoid createBookList(struct Book books[], int count) {\n    for (int i = 0; i < count; i++) {\n        printf(\"Kitap %d başlığı: \", i + 1);\n        scanf(\"%[^\n]s\", books[i].title);\n        getchar(); // Yeni satırı temizlemek için\n        printf(\"Yazar: \");\n        scanf(\"%[^\n]s\", books[i].author);\n        printf(\"Yıl: \");\n        scanf(\"%d\", &books[i].year);\n        printf(\"Sayfa sayısı: \");\n        scanf(\"%d\", &books[i].pages);\n        getchar(); // Yeni satırı temizlemek için\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Kaç kitap girmek istersiniz? \");\n    scanf(\"%d\", &n);\n    struct Book books[n];\n    createBookList(books, n);\n    return 0;\n}\n```\nBurada, kullanıcının gireceği kitap bilgilerini tutmak için bir dizi oluşturuyoruz ve 'createBookList' fonksiyonu ile bu diziyi dolduruyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164145"
  },
  {
    "question": "Bir öğrenci yapısı tanımlayın ve belirli bir not ortalamasına göre öğrencileri filtreleyen bir fonksiyon yazın.",
    "answer": "Öğrenci bilgilerini tutacak bir yapı tanımlıyoruz: 'name', 'id' ve 'grade'. Ardından, belirli bir not ortalamasının üzerindeki öğrencileri filtreleyen bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Student {\n    char name[50];\n    int id;\n    float grade;\n};\n\nvoid filterStudents(struct Student students[], int count, float threshold) {\n    printf(\"Not ortalaması %.2f ve üzerindeki öğrenciler:\\n\", threshold);\n    for (int i = 0; i < count; i++) {\n        if (students[i].grade >= threshold) {\n            printf(\"%s (ID: %d, Not: %.2f)\\n\", students[i].name, students[i].id, students[i].grade);\n        }\n    }\n}\n\nint main() {\n    struct Student students[3] = {\n        {\"Ali\", 1, 85.5},\n        {\"Ayşe\", 2, 90.0},\n        {\"Mehmet\", 3, 75.0}\n    };\n    filterStudents(students, 3, 80.0);\n    return 0;\n}\n```\nBu yapıda öğrencileri tanımlayıp, belirli bir not ortalamasının üzerindekileri listeleyebiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164194"
  },
  {
    "question": "Bir tarih yapısı tanımlayın ve iki tarih arasındaki farkı hesaplayan bir fonksiyon yazın.",
    "answer": "Tarih bilgilerini tutacak bir yapı tanımlıyoruz: 'day', 'month' ve 'year'. Ardından, iki tarih arasındaki gün farkını hesaplayan bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Date {\n    int day;\n    int month;\n    int year;\n};\n\nint dateDifference(struct Date start, struct Date end) {\n    // Basit bir hesaplama, yıl ve ay farkını dikkate alarak gün farkını hesaplayacağız\n    int totalDaysStart = start.year * 365 + start.month * 30 + start.day;\n    int totalDaysEnd = end.year * 365 + end.month * 30 + end.day;\n    return totalDaysEnd - totalDaysStart;\n}\n\nint main() {\n    struct Date start = {15, 5, 2023};\n    struct Date end = {20, 5, 2023};\n    printf(\"İki tarih arasındaki gün farkı: %d\\n\", dateDifference(start, end));\n    return 0;\n}\n```\nBu yapı ile tarihleri tanımlayıp, iki tarih arasındaki gün farkını basit bir hesaplama ile bulabiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164223"
  },
  {
    "question": "Bir araç yapısı tanımlayın ve bu araçların toplam değerini hesaplayan bir fonksiyon yazın.",
    "answer": "Araç bilgilerini tutacak bir yapı tanımlıyoruz: 'model', 'year' ve 'price'. Ardından, bir dizi araç oluşturup bu araçların toplam değerini hesaplayan bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Vehicle {\n    char model[50];\n    int year;\n    float price;\n};\n\nfloat calculateTotalValue(struct Vehicle vehicles[], int count) {\n    float total = 0;\n    for (int i = 0; i < count; i++) {\n        total += vehicles[i].price;\n    }\n    return total;\n}\n\nint main() {\n    struct Vehicle vehicles[3] = {\n        {\"Toyota\", 2020, 30000},\n        {\"Honda\", 2019, 25000},\n        {\"Ford\", 2021, 35000}\n    };\n    printf(\"Toplam araç değeri: %.2f\\n\", calculateTotalValue(vehicles, 3));\n    return 0;\n}\n```\nBu yapı ile araçları tanımlayıp, araçların toplam değerini hesaplayabiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164250"
  },
  {
    "question": "Bir film yapısı tanımlayın ve bir filmin bilgilerini güncelleyen bir fonksiyon yazın.",
    "answer": "Film bilgilerini tutacak bir yapı tanımlıyoruz: 'title', 'director' ve 'releaseYear'. Ardından, bir filmin bilgilerini güncelleyen bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Movie {\n    char title[100];\n    char director[100];\n    int releaseYear;\n};\n\nvoid updateMovie(struct Movie *movie, const char *newTitle, const char *newDirector, int newYear) {\n    strcpy(movie->title, newTitle);\n    strcpy(movie->director, newDirector);\n    movie->releaseYear = newYear;\n}\n\nint main() {\n    struct Movie movie = {\"Inception\", \"Christopher Nolan\", 2010};\n    printf(\"Eski Film: %s, Yönetmen: %s, Yıl: %d\\n\", movie.title, movie.director, movie.releaseYear);\n    updateMovie(&movie, \"Dunkirk\", \"Christopher Nolan\", 2017);\n    printf(\"Güncellenmiş Film: %s, Yönetmen: %s, Yıl: %d\\n\", movie.title, movie.director, movie.releaseYear);\n    return 0;\n}\n```\nBu yapı ile film bilgilerini tanımlayıp, güncelleyebiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164275"
  },
  {
    "question": "Bir müşteri yapısı tanımlayın ve belirli bir müşteri id'sine göre müşteri bilgilerini döndüren bir fonksiyon yazın.",
    "answer": "Müşteri bilgilerini tutacak bir yapı tanımlıyoruz: 'id', 'name' ve 'email'. Ardından, müşteri id'sine göre bilgileri döndüren bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Customer {\n    int id;\n    char name[50];\n    char email[100];\n};\n\nstruct Customer* getCustomerById(struct Customer customers[], int count, int id) {\n    for (int i = 0; i < count; i++) {\n        if (customers[i].id == id) {\n            return &customers[i];\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    struct Customer customers[3] = {\n        {1, \"Ali\", \"ali@example.com\"},\n        {2, \"Ayşe\", \"ayse@example.com\"},\n        {3, \"Mehmet\", \"mehmet@example.com\"}\n    };\n    struct Customer *customer = getCustomerById(customers, 3, 2);\n    if (customer) {\n        printf(\"Müşteri ID: %d, İsim: %s, Email: %s\\n\", customer->id, customer->name, customer->email);\n    } else {\n        printf(\"Müşteri bulunamadı.\\n\");\n    }\n    return 0;\n}\n```\nBu yapı ile müşteri bilgilerini saklayıp, belirli bir id ile müşteri bilgilerini döndürebiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164309"
  },
  {
    "question": "Bir oyun yapısı tanımlayın ve bu oyunun bilgilerini taşıyan bir dizi oluşturup, en yüksek puanı bulan bir fonksiyon yazın.",
    "answer": "Oyun bilgilerini tutacak bir yapı tanımlıyoruz: 'name' ve 'highScore'. Ardından, bu oyunların en yüksek puanını bulan bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Game {\n    char name[50];\n    int highScore;\n};\n\nint findHighestScore(struct Game games[], int count) {\n    int maxScore = 0;\n    for (int i = 0; i < count; i++) {\n        if (games[i].highScore > maxScore) {\n            maxScore = games[i].highScore;\n        }\n    }\n    return maxScore;\n}\n\nint main() {\n    struct Game games[3] = {\n        {\"Super Mario\", 150},\n        {\"The Legend of Zelda\", 200},\n        {\"Pac-Man\", 300}\n    };\n    printf(\"En yüksek puan: %d\\n\", findHighestScore(games, 3));\n    return 0;\n}\n```\nBu yapı ile oyun bilgilerini tanımlayıp, en yüksek puanı bulabiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164344"
  },
  {
    "question": "Bir ürün yapısı tanımlayın ve bu ürünlerin fiyatlarını hesaplayan bir fonksiyon yazın.",
    "answer": "Ürün bilgilerini tutacak bir yapı tanımlıyoruz: 'name', 'price' ve 'quantity'. Ardından, ürünlerin toplam fiyatını hesaplayan bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Product {\n    char name[50];\n    float price;\n    int quantity;\n};\n\nfloat calculateTotalPrice(struct Product products[], int count) {\n    float total = 0;\n    for (int i = 0; i < count; i++) {\n        total += products[i].price * products[i].quantity;\n    }\n    return total;\n}\n\nint main() {\n    struct Product products[3] = {\n        {\"Laptop\", 1500.00, 2},\n        {\"Mouse\", 20.00, 5},\n        {\"Keyboard\", 50.00, 3}\n    };\n    printf(\"Toplam fiyat: %.2f\\n\", calculateTotalPrice(products, 3));\n    return 0;\n}\n```\nBu yapı ile ürün bilgilerini tanımlayıp, toplam fiyatını hesaplayabiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164370"
  },
  {
    "question": "Bir çalışan yapısı tanımlayın ve bu çalışanların maaşlarını güncelleyen bir fonksiyon yazın.",
    "answer": "Çalışan bilgilerini tutacak bir yapı tanımlıyoruz: 'name', 'id' ve 'salary'. Ardından, bir çalışanın maaşını güncelleyen bir fonksiyon yazıyoruz.\n\n```c\n#include <stdio.h>\n\nstruct Employee {\n    char name[50];\n    int id;\n    float salary;\n};\n\nvoid updateSalary(struct Employee *employee, float newSalary) {\n    employee->salary = newSalary;\n}\n\nint main() {\n    struct Employee employee = {\"Hasan\", 1, 3000.00};\n    printf(\"Eski Maaş: %.2f\\n\", employee.salary);\n    updateSalary(&employee, 3500.00);\n    printf(\"Yeni Maaş: %.2f\\n\", employee.salary);\n    return 0;\n}\n```\nBu yapı ile çalışan bilgilerini tanımlayıp, maaşlarını güncelleyebiliyoruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:22.164396"
  },
  {
    "question": "Bir oyun geliştirme projesinde karakterlerin özelliklerini tutmak için bir struct yapısı oluşturun. Bu yapıyı nasıl tanımlarsınız ve optimize edersiniz?",
    "answer": "Karakterlerin özelliklerini tutmak için bir struct yapısı tanımlarken, her karakterin ismi, yaşı, sağlığı ve saldırı gücü gibi özellikleri içerebiliriz. Ayrıca, daha fazla genişlemeye izin vermek için 'health' ve 'attack' değerlerini birer float olarak tanımlamak ve 'name' için bir dizi kullanmak iyi bir tercih olabilir. Önerilen yapı şöyle olabilir:\n\n```c\ntypedef struct {\n    char name[50];\n    int age;\n    float health;\n    float attack;\n} Character;\n```\n\nBu yapı, karakterlerin özelliklerini daha iyi organize etmeye ve gerektiğinde daha fazla özellik eklemeye olanak tanır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193403"
  },
  {
    "question": "Bir kitaplık uygulaması için kitap bilgilerini tutacak bir struct yapısı oluşturun ve bu yapıyı nasıl kullanırsınız?",
    "answer": "Kitap bilgileri için bir struct oluşturmak, bir kitap nesnesinin tüm bilgilerini tek bir yerde tutmamızı sağlar. Aşağıdaki gibi bir yapı tanımlayabiliriz:\n\n```c\ntypedef struct {\n    char title[100];\n    char author[50];\n    int year;\n    float price;\n} Book;\n```\n\nBu yapı ile kitap bilgilerini tutabiliriz. Örneğin, bir kitap oluşturup bilgilerini atamak için aşağıdaki şekilde kullanabiliriz:\n\n```c\nBook myBook;\nstrcpy(myBook.title, \"C Programming\");\nstrcpy(myBook.author, \"Brian Kernighan\");\nmyBook.year = 1978;\nmyBook.price = 29.99;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193451"
  },
  {
    "question": "Bir okul yönetim sistemi için öğrenci bilgilerini tutacak bir struct yapısı nasıl tanımlanır ve kullanılır?",
    "answer": "Öğrenci bilgilerini tutmak için aşağıdaki gibi bir struct tanımlayabiliriz:\n\n```c\ntypedef struct {\n    int id;\n    char name[100];\n    float gpa;\n} Student;\n```\n\nBu yapıyı kullanarak farklı öğrenciler oluşturabiliriz. Örneğin:\n\n```c\nStudent student1;\nstudent1.id = 1;\nstrcpy(student1.name, \"Ali Veli\");\nstudent1.gpa = 3.5;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193499"
  },
  {
    "question": "Bir otomobil bilgilerini tutacak bir struct yapısı oluşturun. Bu yapının içinde birden fazla otomobili nasıl saklayabilirsiniz?",
    "answer": "Otomobil bilgilerini tutmak için şu şekilde bir struct oluşturabiliriz:\n\n```c\ntypedef struct {\n    char model[50];\n    int year;\n    float price;\n} Car;\n```\n\nBirden fazla otomobil bilgisi saklamak için, bu yapıyı bir dizi (array) içinde kullanabiliriz:\n\n```c\nCar cars[10]; // 10 otomobil için alan ayırdık\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193579"
  },
  {
    "question": "Bir banka uygulaması için hesap bilgilerini tutacak bir struct yapısı nasıl optimize edilir?",
    "answer": "Banka hesap bilgilerini tutmak için aşağıdaki gibi bir struct tanımlayabiliriz:\n\n```c\ntypedef struct {\n    int accountNumber;\n    float balance;\n    char accountHolder[50];\n} BankAccount;\n```\n\nBu yapı optimize edilerek, 'balance' float yerine double olarak tanımlanabilir. Bu sayede daha yüksek hassasiyete sahip olabiliriz:\n\n```c\ntypedef struct {\n    int accountNumber;\n    double balance;\n    char accountHolder[50];\n} BankAccount;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193615"
  },
  {
    "question": "Bir hava durumu uygulaması için hava durumu verilerini tutacak bir struct yapısı oluşturun. Bu yapı nasıl genişletilebilir?",
    "answer": "Hava durumu verilerini tutmak için aşağıdaki gibi bir struct tanımlayabiliriz:\n\n```c\ntypedef struct {\n    float temperature;\n    float humidity;\n    float windSpeed;\n    char condition[20];\n} Weather;\n```\n\nBu yapı, gelecekte daha fazla veri eklemek için genişletilebilir. Örneğin, 'precipitation' eklenebilir:\n\n```c\ntypedef struct {\n    float temperature;\n    float humidity;\n    float windSpeed;\n    char condition[20];\n    float precipitation;\n} Weather;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193658"
  },
  {
    "question": "Bir sosyal medya uygulaması için kullanıcı bilgilerini tutacak bir struct nasıl oluşturulur?",
    "answer": "Kullanıcı bilgilerini tutan bir struct şu şekilde tanımlanabilir:\n\n```c\ntypedef struct {\n    char username[50];\n    char email[100];\n    int age;\n    int followersCount;\n} User;\n```\n\nBu struct ile bir kullanıcı oluşturup bilgilerini atamak için şöyle bir kod yazılabilir:\n\n```c\nUser user1;\nstrcpy(user1.username, \"user123\");\nstrcpy(user1.email, \"user@example.com\");\nuser1.age = 25;\nuser1.followersCount = 100;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193696"
  },
  {
    "question": "Bir müzik çalar uygulaması için şarkı bilgilerini tutacak bir struct yapısı nasıl tanımlanır?",
    "answer": "Şarkı bilgilerini tutmak için aşağıdaki gibi bir struct tanımlayabiliriz:\n\n```c\ntypedef struct {\n    char title[100];\n    char artist[50];\n    float duration;\n} Song;\n```\n\nBu yapı ile bir şarkı oluşturup bilgilerini atamak için şu şekilde kullanılabilir:\n\n```c\nSong song1;\nstrcpy(song1.title, \"Shape of You\");\nstrcpy(song1.artist, \"Ed Sheeran\");\nsong1.duration = 3.5;\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193725"
  },
  {
    "question": "Bir alışveriş sepeti uygulaması için ürün bilgilerini tutacak bir struct yapısı nasıl oluşturulur?",
    "answer": "Ürün bilgilerini tutmak için aşağıdaki gibi bir struct tanımlayabiliriz:\n\n```c\ntypedef struct {\n    char productName[100];\n    float price;\n    int quantity;\n} Product;\n```\n\nBirden fazla ürün saklamak için bu yapıyı bir dizi içinde kullanabiliriz:\n\n```c\nProduct cart[50]; // 50 ürün için alan ayırdık\n```",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193753"
  },
  {
    "question": "Bir kullanıcı oturum açma uygulaması için kullanıcı bilgilerini tutacak bir struct yapısı nasıl optimize edilir?",
    "answer": "Kullanıcı bilgilerini tutan bir struct şu şekilde optimize edilebilir:\n\n```c\ntypedef struct {\n    char username[50];\n    char passwordHash[64];\n    bool isActive;\n} UserSession;\n```\n\n'passwordHash' alanı için bir dizi kullanarak şifreleri daha güvenli bir şekilde saklayabiliriz. Ayrıca, boolean değişken kullanarak kullanıcı oturum durumunu tutmak için 'isActive' alanını ekleyebiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:22:44.193784"
  },
  {
    "question": "Bir struct içinde diğer struct'ların kullanılması durumunda bellek yönetimini nasıl optimize edebiliriz?",
    "answer": "Struct içinde diğer struct'ları kullanırken, bellekte gereksiz yere yer kaplamamak için 'flexible array member' kullanabiliriz. Örneğin, bir dizi içeren bir struct düşünelim. Dizi boyutunu dinamik olarak belirleyerek, ihtiyacımız kadar bellek ayırabiliriz. Aşağıdaki örneği inceleyin:\n\n```c\ntypedef struct {\n    int count;\n    int array[]; // Flexible array member\n} MyStruct;\n\nMyStruct* create_struct(int n) {\n    MyStruct* s = malloc(sizeof(MyStruct) + sizeof(int) * (n - 1));\n    s->count = n;\n    return s;\n}\n```\nBu yöntemle, yalnızca ihtiyaç duyduğumuz kadar bellek kullanırız.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248692"
  },
  {
    "question": "Struct'ların genellikle kullanıldığı veri yapılarında, performansı artırmak için hangi yolları izlemeliyiz?",
    "answer": "Struct'lar ile birlikte kullanılan veri yapılarında, özellikle sık erişilen alanlar için veri hizalamasına (alignment) dikkat etmek önemlidir. Örneğin, struct içindeki alanları boyutlarına göre sıralamak, bellek erişim hızını artırabilir:\n\n```c\ntypedef struct {\n    char a;\n    int b;\n    short c;\n} AlignedStruct;\n\n// Optimize edilmiş versiyon\ntypedef struct {\n    int b;\n    short c;\n    char a;\n} OptimizedStruct;\n```\nBu şekilde, bellek hizalaması daha iyi olur ve erişim süreleri kısalır.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248741"
  },
  {
    "question": "Struct'ların kopyalanması sırasında performans sorunları yaşayabilir miyiz? Çözüm öneriniz nedir?",
    "answer": "Evet, büyük struct'ların kopyalanması sırasında performans sorunları yaşayabiliriz. Bunun önüne geçmek için struct'ları işaretçi (pointer) olarak kullanabilir ve bellek yönetimini bu şekilde gerçekleştirebiliriz:\n\n```c\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nvoid process(Point* p) {\n    // İşlemler\n}\n```\nBöylece, struct'ın tam olarak kopyalanması yerine sadece işaretçisi ile çalışmış oluruz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248776"
  },
  {
    "question": "Struct'ların içindeki işlevleri nasıl daha modüler hale getirebiliriz?",
    "answer": "Struct'ların içerisine işlev eklemek, modülerliği artırmak için uygun değildir. Bunun yerine, struct ile ilgili işlevleri ayrı fonksiyonlar olarak tanımlamak daha iyidir. Bu, kodun okunabilirliğini ve bakımını kolaylaştırır:\n\n```c\ntypedef struct {\n    int id;\n    char name[50];\n} Employee;\n\nvoid print_employee(const Employee* e) {\n    printf(\"ID: %d, Name: %s\\n\", e->id, e->name);\n}\n```\nBu yaklaşımla, her işlevin özgün bir sorumluluğu olur ve yeniden kullanılabilirlik artar.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248814"
  },
  {
    "question": "Struct'lar ile beraber union kullanmanın avantajları nelerdir?",
    "answer": "Struct içinde union kullanmak, bellek tasarrufu sağlamak için oldukça etkilidir. Örneğin bir veri türü olarak hem tam sayı hem de float tutmak istiyorsanız, union kullanarak bellek alanını paylaşabilirsiniz:\n\n```c\ntypedef union {\n    int intValue;\n    float floatValue;\n} Value;\n\ntypedef struct {\n    char type;\n    Value data;\n} Data;\n```\nBu yapı ile aynı bellek alanında farklı veri türlerini saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248851"
  },
  {
    "question": "Struct içindeki alanların erişim hızı nasıl artırılabilir?",
    "answer": "Struct içindeki sık erişilen alanları bit alanları (bit-fields) olarak tanımlayarak bellek kullanımını optimize edebiliriz:\n\n```c\ntypedef struct {\n    unsigned int a : 4;\n    unsigned int b : 4;\n} BitFieldStruct;\n```\nBu sayede, her alan için yalnızca gerekli olan bit sayısı kadar bellek kullanılır ve erişim süreleri azalabilir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248877"
  },
  {
    "question": "Struct'ların versiyonlaması ve uyumluluğu nasıl sağlanabilir?",
    "answer": "Struct'ların versiyonlaması için, her struct'a bir versiyon numarası eklemek faydalı olur. Bu, uygulama geliştirme sürecinde geriye dönük uyumluluğu korumayı sağlar:\n\n```c\ntypedef struct {\n    int version;\n    float data;\n} VersionedStruct;\n```\nBu sayede, uygulamanızın hangi versiyonla çalıştığını kolayca takip edebilirsiniz.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248901"
  },
  {
    "question": "Struct'ların nesne yönelimli programlama (OOP) paradigmalarıyla entegrasyonu nasıl sağlanır?",
    "answer": "C dilinde OOP benzeri özellikler sağlamak için struct'ların yanında işlev pointer'ları kullanabiliriz. Bu şekilde, yapıların davranışlarını işlev tanımları ile ilişkilendirebiliriz:\n\n```c\ntypedef struct {\n    void (*draw)(void);\n} Shape;\n\nvoid circle_draw() {\n    // Çizim işlemleri\n}\n\nShape circle = { circle_draw }; // Circle şekli için işlevi atama\n```\nBu yaklaşım, C dilinde OOP benzeri bir yapı oluşturur.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248931"
  },
  {
    "question": "Struct'ların bellekte nasıl hizalandığını nasıl anlayabiliriz ve buna göre tasarım yaparken nelere dikkat etmeliyiz?",
    "answer": "Struct'ların bellekteki hizalanmasını anlamak için 'sizeof' operatörünü kullanabiliriz. Bellek hizalamasına dikkat ederek tasarım yapmak, performansı artırır. Özellikle, farklı veri türlerinin boyutları ve hizalamaları göz önünde bulundurulmalıdır:\n\n```c\ntypedef struct {\n    char a;\n    int b;\n    short c;\n} MisalignedStruct;\n\nprintf(\"Struct Boyutu: %zu\\n\", sizeof(MisalignedStruct));\n```\nBu durumlar göz önüne alındığında, veri alanlarını uygun şekilde düzenlemek önemlidir.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248967"
  },
  {
    "question": "Struct'lar ile birlikte makrolar kullanılmasının avantajları ve dezavantajları nelerdir?",
    "answer": "Makrolar, struct'lar ile birlikte kullanıldığında, kod tekrarını azaltabilir. Ancak, makro kullanımının dezavantajı hata ayıklama sürecini zorlaştırmasıdır. Örneğin:\n\n```c\n#define CREATE_POINT(x, y) ((Point){(x), (y)})\n\nPoint p = CREATE_POINT(10, 20);\n```\nBu, kodu daha okunabilir hale getirebilir. Ancak, makrolar karmaşık hale geldiğinde hataların tespiti zorlaşır. Dolayısıyla, makro kullanırken dikkatli olunmalı.",
    "category": "advanced_topics",
    "topic": "structures",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Struct yapıları",
    "timestamp": "2025-06-01T17:23:11.248996"
  },
  {
    "question": "Bir öğrenci bilgilerini tutacak bir union tanımlayın. Öğrenci numarası veya isim tutabilsin.",
    "answer": "Aşağıdaki gibi bir union tanımlayabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Student {\n    int student_id;\n    char name[50];\n};\n\nint main() {\n    union Student s;\n    s.student_id = 12345;\n    printf(\"Öğrenci Numarası: %d\\n\", s.student_id);\n    return 0;\n}\n```\n\nBu kodda, `Student` adında bir union tanımlıyoruz. Öğrenci numarasını veya ismini tutabiliyoruz, fakat bunlardan yalnızca birini aynı anda kullanabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782791"
  },
  {
    "question": "Bir kullanıcı bilgilerini tutmak için bir union oluşturun. Kullanıcı adı veya kullanıcı tipi tutabilsin.",
    "answer": "Aşağıdaki örnekte kullanıcı bilgileri için bir union tanımlıyoruz:\n\n```c\n#include <stdio.h>\n\nunion User {\n    char username[30];\n    int user_type;\n};\n\nint main() {\n    union User u;\n    // Kullanıcı ismi atama\n    sprintf(u.username, \"admin\");\n    printf(\"Kullanıcı Adı: %s\\n\", u.username);\n    return 0;\n}\n```\n\nBu kodda, `User` adında bir union oluşturuyoruz. Kullanıcı adı veya kullanıcı tipi saklayabiliyoruz, fakat ikisi aynı anda kullanılmamalıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782839"
  },
  {
    "question": "Bir renk değerini RGB formatında tutmak için bir union tanımlayın. Kırmızı, yeşil ve mavi değerlerini tutabilsin.",
    "answer": "Aşağıdaki gibi bir union tanımlaması yapabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Color {\n    struct {\n        unsigned char red;\n        unsigned char green;\n        unsigned char blue;\n    } rgb;\n    unsigned int hex;\n};\n\nint main() {\n    union Color c;\n    c.rgb.red = 255;\n    c.rgb.green = 0;\n    c.rgb.blue = 0;\n    printf(\"Renk: RGB(%d, %d, %d)\\n\", c.rgb.red, c.rgb.green, c.rgb.blue);\n    return 0;\n}\n```\n\nBu kod, bir rengi RGB formatında saklamak için kullanılır. Ayrıca bu rengi hex formatında da tutabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782875"
  },
  {
    "question": "Bir form verisini tutacak bir union yaratın. Ad, soyad veya e-posta adresi tutabilsin.",
    "answer": "Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion FormData {\n    char first_name[30];\n    char last_name[30];\n    char email[50];\n};\n\nint main() {\n    union FormData data;\n    sprintf(data.first_name, \"Ahmet\");\n    printf(\"İsim: %s\\n\", data.first_name);\n    return 0;\n}\n```\n\nBurada `FormData` adında bir union tanımlıyoruz. Kullanıcının adı, soyadı veya e-posta adresini saklayabiliyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782912"
  },
  {
    "question": "Bir malzeme bilgisini tutmak için bir union oluşturun. Malzeme adı veya fiyatı tutabilsin.",
    "answer": "Aşağıdaki şekilde bir union örneği yazabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Material {\n    char name[50];\n    float price;\n};\n\nint main() {\n    union Material m;\n    m.price = 10.99;\n    printf(\"Malzeme Fiyatı: %.2f\\n\", m.price);\n    return 0;\n}\n```\n\nBu kod, malzeme adı veya fiyatını tutabilen bir union tanımlar. Fakat bunlardan yalnızca birini kullanmalıyız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782949"
  },
  {
    "question": "Bir kitap bilgilerini tutacak bir union oluşturun. Kitap ismi veya ISBN numarasını tutabilsin.",
    "answer": "Aşağıdaki gibi bir union yazabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Book {\n    char title[100];\n    char isbn[20];\n};\n\nint main() {\n    union Book b;\n    sprintf(b.title, \"C Programlama Dili\");\n    printf(\"Kitap Adı: %s\\n\", b.title);\n    return 0;\n}\n```\n\nBu kod, kitapların ismini veya ISBN numarasını tutmak için kullanılır. İkisi aynı anda değil, yalnızca bir tanesi kullanılabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.782978"
  },
  {
    "question": "Bir araç bilgilerini tutmak için bir union oluşturun. Araç tipi veya plaka numarasını tutabilsin.",
    "answer": "Aşağıdaki gibi bir union tanımlayabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Vehicle {\n    char type[30];\n    char plate[10];\n};\n\nint main() {\n    union Vehicle v;\n    sprintf(v.plate, \"34ABC123\");\n    printf(\"Araç Plakası: %s\\n\", v.plate);\n    return 0;\n}\n```\n\nBu kod, araçların tipi veya plaka numarasını tutmak için kullanılır. Yalnızca birini kullanmalıyız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.783006"
  },
  {
    "question": "Bir oyun karakterinin bilgilerini tutmak için bir union oluşturun. Karakter ismi veya seviyesini tutabilsin.",
    "answer": "Aşağıdaki gibi bir union yazabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Character {\n    char name[50];\n    int level;\n};\n\nint main() {\n    union Character c;\n    c.level = 5;\n    printf(\"Karakter Seviyesi: %d\\n\", c.level);\n    return 0;\n}\n```\n\nBurada `Character` adında bir union tanımlıyoruz. Karakterin ismini veya seviyesini saklayabiliyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.783046"
  },
  {
    "question": "Bir ürün bilgilerini tutacak bir union oluşturun. Ürün adı veya SKU numarasını tutabilsin.",
    "answer": "Aşağıdaki örneği inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion Product {\n    char name[50];\n    char sku[20];\n};\n\nint main() {\n    union Product p;\n    sprintf(p.sku, \"SKU123456\");\n    printf(\"Ürün SKU: %s\\n\", p.sku);\n    return 0;\n}\n```\n\nBu kod, ürün bilgilerini tutmak için bir union kullanır. Ürün adı veya SKU numarası saklayabiliriz, fakat yalnızca birini kullanmalıyız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.783073"
  },
  {
    "question": "Bir iletişim bilgilerini tutacak bir union oluşturun. Telefon numarası veya adres bilgisi tutabilsin.",
    "answer": "Aşağıdaki gibi bir union tanımlayabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Contact {\n    char phone[15];\n    char address[100];\n};\n\nint main() {\n    union Contact c;\n    sprintf(c.phone, \"123-456-7890\");\n    printf(\"Telefon Numarası: %s\\n\", c.phone);\n    return 0;\n}\n```\n\nBu kod, iletişim bilgilerini tutmak için bir union kullanır. Telefon numarası veya adres bilgisi saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:23:43.783102"
  },
  {
    "question": "Bir kullanıcının hem tamsayı hem de ondalıklı sayı tutmasını sağlayan bir union tanımlayın. Kullanıcının girdiği sayıyı bu union kullanarak nasıl saklayabilirsiniz?",
    "answer": "Union kullanarak bir tamsayı ve bir ondalıklı sayıyı tutan bir yapı oluşturabilirsiniz. Aşağıdaki kodda, 'Number' adında bir union ve 'data' adında bir yapı tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nunion Number {\n    int intValue;\n    float floatValue;\n};\n\nstruct Data {\n    union Number num;\n    int isFloat;\n};\n\nint main() {\n    struct Data data;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &data.num.intValue);\n    data.isFloat = 0;\n    printf(\"Girdiğiniz tamsayı: %d\\n\", data.num.intValue);\n\n    printf(\"Bir ondalıklı sayı girin: \");\n    scanf(\"%f\", &data.num.floatValue);\n    data.isFloat = 1;\n    printf(\"Girdiğiniz ondalıklı sayı: %.2f\\n\", data.num.floatValue);\n    return 0;\n}\n```\n\nBu kodda, kullanıcıdan hem tamsayı hem de ondalıklı sayı girişi alınıyor ve bu değer union içinde saklanıyor.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800250"
  },
  {
    "question": "Bir öğrencinin adı, yaşı ve notunu tutan bir union ve yapı tanımlayın. Bu bilgileri ekrana yazdırmak için bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte, 'Student' isimli bir yapı ve içinde 'Info' isimli bir union tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nunion Info {\n    int age;\n    float grade;\n};\n\nstruct Student {\n    char name[50];\n    union Info info;\n    int isGrade;\n};\n\nvoid printStudent(struct Student s) {\n    printf(\"Öğrenci Adı: %s\\n\", s.name);\n    if (s.isGrade) {\n        printf(\"Notu: %.2f\\n\", s.info.grade);\n    } else {\n        printf(\"Yaşı: %d\\n\", s.info.age);\n    }\n}\n\nint main() {\n    struct Student student;\n    printf(\"Öğrenci adı girin: \");\n    scanf(\"%s\", student.name);\n    student.info.age = 20;\n    student.isGrade = 0;\n    printStudent(student);\n\n    printf(\"Öğrenci adı girin: \");\n    scanf(\"%s\", student.name);\n    student.info.grade = 90.5;\n    student.isGrade = 1;\n    printStudent(student);\n\n    return 0;\n}\n```\n\nBu kod, öğrenci bilgilerini tutan bir yapı tanımlayarak ekrana yazdırmayı sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800304"
  },
  {
    "question": "Bir union kullanarak bir ürün bilgilerini tutan bir yapı oluşturun: ürün adı, fiyatı ve stoğu. Ürün bilgilerini ekrana yazdıracak bir fonksiyon yazın.",
    "answer": "Ürün bilgilerini tutmak için aşağıdaki gibi bir union ve yapı tanımlayabilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion ProductInfo {\n    char name[50];\n    float price;\n    int stock;\n};\n\nstruct Product {\n    union ProductInfo info;\n    int isPrice;\n};\n\nvoid printProduct(struct Product p) {\n    if (p.isPrice) {\n        printf(\"Ürün Fiyatı: %.2f\\n\", p.info.price);\n    } else {\n        printf(\"Ürün Adı: %s\\n\", p.info.name);\n        printf(\"Ürün Stoku: %d\\n\", p.info.stock);\n    }\n}\n\nint main() {\n    struct Product product;\n    printf(\"Ürün adını girin: \");\n    scanf(\"%s\", product.info.name);\n    product.info.stock = 100;\n    printProduct(product);\n    product.isPrice = 1;\n    product.info.price = 29.99;\n    printProduct(product);\n    return 0;\n}\n```\n\nBu kod, ürün bilgilerini saklamak ve yazdırmak için union kullanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800345"
  },
  {
    "question": "Bir kişinin telefon numarası ve e-posta adresini saklamak için bir union tanımlayın. Kullanıcının istediği bilgiyi girip saklayabilmesi için bir örnek kod yazın.",
    "answer": "Aşağıdaki örnek, bir kişinin iletişim bilgilerini tutmak için bir union ve yapı kullanır:\n\n```c\n#include <stdio.h>\n\nunion ContactInfo {\n    char phone[15];\n    char email[50];\n};\n\nstruct Person {\n    char name[50];\n    union ContactInfo contact;\n    int isPhone;\n};\n\nint main() {\n    struct Person person;\n    printf(\"Kişinin adını girin: \");\n    scanf(\"%s\", person.name);\n\n    printf(\"Telefon numarasını girin (0) veya e-posta adresini girin (1): \");\n    scanf(\"%d\", &person.isPhone);\n\n    if (person.isPhone) {\n        printf(\"E-posta adresini girin: \");\n        scanf(\"%s\", person.contact.email);\n    } else {\n        printf(\"Telefon numarasını girin: \");\n        scanf(\"%s\", person.contact.phone);\n    }\n\n    printf(\"Kişinin Adı: %s\\n\", person.name);\n    if (person.isPhone) {\n        printf(\"E-posta: %s\\n\", person.contact.email);\n    } else {\n        printf(\"Telefon Numarası: %s\\n\", person.contact.phone);\n    }\n    return 0;\n}\n```\n\nBu kod, kullanıcının iletişim bilgilerini saklamasına olanak tanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800385"
  },
  {
    "question": "Bir bilgisayarın özelliklerini (RAM, HDD) tutan bir union tanımlayın ve bu bilgileri ekrana yazdıracak bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte, bir bilgisayarın özelliklerini tutmak için bir union ve yapı oluşturulmuştur:\n\n```c\n#include <stdio.h>\n\nunion ComputerSpecs {\n    int ram;\n    int hdd;\n};\n\nstruct Computer {\n    char brand[50];\n    union ComputerSpecs specs;\n    int isRAM;\n};\n\nvoid printComputer(struct Computer c) {\n    printf(\"Bilgisayar Markası: %s\\n\", c.brand);\n    if (c.isRAM) {\n        printf(\"RAM: %d GB\\n\", c.specs.ram);\n    } else {\n        printf(\"HDD: %d GB\\n\", c.specs.hdd);\n    }\n}\n\nint main() {\n    struct Computer comp;\n    printf(\"Bilgisayar markasını girin: \");\n    scanf(\"%s\", comp.brand);\n\n    comp.specs.ram = 16;\n    comp.isRAM = 1;\n    printComputer(comp);\n\n    comp.specs.hdd = 512;\n    comp.isRAM = 0;\n    printComputer(comp);\n\n    return 0;\n}\n```\n\nBu kod, bilgisayarın RAM ve HDD bilgilerini saklamayı ve yazdırmayı sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800419"
  },
  {
    "question": "Bir çalışanın kimlik bilgisini (TC kimlik numarası veya pasaport numarası) saklamak için bir union tanımlayın. Kullanıcının istediği bilgiyi girip saklayabilmesi için bir kod yazın.",
    "answer": "Aşağıdaki örnek, bir çalışanın kimlik bilgisini saklamak için bir union ve yapı kullanır:\n\n```c\n#include <stdio.h>\n\nunion Identity {\n    char tcNumber[12];\n    char passportNumber[10];\n};\n\nstruct Employee {\n    char name[50];\n    union Identity id;\n    int isTC;\n};\n\nint main() {\n    struct Employee emp;\n    printf(\"Çalışanın adını girin: \");\n    scanf(\"%s\", emp.name);\n\n    printf(\"TC Kimlik Numarası (0) veya Pasaport Numarası (1) girin: \");\n    scanf(\"%d\", &emp.isTC);\n\n    if (emp.isTC) {\n        printf(\"Pasaport numarasını girin: \");\n        scanf(\"%s\", emp.id.passportNumber);\n    } else {\n        printf(\"TC kimlik numarasını girin: \");\n        scanf(\"%s\", emp.id.tcNumber);\n    }\n\n    printf(\"Çalışanın Adı: %s\\n\", emp.name);\n    if (emp.isTC) {\n        printf(\"Pasaport Numarası: %s\\n\", emp.id.passportNumber);\n    } else {\n        printf(\"TC Kimlik Numarası: %s\\n\", emp.id.tcNumber);\n    }\n    return 0;\n}\n```\n\nBu kod, çalışanın kimlik bilgilerini saklamasına olanak tanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800465"
  },
  {
    "question": "Bir oyunun karakter bilgilerini (sağlık durumu ve seviyesini) tutan bir union tanımlayın. Kullanıcının karakter bilgilerini girmesi için bir örnek oluşturun.",
    "answer": "Aşağıdaki örnekte, bir oyun karakterinin bilgilerini tutmak için bir union ve yapı tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nunion CharacterStatus {\n    int health;\n    int level;\n};\n\nstruct Character {\n    char name[50];\n    union CharacterStatus status;\n    int isHealth;\n};\n\nint main() {\n    struct Character charac;\n    printf(\"Karakter adını girin: \");\n    scanf(\"%s\", charac.name);\n\n    printf(\"Sağlık durumu (0) veya seviye (1) girin: \");\n    scanf(\"%d\", &charac.isHealth);\n\n    if (charac.isHealth) {\n        printf(\"Seviyeyi girin: \");\n        scanf(\"%d\", &charac.status.level);\n    } else {\n        printf(\"Sağlık durumunu girin: \");\n        scanf(\"%d\", &charac.status.health);\n    }\n\n    printf(\"Karakter Adı: %s\\n\", charac.name);\n    if (charac.isHealth) {\n        printf(\"Seviye: %d\\n\", charac.status.level);\n    } else {\n        printf(\"Sağlık Durumu: %d\\n\", charac.status.health);\n    }\n    return 0;\n}\n```\n\nBu kod, bir oyun karakterinin sağlık ve seviye bilgilerini saklamasına olanak tanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800530"
  },
  {
    "question": "Bir müşteri kaydı için isim, yaşı ve cinsiyet gibi bilgileri saklamak üzere bir union ve yapı tanımlayın. Kullanıcının bu bilgileri girmesi için bir örnek yazın.",
    "answer": "Aşağıdaki örnekte, bir müşteri kaydını tutmak için bir union ve yapı kullanılmıştır:\n\n```c\n#include <stdio.h>\n\nunion CustomerInfo {\n    int age;\n    char gender;\n};\n\nstruct Customer {\n    char name[50];\n    union CustomerInfo info;\n    int isAge;\n};\n\nint main() {\n    struct Customer cust;\n    printf(\"Müşteri adını girin: \");\n    scanf(\"%s\", cust.name);\n\n    printf(\"Yaş (0) veya Cinsiyet (1) girin: \");\n    scanf(\"%d\", &cust.isAge);\n\n    if (cust.isAge) {\n        printf(\"Cinsiyeti girin (M/K): \");\n        scanf(\" %c\", &cust.info.gender);\n    } else {\n        printf(\"Yaşı girin: \");\n        scanf(\"%d\", &cust.info.age);\n    }\n\n    printf(\"Müşteri Adı: %s\\n\", cust.name);\n    if (cust.isAge) {\n        printf(\"Cinsiyet: %c\\n\", cust.info.gender);\n    } else {\n        printf(\"Yaş: %d\\n\", cust.info.age);\n    }\n    return 0;\n}\n```\n\nBu kod, müşteri bilgilerini saklamayı ve yazdırmayı sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800572"
  },
  {
    "question": "Bir kitabın bilgilerini (başlık, yazar ve sayfa sayısı) saklayan bir union ve yapı oluşturun. Kitap bilgilerini ekrana yazdıracak bir fonksiyon yazın.",
    "answer": "Aşağıdaki örnekte, bir kitabın bilgilerini tutmak için bir union ve yapı tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nunion BookInfo {\n    char title[100];\n    char author[50];\n    int pages;\n};\n\nstruct Book {\n    union BookInfo info;\n    int isTitle;\n};\n\nvoid printBook(struct Book b) {\n    if (b.isTitle) {\n        printf(\"Kitap Başlığı: %s\\n\", b.info.title);\n    } else {\n        printf(\"Yazar: %s\\n\", b.info.author);\n    }\n}\n\nint main() {\n    struct Book book;\n    printf(\"Kitap başlığını girin: \");\n    scanf(\"%s\", book.info.title);\n    book.isTitle = 1;\n    printBook(book);\n\n    printf(\"Yazar adını girin: \");\n    scanf(\"%s\", book.info.author);\n    book.isTitle = 0;\n    printBook(book);\n\n    printf(\"Sayfa sayısını girin: \");\n    scanf(\"%d\", &book.info.pages);\n    printf(\"Sayfa Sayısı: %d\\n\", book.info.pages);\n\n    return 0;\n}\n```\n\nBu kod, bir kitabın bilgilerini saklamak ve yazdırmak için union kullanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:24:36.800610"
  },
  {
    "question": "Bir 'Union' tanımlayın ve içinde hem bir tam sayı hem de bir ondalıklı sayı barındıran bir yapı oluşturun. Ardından bu 'Union' ile bir hesaplama yapın.",
    "answer": "C dilinde bir 'Union' tanımlamak için önce bir 'Union' yapısını oluşturmalıyız. Aşağıda, bir tam sayı ve bir ondalıklı sayı içeren bir 'Union' örneği bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nunion Sayilar {\n    int tamsayi;\n    float ondalik;\n};\n\nint main() {\n    union Sayilar veri;\n    veri.tamsayi = 10;\n    printf(\"Tam sayi: %d\\n\", veri.tamsayi);\n    veri.ondalik = 5.5;\n    printf(\"Ondalik sayi: %.2f\\n\", veri.ondalik);\n    printf(\"Tam sayinin degeri: %d (ondalik alana yazildigindan bu deger belirsizdir.)\\n\", veri.tamsayi);\n    return 0;\n}\n```\nBurada 'Union', hem tam sayıyı hem de ondalıklı sayıyı saklamaktadır. Ancak, 'Union' içindeki bir değer değiştirildiğinde, diğer değer belirsiz hale gelir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928187"
  },
  {
    "question": "Bir 'Union' ile bir öğrencinin kimlik bilgilerini tanımlayın. Öğrencinin tüm bilgilerini saklamak için 'Union' kullanmanın avantajlarını açıklayın.",
    "answer": "Aşağıdaki kodda bir öğrenci kimlik bilgilerini saklamak için 'Union' kullanılmıştır:\n\n```c\n#include <stdio.h>\n\nunion KimlikBilgisi {\n    int ogrenciNo;\n    char tcKimlik[12];\n};\n\nstruct Ogrenci {\n    char isim[50];\n    union KimlikBilgisi kimlik;\n};\n\nint main() {\n    struct Ogrenci ogr;\n    printf(\"Ogrenci ismini girin: \");\n    scanf(\"%s\", ogr.isim);\n    printf(\"Ogrenci numarasını girin: \");\n    scanf(\"%d\", &ogr.kimlik.ogrenciNo);\n    printf(\"Ogrenci: %s, No: %d\\n\", ogr.isim, ogr.kimlik.ogrenciNo);\n    return 0;\n}\n```\n'Union' kullanmanın avantajı, bellek tasarrufu sağlamasıdır. Öğrencinin numarası veya T.C. kimlik numarası gibi farklı bilgileri tek bir alanda saklayarak bellek kullanımını optimize edebiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928241"
  },
  {
    "question": "Bir 'Union' ile bir veri türü oluşturun. Ardından, bu veri türü ile bir dizi tanımlayın ve dizi elemanlarını yazdırın.",
    "answer": "Aşağıdaki örnekte, bir 'Union' ile bir veri türü oluşturulmuş ve bu türden bir dizi tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nunion Veri {\n    int tamsayi;\n    float ondalik;\n    char karakter;\n};\n\nint main() {\n    union Veri veriDizisi[3];\n    veriDizisi[0].tamsayi = 10;\n    veriDizisi[1].ondalik = 15.5;\n    veriDizisi[2].karakter = 'A';\n\n    printf(\"Dizi elemanları:\\n\");\n    printf(\"1. Eleman (Tam Sayı): %d\\n\", veriDizisi[0].tamsayi);\n    printf(\"2. Eleman (Ondalık): %.2f\\n\", veriDizisi[1].ondalik);\n    printf(\"3. Eleman (Karakter): %c\\n\", veriDizisi[2].karakter);\n    return 0;\n}\n```\nBu örnekte, 'Union' veri türü ile farklı türde verileri tek bir yapı altında saklayabiliyoruz. Ancak unutulmamalıdır ki, her bir 'Union' elemanı aynı bellek alanını paylaştığı için sadece bir değer geçerli olur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928279"
  },
  {
    "question": "Bir 'Union' ve bir 'Struct' yapısını bir arada kullanarak bir üçgen veri yapısını tanımlayın. Üçgenin alanını hesaplayın.",
    "answer": "Aşağıdaki örnekte, bir 'Struct' içinde 'Union' kullanarak bir üçgen yapısı tanımlanmış ve alan hesaplaması yapılmıştır:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nunion Kenar {\n    float uzunluk;\n    float kisa;\n};\n\nstruct Ucgen {\n    union Kenar kenar;\n    float yukseklik;\n};\n\nint main() {\n    struct Ucgen ucgen;\n    ucgen.kenar.uzunluk = 5.0;\n    ucgen.yukseklik = 4.0;\n    float alan = (ucgen.kenar.uzunluk * ucgen.yukseklik) / 2;\n    printf(\"Ucgenin alani: %.2f\\n\", alan);\n    return 0;\n}\n```\nBu örnekte, üçgenin bir kenarı ve yüksekliği 'Union' ve 'Struct' kullanılarak tanımlanmıştır. Bu sayede alan hesaplama işlemi yapılmıştır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928315"
  },
  {
    "question": "Bir 'Union' ile bir dosya türü tanımlayın ve bu dosya türüne göre bir dosya açma fonksiyonu yazın.",
    "answer": "Aşağıdaki kod örneğinde, farklı dosya türlerini saklamak için bir 'Union' tanımlanmış ve dosya açma işlemi için bir fonksiyon yazılmıştır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nunion DosyaTuru {\n    char text[50];\n    char binary[50];\n};\n\nvoid dosyaAc(union DosyaTuru dosya, int secim) {\n    FILE *fp;\n    if (secim == 1) {\n        fp = fopen(dosya.text, \"r\");\n        if (fp == NULL) {\n            printf(\"Dosya açılamadı\\n\");\n        } else {\n            printf(\"Text dosyası açıldı: %s\\n\", dosya.text);\n            fclose(fp);\n        }\n    } else {\n        fp = fopen(dosya.binary, \"rb\");\n        if (fp == NULL) {\n            printf(\"Dosya açılamadı\\n\");\n        } else {\n            printf(\"Binary dosyası açıldı: %s\\n\", dosya.binary);\n            fclose(fp);\n        }\n    }\n}\n\nint main() {\n    union DosyaTuru dosya;\n    strcpy(dosya.text, \"ornek.txt\");\n    dosyaAc(dosya, 1);\n    strcpy(dosya.binary, \"ornek.bin\");\n    dosyaAc(dosya, 2);\n    return 0;\n}\n```\n'Union' kullanarak dosya türlerini tanımlamak, bellek kullanımını optimize etmekte ve farklı türde dosya açma işlemlerini kolaylaştırmaktadır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928346"
  },
  {
    "question": "Bir 'Union' ile bir renk kodu tanımlayın. RGB ve HEX formatında renkleri saklayın ve her iki formatı da yazdırın.",
    "answer": "Aşağıdaki örnekte, bir 'Union' kullanarak renk kodlarını tanımlayan bir yapı oluşturulmuş ve her iki renk formatı yazdırılmıştır:\n\n```c\n#include <stdio.h>\n\nunion Renk {\n    struct {\n        unsigned char r, g, b;\n    } rgb;\n    char hex[7];\n};\n\nint main() {\n    union Renk renk;\n    renk.rgb.r = 255;\n    renk.rgb.g = 0;\n    renk.rgb.b = 0;\n    sprintf(renk.hex, \"#%02X%02X%02X\", renk.rgb.r, renk.rgb.g, renk.rgb.b);\n    printf(\"RGB: (%d, %d, %d)\\n\", renk.rgb.r, renk.rgb.g, renk.rgb.b);\n    printf(\"HEX: %s\\n\", renk.hex);\n    return 0;\n}\n```\nBu örnekte, 'Union' kullanarak RGB ve HEX formatında renkleri saklayabiliyoruz. Ancak, sadece bir format geçerli olacak ve diğer format belirsizleşecektir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928380"
  },
  {
    "question": "Bir 'Union' ile bir öğrencinin notlarını ve isimlerini saklayan bir yapı tanımlayın. En yüksek notu yazdırın.",
    "answer": "Aşağıdaki kodda bir 'Union' ile bir öğrencinin notlarını ve isimlerini saklayan bir yapı tanımlanmış ve en yüksek not yazdırılmıştır:\n\n```c\n#include <stdio.h>\n\nunion Notlar {\n    int not1;\n    float not2;\n};\n\nstruct Ogrenci {\n    char isim[50];\n    union Notlar not;\n};\n\nint main() {\n    struct Ogrenci ogr;\n    printf(\"Ogrenci ismini girin: \");\n    scanf(\"%s\", ogr.isim);\n    ogr.not.not1 = 85;\n    printf(\"Ogrenci: %s, Not: %d\\n\", ogr.isim, ogr.not.not1);\n    ogr.not.not2 = 92.5;\n    printf(\"Ogrenci: %s, En yüksek not: %.2f\\n\", ogr.isim, ogr.not.not2);\n    return 0;\n}\n```\nBu örnekte, 'Union' kullanarak bir öğrencinin notlarını saklayabiliyoruz. Ancak dikkat edilmesi gereken nokta, son olarak hangi not türünün geçerli olduğu.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928412"
  },
  {
    "question": "Bir 'Union' ile bir araç türü tanımlayın. Farklı araç türleri ile bir dizi oluşturun ve bu araçların bilgilerini yazdırın.",
    "answer": "Aşağıdaki örnekte, bir 'Union' ile farklı araç türlerini tanımlamak ve bu türlerden bir dizi oluşturmak için bir yapı oluşturulmuştur:\n\n```c\n#include <stdio.h>\n\nunion Arac {\n    struct {\n        char marka[20];\n        int hiz;\n    } araba;\n    struct {\n        char marka[20];\n        int kapasite;\n    } otobus;\n};\n\nint main() {\n    union Arac araclar[2];\n    strcpy(araclar[0].araba.marka, \"Ford\");\n    araclar[0].araba.hiz = 120;\n    strcpy(araclar[1].otobus.marka, \"Mercedes\");\n    araclar[1].otobus.kapasite = 50;\n\n    printf(\"Araba: %s, Hız: %d km/s\\n\", araclar[0].araba.marka, araclar[0].araba.hiz);\n    printf(\"Otobus: %s, Kapasite: %d\\n\", araclar[1].otobus.marka, araclar[1].otobus.kapasite);\n    return 0;\n}\n```\nBu örnekte, 'Union' kullanarak farklı araç türlerinin bilgilerini saklayabiliyoruz. Her bir araç türü için farklı alanlar kullanılmakta ancak her biri aynı bellek alanını paylaşmaktadır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928446"
  },
  {
    "question": "Bir 'Union' ile bir hesap makinesi uygulaması oluşturun. Kullanıcının seçimine göre toplama ve çarpma işlemlerini gerçekleştirin.",
    "answer": "Aşağıdaki örnekte, bir 'Union' ile bir hesap makinesi uygulaması oluşturulmuş ve kullanıcıdan alınan verilere göre toplama ve çarpma işlemleri yapılmıştır:\n\n```c\n#include <stdio.h>\n\nunion HesapMakinesi {\n    float sayi1;\n    float sayi2;\n};\n\nint main() {\n    union HesapMakinesi hesap;\n    int secim;\n    printf(\"1. sayıyı girin: \");\n    scanf(\"%f\", &hesap.sayi1);\n    printf(\"2. sayıyı girin: \");\n    scanf(\"%f\", &hesap.sayi2);\n    printf(\"1. işlem için 1, 2. işlem için 2'yi seçin: \");\n    scanf(\"%d\", &secim);\n    if (secim == 1) {\n        printf(\"Toplama: %.2f\\n\", hesap.sayi1 + hesap.sayi2);\n    } else if (secim == 2) {\n        printf(\"Çarpma: %.2f\\n\", hesap.sayi1 * hesap.sayi2);\n    } else {\n        printf(\"Geçersiz seçim.\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, 'Union' kullanarak bir hesap makinesi uygulaması oluşturulmuştur. Kullanıcıdan alınan sayılar üzerinden toplama veya çarpma işlemleri gerçekleştirilmiştir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:24.928480"
  },
  {
    "question": "Union kullanırken alan boyutları doğru hesaplanmadığında ne olur?",
    "answer": "Union kullanıldığında, tüm alanlar için en büyük boyutlu alan yeterince alan kaplar. Eğer alan boyutları yanlış hesaplanırsa, bellek hataları oluşabilir. Örneğin, bir union tanımlarken int ve float tiplerini kullandığınızda, float için alan boyutu yeterince büyük olmayabilir ve bu durum bellek bozulmalarına yol açabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.445909"
  },
  {
    "question": "Union içindeki bir alanı atadıktan sonra diğer alanı okuduğumda neden beklenmedik sonuçlar alıyorum?",
    "answer": "Union'da sadece bir alan aynı anda kullanılmalıdır. Eğer bir alanı atayıp diğerini okumaya çalışırsanız, okumadığınız alanın içeriği bozulmuş olacaktır. Örneğin, bir union tanımında önce bir int atayıp, sonrasında float okumaya çalışırsanız, float değeri geçersiz olacaktır çünkü int'in bellekte kapladığı alan, float için uyumlu bir formatta saklanmıyor olabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.445957"
  },
  {
    "question": "Union kullanırken hangi durumlarda tipi değiştirmeliyim?",
    "answer": "Union kullanımı sırasında, içerideki veri tipine göre işlemler yapmalısınız. Eğer union'dan bir alan okuduysanız, o alanın tipine göre işlem yapmalısınız. Örneğin, bir kullanıcıdan alınan veri uzunluğu bilinmiyorsa, önce hangi tipin kullanıldığını belirlemek için bir işaretçi kullanarak tipi kontrol etmelisiniz. Bu, belleği korumak ve hataları önlemek için önemlidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.445978"
  },
  {
    "question": "Union ve struct arasındaki temel fark nedir?",
    "answer": "Union ve struct arasındaki temel fark, memory alanını yönetim şeklidir. Struct, tüm alanlar için ayrı ayrı bellek alanları ayırırken, union yalnızca en büyük alana göre tek bir bellek alanı ayırır. Bu, union'ı daha az bellek kullanımı için ideal hale getirir ancak sadece bir alanın geçerli olduğu durumlar için kullanılması gerektiğini unutmamalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.445997"
  },
  {
    "question": "Union içinde bir dizi tanımlamak mantıklı mı?",
    "answer": "Union içinde bir dizi tanımlamak mantıklı değildir çünkü union'da yalnızca bir alan geçerli olmalıdır. Eğer bir dizi tanımlarsanız, dizi içindeki her eleman için bellekte yer kaplayacağından bu, beklenmedik sonuçlar ve bellek sorunlarına yol açabilir. Bunun yerine, diziyi struct içinde tanımlamak daha uygun bir yaklaşımdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446016"
  },
  {
    "question": "Bir union tanımladıktan sonra bellekte ne kadar alan kaplar?",
    "answer": "Union, tanımlanan en büyük alanın boyutunu kullanır. Örneğin, bir union'da bir int (4 byte) ve bir double (8 byte) varsa, union 8 byte yer kaplayacaktır. Bu nedenle, her zaman en büyük veri tipinin boyutunu göz önünde bulundurmalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446038"
  },
  {
    "question": "Union kullanarak farklı tipteki verileri nasıl saklayabilirim?",
    "answer": "Union, farklı veri tiplerini aynı bellek alanında saklamak için idealdir. Örneğin, bir veri tipini tanımlamak için bir union oluşturabilir ve bu union içinde int, float ve char gibi farklı türleri tanımlayabilirsiniz. Belleği etkin kullanmak için yalnızca ihtiyacınız olan alanı kullanmalısınız; ancak işlem yaparken hangi veriyi kullandığınıza dikkat etmelisiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446059"
  },
  {
    "question": "Union kullanımı sırasında hangi hata mesajları ile karşılaşabilirim?",
    "answer": "Union kullanımı sırasında genellikle 'type punning' hataları ile karşılaşabilirsiniz. Bu, bir union içindeki bir alanı atayıp diğerini okuduğunuzda, beklenmedik veri veya bellek erişim hataları almanıza neden olur. Bunun için, kullandığınız veri tipinin doğruluğunu kontrol etmek önemlidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446080"
  },
  {
    "question": "Union kullanarak bir veri yapısını nasıl tanımlarım?",
    "answer": "Union kullanarak bir veri yapısını tanımlamak için önce union'ı tanımlamalı ve ardından ihtiyacınıza göre alanları eklemelisiniz. Örneğin, bir union ile bir kullanıcı verisi içeren yapı oluşturabilirsiniz: 'union UserData { int id; float salary; char name[20]; };'. Bu şekilde, kullanıcıya ait verileri tek bir yapıda saklayabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446099"
  },
  {
    "question": "Eğer union içinde bir pointer kullanırsam nelere dikkat etmeliyim?",
    "answer": "Union içinde bir pointer kullanmak, özellikle pointer'ın işaret ettiği alanın yönetimi açısından dikkat gerektirir. Pointer'ın işaret ettiği belleği doğru bir şekilde yönetmediğinizde, bellek sızıntıları veya çökme gibi sorunlar yaşayabilirsiniz. Pointer'ı kullanmadan önce hangi tipin kullanıldığını kontrol etmek önemlidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446120"
  },
  {
    "question": "Bir union içindeki bir alanı atadıktan sonra nasıl kontrol ederim?",
    "answer": "Union içindeki bir alanı atadıktan sonra, hangi alanın kullanıldığını kontrol etmek için bir tür belirteci kullanabilirsiniz. Örneğin, bir enum tanımlayarak hangi alanın geçerli olduğunu belirtebilirsiniz. Bu, kodunuzun daha okunabilir olmasını sağlar ve yanlışlıkla kullanılabilecek alanları önler.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:25:49.446142"
  },
  {
    "question": "Bir union tanımladım ama içindeki değerleri doğru bir şekilde yazdıramıyorum. Nedenini açıklayabilir misiniz?",
    "answer": "Union, birden fazla veri tipini aynı bellek alanında saklamanızı sağlar. Ancak, sadece bir veri tipi ile çalışabilirsiniz. Eğer union içerisindeki bir değeri yazdırmak istiyorsanız, o an kullanılan veri tipini bilmeniz gerekir. Aksi takdirde, beklenmeyen sonuçlar alabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    union Data data;\n    data.i = 10; // 'i' alanını kullanıyoruz\n    printf(\"Data: %d\\n\", data.i); // Çalışır, 10 basılır\n    printf(\"Data: %f\\n\", data.f); // Yanlış, belirsiz sonuç\n    return 0;\n}\n```\nBurada `data.f` yazdırıldığında, beklenmedik bir değer alırsınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.520924"
  },
  {
    "question": "Bir union içerisindeki elemanların boyutunu nasıl doğru bir şekilde alabilirim?",
    "answer": "Union'ın boyutu, en büyük elemanının boyutuna eşittir. Yani, içindeki elemanlardan hangisi büyükse, union o büyüklükte yer kaplar. Bu durumu şöyle inceleyebilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    printf(\"Union boyutu: %zu\\n\", sizeof(union Data)); // Çıktı: 4 veya 8 (platforma bağlı)\n    return 0;\n}\n```\nBu durumda, `int` ve `float` genellikle 4 byte, `char` ise 1 byte'tır. En büyük olan `int` ya da `float` olduğu için union boyutu 4 byte olur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.520966"
  },
  {
    "question": "Union kullanırken birden fazla elemanı nasıl güvenli bir şekilde saklayabilirim?",
    "answer": "Union'da sadece bir eleman aktif olarak kullanılabilir. Bu nedenle, birden fazla elemanı saklamak için bir yapı (struct) ya da bir dizi kullanmayı düşünebilirsiniz. Ancak, bir union ve bir struct'ı birleştirerek bir çözüm bulabilirsiniz:\n\n```c\n#include <stdio.h>\n\nstruct Data {\n    union {\n        int i;\n        float f;\n    } value;\n    char type; // Hangi tür veriyi sakladığımızı belirtmek için\n};\n\nint main() {\n    struct Data data;\n    data.value.i = 10;\n    data.type = 'i';\n    printf(\"Data: %d, Type: %c\\n\", data.value.i, data.type);\n    return 0;\n}\n```\nBu şekilde, hangi tür veriyi sakladığınızı bilirsiniz ve gerektiğinde doğru elemanı kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.520993"
  },
  {
    "question": "Union ve struct arasındaki temel farklar nelerdir?",
    "answer": "Union ve struct arasındaki temel fark, bellek yönetimidir. Struct, her bir üyesi için ayrı bir bellek alanı ayırırken, union sadece en büyük üyesi için bir alan ayırır. Örneğin:\n\n```c\nstruct Example {\n    int i;\n    float f;\n};\n\nunion ExampleUnion {\n    int i;\n    float f;\n};\n\nint main() {\n    printf(\"Struct boyutu: %zu\\n\", sizeof(struct Example)); // Çıktı: 8 veya 12 (platforma bağlı)\n    printf(\"Union boyutu: %zu\\n\", sizeof(union ExampleUnion)); // Çıktı: 4 veya 8 (en büyük elemana göre)\n    return 0;\n}\n```\nBuradan, struct'ın daha fazla bellek kullandığını görebilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521013"
  },
  {
    "question": "Bir union içerisinde birden fazla türle nasıl işlem yapabilirim?",
    "answer": "Union içerisinde birden fazla türle işlem yaparken, hangi türün kullanıldığını bilmek önemlidir. Bunu bir kontrol mekanizması ile sağlamak en iyi yöntemdir. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    union Data data;\n    data.i = 10;\n    int type = 1; // 1 = int, 2 = float, 3 = char\n\n    if (type == 1) {\n        printf(\"Data: %d\\n\", data.i);\n    } else if (type == 2) {\n        printf(\"Data: %f\\n\", data.f);\n    } else if (type == 3) {\n        printf(\"Data: %c\\n\", data.c);\n    }\n    return 0;\n}\n```\nBu şekilde, tür kontrolü yaparak doğru elemanı kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521036"
  },
  {
    "question": "Union içinde pointer kullanmak mantıklı mı? Hangi durumlarda sorun çıkarabilir?",
    "answer": "Union içinde pointer kullanmak mümkündür, ancak dikkatli olmanız gerekir. Çünkü pointer'ın işaret ettiği bellek alanı, union'ın diğer elemanları ile çakışabilir ve bellek sızıntısına yol açabilir. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int *i;\n    float *f;\n};\n\nint main() {\n    union Data data;\n    int num = 10;\n    data.i = &num;\n    printf(\"Data: %d\\n\", *(data.i)); // Çalışır\n    return 0;\n}\n```\nAncak, eğer `data.f`'yi kullanmaya çalışırsanız, belirsiz bir davranış elde edersiniz. Bu nedenle, union kullanırken pointer'ların yönetimine dikkat etmelisiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521061"
  },
  {
    "question": "Union ve enum birlikte nasıl kullanılabilir? Bir örnek verebilir misiniz?",
    "answer": "Union ve enum birlikte kullanılabilir ve bu, veri türlerini daha düzenli hale getirir. Enum, hangi tür verinin aktif olduğunu belirlemek için kullanılabilir. Örnek:\n\n```c\n#include <stdio.h>\n\nenum DataType {\n    INTEGER,\n    FLOAT,\n    CHAR\n};\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    union Data data;\n    enum DataType type = INTEGER;\n\n    if (type == INTEGER) {\n        data.i = 10;\n        printf(\"Data: %d\\n\", data.i);\n    }\n    return 0;\n}\n```\nBu örnekte, enum belirli bir türü belirtmek için kullanılır ve bu sayede veriyi daha güvenli bir şekilde yönetebiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521085"
  },
  {
    "question": "Union kullanarak bazı bellek optimizasyonları yapabilir miyim?",
    "answer": "Evet, union kullanmak bellek optimizasyonu için etkili bir yöntem olabilir. Çünkü union, birden fazla veri tipini aynı bellek alanında saklar. Bu, özellikle sınırlı bellek kaynaklarına sahip sistemlerde faydalıdır. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    union Data data[10]; // 10 elemanlı bir union dizisi\n    data[0].i = 10;\n    data[1].f = 5.5;\n    data[2].c = 'A';\n    // Her eleman için sadece en büyük alan kadar bellek kullanılır\n    printf(\"Union dizisinin boyutu: %zu\\n\", sizeof(data));\n    return 0;\n}\n```\nBurada 10 elemanlı bir union dizisi, her eleman için yalnızca en büyük tipin boyutunu kullanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521106"
  },
  {
    "question": "C'de union kullanmanın dezavantajları nelerdir?",
    "answer": "Union kullanmanın bazı dezavantajları vardır. Öncelikle, sadece bir elemanı aynı anda kullanabilirsiniz; bu, veri kaybına yol açabilir. Ayrıca, hangi verinin geçerli olduğunu takip etmek için ek bir mekanizma gerekir. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n};\n\nint main() {\n    union Data data;\n    data.i = 10;\n    // data.f kullanılırsa, 'i' değeri kaybolur\n    printf(\"Data: %d\\n\", data.i);\n    return 0;\n}\n```\nBu örnekte, `data.f` kullanıldığında `data.i` değeri geçersiz hale gelir. Ayrıca, union'ların boyutları sınırlıdır ve karmaşık yapılar oluşturmak zorlaşabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:26:24.521124"
  },
  {
    "question": "C dilinde bir union tanımlayıp, birden fazla değişkeni aynı bellek alanında depolamak istiyorum. Ancak union'ı kullanarak iki farklı türde veri saklamak istediğimde veriler birbirine karışıyor. Sorun nedir?",
    "answer": "Union, aynı bellek alanını paylaşan değişkenleri tanımlamak için kullanılır. Örneğin, aşağıdaki şekilde tanımlanmış bir union: \n\n```c\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n```\nBu union'da `i`, `f` ve `c` aynı bellek alanında yer alır. Eğer `i`'yi atadıktan sonra `f`'ye bir değer atarsanız, `i`'nin değeri kaybolur ve bellek alanında `f`'nin değeri görünür hale gelir. Bu nedenle, her seferinde bir türde veri saklamalısınız. Eğer her türde veri saklamak istiyorsanız, struct kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094546"
  },
  {
    "question": "Union kullanarak bir değişkenin tipini nasıl kontrol edebilirim? Örnek bir senaryo sunabilir misin?",
    "answer": "Union ile birlikte tip kontrolü için genellikle bir enum veya bir işaretçi kullanılır. Aşağıdaki örnekte, bir union içindeki veriyi kontrol etmek için bir enum kullandık:\n\n```c\n#include <stdio.h>\n\ntypedef enum { INT, FLOAT, CHAR } DataType;\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nstruct Variable {\n    DataType type;\n    union Data data;\n};\n\nint main() {\n    struct Variable var;\n    var.type = INT;\n    var.data.i = 10;\n\n    switch (var.type) {\n        case INT:\n            printf(\"Int: %d\\n\", var.data.i);\n            break;\n        case FLOAT:\n            printf(\"Float: %f\\n\", var.data.f);\n            break;\n        case CHAR:\n            printf(\"Char: %c\\n\", var.data.c);\n            break;\n    }\n    return 0;\n}\n```\nBu örnekte, union'ı kullanarak bir değişkenin türünü `DataType` enum'u ile kontrol ediyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094593"
  },
  {
    "question": "C dilinde union kullanarak bir yapı içerisinde kullanmak istiyorum. Ancak iç içe yapıların bellek alanı hesaplamasında sorun yaşıyorum. Nedenini açıklayabilir misin?",
    "answer": "Union kullanırken bellek alanı en büyük elemanın boyutu kadar olur. Eğer union'ı bir yapı içinde kullanıyorsanız, yapının toplam boyutu da union'ın boyutuna göre hesaplanacaktır. Örneğin:\n\n```c\nstruct Example {\n    union Data {\n        int i;\n        float f;\n        char c;\n    } data;\n    int id;\n};\n```\nBu durumda, `Example` yapısının boyutu `union Data`'nın en büyük elemanı olan `float`'un boyutuna göre hesaplanacaktır. Bu durum, iç içe yapıların bellek kullanımında hatalara yol açabilir, dolayısıyla dikkatli kullanılmalıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094639"
  },
  {
    "question": "Bir union'daki verilerin boyutunu öğrenmek istiyorum. Bunun için uygun bir yöntem var mı?",
    "answer": "Union'daki verilerin boyutunu öğrenmek için `sizeof` operatörünü kullanabilirsiniz. Ancak, union'ın boyutu, en büyük veri türünün boyutuna eşit olacaktır. Örneğin:\n\n```c\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    printf(\"Union boyutu: %zu\\n\", sizeof(union Data));\n    return 0;\n}\n```\nBurada `sizeof(union Data)` ifadesi, union'ın en büyük öğesi olan `float`'un boyutunu döndürecektir. Bu nedenle, her zaman en büyük türün boyutunu dikkate alarak hesap yapmalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094676"
  },
  {
    "question": "C dilinde bir union ile fonksiyona geçiş yaparken, hangi türde verinin geçileceğini nasıl belirleyebilirim?",
    "answer": "Union'ı bir fonksiyona geçirirken, verinin türünü belirlemek için genellikle ek bir parametre kullanırız. Örneğin:\n\n```c\n#include <stdio.h>\n\ntypedef enum { INT, FLOAT } DataType;\n\nunion Data {\n    int i;\n    float f;\n};\n\nvoid printData(DataType type, union Data data) {\n    switch (type) {\n        case INT:\n            printf(\"Değer: %d\\n\", data.i);\n            break;\n        case FLOAT:\n            printf(\"Değer: %f\\n\", data.f);\n            break;\n    }\n}\n\nint main() {\n    union Data d;\n    d.i = 10;\n    printData(INT, d);\n    d.f = 3.14;\n    printData(FLOAT, d);\n    return 0;\n}\n```\nBu örnekte, `printData` fonksiyonu, verinin türünü belirlemek için `DataType` enum'ını kullanıyor.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094707"
  },
  {
    "question": "Bir union içindeki veriler, programın akışında beklenmedik bir şekilde değişiyor. Neden böyle bir durumla karşılaşabilirim?",
    "answer": "Eğer bir union içindeki veri türünü değiştirdiyseniz ve önceki değeri kullanıyorsanız, bu beklenmedik sonuçlara yol açabilir. Örneğin:\n\n```c\nunion Data {\n    int i;\n    float f;\n};\n\nint main() {\n    union Data d;\n    d.i = 5;\n    printf(\"Int: %d\\n\", d.i);\n    d.f = 3.14;\n    printf(\"Float: %f\\n\", d.f);\n    printf(\"Int: %d\\n\", d.i); // Beklenmedik sonuç\n    return 0;\n}\n```\nBu kodda ilk önce `i` değerine bir veri atanıyor, sonra `f` değerine yeni bir veri atanıyor. Ancak `i` değerinin durumu bilinmez hale geliyor ve bu nedenle beklenmedik sonuçlar çıkabilir. Her seferinde yalnızca bir türde veri kullanmalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094740"
  },
  {
    "question": "Bir union içerisinde bir işlev tanımlarken, o işlevin hangi türde veri ile çalıştığını belirtmek için ne yapmalıyım?",
    "answer": "Bir union içindeki işlev tanımlarken, öncelikle bir parametre ile veri türünü belirtmelisiniz. İşte bir örnek:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n};\n\nvoid processData(union Data data, int type) {\n    if (type == 0) {\n        printf(\"Integer: %d\\n\", data.i);\n    } else if (type == 1) {\n        printf(\"Float: %f\\n\", data.f);\n    }\n}\n\nint main() {\n    union Data d;\n    d.i = 20;\n    processData(d, 0);\n    d.f = 7.5;\n    processData(d, 1);\n    return 0;\n}\n```\nBurada `processData` fonksiyonu, hangi türde veri ile çalıştığını belirlemek için bir `type` parametresi alıyor.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094772"
  },
  {
    "question": "C dilinde union kullanarak bir dizi oluşturmak istiyorum, ancak dizinin elemanlarını nasıl yönetebilirim? Bu konuda bir örnek verebilir misin?",
    "answer": "Union ile bir dizi oluşturmak mümkündür, ancak her bir elemanın türünü yönetmek için ek bir yapı veya enum kullanmanız gerekir. Örneğin:\n\n```c\n#include <stdio.h>\n\ntypedef enum { INT, FLOAT } DataType;\n\nunion Data {\n    int i;\n    float f;\n};\n\nstruct Variable {\n    DataType type;\n    union Data data;\n};\n\nint main() {\n    struct Variable array[3];\n    array[0].type = INT;\n    array[0].data.i = 10;\n    array[1].type = FLOAT;\n    array[1].data.f = 5.5;\n\n    for (int i = 0; i < 2; i++) {\n        if (array[i].type == INT) {\n            printf(\"Int: %d\\n\", array[i].data.i);\n        } else if (array[i].type == FLOAT) {\n            printf(\"Float: %f\\n\", array[i].data.f);\n        }\n    }\n    return 0;\n}\n```\nBurada `Variable` yapısını kullanarak bir dizi oluşturdum ve her elemanın türünü kontrol edebiliyoruz. Bu sayede her elemanı doğru bir şekilde işleyebiliyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094809"
  },
  {
    "question": "Union kullanarak iki farklı türde değişken ile birlikte bir veri yapısı oluşturmak istiyorum. Belirli bir türü kullandıktan sonra diğerine geçiş yaparken dikkat etmem gerekenler neler?",
    "answer": "Union kullanırken, geçiş yaparken dikkat etmeniz gereken ana nokta, yalnızca bir türde veriyle çalışmanız gerektiğidir. Aşağıdaki örnek, bu durumu göstermektedir:\n\n```c\n#include <stdio.h>\n\nunion Value {\n    int i;\n    float f;\n};\n\nint main() {\n    union Value val;\n    val.i = 42;\n    printf(\"Integer: %d\\n\", val.i);\n    // Burada float'a geçiyoruz\n    val.f = 3.14;\n    printf(\"Float: %f\\n\", val.f);\n    // Burada val.i kullanmak belirsiz bir sonuç verecektir\n    printf(\"Integer: %d\\n\", val.i); // Belirsiz sonuç\n    return 0;\n}\n```\nBu örnekte, ilk önce `i` değerine bir değer atanıyor, daha sonra `f` değerine geçiliyor. Ancak `val.i` kullanıldığında belirsiz bir sonuç alacağız. Bu nedenle, sadece bir türde veriyi kullanmalı ve diğer türü kullandıktan sonra önceki değeri referans almamalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:12.094866"
  },
  {
    "question": "C dilinde union nedir?",
    "answer": "Union, birden fazla veri tipini tek bir bellek alanında tutabilen bir veri yapısıdır. Tüm elemanlar aynı bellek alanını paylaştığı için, yalnızca bir elemanın değeri tutulabilir. Bu, bellek kullanımını optimize etmek için yararlıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770487"
  },
  {
    "question": "Bir union nasıl tanımlanır?",
    "answer": "Bir union tanımlamak için 'union' anahtar kelimesi kullanılır. Örneğin:\n\n```c\nunion Veri {\n    int sayi;\n    float ondalik;\n};\n```\nBu örnekte, 'Veri' adında bir union tanımlanmıştır ve içinde bir tamsayı ve bir float değişkeni bulunmaktadır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770554"
  },
  {
    "question": "Bir union'dan nasıl değer okunur?",
    "answer": "Union'dan değer okumak için ilgili elemanın adı kullanılır. Örneğin:\n\n```c\nunion Veri veri;\nveri.sayi = 10;\nprintf(\"Sayi: %d\", veri.sayi);\n```\nBu kod, 'sayi' elemanının değerini okur ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770586"
  },
  {
    "question": "Union kullanmanın avantajları nelerdir?",
    "answer": "Union kullanmanın başlıca avantajı; bellek tasarrufu sağlamasıdır. Aynı bellek alanını farklı veri tipleri için kullanarak, programın genel bellek tüketimini azaltır. Ayrıca, karmaşık veri yapılarında daha esnek bir yapı sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770613"
  },
  {
    "question": "Union ile struct arasındaki fark nedir?",
    "answer": "Union ve struct arasındaki temel fark, bellek yönetimidir. Struct'ta her eleman ayrı bir bellek alanı kaplar ve tüm elemanlar aynı anda kullanılabilir. Union'da ise tüm elemanlar aynı bellek alanını paylaşır ve yalnızca bir eleman kullanılabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770642"
  },
  {
    "question": "Bir union içinde string kullanabilir miyim?",
    "answer": "Evet, ancak dikkatli olmalısınız. Çünkü union içinde bir dizi (örneğin string) kullanırsanız, dizi boyutunu yeterince büyük tanımlamanız gerekir. Örneğin:\n\n```c\nunion Veri {\n    char mesaj[20];\n    int sayi;\n};\n```\nBu örnekte 'mesaj' elemanı için 20 karakterlik bir alan tanımlanmıştır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770673"
  },
  {
    "question": "Union içindeki son atanan değeri nasıl alırım?",
    "answer": "Union içindeki son atanan değeri almak için ilgili eleman adıyla erişmeniz gerekir. Örneğin:\n\n```c\nunion Veri veri;\nveri.sayi = 10;\nveri.ondalik = 5.5;\nprintf(\"Ondalik: %f\", veri.ondalik);\n```\nBurada 'ondalik' elemanı son atanan değerdir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770707"
  },
  {
    "question": "Bir union kullanarak bir dosyadan veri okuma işlemi nasıl yapılır?",
    "answer": "Bir union kullanarak bir dosyadan veri okuma işlemi, dosyadan okunan veriyi bir union elemanı ile eşleştirerek yapılabilir. Örneğin:\n\n```c\nunion Veri {\n    int sayi;\n    float ondalik;\n};\n\nunion Veri veri;\nFILE *dosya = fopen(\"veri.txt\", \"r\");\nfscanf(dosya, \"%d\", &veri.sayi);\nfclose(dosya);\n```\nBu kod parçası, bir dosyadan tamsayı okur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770756"
  },
  {
    "question": "Union içinde birden fazla eleman tanımlayabilir miyim?",
    "answer": "Evet, bir union içinde birden fazla eleman tanımlayabilirsiniz, ancak bunların hepsi aynı bellek alanını paylaşır. Yani yalnızca bir elemanın değeri geçerli olur. Örneğin:\n\n```c\nunion Veri {\n    int sayi;\n    float ondalik;\n    char karakter;\n};\n```\nBu union'da üç eleman tanımlanmıştır ama yalnızca birini kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770789"
  },
  {
    "question": "Union kullanırken bellek sızıntısı olma ihtimali var mı?",
    "answer": "Union kullanırken doğrudan bellek sızıntısı olmaz çünkü union, yalnızca bir eleman için bellek tahsis eder. Ancak, union içindeki dizi veya struct gibi karmaşık elemanlar kullanılıyorsa, bu elemanların yönetimi sırasında bellek sızıntısı oluşabilir. Bu nedenle, dinamik bellek kullanıyorsanız dikkatli olmalısınız.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770824"
  },
  {
    "question": "Union kullanarak bir enum ile birlikte nasıl çalışabilirim?",
    "answer": "Union ile birlikte bir enum kullanarak değişkenlerinizi daha düzenli bir şekilde yönetebilirsiniz. Örneğin:\n\n```c\ntypedef enum { SAYI, ONDALIK } VeriTipi;\n\nunion Veri {\n    int sayi;\n    float ondalik;\n};\n\nstruct VeriBilgisi {\n    union Veri veri;\n    VeriTipi tip;\n};\n```\nBu yapıda, 'VeriBilgisi' yapısı bir union ve enum kullanarak hem veri tipini hem de verinin kendisini saklar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:33.770860"
  },
  {
    "question": "C dilinde union nedir ve ne amaçla kullanılır?",
    "answer": "Union, birden fazla veri tipini aynı bellek alanında saklamaya olanak tanıyan bir yapıdır. Bu yapı sayesinde, bir değişkenin farklı veri tiplerinde saklanabilmesini sağlarız. Örneğin, bir değişkenin hem bir tam sayıyı hem de bir float sayıyı temsil etmesini istediğimizde union kullanabiliriz. Bütün veri tipleri için en büyük boyut kadar alan kaplar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746189"
  },
  {
    "question": "Bir union tanımlarken nelere dikkat etmeliyiz?",
    "answer": "Union tanımlarken, içindeki en büyük veri tipinin boyutuna göre bellek alanı ayrıldığını unutmamalıyız. Ayrıca, her bir üyeye erişim sağlarken yalnızca son atanan değeri kullanmalıyız. Aksi takdirde beklenmedik sonuçlar elde edebiliriz. Örneğin, bir union'da bir tam sayıyı atadıktan sonra float bir değer atadığımızda, tam sayıya geri döndüğümüzde yanlış sonuç alabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746227"
  },
  {
    "question": "C dilinde union kullanarak bir renk modelini nasıl temsil edebiliriz?",
    "answer": "Bir renk modelini temsil etmek için bir union tanımlayabiliriz. Örneğin, RGB renk modelini kullanarak, her bir rengin değerini ayrı ayrı saklayabiliriz. Aşağıdaki örnekte, bir union kullanarak RGB modelini tanımlıyoruz:\n\n```c\nunion RGB {\n    struct {\n        unsigned char r;\n        unsigned char g;\n        unsigned char b;\n    } color;\n    unsigned int hex;\n};\n``` \nBu union, hem RGB değerlerini hem de hex renk kodunu saklayabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746256"
  },
  {
    "question": "Bir union içinde struct kullanabilir miyiz? Örnek verir misin?",
    "answer": "Evet, union içinde struct kullanabiliriz. Bu durum, daha karmaşık veri yapıları oluşturmak için faydalıdır. Örneğin, aşağıdaki kodda bir union içinde bir struct kullanarak bir öğrenci bilgilerini saklıyoruz:\n\n```c\nstruct Student {\n    char name[50];\n    int id;\n};\n\nunion Data {\n    struct Student student;\n    float score;\n};\n``` \nBurada, union hem öğrenci bilgilerini hem de bir puanı saklayabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746288"
  },
  {
    "question": "Union kullanarak bir veritabanı kaydını nasıl tasarlayabiliriz?",
    "answer": "Bir veritabanı kaydını temsil etmek için union kullanabiliriz. Örneğin, bir kullanıcı kaydında kullanıcı adı, kullanıcı tipi (öğrenci veya öğretmen) gibi bilgileri saklayacak bir union oluşturabiliriz:\n\n```c\nunion UserInfo {\n    struct {\n        char username[50];\n        int studentId;\n    } student;\n    struct {\n        char username[50];\n        int teacherId;\n    } teacher;\n};\n``` \nBu yapıyla, kullanıcı bilgilerini dinamik olarak saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746313"
  },
  {
    "question": "Union ile veri kaybını önlemek için kullanılabilecek yöntemler nelerdir?",
    "answer": "Union kullanırken veri kaybını önlemek için, her zaman en son atadığımız değer ile çalışmalıyız. Ayrıca, union'da kullandığımız veri tipini takip etmek için bir yardımcı değişken tanımlayabiliriz. Bunun için bir enum yapısı kullanarak hangi türün aktif olduğunu belirtebiliriz. Örneğin:\n\n```c\ntypedef enum { STUDENT, TEACHER } UserType;\n\nunion UserInfo {\n    struct { char name[50]; int id; } student;\n    struct { char name[50]; int id; } teacher;\n};\n\nstruct User {\n    UserType type;\n    union UserInfo info;\n};\n```",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746341"
  },
  {
    "question": "Bir union'ın boyutunu belirlemek için sizeof operatörünü nasıl kullanırız?",
    "answer": "Bir union'ın boyutunu belirlemek için sizeof operatörünü kullanabiliriz. Union, içindeki en büyük veri tipinin boyutunu kullanır. Örneğin:\n\n```c\nunion Example {\n    int i;\n    double d;\n};\n\nprintf(\"Union boyutu: %zu\\n\", sizeof(union Example));\n``` \nBu kod, Example union'ının boyutunu çıktı olarak verir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746369"
  },
  {
    "question": "C dilinde union'ları nasıl kullanarak bir oyun tasarımı yapabiliriz?",
    "answer": "Bir oyun tasarımında, bir karakterin farklı durumlarını represent etmek için union kullanabiliriz. Örneğin, bir karakterin sağlığı, zırhı veya yetenekleri gibi bilgileri saklamak için bir union oluşturabiliriz:\n\n```c\nunion CharacterStatus {\n    int health;\n    int armor;\n    char ability[30];\n};\n\nstruct Character {\n    char name[50];\n    union CharacterStatus status;\n};\n``` \nBu yapı ile karakterin durumu dinamik olarak güncellenebilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746396"
  },
  {
    "question": "Union içindeki değerleri nasıl güncelleyebiliriz?",
    "answer": "Union içindeki değerleri güncellemek oldukça basittir. İlgili veri tipine uygun bir değer atayarak güncelleme yapabiliriz. Ancak, her zaman en son atanan değeri kullanmayı unutmamalıyız. Örneğin:\n\n```c\nunion Data {\n    int intValue;\n    float floatValue;\n};\n\nunion Data data;\n\ndata.intValue = 10;  // intValue atandı\nprintf(\"Int: %d\\n\", data.intValue);\n\ndata.floatValue = 5.5;  // floatValue atandı\nprintf(\"Float: %f\\n\", data.floatValue);  // intValue'nın atandığını unutmamalıyız!\n```",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:27:57.746426"
  },
  {
    "question": "C programında multiple veri tiplerini bir arada tutmak için union nasıl kullanılır?",
    "answer": "Union kullanarak farklı veri tiplerini aynı bellek alanında tanımlayabiliriz. Örneğin, bir kullanıcıdan hem bir tamsayı hem de bir float değeri alıyorsak, bu değerleri union ile tutabiliriz. Aşağıda bir örnek: \n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n};\n\nint main() {\n    union Data data;\n    data.i = 10;\n    printf(\"Integer: %d\\n\", data.i);\n    data.f = 220.5;\n    printf(\"Float: %f\\n\", data.f);\n    return 0;\n}\n``` \nBu örnekte, `data` union'ı integer ve float değerlerini tutabilir, ancak yalnızca birini aynı anda tutar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649482"
  },
  {
    "question": "C dilinde union kullanırken bellek hizalaması (alignment) sorunları nelerdir?",
    "answer": "Union kullanırken, en büyük elemanın boyutuna göre bellek hizalaması yapılır. Eğer union içindeki en büyük veri tipi 8 byte ise, tüm union 8 byte'lık bir alan kaplar. Bu, bellekte yer tasarrufu sağlasa da, bazı platformlarda hizalama hataları ortaya çıkabilir. Örneğin, 4 byte'lık bir integer ve 8 byte'lık bir double içeren bir union oluşturduğumuzda, integer 4 byte yer kaplar, ancak hizalaması nedeniyle toplam alan 8 byte olarak korunur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649596"
  },
  {
    "question": "Bir union içinde yapı (struct) ve dizi kullanmak mümkün müdür?",
    "answer": "Evet, union içinde bir yapı ve dizi kullanmak mümkündür. Bu, farklı veri türlerini birlikte kullanmamıza olanak tanır. Örneğin:\n\n```c\n#include <stdio.h>\n\nstruct Person {\n    char name[30];\n    int age;\n};\n\nunion Data {\n    struct Person person;\n    int id;\n};\n\nint main() {\n    union Data data;\n    data.person.age = 25;\n    snprintf(data.person.name, sizeof(data.person.name), \"Ali\");\n    printf(\"Name: %s, Age: %d\\n\", data.person.name, data.person.age);\n    return 0;\n}\n``` \nBu örnekte, `Data` union'ı hem bir `Person` yapısını hem de bir tamsayıyı tutabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649642"
  },
  {
    "question": "Union kullanımı ile bellek tasarrufu sağlamak için örnek verir misiniz?",
    "answer": "Union, bellek tasarrufu sağlamak için idealdir çünkü yalnızca en büyük veri tipinin boyutunu kullanır. Örneğin, bir veri tabanı kaydında kullanıcı adı, yaş ve maaş bilgilerini tutmak istiyorsak, union kullanarak bellek tasarrufu yapabiliriz. Örnek: \n\n```c\n#include <stdio.h>\n\nunion UserInfo {\n    char username[20];\n    int age;\n    float salary;\n};\n\nint main() {\n    union UserInfo user;\n    snprintf(user.username, sizeof(user.username), \"Ahmet\");\n    printf(\"Username: %s\\n\", user.username);\n    user.age = 30;\n    printf(\"Age: %d\\n\", user.age);\n    return 0;\n}\n``` \nBu durumda, `UserInfo` union'ı sadece bir bilginin saklanması için yeterli bellek alanı kullanacaktır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649684"
  },
  {
    "question": "Union içinde bir enum kullanılabilir mi? Örnekle gösterin.",
    "answer": "Evet, union içinde bir enum kullanmak mümkündür. Bu, çeşitli durumları temsil eden değerleri saklamak için faydalıdır. Örneğin:\n\n```c\n#include <stdio.h>\n\ntypedef enum { RED, GREEN, BLUE } Color;\n\nunion Shape {\n    int radius;\n    Color color;\n};\n\nint main() {\n    union Shape shape;\n    shape.color = RED;\n    printf(\"Color: %d\\n\", shape.color);\n    return 0;\n}\n``` \nBu örnekte, `Shape` union'ı hem bir `int` olarak çemberin yarıçapını hem de bir `Color` enum değerini tutabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649721"
  },
  {
    "question": "C dilinde union kullanarak veri tabanı örneği oluşturabilir misiniz?",
    "answer": "Tabii! Bir veri tabanında kullanıcıların farklı türde bilgilerini saklamak için union kullanabiliriz. Örneğin:\n\n```c\n#include <stdio.h>\n\nunion UserData {\n    int userId;\n    float balance;\n};\n\nstruct User {\n    char name[30];\n    union UserData data;\n};\n\nint main() {\n    struct User user;\n    snprintf(user.name, sizeof(user.name), \"Mehmet\");\n    user.data.userId = 101;\n    printf(\"User: %s, UserID: %d\\n\", user.name, user.data.userId);\n    return 0;\n}\n``` \nBu örnekte, `User` yapısı içinde bir union tanımlanmış ve kullanıcı bilgileri bu union ile saklanmıştır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649765"
  },
  {
    "question": "Union kullanarak bir tür güvenliği sağlamak için nasıl bir yöntem izlenebilir?",
    "answer": "Union kullanırken tür güvenliği sağlamak için, genellikle bir tür belirteci kullanılır. Bu, hangi verinin geçerli olduğunu anlamamıza yardımcı olur. Örnek:\n\n```c\n#include <stdio.h>\n\ntypedef enum { INT_TYPE, FLOAT_TYPE } DataType;\n\nunion Data {\n    int i;\n    float f;\n};\n\nstruct Container {\n    DataType type;\n    union Data data;\n};\n\nint main() {\n    struct Container container;\n    container.type = INT_TYPE;\n    container.data.i = 100;\n\n    if (container.type == INT_TYPE) {\n        printf(\"Int: %d\\n\", container.data.i);\n    }\n    return 0;\n}\n``` \nBu örnekte, `Container` yapısı bir tür belirteci (type) içerir ve bu sayede geçerli türdeki veriyi güvenle kullanabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649807"
  },
  {
    "question": "Union kullanarak bit alanı (bit-field) yönetimi nasıl yapılır?",
    "answer": "C dilinde union ile bit alanı yönetimi yapılabilir. Bu, kaynakları etkin kullanmak için önemlidir. Örnek:\n\n```c\n#include <stdio.h>\n\nunion Flags {\n    struct {\n        unsigned int flag1 : 1;\n        unsigned int flag2 : 1;\n        unsigned int flag3 : 1;\n    } bits;\n    unsigned int allFlags;\n};\n\nint main() {\n    union Flags flags;\n    flags.allFlags = 0;\n    flags.bits.flag1 = 1;\n    flags.bits.flag2 = 0;\n    printf(\"Flags: %u\\n\", flags.allFlags);\n    return 0;\n}\n``` \nBu örnekte, `Flags` union'ı bit alanlarını ve tüm baytları aynı anda tutar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:28:30.649847"
  },
  {
    "question": "Bir kişi bilgilerini tutan bir union tanımlayın ve örnek bir kişi bilgisi oluşturun.",
    "answer": "Aşağıdaki gibi bir union tanımlayarak kişi bilgilerini tutabilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion Kisi {\n    char ad[50];\n    int yas;\n};\n\nint main() {\n    union Kisi kisi;\n    strcpy(kisi.ad, \"Ali\"); // Kişinin adı\n    printf(\"Kişi adı: %s\\n\", kisi.ad);\n    kisi.yas = 30; // Kişinin yaşı\n    printf(\"Kişi yaşı: %d\\n\", kisi.yas);\n    return 0;\n}\n```\nBurada bir `Kisi` union'ı tanımladık. `ad` ve `yas` değişkenlerini aynı bellek alanında sakladık. Ancak, yalnızca birini kullanabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852399"
  },
  {
    "question": "Bir union kullanarak bir şeklin alanını hesaplayan bir yapı oluşturun.",
    "answer": "Aşağıdaki örnekte, bir union kullanarak dairenin ve dikdörtgenin alanını hesaplayan bir yapı oluşturalım:\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nunion Sekil {\n    struct {\n        float yaricap;\n    } daire;\n    struct {\n        float uzunluk;\n        float genislik;\n    } dikdortgen;\n};\n\nint main() {\n    union Sekil sekil;\n    sekil.daire.yaricap = 5.0;\n    printf(\"Dairenin Alanı: %.2f\\n\", M_PI * sekil.daire.yaricap * sekil.daire.yaricap);\n    sekil.dikdortgen.uzunluk = 4.0;\n    sekil.dikdortgen.genislik = 6.0;\n    printf(\"Dikdörtgenin Alanı: %.2f\\n\", sekil.dikdortgen.uzunluk * sekil.dikdortgen.genislik);\n    return 0;\n}\n```\nBu örnekte, `Sekil` union'ı, bir daire veya dikdörtgenin alanını hesaplamak için kullanıldı.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852446"
  },
  {
    "question": "Bir union ile bir öğrenci bilgilerini tutun ve hangi bilginin kullanıldığını belirtin.",
    "answer": "Aşağıdaki gibi bir union tanımlayarak öğrenci bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Ogrenci {\n    int numara;\n    char isim[50];\n};\n\nint main() {\n    union Ogrenci ogr;\n    ogr.numara = 12345;\n    printf(\"Öğrenci numarası: %d\\n\", ogr.numara);\n    strcpy(ogr.isim, \"Ahmet\");\n    printf(\"Öğrenci ismi: %s\\n\", ogr.isim);\n    return 0;\n}\n```\nBu örnekte, `Ogrenci` union'ı kullanılarak bir öğrencinin numarası ya da ismi saklanabilir. Ancak sadece birini aynı anda kullanmak mümkündür.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852474"
  },
  {
    "question": "Bir union kullanarak bir renk bilgisini RGB ve HEX formatında saklayın.",
    "answer": "Aşağıdaki örnekte, bir union kullanarak renk bilgisini RGB ve HEX formatlarında saklayalım:\n\n```c\n#include <stdio.h>\n\nunion Renk {\n    struct {\n        unsigned char r, g, b;\n    } rgb;\n    unsigned int hex;\n};\n\nint main() {\n    union Renk renk;\n    renk.rgb.r = 255;\n    renk.rgb.g = 0;\n    renk.rgb.b = 0;\n    renk.hex = (renk.rgb.r << 16) | (renk.rgb.g << 8) | renk.rgb.b;\n    printf(\"RGB: (%d, %d, %d)\\n\", renk.rgb.r, renk.rgb.g, renk.rgb.b);\n    printf(\"HEX: #%06X\\n\", renk.hex);\n    return 0;\n}\n```\nBu örnekte, `Renk` union'ı kullanılarak bir rengin RGB değerleri ve HEX kodu aynı bellek alanında saklanmıştır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852498"
  },
  {
    "question": "Bir union kullanarak bir müzik parçasının bilgilerini saklayın, parça adı ve sanatçı bilgileri.",
    "answer": "Bir müzik parçasının bilgilerini saklamak için aşağıdaki gibi bir union tanımlayabiliriz:\n\n```c\n#include <stdio.h>\n\nunion MuzikParcasi {\n    char parcaAdi[100];\n    char sanatci[100];\n};\n\nint main() {\n    union MuzikParcasi parca;\n    strcpy(parca.parcaAdi, \"Shape of You\");\n    printf(\"Parça Adı: %s\\n\", parca.parcaAdi);\n    strcpy(parca.sanatci, \"Ed Sheeran\");\n    printf(\"Sanatçı: %s\\n\", parca.sanatci);\n    return 0;\n}\n```\nBu örnekte, `MuzikParcasi` union'ı ile parça adı veya sanatçı bilgisi tutulabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852545"
  },
  {
    "question": "Bir union kullanarak bir kitap bilgisini (ad, yazar, sayfa sayısı) tutun.",
    "answer": "Aşağıdaki gibi bir union ile bir kitap bilgisini tutabiliriz:\n\n```c\n#include <stdio.h>\n\nunion Kitap {\n    char ad[100];\n    char yazar[100];\n    int sayfaSayisi;\n};\n\nint main() {\n    union Kitap kitap;\n    strcpy(kitap.ad, \"Yüzüklerin Efendisi\");\n    printf(\"Kitap Adı: %s\\n\", kitap.ad);\n    kitap.sayfaSayisi = 1000;\n    printf(\"Sayfa Sayısı: %d\\n\", kitap.sayfaSayisi);\n    return 0;\n}\n```\nBurada `Kitap` union'ı ile bir kitabın adı, yazarı veya sayfa sayısını tutabiliyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852573"
  },
  {
    "question": "Bir union kullanarak bir hava durumu raporunu (sıcaklık, nem, rüzgar hızı) saklayın.",
    "answer": "Bir hava durumu raporunu saklamak için aşağıdaki gibi bir union oluşturabiliriz:\n\n```c\n#include <stdio.h>\n\nunion HavaDurumu {\n    float sıcaklık;\n    float nem;\n    float ruzgarHizi;\n};\n\nint main() {\n    union HavaDurumu hava;\n    hava.sıcaklık = 25.5;\n    printf(\"Sıcaklık: %.1f°C\\n\", hava.sıcaklık);\n    hava.nem = 60.0;\n    printf(\"Nem: %.1f%%\\n\", hava.nem);\n    return 0;\n}\n```\nBu örnekte, `HavaDurumu` union'ı ile hava durumu bilgileri saklanabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852603"
  },
  {
    "question": "Bir union kullanarak bir aracın bilgilerini (marka, model, yıl) saklayın.",
    "answer": "Aşağıdaki gibi bir union ile bir aracın bilgilerini tutabilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion Arac {\n    char marka[50];\n    char model[50];\n    int yil;\n};\n\nint main() {\n    union Arac arac;\n    strcpy(arac.marka, \"Toyota\");\n    printf(\"Araç Markası: %s\\n\", arac.marka);\n    arac.yil = 2020;\n    printf(\"Araç Yılı: %d\\n\", arac.yil);\n    return 0;\n}\n```\nBu örnekte, `Arac` union'ı ile bir aracın marka, model veya yıl bilgisi saklanabilmektedir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852631"
  },
  {
    "question": "Bir union kullanarak bir ürünün bilgilerini tutun (isim, fiyat, stok durumu).",
    "answer": "Aşağıdaki gibi bir union ile bir ürünün bilgilerini tutabilirsiniz:\n\n```c\n#include <stdio.h>\n\nunion Urun {\n    char isim[100];\n    float fiyat;\n    int stok;\n};\n\nint main() {\n    union Urun urun;\n    strcpy(urun.isim, \"Laptop\");\n    printf(\"Ürün İsmi: %s\\n\", urun.isim);\n    urun.fiyat = 15000.0;\n    printf(\"Ürün Fiyatı: %.2f TL\\n\", urun.fiyat);\n    urun.stok = 20;\n    printf(\"Stok Durumu: %d adet\\n\", urun.stok);\n    return 0;\n}\n```\nBu örnekte, `Urun` union'ı ile bir ürünün ismi, fiyatı veya stok durumu tutulabilmektedir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:04.852664"
  },
  {
    "question": "Bir öğrenci bilgilerini tutan bir yapı oluşturun. Öğrencinin adı, yaşı ve not ortalamasını tutun. Adres bilgilerine ihtiyacınız olduğunda, adresi bir union kullanarak ekleyin.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak öğrenci bilgilerini tutabiliriz. Union, hem adres bilgilerini hem de not ortalamasını tek bir alanda tutmamıza olanak tanır.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n    union {\n        float gpa;\n        char address[100];\n    } info;\n} Student;\n\nint main() {\n    Student student;\n    strcpy(student.name, \"Ahmet\");\n    student.age = 20;\n    student.info.gpa = 3.5; // Not ortalaması\n    printf(\"Öğrenci: %s, Yaş: %d, Not Ortalaması: %.2f\\n\", student.name, student.age, student.info.gpa);\n\n    strcpy(student.info.address, \"İstanbul, Türkiye\"); // Adres bilgisi\n    printf(\"Adres: %s\\n\", student.info.address);\n    return 0;\n}\n```\nBurada union kullanarak, bir öğrencinin ya not ortalamasını ya da adresini tutabiliyoruz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227772"
  },
  {
    "question": "Bir şekil (dikdörtgen veya daire) tanımlamak için bir union ve yapı kullanarak bir program yazın. Alan hesaplaması yapın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak farklı şekillerin alanını hesaplayabiliriz.\n\n```c\n#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    union {\n        struct {\n            float length;\n            float width;\n        } rectangle;\n        struct {\n            float radius;\n        } circle;\n    } shape;\n    int type; // 0 için dikdörtgen, 1 için daire\n} Shape;\n\nfloat calculateArea(Shape s) {\n    if (s.type == 0) {\n        return s.shape.rectangle.length * s.shape.rectangle.width;\n    } else {\n        return M_PI * s.shape.circle.radius * s.shape.circle.radius;\n    }\n}\n\nint main() {\n    Shape rect;\n    rect.type = 0;\n    rect.shape.rectangle.length = 5.0;\n    rect.shape.rectangle.width = 4.0;\n\n    Shape circ;\n    circ.type = 1;\n    circ.shape.circle.radius = 3.0;\n\n    printf(\"Dikdörtgen Alanı: %.2f\\n\", calculateArea(rect));\n    printf(\"Daire Alanı: %.2f\\n\", calculateArea(circ));\n    return 0;\n}\n```\nBu yapı, şekli türüne göre tutar ve alan hesaplamasını dinamik olarak yapmamıza olanak tanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227827"
  },
  {
    "question": "Bir çalışan bilgilerini tutan bir yapı oluşturun. Çalışanın maaşına göre ek bir yan hak olarak bir ipotek veya araç ile ilgili bilgileri içeren bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı oluşturabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    float salary;\n    union {\n        struct {\n            float mortgage;\n            int duration;\n        } mortgageInfo;\n        struct {\n            char vehicle[50];\n            float value;\n        } carInfo;\n    } benefits;\n    int isMortgage; // 1 ise ipotek, 0 ise araç\n} Employee;\n\nint main() {\n    Employee emp;\n    strcpy(emp.name, \"Murat\");\n    emp.salary = 5000;\n    emp.isMortgage = 1;\n    emp.benefits.mortgageInfo.mortgage = 150000;\n    emp.benefits.mortgageInfo.duration = 30; // yıl\n\n    printf(\"Çalışan: %s, Maaş: %.2f, İpotek: %.2f, Süre: %d yıl\\n\", emp.name, emp.salary, emp.benefits.mortgageInfo.mortgage, emp.benefits.mortgageInfo.duration);\n    return 0;\n}\n```\nBu yapı, çalışanın ek haklarını maaşına göre değiştirerek tutmamıza olanak tanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227872"
  },
  {
    "question": "Bir araç bilgilerini tutan bir yapı oluşturun. Araç türüne bağlı olarak bir motor veya elektrikli batarya bilgilerini tutan bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak araç bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char model[50];\n    union {\n        struct {\n            float engineSize;\n            int horsepower;\n        } combustion;\n        struct {\n            float batteryCapacity;\n            int range;\n        } electric;\n    } engine;\n    int isElectric; // 1 ise elektrikli, 0 ise içten yanmalı\n} Vehicle;\n\nint main() {\n    Vehicle car;\n    strcpy(car.model, \"Tesla Model 3\");\n    car.isElectric = 1;\n    car.engine.electric.batteryCapacity = 75.0;\n    car.engine.electric.range = 500; // km\n\n    printf(\"Araç: %s, Batarya Kapasitesi: %.1f kWh, Menzil: %d km\\n\", car.model, car.engine.electric.batteryCapacity, car.engine.electric.range);\n    return 0;\n}\n```\nBu yapı, araç bilgilerini türüne göre tutarak esnek bir çözüm sunar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227913"
  },
  {
    "question": "Bir kitap bilgilerini tutan bir yapı oluşturun. Kitap türüne göre e-kitap veya basılı kitap bilgilerini tutmak için bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak kitap bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char title[50];\n    union {\n        struct {\n            int pages;\n            float weight;\n        } printed;\n        struct {\n            float fileSize;\n            char format[10];\n        } ebook;\n    } bookType;\n    int isEbook; // 1 ise e-kitap, 0 ise basılı kitap\n} Book;\n\nint main() {\n    Book myBook;\n    strcpy(myBook.title, \"C Programlama Dili\");\n    myBook.isEbook = 0;\n    myBook.bookType.printed.pages = 300;\n    myBook.bookType.printed.weight = 0.5; // kg\n\n    printf(\"Kitap: %s, Sayfa Sayısı: %d, Ağırlık: %.2f kg\\n\", myBook.title, myBook.bookType.printed.pages, myBook.bookType.printed.weight);\n    return 0;\n}\n```\nBu yapı, kitabın türüne göre esnek içerikler tutar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227959"
  },
  {
    "question": "Bir müşteri bilgilerini tutan bir yapı oluşturun. Müşterinin kredi kartı veya banka hesap bilgilerini tutmak için bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak müşteri bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    union {\n        struct {\n            char cardNumber[20];\n            char expiryDate[10];\n        } creditCard;\n        struct {\n            char accountNumber[20];\n            char bankName[50];\n        } bankAccount;\n    } paymentInfo;\n    int isCreditCard; // 1 ise kredi kartı, 0 ise banka hesabı\n} Customer;\n\nint main() {\n    Customer cust;\n    strcpy(cust.name, \"Zeynep\");\n    cust.isCreditCard = 1;\n    strcpy(cust.paymentInfo.creditCard.cardNumber, \"1234-5678-9012-3456\");\n    strcpy(cust.paymentInfo.creditCard.expiryDate, \"12/25\");\n\n    printf(\"Müşteri: %s, Kredi Kartı: %s, Son Kullanma Tarihi: %s\\n\", cust.name, cust.paymentInfo.creditCard.cardNumber, cust.paymentInfo.creditCard.expiryDate);\n    return 0;\n}\n```\nBu yapı, müşteri bilgilerini dinamik olarak tutarak esneklik sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.227995"
  },
  {
    "question": "Bir hayvan bilgilerini tutan bir yapı oluşturun. Hayvan türüne göre evcil hayvan veya vahşi hayvan bilgilerini tutmak için bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak hayvan bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    union {\n        struct {\n            char breed[50];\n            float weight;\n        } domestic;\n        struct {\n            char habitat[50];\n            char diet[20];\n        } wild;\n    } animalType;\n    int isDomestic; // 1 ise evcil, 0 ise vahşi\n} Animal;\n\nint main() {\n    Animal pet;\n    strcpy(pet.name, \"Mavi\");\n    pet.isDomestic = 1;\n    strcpy(pet.animalType.domestic.breed, \"Kedi\");\n    pet.animalType.domestic.weight = 4.5;\n\n    printf(\"Hayvan: %s, Tür: %s, Ağırlık: %.2f kg\\n\", pet.name, pet.animalType.domestic.breed, pet.animalType.domestic.weight);\n    return 0;\n}\n```\nBu yapı, hayvan bilgilerini türüne göre tutar ve esneklik sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.228032"
  },
  {
    "question": "Bir telefon bilgilerini tutan bir yapı oluşturun. Telefon türüne göre akıllı telefon veya klasik telefon bilgilerini tutmak için bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak telefon bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char brand[50];\n    union {\n        struct {\n            int storage; // GB\n            int ram; // GB\n        } smartphone;\n        struct {\n            char type[20]; // Klasik telefon için\n        } classic;\n    } phoneType;\n    int isSmartphone; // 1 ise akıllı telefon, 0 ise klasik telefon\n} Phone;\n\nint main() {\n    Phone myPhone;\n    strcpy(myPhone.brand, \"Samsung\");\n    myPhone.isSmartphone = 1;\n    myPhone.phoneType.smartphone.storage = 128;\n    myPhone.phoneType.smartphone.ram = 8;\n\n    printf(\"Telefon Markası: %s, Depolama: %d GB, RAM: %d GB\\n\", myPhone.brand, myPhone.phoneType.smartphone.storage, myPhone.phoneType.smartphone.ram);\n    return 0;\n}\n```\nBu yapı, telefon bilgilerini türüne göre tutarak esneklik sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.228070"
  },
  {
    "question": "Bir ürün bilgilerini tutan bir yapı oluşturun. Ürün türüne göre gıda maddesi veya elektronik ürün bilgilerini tutmak için bir union kullanın.",
    "answer": "Aşağıdaki gibi bir yapı tanımlayarak ürün bilgilerini tutabiliriz:\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    union {\n        struct {\n            float weight; // kg\n            char expirationDate[10];\n        } food;\n        struct {\n            int warrantyPeriod; // yıl\n            float power; // W\n        } electronic;\n    } productType;\n    int isFood; // 1 ise gıda, 0 ise elektronik\n} Product;\n\nint main() {\n    Product item;\n    strcpy(item.name, \"Elma\");\n    item.isFood = 1;\n    item.productType.food.weight = 0.2;\n    strcpy(item.productType.food.expirationDate, \"2023-12-31\");\n\n    printf(\"Ürün: %s, Ağırlık: %.2f kg, Son Tüketim Tarihi: %s\\n\", item.name, item.productType.food.weight, item.productType.food.expirationDate);\n    return 0;\n}\n```\nBu yapı, ürün bilgilerini türüne göre tutarak esneklik sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:29:57.228127"
  },
  {
    "question": "C dilinde bir union tanımlayıp, içinde bir int, bir float ve bir char değişkeni bulundurun. Ardından bu değişkenlerin nasıl kullanılacağını gösterin.",
    "answer": "Union, birden fazla değişkeni aynı bellek alanında saklamamıza olanak tanır. Aşağıda bir union tanımı ve kullanımı verilmiştir:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    union Data data;\n    data.i = 10;\n    printf(\"int: %d\\n\", data.i);\n    data.f = 220.5;\n    printf(\"float: %f\\n\", data.f);\n    data.c = 'A';\n    printf(\"char: %c\\n\", data.c);\n    return 0;\n}\n```\nBu kodda, union tanımlandıktan sonra sadece bir değişkenin değeri kullanılabilir. İlk olarak int değişkeni, ardından float ve en son olarak char değişkeni yazdırılır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092415"
  },
  {
    "question": "Bir union kullanarak, aynı bellek alanında birden fazla veri türü tutmanın avantajlarını açıklayın.",
    "answer": "Union kullanmanın en büyük avantajı, bellek tasarrufu sağlamasıdır. Örneğin, bir yapı (struct) ile her bir veri türü için ayrı bellek alanı ayırmak gerekirken, union ile yalnızca en büyük veri türünün boyutu kadar bellek ayrılır. Bu, özellikle bellek kısıtlamalarının olduğu sistemlerde önemli olabilir. Ayrıca, verinin tipini dinamik olarak değiştirmek de mümkündür, bu esneklik sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092492"
  },
  {
    "question": "Bir union ve yapı (struct) birlikte kullanarak, bir veri paketini nasıl temsil edersiniz?",
    "answer": "Union ve struct birlikte, veri paketleri için etkili bir çözüm sunar. Aşağıdaki örnekte, bir veri paketi içinde hem bir sayıyı hem de bir mesajı tutan bir yapı oluşturulmuştur:\n\n```c\n#include <stdio.h>\n\nstruct Packet {\n    int type;\n    union {\n        int number;\n        char message[20];\n    } data;\n};\n\nint main() {\n    struct Packet p1;\n    p1.type = 1; // number\n    p1.data.number = 100;\n\n    struct Packet p2;\n    p2.type = 2; // message\n    snprintf(p2.data.message, sizeof(p2.data.message), \"Hello\");\n\n    printf(\"Packet 1: type = %d, number = %d\\n\", p1.type, p1.data.number);\n    printf(\"Packet 2: type = %d, message = %s\\n\", p2.type, p2.data.message);\n    return 0;\n}\n```\nBu örnekte, `Packet` yapısı, türü ve veriyi tutan bir union içerir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092573"
  },
  {
    "question": "Bir union içinde dizileri tutmanın mümkün olup olmadığını açıklayın ve bir örnek ile gösterin.",
    "answer": "C dilinde union içinde doğrudan dizileri tutmak mümkün değildir, çünkü union, yalnızca bir veri türünün değerini saklar. Ancak bir dizi boyutunu belirleyerek bir union içinde göstermek mümkündür. Aşağıda bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n\nunion ArrayData {\n    int intArray[5];\n    float floatArray[5];\n};\n\nint main() {\n    union ArrayData data;\n    for (int i = 0; i < 5; i++) {\n        data.intArray[i] = i * 10;\n    }\n    for (int i = 0; i < 5; i++) {\n        printf(\"intArray[%d] = %d\\n\", i, data.intArray[i]);\n    }\n    return 0;\n}\n```\nBu kodda, `intArray` değişkeni kullanılarak bir dizi oluşturulmuştur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092622"
  },
  {
    "question": "Bir union kullanarak bir veri türü için toplam boyut hesaplamak istiyorsunuz. Bu işlemi nasıl yaparsınız?",
    "answer": "Union içinde yalnızca bir veri türü saklandığı için boyut hesaplama işlemi, en büyük veri türüne bağlıdır. Aşağıdaki örnekte, bir union ve boyut hesaplama gösterilmiştir:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    printf(\"Union boyutu: %zu\\n\", sizeof(union Data));\n    return 0;\n}\n```\nBurada `sizeof` operatörü kullanılarak union boyutu hesaplanmıştır. Bu, en büyük veri türü olan `float` tipinin boyutuna eşit olacaktır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092672"
  },
  {
    "question": "Bir union kullanarak bir tip güvenliği sağlamak için nasıl bir yapı oluşturabilirsiniz?",
    "answer": "Tür güvenliği sağlamak için union ile birlikte bir enum kullanmak iyi bir yöntemdir. Aşağıda bir örnek gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nenum DataType { INT, FLOAT, CHAR };\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nstruct SafeData {\n    enum DataType type;\n    union Data data;\n};\n\nint main() {\n    struct SafeData myData;\n    myData.type = INT;\n    myData.data.i = 10;\n    if (myData.type == INT) {\n        printf(\"Data: %d\\n\", myData.data.i);\n    }\n    return 0;\n}\n```\nBu örnekte, `SafeData` yapısı bir enum ile verinin türünü saklar, böylece güvenli bir veri erişimi sağlanır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092716"
  },
  {
    "question": "Bir union ile birlikte bir fonksiyon yazın ve bu fonksiyonun parametre olarak aldığı union'ın elemanını gösterin.",
    "answer": "Aşağıdaki örnekte bir union ve bir fonksiyon ile nasıl çalışılacağını gösterilmektedir:\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c;\n};\n\nvoid printData(union Data data, int type) {\n    switch (type) {\n        case 0:\n            printf(\"int: %d\\n\", data.i);\n            break;\n        case 1:\n            printf(\"float: %f\\n\", data.f);\n            break;\n        case 2:\n            printf(\"char: %c\\n\", data.c);\n            break;\n    }\n}\n\nint main() {\n    union Data myData;\n    myData.i = 123;\n    printData(myData, 0);\n    return 0;\n}\n```\nFonksiyon, union'ı ve türünü alarak uygun veriyi yazdırmaktadır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092771"
  },
  {
    "question": "Bir union içinde karmaşık bir veri yapısını nasıl temsil edersiniz?",
    "answer": "Karmaşık veri yapıları için union kullanarak alt yapılara sahip bir yapı oluşturabiliriz. Aşağıdaki örnekte bir `Shape` yapısı tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nenum ShapeType { CIRCLE, RECTANGLE };\n\nunion ShapeData {\n    struct {\n        float radius;\n    } circle;\n    struct {\n        float length;\n        float width;\n    } rectangle;\n};\n\nstruct Shape {\n    enum ShapeType type;\n    union ShapeData data;\n};\n\nint main() {\n    struct Shape s;\n    s.type = CIRCLE;\n    s.data.circle.radius = 5.0f;\n\n    if (s.type == CIRCLE) {\n        printf(\"Circle radius: %f\\n\", s.data.circle.radius);\n    }\n    return 0;\n}\n```\nBu örnekte, union kullanarak farklı şekil türlerini temsil eden bir yapı oluşturulmuştur.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092809"
  },
  {
    "question": "Farklı türdeki verileri saklamak için bir union kullanarak bir veri tabanı kaydını temsil eden bir yapı oluşturmalısınız. Örneğini yazın.",
    "answer": "Veri tabanı kayıtlarını temsil etmek için union ve struct birlikte kullanılabilir. Aşağıdaki örnekte bir `Record` tanımlanmıştır:\n\n```c\n#include <stdio.h>\n\nenum RecordType { INTEGER, FLOAT, STRING };\n\nunion RecordData {\n    int i;\n    float f;\n    char str[20];\n};\n\nstruct Record {\n    enum RecordType type;\n    union RecordData data;\n};\n\nint main() {\n    struct Record r;\n    r.type = STRING;\n    snprintf(r.data.str, sizeof(r.data.str), \"Hello World\");\n\n    if (r.type == STRING) {\n        printf(\"Record: %s\\n\", r.data.str);\n    }\n    return 0;\n}\n```\nBu örnekte, `Record` yapısı veri türünü ve veriyi temsil eden bir union içermektedir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:30:28.092868"
  },
  {
    "question": "Bir union tanımlarken neden struct kullanımı ile birleştirmek önemli olabilir?",
    "answer": "Union'lar, bellekte aynı alanı paylaşan farklı veri türlerini saklamak için kullanılır. Struct kullanarak birden fazla veri alanını bir arada tutarsak, union içinde bu struct'ı tanımlamak, birden fazla özellik ile işlem yapmamıza olanak tanır. Örneğin, bir 'Data' union'ı içinde bir 'User' struct'ı tanımlayarak, kullanıcı bilgilerini saklayabiliriz. Bu, kullanımı kolaylaştırır ve kodun daha anlaşılır olmasını sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824442"
  },
  {
    "question": "Union kullanırken bellek yönetimine dikkat etmemek ne gibi sorunlara yol açabilir?",
    "answer": "Union kullanırken, hangi veri tipinin aktif olduğunu bilmek ve doğru şekilde yönetmek hayati öneme sahiptir. Eğer bir union içinde bir veri tipi saklanıyorsa, diğer veri tipleri için bellek alanı ayrılmaz. Eğer yanlışlıkla geçersiz bir veri tipi okunursa belirsiz sonuçlar elde edilir. Bu tür hatalar, bellek bozulmasına veya programın çökmesine neden olabilir. Bu yüzden, her zaman hangi türün kullanıldığını kontrol etmek için ek bir işaretçi (örneğin, bir enum) kullanılmalıdır.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824484"
  },
  {
    "question": "Union ile birlikte enum kullanımının avantajları nelerdir?",
    "answer": "Union ile birlikte enum kullanımı, hangi veri türünün aktif olduğunu belirlemek için yararlıdır. Örneğin, bir 'Shape' union'ı tanımlayıp, bu union içinde farklı şekilleri saklarken bir enum kullanarak hangi şeklin aktif olduğunu kolayca izleyebiliriz. Bu, kodun okunabilirliğini artırır ve hata yapma riskini azaltır. Örnek: enum ShapeType { CIRCLE, SQUARE }; union Shape { struct Circle c; struct Square s; };",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824526"
  },
  {
    "question": "Bir union içinde dinamik bellek kullanımı nasıl yönetilmelidir?",
    "answer": "Union içinde dinamik bellek kullanırken dikkatli olunmalıdır. Örneğin, bir union içinde bir string veya bir dizi saklanıyorsa, belleği doğru şekilde allocate ve free etmek gerekir. Eğer bir union'ın içinde geçerli bir veri saklanıyorsa, diğer alanlar için allocated bellek serbest bırakılmalıdır. Aksi takdirde, bellek sızıntısı riski vardır. Bu nedenle, her tür için bellek yönetimini dikkatlice yapmak ve gerektiğinde temizlemek önemlidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824550"
  },
  {
    "question": "Büyük veri yapıları için union kullanmak performansı nasıl etkiler?",
    "answer": "Büyük veri yapıları için union kullanmak, hafıza verimliliğini artırabilir, çünkü tüm veri türleri için ayrı ayrı bellek alanı ayırmaya gerek kalmaz. Ancak, büyük bir union kullanırken, gerektiğinde hangi türde veri ile çalıştığınızı bilmek önemlidir. Performans, veri türleri arasında dönüşüm ve okuma yazma işlemlerinde etkilenebilir. Aşırı derecede büyük union'lar, yönetimsel karmaşıklığa yol açabilir. Bu nedenle, kullanılacak alanların sayısını sınırlandırmak yararlı olabilir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824591"
  },
  {
    "question": "Union kullanarak bir veri tabanı kayıt yapısını nasıl tasarlarsınız?",
    "answer": "Veri tabanı kayıt yapısını tasarlarken union kullanmak, farklı türde verileri aynı yapıda saklamak için idealdir. Örneğin, bir 'Record' union'ı oluşturarak, kullanıcı bilgileri, ürün bilgileri ya da işlem bilgilerini tutabilirsiniz. Yapı şu şekilde olabilir: union Record { struct User { int id; char name[50]; }; struct Product { int id; char description[100]; }; struct Transaction { int id; float amount; }; }; Bu yapıyla farklı veri türlerini tek bir yapı içinde saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824624"
  },
  {
    "question": "C dilinde union ile bit alanlarını nasıl kullanabiliriz?",
    "answer": "Union içinde bit alanları kullanarak bellek verimliliğini artırabiliriz. Örneğin, bir flag yapısı içinde farklı durumları temsil eden bit alanları tanımlayabiliriz. Örnek: union Status { struct { unsigned int is_active : 1; unsigned int is_visible : 1; unsigned int is_enabled : 1; } flags; int value; }; Bu şekilde hem durum bilgilerini hem de diğer değerleri aynı bellek alanında saklayabiliriz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824661"
  },
  {
    "question": "Bir union'da veri ataması yaparken nelere dikkat etmeliyiz?",
    "answer": "Union'da veri atarken, hangi veri türünün geçerli olduğunu bilmek çok önemlidir. Yanlış bir türde veri atarsanız, bu türün kullanımı sırasında beklenmeyen sonuçlar alabilirsiniz. Bu nedenle, bir union'a veri atamadan önce mevcut türü kontrol etmek için bir enum kullanmak faydalı olacaktır. Örneğin, önce enum ile hangi türün aktif olduğunu belirleyin, ardından uygun veri atamasını yapın.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824697"
  },
  {
    "question": "Union kullanırken hangi durumlarda dikkatli olunmalıdır?",
    "answer": "Union kullanırken dikkatli olunması gereken durumlar arasında, hangi türün aktif olduğunun bilinmesi, bellek yönetimi ve geçersiz veri okuma gibi durumlar yer alır. Yanlış bir türle işlem yapmak belirsiz davranışlara yol açabilir. Ayrıca, union'ın içindeki veri türünün büyüklüğü, bellek alanı üzerinde etkili olabilir. Bu nedenle, kullanılacak alanın en büyük veri tipine göre ayarlanması önemlidir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824717"
  },
  {
    "question": "Union'lar ile birlikte yapısal programlamayı nasıl birleştirebiliriz?",
    "answer": "Union'lar ile yapısal programlamayı birleştirerek daha modüler ve okunabilir kodlar yazabiliriz. Örneğin, her bir yapı için fonksiyonlar yazarak, union ile saklanan verilerin işlenmesini sağlayabiliriz. Her bir yapı için ayrı fonksiyonlar tanımlayarak, verilerin nasıl işlendiğini kontrol edebiliriz. Bu, kodun bakımını kolaylaştırır ve modüler yapıyı güçlendirir.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:00.824741"
  },
  {
    "question": "Bir union yapısında bellek yönetimini nasıl optimize edebilirim?",
    "answer": "Union'lar, aynı bellek alanını birden fazla veri tipi için kullanmayı sağlar. Bellek yönetimini optimize etmek için, union içinde en büyük elemanı kullanmalısınız. Örneğin, bir union içinde bir int ve bir double var ise, double'ı kullanarak bellek israfını önleyebilirsiniz. Ayrıca, union'ı kullandığınız yapıda, hangi tipin kullanıldığını takip etmek için bir enum veya bir flag eklemeyi unutmayın.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267247"
  },
  {
    "question": "Union ve struct kullanımı arasındaki farklar nelerdir ve hangi durumlarda union kullanmalıyım?",
    "answer": "Struct'lar, her bir üyesi için ayrı bellek alanı ayırırken, union'lar aynı bellek alanını birden fazla üye için paylaşır. Eğer bir değişkenin yalnızca bir türde veri saklayacağı ve bu türlerin birbirini dışlayacağı durumlar varsa union kullanmak daha mantıklıdır. Örneğin, bir mesaj sisteminde, mesajın türüne göre farklı veri yapıları kullanabiliriz (örneğin, metin ya da ikili veri).",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267319"
  },
  {
    "question": "Union'ların veri tutarlılığını sağlamak için hangi yöntemleri kullanabilirim?",
    "answer": "Union'ların veri tutarlılığını sağlamak için her zaman hangi tipin aktif olduğunu takip eden bir mekanizma oluşturmalısınız. Bunun için bir enum ile birlikte bir struct kullanabilirsiniz. Bu struct içinde hem union'ı hem de aktif olan tipi tutabilirsiniz. Bu şekilde, hangi tipin kullanıldığını bilerek doğru veri ile işlem yapabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267368"
  },
  {
    "question": "Bir union içindeki veriyi güvenli bir şekilde nasıl okuyabilirim?",
    "answer": "Union içindeki veriyi okurken, hangi tipin aktif olduğunu bildiğinizden emin olmalısınız. Bu nedenle, bir enum ile veri tipini izleyebilir ve her okuma işleminden önce bu bilgiyi kontrol edebilirsiniz. Örneğin: \n```c\ntypedef union {\n    int i;\n    float f;\n} Data;\n\ntypedef struct {\n    Data data;\n    enum { INT, FLOAT } type;\n} Container;\n```\nBu yapıyı kullanarak, her okuma işleminde `type` değerini kontrol ederek güvenli bir şekilde veriyi okuyabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267415"
  },
  {
    "question": "C dilinde union kullanırken karşılaşabileceğim olası hatalar nelerdir?",
    "answer": "Union kullanırken en yaygın hatalardan biri, verinin hangi tipte olduğunu bilmeden erişim yapmaktır. Bu durumda bellek içeriği yanlış yorumlanabilir. Ayrıca, union içinde karmaşık veri yapıları (örneğin, struct'lar) kullanıyorsanız, bu yapının içindeki verilerin yönetimi zorlaşabilir. Her zaman hangi tipin aktif olduğunu kontrol etmek için bir mekanizma (örneğin, bir enum) kullanmayı unutmayın.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267459"
  },
  {
    "question": "Union ve pointer kombinasyonunu nasıl etkili bir şekilde kullanabilirim?",
    "answer": "Union'lar ile pointer'ları bir arada kullanarak esnek veri yapıları oluşturabilirsiniz. Örneğin, bir union içinde farklı türde veri tiplerini saklarken, bu türlere işaret eden pointer'lar kullanabilirsiniz. Bu, veri tiplerinin dinamik olarak değişebileceği durumlarda oldukça kullanışlıdır. Örneğin:\n```c\ntypedef union {\n    int *intPtr;\n    float *floatPtr;\n} PointerUnion;\n```",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267503"
  },
  {
    "question": "Union kullanarak bir bit alanı (bit field) nasıl oluşturabilirim?",
    "answer": "C dilinde union kullanarak bit alanları oluşturmak mümkündür. Bit alanları, bellekte yer tasarrufu sağlamak için bit düzeyinde veri saklar. Örneğin:\n```c\ntypedef union {\n    struct {\n        unsigned int flag1 : 1;\n        unsigned int flag2 : 1;\n        unsigned int flag3 : 1;\n    } bits;\n    unsigned int allFlags;\n} BitFieldUnion;\n``` \nBu yapı, `allFlags` değişkenini kullanarak tüm bitleri okuyup yazarken, `bits` yapısını kullanarak spesifik bitlere erişim sağlar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267568"
  },
  {
    "question": "Union kullanarak bir mesaj yapısı tasarlamak için nasıl bir yaklaşım izlemeliyim?",
    "answer": "Bir mesaj yapısı tasarlarken, union kullanarak farklı mesaj türlerini temsil edebilirsiniz. Örneğin, bir mesajın içeriği metin ya da sayısal veri olabilir. Aşağıda bir örnek verilmiştir:\n```c\ntypedef union {\n    char text[256];\n    int number;\n} MessageContent;\n\ntypedef struct {\n    enum { TEXT_MESSAGE, NUMBER_MESSAGE } type;\n    MessageContent content;\n} Message;\n``` \nBu yapı ile farklı türde mesajlar oluşturabilir ve işleyebilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267628"
  },
  {
    "question": "C dilinde union kullanımında bellek sıralamasını (endianness) nasıl yönetebilirim?",
    "answer": "Union kullanırken, verinin bellekte nasıl saklandığını (endianness) yönetmek için verinin her bir parçasını ayrı ayrı tanımlayarak ve erişim yaparak işlemleri gerçekleştirebilirsiniz. Örneğin:\n```c\ntypedef union {\n    struct {\n        unsigned char byte0;\n        unsigned char byte1;\n    } bytes;\n    unsigned int value;\n} EndiannessUnion;\n``` \nBu yapı, byte'lar üzerinde işlem yapmanıza olanak tanırken, aynı zamanda tüm değeri tek bir değişken olarak da tutar.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267677"
  },
  {
    "question": "Union kullanarak düşük seviyeli donanım erişimi (hardware access) nasıl gerçekleştirebilirim?",
    "answer": "Donanım erişiminde union kullanarak belirli bir bellek adresini çoklu veri türleri ile temsil edebilirsiniz. Örneğin, bir donanım register'ı farklı alanları temsil ediyorsa, bu alanları union içinde tanımlayarak bu alanlara erişebilirsiniz:\n```c\n#define REGISTER_ADDRESS 0x40000000\ntypedef union {\n    struct {\n        unsigned int field1 : 8;\n        unsigned int field2 : 8;\n        unsigned int field3 : 16;\n    } fields;\n    unsigned int allFields;\n} Register;\n\nvolatile Register *reg = (Register *)REGISTER_ADDRESS;\n``` \nBu sayede register'ın farklı alanlarına kolayca erişim sağlayabilirsiniz.",
    "category": "advanced_topics",
    "topic": "unions",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Union kullanımı",
    "timestamp": "2025-06-01T17:31:31.267729"
  },
  {
    "question": "Aşağıdaki kodun eksik kısmını tamamlayın: int x = 5; int y = 3; int result = x ___ y; printf(\"Sonuç: %d\", result);",
    "answer": "Kodda eksik olan kısım bitwise AND işlemi olan '&' operatörüdür. Bu işlem, her iki sayının bitlerini karşılaştırır ve her bir bit için yalnızca her iki bit de 1 ise 1 döner. Tamamlanmış kod şu şekildedir: \n\n```c\nint x = 5; // (101)\nint y = 3; // (011)\nint result = x & y; // (001) yani 1\nprintf(\"Sonuç: %d\", result); // Çıktı: Sonuç: 1\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609157"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: unsigned int a = 12; unsigned int b = 7; unsigned int result = a ___ b; printf(\"Sonuç: %u\", result);",
    "answer": "Kodda eksik olan kısım bitwise OR işlemi olan '|' operatörüdür. Bu işlem, her iki sayının bitlerini karşılaştırır ve en az bir bitin 1 olduğu durumlarda 1 döner. Tamamlanmış kod şu şekildedir: \n\n```c\nunsigned int a = 12; // (1100)\nunsigned int b = 7;  // (0111)\nunsigned int result = a | b; // (1111) yani 15\nprintf(\"Sonuç: %u\", result); // Çıktı: Sonuç: 15\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609222"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int num = 10; num = num ___ 1; printf(\"Sonuç: %d\", num);",
    "answer": "Kodda eksik olan kısım bitwise XOR işlemi olan '^' operatörüdür. Bu işlem, her iki sayının bitlerini karşılaştırır ve yalnızca bitler farklıysa 1 döner. Tamamlanmış kod şu şekildedir: \n\n```c\nint num = 10; // (1010)\nnum = num ^ 1; // (1011) yani 11\nprintf(\"Sonuç: %d\", num); // Çıktı: Sonuç: 11\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609259"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int value = 4; value ___= 2; printf(\"Sonuç: %d\", value);",
    "answer": "Kodda eksik olan kısım bitwise sağa kaydırma işlemi olan '>>=' operatörüdür. Bu, sayının bitlerini sağa kaydırır. Tamamlanmış kod şu şekildedir: \n\n```c\nint value = 4; // (100)\nvalue >>= 1; // (10) yani 2\nprintf(\"Sonuç: %d\", value); // Çıktı: Sonuç: 2\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609294"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int a = 5; int b = 1; int clearBit = a ___ (1 << b); printf(\"Sonuç: %d\", clearBit);",
    "answer": "Kodda eksik olan kısım bitwise NOT işlemi olan '~' operatörüdür. Bu işlem, belirli bir bitin tersini alır. Tamamlanmış kod şu şekildedir: \n\n```c\nint a = 5; // (0101)\nint b = 1;\nint clearBit = a & ~(1 << b); // (0101) & (1110) yani 4\nprintf(\"Sonuç: %d\", clearBit); // Çıktı: Sonuç: 4\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609338"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int num = 5; num ___= 2; printf(\"Sonuç: %d\", num);",
    "answer": "Kodda eksik olan kısım bitwise sola kaydırma işlemi olan '<<=' operatörüdür. Bu, sayının bitlerini sola kaydırır. Tamamlanmış kod şu şekildedir: \n\n```c\nint num = 5; // (0101)\nnum <<= 1; // (1010) yani 10\nprintf(\"Sonuç: %d\", num); // Çıktı: Sonuç: 10\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609380"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int a = 6; int b = 2; int result = a ___ b; printf(\"Sonuç: %d\", result);",
    "answer": "Kodda eksik olan kısım bitwise AND işlemi olan '&' operatörüdür. Tamamlanmış kod şu şekildedir: \n\n```c\nint a = 6; // (0110)\nint b = 2; // (0010)\nint result = a & b; // (0010) yani 2\nprintf(\"Sonuç: %d\", result); // Çıktı: Sonuç: 2\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609420"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int a = 5; int b = 3; int result = a ___ b; printf(\"Sonuç: %d\", result);",
    "answer": "Kodda eksik olan kısım bitwise XOR işlemi olan '^' operatörüdür. Tamamlanmış kod şu şekildedir: \n\n```c\nint a = 5; // (0101)\nint b = 3; // (0011)\nint result = a ^ b; // (0110) yani 6\nprintf(\"Sonuç: %d\", result); // Çıktı: Sonuç: 6\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609458"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int a = 15; int b = 3; int result = a ___ b; printf(\"Sonuç: %d\", result);",
    "answer": "Kodda eksik olan kısım bitwise OR işlemi olan '|' operatörüdür. Tamamlanmış kod şu şekildedir: \n\n```c\nint a = 15; // (1111)\nint b = 3;  // (0011)\nint result = a | b; // (1111) yani 15\nprintf(\"Sonuç: %d\", result); // Çıktı: Sonuç: 15\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609498"
  },
  {
    "question": "Aşağıdaki kodda eksik olan kısmı tamamlayın: int a = 8; int b = 5; int result = a ___ b; printf(\"Sonuç: %d\", result);",
    "answer": "Kodda eksik olan kısım bitwise AND işlemi olan '&' operatörüdür. Tamamlanmış kod şu şekildedir: \n\n```c\nint a = 8; // (1000)\nint b = 5; // (0101)\nint result = a & b; // (0000) yani 0\nprintf(\"Sonuç: %d\", result); // Çıktı: Sonuç: 0\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:31:56.609553"
  },
  {
    "question": "Bir tamsayıyı alın ve bu sayının 2. en sağdaki bitini sıfıra ayarlamak için eksik olan kodu tamamlayın.",
    "answer": "Tamsayıyı almak için bir değişken tanımlayın ve bit maskesi kullanarak 2. en sağdaki bitini sıfıra ayarlayın.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // 2. en sağdaki biti sıfıra ayarlamak için bit maskesi kullan\n    sayi &= ~(1 << 2);\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, verilen sayının 2. en sağdaki bitini sıfıra ayarlamak için bit kaydırma ve NOT işlemi kullanır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.059901"
  },
  {
    "question": "Bir tamsayıyı alın ve bu sayının 4. en sağdaki bitine 1 eklemek için eksik olan kodu tamamlayın.",
    "answer": "Bit maskesi kullanarak 4. en sağdaki biti 1 yapmak için aşağıdaki kodu kullanabilirsiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // 4. en sağdaki biti 1 yap\n    sayi |= (1 << 4);\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, verilen sayının 4. en sağdaki bitini 1 yaparak günceller.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.059956"
  },
  {
    "question": "Bir tamsayıyı alın ve bu sayının en yüksek bitini 0 yapmak için eksik olan kodu tamamlayın.",
    "answer": "En yüksek bitin 0 olması için bit maskesi oluşturun ve AND işlemi uygulayın.\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // En yüksek biti sıfıra ayarlamak için hesapla\n    sayi &= ~(1 << (sizeof(int) * 8 - 1));\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, tamsayıların bit genişliğini kullanarak en yüksek biti sıfıra ayarlamaktadır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.059988"
  },
  {
    "question": "Bir tamsayı alıp bu sayının tüm bitlerini ters çevirmek için eksik olan kodu tamamlayın.",
    "answer": "Tamsayıyı alıp bitleri ters çevirmek için NOT işlemi kullanabilirsiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // Tamsayının tüm bitlerini ters çevir\n    sayi = ~sayi;\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, verilen tamsayının bitlerini ters çevirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060016"
  },
  {
    "question": "Bir tamsayıyı alın ve bu sayının 3 en sağdaki bitine 1 eklemek için eksik olan kodu tamamlayın.",
    "answer": "3. en sağdaki biti 1 yapmak için bit maskesi kullanarak aşağıdaki gibi kod yazabilirsiniz.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // 3. en sağdaki biti 1 yap\n    sayi |= (1 << 3);\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, belirtilen sayının 3. en sağdaki bitine 1 ekler.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060046"
  },
  {
    "question": "İki tamsayının bitwise AND işlemini gerçekleştirmek için eksik olan kodu tamamlayın.",
    "answer": "İki tamsayı alıp bitwise AND işlemi yapmak için şu kodu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    printf(\"İki tamsayı girin: \");\n    scanf(\"%d %d\", &a, &b);\n    // Bitwise AND işlemi\n    int sonuc = a & b;\n    printf(\"Sonuç (a & b): %d\\n\", sonuc);\n    return 0;\n}\n```\nBu kod, iki tamsayı arasında bitwise AND işlemine örnektir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060074"
  },
  {
    "question": "Bir tamsayı alıp ondalık değere dönüştürmek için eksik olan kodu tamamlayın, fakat sadece en yüksek bit olan 1'i koruyun.",
    "answer": "En yüksek biti koruyarak ondalık değere dönüştürmek için şu kodu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // En yüksek biti koru\n    int enYuksekBit = (sayi & (1 << (sizeof(int) * 8 - 1))) ? 1 : 0;\n    // Sonucu yaz\n    printf(\"Sonuç: %d\\n\", enYuksekBit);\n    return 0;\n}\n```\nBu kod, yalnızca en yüksek bitin durumunu kontrol eder ve sonucu döndürür.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060112"
  },
  {
    "question": "Bir tamsayı alın ve bu sayının tüm bitlerini 0 yapmak için eksik olan kodu tamamlayın.",
    "answer": "Tamsayıyı alıp tüm bitlerini 0 yapmanın en basit yolu, sayıyı 0'a atamaktır:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // Tüm bitleri 0 yap\n    sayi = 0;\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, her durumda sayıyı 0 yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060139"
  },
  {
    "question": "Bir tamsayıyı alın ve bu sayının bit düzeyinde tersini almak için eksik olan kodu tamamlayın, ancak sadece en düşük 4 biti ters çevirin.",
    "answer": "En düşük 4 biti ters çevirmek için bit maskesi ile işlem yapabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // En düşük 4 biti ters çevir\n    sayi ^= 0b1111;\n    printf(\"Sonuç: %d\\n\", sayi);\n    return 0;\n}\n```\nBu kod, yalnızca en düşük 4 biti ters çevirerek sonucu günceller.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060178"
  },
  {
    "question": "Bir tamsayı alıp bu sayının 1. en sağdaki bitinin durumunu kontrol etmek için eksik olan kodu tamamlayın.",
    "answer": "Belirtilen bitin durumunu kontrol etmek için aşağıdaki kodu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int sayi;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &sayi);\n    // 1. en sağdaki bitin durumunu kontrol et\n    if (sayi & (1 << 1)) {\n        printf(\"1. en sağdaki bit 1'dir.\\n\");\n    } else {\n        printf(\"1. en sağdaki bit 0'dır.\\n\");\n    }\n    return 0;\n}\n```\nBu kod, kullanıcının girdiği sayının 1. en sağdaki bitinin durumunu kontrol eder.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:07.060209"
  },
  {
    "question": "Aşağıdaki kodda, sayının tek mi çift mi olduğunu kontrol eden bir fonksiyon var. Ancak çalışmıyor. Hatanın nedeni nedir?\n\n```c\n#include <stdio.h>\n\nvoid checkEvenOdd(int num) {\n    if (num & 1 == 0) {\n        printf(\"Çift\\n\");\n    } else {\n        printf(\"Tek\\n\");\n    }\n}\n\nint main() {\n    checkEvenOdd(5);\n    return 0;\n}\n```",
    "answer": "Hatanın nedeni, 'if (num & 1 == 0)' ifadesindeki öncelik sırasıdır. Burada '==' operatörü 'bitwise AND' operatöründen daha yüksek önceliğe sahiptir. Bu nedenle, 'num & 1' ifadesi öncelikle işlenir, ancak sonucu 0 ile karşılaştırma işlemi hatalı olur. Doğru kullanım şu şekildedir:\n\n```c\nif ((num & 1) == 0) {\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197434"
  },
  {
    "question": "Aşağıdaki kod, bir sayının ikilik sistemdeki tüm bitlerini tersine çevirmeye çalışıyor. Ama sonuç yanlış. Hatanın kaynağı nedir?\n\n```c\n#include <stdio.h>\n\nint reverseBits(int num) {\n    return ~num;\n}\n\nint main() {\n    int result = reverseBits(5);\n    printf(\"Ters çevrilmiş: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kod, sayının tüm bitlerini tersine çeviriyor ama bunun sonucu beklenenden farklı görünüyor. Bunun nedeni, 'int' türünün negatif bitlerin de tersine çevrilmesi ve bu durumun doğru bir şekilde anlaşılmamasıdır. Bunun yerine, sonuç bitlerini görmek için ikilik gösterimiyle yazdırmak faydalı olabilir. Ayrıca, sonucu ekrana yazdırmadan önce `unsigned int` olarak yazdırmak daha doğru olur:\n\n```c\nprintf(\"Ters çevrilmiş: %u\\n\", (unsigned int)result);\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197564"
  },
  {
    "question": "Aşağıdaki kodda, iki sayının bit düzeyinde AND işlemini gerçekleştiren bir fonksiyon var. Ancak her zaman sıfır döndürüyor. Hatanın nedenini bulun:\n\n```c\n#include <stdio.h>\n\nint bitwiseAnd(int a, int b) {\n    return a  b;\n}\n\nint main() {\n    int result = bitwiseAnd(6, 3);\n    printf(\"AND sonucu: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Hata, 'bitwiseAnd' fonksiyonundaki AND işleminin yanlış yazılmasından kaynaklanıyor. C dilinde bit düzeyinde AND işlemi için '&' operatörü kullanılmalıdır. Doğru kullanım şu şekildedir:\n\n```c\nint bitwiseAnd(int a, int b) {\n    return a & b;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197696"
  },
  {
    "question": "Aşağıdaki kodda, bir sayının en yüksek bitini bulmaya çalışan bir fonksiyon yazılmış. Ancak sonuç beklenenden farklı çıkıyor. Hatanın sebebi nedir?\n\n```c\n#include <stdio.h>\n\nint highestBit(int num) {\n    return num & (num - 1);\n}\n\nint main() {\n    int result = highestBit(10);\n    printf(\"En yüksek bit: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kod, en yüksek biti bulmak için gereken işlemi gerçekleştirmiyor. 'num & (num - 1)' ifadesi, en yüksek bitin sıfırlanmasına neden olur. Bunun yerine, en yüksek bitin konumunu bulmak için bit kaydırma işlemleri ve döngü kullanılmalıdır. Örneğin:\n\n```c\nint highestBit(int num) {\n    int position = 0;\n    while (num >>= 1) {\n        position++;\n    }\n    return position;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197796"
  },
  {
    "question": "Aşağıdaki kod, bir sayının 4. bitini set etmek (1 yapmak) için yazılmış. Ancak başarılı olamıyor. Hatanın kaynağını belirleyin:\n\n```c\n#include <stdio.h>\n\nint setBit(int num) {\n    return num | 4;\n}\n\nint main() {\n    int result = setBit(5);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda 4 yerine doğru bit konumunu belirtmek için 4. bitin maskesi olan '1 << 4' kullanılmalıdır. Bu durumda, 4 sayısı yerine 16 kullanmak gerekir. Doğru kod şöyle olmalıdır:\n\n```c\nint setBit(int num) {\n    return num | (1 << 4);\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197890"
  },
  {
    "question": "Aşağıdaki kodda, bir sayının tüm bitlerini sıfırlayan bir fonksiyon var. Ancak sonuç doğru değil. Hatanın nedeni nedir?\n\n```c\n#include <stdio.h>\n\nint clearBits(int num) {\n    return num & 0;\n}\n\nint main() {\n    int result = clearBits(15);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kod, tüm bitleri sıfırlamak için doğru bir yaklaşım değil. 'num & 0' ifadesi her zaman sıfır döndürür. Bunun yerine, 'return 0;' ifadesini kullanmalıyız. Doğru kod şöyle olmalıdır:\n\n```c\nint clearBits(int num) {\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.197976"
  },
  {
    "question": "Aşağıdaki kodda, iki sayının bit düzeyinde XOR işlemi yapılmak isteniyor. Ancak sonuç her zaman ilk sayıyı döndürüyor. Hatanın sebebini belirleyin:\n\n```c\n#include <stdio.h>\n\nint bitwiseXOR(int a, int b) {\n    return a ^ a;\n}\n\nint main() {\n    int result = bitwiseXOR(10, 5);\n    printf(\"XOR sonucu: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Hata, XOR işleminin 'a ^ a' olarak yazılmasından kaynaklanıyor. Bu ifade, her zaman sıfır döndürür. Doğru kod şu şekilde olmalıdır:\n\n```c\nint bitwiseXOR(int a, int b) {\n    return a ^ b;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.198067"
  },
  {
    "question": "Aşağıdaki kodda, verilen bir sayının 2'ye bölümünden kalanı bulmak için bir fonksiyon yazılmış. Ancak sonuç beklenenden farklı. Hatanın nedenini bulun:\n\n```c\n#include <stdio.h>\n\nint remainderByTwo(int num) {\n    return num % 1;\n}\n\nint main() {\n    int result = remainderByTwo(9);\n    printf(\"Kalan: %d\\n\", result);\n    return 0;\n}\n```",
    "answer": "Bu kodda, 2'ye bölümünden kalan bulmak için 'num % 2' ifadesi kullanılmalıdır. 'num % 1' ifadesi her zaman sıfır döndürür. Doğru kod şu şekilde olmalıdır:\n\n```c\nint remainderByTwo(int num) {\n    return num % 2;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.198156"
  },
  {
    "question": "Aşağıdaki kod, bir sayının belirli bir bitini sıfırlamak için yazılmış. Ancak çalışmıyor. Hatanın kaynağı nedir?\n\n```c\n#include <stdio.h>\n\nint clearSpecificBit(int num, int bit) {\n    return num & (1 << bit);\n}\n\nint main() {\n    int result = clearSpecificBit(5, 1);\n    printf(\"Sonuç: %d\\n\", result);\n    return 0;\n```",
    "answer": "Bu kodda, belirli bir bitin sıfırlanması için doğru maske oluşturulmamış. 'num & (1 << bit)' ifadesi yerine 'num & ~(1 << bit)' ifadesi kullanılmalıdır. Doğru kod şu şekilde olmalıdır:\n\n```c\nint clearSpecificBit(int num, int bit) {\n    return num & ~(1 << bit);\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:38:43.198247"
  },
  {
    "question": "Bitwise AND işlemi ile iki sayının ortak bitlerini nasıl bulabilirim? Kodumda neden beklediğim sonucu almıyorum?",
    "answer": "Bitwise AND işlemi, her iki bit de 1 olduğunda 1 döner. Örneğin, iki sayıyı AND ile işlem yaparken şöyle yapabiliriz: `int a = 12; int b = 10; int result = a & b;`. 12'nin ikili gösterimi 1100 ve 10'un 1010'dur. Bu sayılar AND işlemine sokulduğunda sonuç 8 (1000) olacaktır. Eğer beklediğiniz sonuç farklıysa, sayıları kontrol edin ve doğru ikili değerlerini kullandığınızdan emin olun.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.151861"
  },
  {
    "question": "Bitwise OR işlemi ile iki değer arasında nasıl bir birleşim elde edebilirim? Kodumda hata var.",
    "answer": "Bitwise OR işlemi, en az bir bit 1 olduğunda 1 döner. Örneğin, `int a = 5; int b = 3; int result = a | b;`. 5'in ikili gösterimi 0101 ve 3'ün 0011. Bu durumda OR işlemi sonucu 7 (0111) olacaktır. Eğer beklediğiniz sonuç 8 çıkıyorsa, kontrol edin; belki de yanlış bir sayı kullandınız.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.151909"
  },
  {
    "question": "Bitwise NOT işlemi nasıl çalışır ve uygulamamdaki hata nedir?",
    "answer": "Bitwise NOT işlemi, bir sayının tüm bitlerini ters çevirir. Örneğin, `int a = 5; int result = ~a;`. 5'in ikili gösterimi 0101, NOT işlemi yapıldığında sonuç 1111...1010 (negatif bir sayı) olacaktır. Eğer beklenmedik bir sonuç alıyorsanız, işaretli sayılar üzerinde NOT işlemi yaparken dikkatli olun; çünkü MSB (en yüksek bit) işareti değiştirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.151945"
  },
  {
    "question": "Bit kaydırma işlemi (shift) ile nasıl bir sayı üzerinde etkili bir değişiklik yapabilirim? Hata alıyorum.",
    "answer": "Sağ kaydırma (`>>`) ve sol kaydırma (`<<`) işlemleri, sayının bitlerini sağa veya sola kaydırır. Örneğin, `int a = 8; int result = a << 2;` işlemi 8'in (1000) 2 bit sola kaydırılmasıyla 32 (100000) verir. Eğer beklenmedik bir sonuç alıyorsanız, kaydırma işleminin sayının işaretini nasıl etkilediğini kontrol edin.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.151980"
  },
  {
    "question": "Bir sayının belirli bir bitini nasıl ayarlayabilirim? Hatanın kaynağı nedir?",
    "answer": "Belirli bir bitin ayarlanması için bitwise OR işlemi kullanılır. Örneğin, 3. biti 1 yapmak için `int a = 5; a |= (1 << 3);`. Burada `5` (0101) sayısını alır ve 3. bitini 1 yapar. Eğer beklenmeyen bir sonuç alıyorsanız, bit kaydırma işleminin doğru bir şekilde yapıldığından ve hedef bitin doğru seçildiğinden emin olun.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152006"
  },
  {
    "question": "Bir sayının belirli bir bitini sıfırlamak için hangi işlemi kullanmalıyım? Hatalı sonuç alıyorum.",
    "answer": "Belirli bir bitin sıfırlanması için bitwise AND ve NOT işlemi kombinasyonu kullanılır. Örneğin, 2. bitini sıfırlamak için `int a = 7; a &= ~(1 << 2);`. Burada `7` (0111) sayısından 2. bit sıfırlanır. Eğer beklenmedik bir sonuç alıyorsanız, NOT işleminizin doğru yapıldığını ve doğru bitin hedeflendiğini kontrol edin.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152035"
  },
  {
    "question": "Bir sayının belirli bir bitini ters çevirmek için hangi işlemi kullanmalıyım? Kodum çalışmıyor.",
    "answer": "Bir bitin ters çevrilmesi için bitwise XOR işlemi kullanılır. Örneğin, 1. bitini ters çevirmek için `int a = 5; a ^= (1 << 1);`. 5'in (0101) 1. biti 0 ise 1 olur. Eğer beklediğiniz sonuç farklıysa, doğru bitin seçildiğinden emin olun ve XOR işleminin mantığını kontrol edin.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152063"
  },
  {
    "question": "Bir sayı içinde belirli bir bit grubu olup olmadığını nasıl kontrol edebilirim? Kodumda hata var.",
    "answer": "Bunun için bitwise AND ve karşılaştırma kullanabilirsiniz. Örneğin, bir sayının 3. bit grubunun varlığını kontrol etmek için: `if (a & (1 << 3))`. Eğer bu işlem doğru çalışmıyorsa, doğru bitin kontrol edildiğinden ve sayının değerinin doğru ayarlandığından emin olun.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152093"
  },
  {
    "question": "Bit maskesi kullanarak hangi bitlerin ayıklandığını nasıl belirleyebilirim? Hatanın nedeni nedir?",
    "answer": "Bit maskesi, belirli bitlerin kontrol edilmesine olanak sağlar. Örneğin, `int mask = 0b00001100; int a = 0b10101010; int result = a & mask;`. Burada `result`, a'daki 2. ve 3. bitleri içerecektir. Eğer beklenmeyen bir sonuç alıyorsanız, maskenin doğru tanımlandığından emin olun.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152120"
  },
  {
    "question": "C dilinde bir sayının en düşük bitini nasıl kontrol ederim? Kodumda neden hata alıyorum?",
    "answer": "En düşük bitin kontrolü için bitwise AND işlemi kullanılır. Örneğin, `if (a & 1)`, a'nın en düşük bitinin 1 olup olmadığını kontrol eder. Eğer beklenmedik bir sonuç alıyorsanız, sayının değerine ve bit kontrolü sırasında doğru işlemi yaptığınıza dikkat edin.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:17.152149"
  },
  {
    "question": "Aşağıdaki C kodunda bit kaydırma işlemi ile bir sayının çift mi tek mi olduğunu belirliyorum. Ancak sonuç beklediğim gibi çıkmıyor. Hata nerede?",
    "answer": "Kod şu şekilde: \n```c\nint sayi = 5; \nif (sayi & 1) { \n    printf(\"Tek\"); \n} else { \n    printf(\"Çift\"); \n}\n```\nBurada hata yok. Ancak bit kaydırma işleminin yanlış anlaşılması sonucu, eğer bit kaydırma ile denemek isteseydik şöyle olmalıydı: \n```c\nif (sayi >> 1 & 1) { ... }\n```\nBu durumda, sayının ikinci bitine bakıyorduk, bu da yanlış sonuç verir. Doğru olan, en son bit (1. bit) üzerinden kontrol yapmaktır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338119"
  },
  {
    "question": "Aşağıdaki kodun çıktısı beklenmedik bir değer veriyor. Hata nerede? \n```c\nunsigned int a = 15; \nunsigned int b = 2; \nprintf(\"%d\", a & ~b);\n```",
    "answer": "Bu kodda, 'b' değişkeninin bitlerinin tersine çevrilmesi (NOT işlemi) sonucu 4294967293 değeri elde edilir ve bu değerle 'a' değişkeni AND işlemi yapılır. Bu durumda, 'a' değişkeni 15 (1111) ve ~b 4294967293 (11111111111111111111111111111100) olduğundan dolayı sadece ilk iki bit 0 çıkacak ve sonuç 12 (1100) olur. Beklenmeyen sonuç, bitlerin nasıl tersine çevrileceği konusunda dikkatli olunmamasıydı.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338191"
  },
  {
    "question": "Aşağıdaki kodda bir sayının 3. bitini değiştirmek istiyorum. Ancak sonuç beklediğim gibi çıkmıyor. Hata nerede? \n```c\nint sayi = 8; \nsayi |= (1 << 3); \nprintf(\"%d\", sayi);\n```",
    "answer": "Burada sorun şu: 'sayi' başlangıçta 8 (1000) ve 3. bitini değiştirmek için 3. bitin set edilmesi bekleniyor. Ancak 'sayi' zaten 3. bitin 1 olduğu bir değerdir, bu yüzden değişim olmayacak. Eğer 3. bitin 0 olmasını istemişsek, 'sayi ^= (1 << 3);' kullanmalıyız. Bu 'sayi' değişkeninin 3. bitini tersine çevirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338250"
  },
  {
    "question": "Aşağıdaki kodda tüm bitleri tersine çevirmek istiyorum ama beklediğim sonucu alamıyorum. Neden? \n```c\nint sayi = 21; \nsayi = ~sayi; \nprintf(\"%d\", sayi);\n```",
    "answer": "Bu kodda, 'sayi' değişkeni 21 (00000000000000000000000000010101) olarak tanımlanmıştır. '~' operatörü, sayının tüm bitlerini tersine çevirir. Ancak, int veri tipinin işareti olduğu için, sonuç negatif bir değer çıkacaktır. Bu durumda, 'sayi' değeri -22 (11111111111111111111111111101010) olur. Eğer unsigned int kullanırsanız, beklediğiniz sonucu elde edersiniz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338300"
  },
  {
    "question": "Aşağıdaki kodda iki sayının bitwise OR işlemiyle birleştirilmesini bekliyorum ama hata alıyorum. Neden? \n```c\nint a = 5; \nint b = -3; \nprintf(\"%d\", a | b);\n```",
    "answer": "Bu durumda, 'b' negatif bir sayı olduğu için, bitwise OR işlemi sonucu, işaret bitinin etkisi nedeniyle beklenmeyen bir değer döndürülüyor. Negatif sayıların ikilik gösteriminde işaret bitinin etkisi sonucu farklı sonuçlar alırız. 'b' pozitif bir değerle değiştirilirse, beklenen sonuç elde edilecektir. Negatif sayılarla çalışırken, bit işlemlerine dikkat etmelisiniz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338351"
  },
  {
    "question": "Aşağıdaki C kodunda, bitwise XOR ile bir dizi elemanlarını değiştiriyorum. Ancak sonucun beklediğim gibi çıkmadığını fark ettim. Neden? \n```c\nint x = 10; \nint y = 20; \nx = x ^ y; \ny = x ^ y; \nx = x ^ y; \nprintf(\"x: %d, y: %d\", x, y);\n```",
    "answer": "Bu kod, iki sayının değerlerini geçici olarak değiştirmek için XOR kullanır. Ancak son XOR işlemi yerine 'y' değerini yeniden atadığınızda, 'x' değişkeninin eski değerini kaybedersiniz. Doğru şekilde kullanmak için, XOR işlemlerinin her birinin sonucunu tutarak bu değerleri kullanmalısınız. Aşağıdaki gibi düzeltmeniz gerekir: \n```c\nint temp = x; \nx = x ^ y; \ny = temp ^ y; \n```\nBu sayede her iki değişkenin de değerini doğru bir şekilde değiştirebilirsiniz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338435"
  },
  {
    "question": "Aşağıdaki kodda bir sayının 5. bitini sıfırlamak istiyorum ama doğru sonucu alamıyorum. Hata nerede? \n```c\nint sayi = 43; \nsayi &= ~(1 << 5); \nprintf(\"%d\", sayi);\n```",
    "answer": "Kodda bit sıfırlama işlemi doğru yapılmış. 'sayi' başlangıçta 43 (00101011) ve 5. bitini sıfırlamak için '~(1 << 5)' ile 00101111 elde ediliyor. Bu durumda sonuç 11 (00001011) olacak. Eğer beklediğiniz sonuç bu değilse, kontrol edin. Belki bit pozisyonları ile ilgili bir yanlış anlama olmuş olabilir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338490"
  },
  {
    "question": "Aşağıdaki C kodunda, 8 bitlik bir maske kullanarak belirli bitleri ayıklamak istiyorum ama sonuç beklediğim gibi çıkmıyor. Hata nerede? \n```c\nint sayi = 255; \nint maske = 0x0F; \nprintf(\"%d\", sayi & maske);\n```",
    "answer": "Kodda maske olarak 0x0F kullanılıyor ve bu değer sadece en düşük 4 bitin (00001111) maskelenmesine neden oluyor. 'sayi' değişkeni 255 (11111111) iken, bu maske uygulanınca sonuç 15 (00001111) çıkıyor. Eğer 4 bit yerine 8 bit almak istiyorsanız, maskeyi 0xFF olarak değiştirin. Bu durumda sonuç 255 olacaktır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338583"
  },
  {
    "question": "Aşağıdaki kodda bit kaydırma işlemi ile bir sayı oluşturuyorum ama beklediğim sonucu alamıyorum. Neden? \n```c\nint sayi = 1; \nsayi << 4; \nprintf(\"%d\", sayi);\n```",
    "answer": "Bu kodda 'sayi' değişkeni 1 (00000001) değerine sahip. Ancak 'sayi << 4' işleminden sonra sonucu tekrar 'sayi' değişkenine atamanız gerekiyor. Aksi takdirde, kaydırma işlemi geçici olarak yapılır ve 'sayi' değişkeni değişmez. Doğru kullanım şu şekilde olmalıdır: \n```c\nsayi = sayi << 4; \n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338636"
  },
  {
    "question": "Aşağıdaki kodda 2 sayının bitwise AND işlemiyle karşılaştırmasını yapıyorum ama sonuç beklediğim gibi değil. Hata nerede? \n```c\nint a = 3; \nint b = 5; \nif (a & b) { \n    printf(\"Ortak bit var\"); \n} else { \n    printf(\"Ortak bit yok\"); \n}\n```",
    "answer": "Kodda 'a' ve 'b' değişkenleri 3 (00000011) ve 5 (00000101) olarak tanımlanmış. Bitwise AND işlemi sonucu 1 (00000001) dönecektir. Eğer ortak bit varsa, 'if' bloğu çalışır. Hata yok, ancak beklemediğiniz bir sonuç varsa, bu durumda 'a' ve 'b' değerlerini kontrol etmelisiniz. Düzgün çalışıyor, ancak bit değerlerinin ne olduğu konusunda net olun.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:39:58.338710"
  },
  {
    "question": "Bit işlemleri nedir?",
    "answer": "Bit işlemleri, sayılardaki bireysel bitlerin üzerinde yapılan işlemlerdir. Bu işlemler, genellikle mantıksal operatörler (AND, OR, NOT, XOR) ve kaydırma operatörleri (sola kaydırma, sağa kaydırma) kullanılarak gerçekleştirilir. Bit işlemleri, düşük seviyeli programlama ve optimize edilmiş hesaplamalar için sıkça kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013823"
  },
  {
    "question": "C dilinde iki sayının bitlerini AND işlemi ile nasıl karşılaştırabilirim?",
    "answer": "Bitleri AND işlemi ile karşılaştırmak için '&' operatörünü kullanırız. Örneğin, iki tamsayı olan 'a' ve 'b' için 'c = a & b;' ifadesi, 'c' değişkenine 'a' ve 'b' sayılarının bit düzeyinde AND işleminin sonucunu atar. Bu işlem, yalnızca her iki sayının bitlerinde '1' olan yerlerde '1' döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013882"
  },
  {
    "question": "Bit işlemleri ile bir sayının tek veya çift olduğunu nasıl belirlerim?",
    "answer": "Bir sayının tek mi çift mi olduğunu belirlemek için en son bitine bakarız. Eğer sayı tekse son bit '1' olur, eğer çiftse son bit '0' olur. Bu, 'n % 2' yerine 'n & 1' ifadesi ile daha verimli bir şekilde kontrol edilebilir. Örneğin, 'if (n & 1) { printf(\"Tek\"); } else { printf(\"Çift\"); }' şeklinde yazabiliriz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013913"
  },
  {
    "question": "Bit kaydırma işlemleri nelerdir ve neden kullanılır?",
    "answer": "Bit kaydırma işlemleri, bir sayının bitlerini sola veya sağa kaydırmak için kullanılır. '<<' operatörü sola kaydırma, '>>' operatörü ise sağa kaydırma işlemini temsil eder. Sola kaydırma, sayıyı 2 ile çarpmak gibidir; sağa kaydırma ise sayıyı 2'ye bölmek gibidir. Örneğin, 'x << 1' ifadesi, 'x' değerini iki katına çıkarır. Bu işlemler, performans artırımı için sıkça kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013934"
  },
  {
    "question": "XOR işlemi ne işe yarar?",
    "answer": "XOR (^) işlemi, iki bitin birbirine göre karşılaştırılmasını sağlar. Eğer iki bit farklıysa sonuç '1', aynıysa sonuç '0' olur. XOR işlemi, veri güvenliğinde, parite kontrolünde ve bitlerin tersine çevrilmesinde kullanılır. Örneğin, 'c = a ^ b;' ifadesi ile 'a' ve 'b' sayılarının XOR sonucunu 'c' değişkenine atarız.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013951"
  },
  {
    "question": "C dilinde bir sayının belirli bir bitini nasıl ayarlayabilirim?",
    "answer": "Bir sayının belirli bir bitini ayarlamak için bit maskesi kullanırız. Örneğin, 3. bitini 1 yapmak için 'num |= (1 << 3);' ifadesini kullanırız. Burada '1 << 3' ile 3. bit 1 yapılır, ardından OR işlemi ile 'num' değişkeninin 3. biti 1 olur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013974"
  },
  {
    "question": "Bir tamsayıyı bit düzeyinde ters çevirmek için ne yapmalıyım?",
    "answer": "Bir tamsayıyı bit düzeyinde ters çevirmek için NOT operatörünü (~) kullanırız. Örneğin, 'result = ~num;' ifadesi, 'num' değişkenindeki tüm bitlerin tersini alır. Bu işlem, her 1'i 0, her 0'ı 1 yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.013997"
  },
  {
    "question": "C dilinde bit alanlarını nasıl kullanabilirim?",
    "answer": "C dilinde, bit alanları, bir yapının (struct) içinde belirli sayıda bit ayırmamıza olanak tanır. Örneğin: 'struct { unsigned int a: 1; unsigned int b: 2; } bits;' şeklinde tanımlama yapabiliriz. Burada 'a' 1 bit, 'b' 2 bit alır. Bu, bellek tasarrufu sağlar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.014015"
  },
  {
    "question": "Aynı anda birden fazla bitin değerini nasıl değiştirebilirim?",
    "answer": "Birden fazla bitin değerini değiştirmek için bit maskeleri kullanarak OR veya AND işlemleri uygulayabiliriz. Örneğin, 'num |= (1 << 1) | (1 << 3);' ifadesi, 'num' değişkeninin 1. ve 3. bitlerini 1 yapar. Bu sayede birden fazla bitin değeri tek bir ifadeyle değiştirilebilir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.014036"
  },
  {
    "question": "C dilinde bit işlemleri ile belirli bitleri sıfırlamak için ne yapmalıyım?",
    "answer": "Belirli bitleri sıfırlamak için AND işlemi ile bit maskesi kullanırız. Örneğin, 2. ve 3. bitleri sıfırlamak için 'num &= ~( (1 << 2) | (1 << 3) );' ifadesini kullanırız. '~' operatörü ile bit maskesinin tersini alıp, AND işlemi ile bu bitleri sıfırlarız.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:31.014060"
  },
  {
    "question": "Bitwise AND işlemi nedir ve hangi durumlarda kullanılır?",
    "answer": "Bitwise AND işlemi, iki sayının her bitini karşılaştırarak her iki bit de 1 olduğunda 1, aksi takdirde 0 döner. Örneğin, 5 (101) ve 3 (011) sayıları için 5 & 3 işlemi 1 (001) sonucunu verir. Genellikle bu işlem, belirli bitlerin kontrol edilmesi gerektiğinde kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025495"
  },
  {
    "question": "Bitwise OR işlemi ile iki sayının birleştirilmesi nasıl yapılır?",
    "answer": "Bitwise OR işlemi, iki sayının bitlerini karşılaştırarak en az bir bit 1 olduğunda 1 döner. Örneğin, 5 (101) ve 3 (011) işlemi 7 (111) sonucunu verir. Bu işlem, bit setleme ve bayrak (flag) yönetimi için sıkça kullanılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025570"
  },
  {
    "question": "Bitwise XOR işlemi nedir ve ne zaman faydalıdır?",
    "answer": "Bitwise XOR, iki sayının bitlerini karşılaştırararak farklı olan bitlerde 1 döner. Örneğin, 5 (101) ve 3 (011) işlemi 6 (110) sonucunu üretir. XOR, veri gizliliği ve hata düzeltme işlemlerinde faydalıdır, çünkü iki aynı değeri XOR'lamak sıfır döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025592"
  },
  {
    "question": "Bir sayının bitlerini sola kaydırma işlemi nasıl yapılır?",
    "answer": "Bir sayının bitlerini sola kaydırmak için bit kaydırma operatörü (<<) kullanılır. Örneğin, 3 (00000011) sayısını 1 bit sola kaydırdığımızda 6 (00000110) sonucunu alırız. Bu işlem, sayıyı 2 ile çarpma efekti oluşturur, yani (3 << 1) = 3 * 2.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025614"
  },
  {
    "question": "Bit kaydırma işlemi ile sayının değerini nasıl etkileyebiliriz?",
    "answer": "Bit kaydırma işlemi, bir sayıyı sola veya sağa kaydırarak değerini etkiler. Sağ kaydırma (>>) işlemi, sayıyı 2 ile bölme etkisi yaratır. Örneğin, 8 (1000) sayısını 1 bit sağa kaydırırsak 4 (0100) elde ederiz. Bu işlemler, performans ve bellek yönetimi açısından oldukça kullanışlıdır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025636"
  },
  {
    "question": "Bit maskeleri nedir ve pratikte nasıl kullanılır?",
    "answer": "Bit maskeleri, belirli bitleri kontrol etmek veya değiştirmek amacıyla kullanılan ikilik sayılardır. Örneğin, bir değişkenin belirli bitlerini kontrol etmek için o bitlerin olduğu bir maske ile AND işlemi yapılır. Örneğin, maske olarak 0x0F (00001111) kullanarak bir sayının son dört bitini kontrol edebiliriz.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025656"
  },
  {
    "question": "İki sayının birbirine eşit olup olmadığını bit işlemleri ile nasıl kontrol edebiliriz?",
    "answer": "İki sayının eşitliğini kontrol etmek için XOR işlemi kullanılabilir. Eğer iki sayı birbirine eşit ise, XOR sonucu 0 döner. Örneğin, (a ^ b) == 0 koşulu, a ve b'nin eşit olduğunu gösterir. Bu yöntem, bazı durumlarda performans avantajı sağlar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025684"
  },
  {
    "question": "Bir değerin belirli bitlerini nasıl ayarlayabiliriz?",
    "answer": "Bir değerin belirli bitlerini ayarlamak için OR ve AND işlemleri birlikte kullanılır. Örneğin, 5 (00000101) sayısının 2. bitini 1 yapmak için 0x04 (00000100) ile OR işlemi yapabilirsiniz. Diğer bitleri sıfıra indirmek için ise 0xFB (11111011) ile AND işlemi yapılır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025705"
  },
  {
    "question": "Bit işlemleri ile bir dizi içindeki tek sayıları nasıl bulabiliriz?",
    "answer": "Bir dizi içinde tek sayıları bulmak için her sayıyı kontrol ederek en sağdaki bitin 1 olup olmadığını belirleyebiliriz. Örneğin, sayının değeri 1 (0001) ile AND işlemi yapılırsa, sonuç 1 ise sayı tektir. Bu işlem, dizideki her eleman için döngü içinde gerçekleştirilir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025728"
  },
  {
    "question": "Bit işlemleri ile bir bayrağın (flag) ayarlanması nasıl yapılır?",
    "answer": "Bir bayrağı ayarlamak için OR işlemi kullanılır. Örneğin, bir değişkende belirli bir bayrağı aktif hale getirmek istiyorsanız, bayrağın değerini içeren bir maske ile OR işlemi yapmalısınız. Bu, o bayrağın durumunu değiştirmeden diğer bayrakları korur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025752"
  },
  {
    "question": "En düşük ve en yüksek bitlerin nasıl kontrol edileceğini örnekleyin.",
    "answer": "Bir sayının en düşük bitini kontrol etmek için sayıyı 1 ile AND işlemi yapabilirsiniz. Örneğin, 4 (0100) en düşük biti 0'dır. En yüksek bit ise, sayıyı bir maske ile AND yaparak kontrol edilebilir. Örneğin, 8 (1000) sayısı için eğer en yüksek bit 1 ise, sonuç 1 döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:40:51.025775"
  },
  {
    "question": "Bit düzeyinde bir maske kullanarak bir sayının belirli bitlerini nasıl sıfırlayabilirim?",
    "answer": "Belirli bitleri sıfırlamak için bir maske (bit mask) kullanabilirsiniz. Maske, sıfırlamak istediğiniz bitlerin pozisyonlarında 0, diğerlerinde ise 1 içeren bir sayı olmalıdır. Örneğin, 0xF0 (11110000) sayısında son 4 biti sıfırlamak istiyorsak, 0x0F (00001111) maskesini kullanarak bit AND işlemi yaparız. Kod örneği:\n\n```c\nint number = 0xFF; // 11111111\nint mask = 0x0F;   // 00001111\nint result = number & mask; // 00001111\n```\nBurada, 'result' değişkeni 15 (0x0F) değerini alır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376833"
  },
  {
    "question": "C dilinde bir sayının en yüksek bitini nasıl ayarlayabilirim?",
    "answer": "Bir sayının en yüksek bitini ayarlamak için, o bitin pozisyonuna 1 ekleyerek bir OR işlemi yapabilirsiniz. Örneğin, 8 bitlik bir sayıda en yüksek bit 7. pozisyondadır. Aşağıdaki kod ile bunu gerçekleştirebiliriz:\n\n```c\nint number = 0b00000000; // 0\nnumber |= (1 << 7); // 10000000\n```\nBurada, 'number' değişkeni 128 (0x80) değerini alır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376874"
  },
  {
    "question": "Bit kaydırma işlemleri (left shift, right shift) hangi senaryolarda kullanılır?",
    "answer": "Bit kaydırma işlemleri, sayıları hızlı bir şekilde çarpma veya bölme işlemleri için kullanılabilir. Örneğin, bir sayıyı 2 ile çarpmak için sola kaydırma yapılır, 2 ile bölmek için ise sağa kaydırma yapılır. Aşağıda örnek bir kullanım:\n\n```c\nint number = 5; // 00000101\nint leftShift = number << 1; // 00001010, 10 değerine eşittir (5 * 2)\nint rightShift = number >> 1; // 00000010, 2 değerine eşittir (5 / 2)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376904"
  },
  {
    "question": "Bit işlemleri kullanarak bir sayının tek mi çift mi olduğunu nasıl kontrol edebilirim?",
    "answer": "Bir sayının tek mi çift mi olduğunu kontrol etmek için, sayıyı 1 ile AND işlemi yapabiliriz. Eğer sonuç 0 ise sayı çifttir, aksi takdirde tektir. Aşağıdaki kodda bu kontrolü görebilirsiniz:\n\n```c\nint number = 7;\nif (number & 1) {\n    printf(\"Tek\");\n} else {\n    printf(\"Çift\");\n}\n// 7 sayısı için çıktı: Tek\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376941"
  },
  {
    "question": "İki sayının bit düzeyinde karşılaştırmasını nasıl yapabilirim?",
    "answer": "İki sayının bit düzeyinde karşılaştırması için XOR işlemi kullanılabilir. XOR işlemi, iki bit aynıysa 0, farklıysa 1 sonuç verir. Bu sayede hangi bitlerin farklı olduğunu görebiliriz. Örnek:\n\n```c\nint a = 0b1100; // 12\nint b = 0b1010; // 10\nint difference = a ^ b; // 0110, 6 değerini alır\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376964"
  },
  {
    "question": "Bit alanları (bit fields) nedir ve ne amaçla kullanılır?",
    "answer": "Bit alanları, yapılar içindeki belirli bit sayılarının kullanılmasını sağlar. Bu, bellek tasarrufu için oldukça faydalıdır. Örneğin, 8 bitlik bir alanda 3 bitlik bir değer saklamayı düşünelim:\n\n```c\nstruct MyStruct {\n    unsigned int field1 : 3; // 3 bit\n    unsigned int field2 : 5; // 5 bit\n};\n```\nBurada, 'MyStruct' yapısı toplam 8 bit (1 byte) bellek kullanır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.376988"
  },
  {
    "question": "Bir bit dizisi (bit array) oluşturmak ve yönetmek için nasıl bir yapı kullanabilirim?",
    "answer": "Bir bit dizisi oluşturmak için bir dizi kullanabiliriz ancak dizinin her bir elemanı bir bit olarak ifade edilmelidir. Aşağıda basit bir örnek verilmiştir:\n\n```c\n#define ARRAY_SIZE 8\nunsigned char bitArray[ARRAY_SIZE / 8]; // 8 bit için 1 byte\n\n// Bit ayarlama fonksiyonu\nvoid setBit(int index) {\n    bitArray[index / 8] |= (1 << (index % 8));\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.377017"
  },
  {
    "question": "C dilinde bit manipülasyonu yaparak bir baytın bütün bitlerini tersine çevirmek için hangi yöntemi kullanabilirim?",
    "answer": "Bir baytın bütün bitlerini tersine çevirmek için XOR işlemi ve bir maske kullanılabilir. Aşağıdaki kodda bu işlemi gerçekleştiren bir fonksiyon örneği bulunmaktadır:\n\n```c\nunsigned char reverseBits(unsigned char byte) {\n    return ~byte;\n}\n// Kullanım:\nunsigned char result = reverseBits(0b10101010); // 01010101 döner\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.377049"
  },
  {
    "question": "Bir sayının belirli bir bitini nasıl değiştirebilirim?",
    "answer": "Bir sayının belirli bir bitini değiştirmek için önce o bitin durumunu belirleyip, ardından uygun bir maske ile OR veya AND işlemleri yapabiliriz. Aşağıda bir örnek verilmiştir:\n\n```c\nvoid setBit(int *number, int position, int value) {\n    if (value) {\n        *number |= (1 << position); // 1 ile ayarla\n    } else {\n        *number &= ~(1 << position); // 0 ile sıfırla\n    }\n}\n// Kullanım:\nint num = 0b00000000;\nsetBit(&num, 3, 1); // 00001000\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.377069"
  },
  {
    "question": "C dilinde bit işlemleri kullanarak bir sayı dizisinin toplamını nasıl hesaplayabilirim?",
    "answer": "Bit işlemleri ile toplamı hesaplamak yerine, normal aritmetik işlemler kullanmak daha uygundur. Ancak, örneğin bir dizinin her elemanını bitwise OR işlemi ile birleştirerek, tüm bitlerin ayarlanıp ayarlanmadığını kontrol edebiliriz:\n\n```c\nint array[] = {1, 2, 4};\nint total = 0;\nfor (int i = 0; i < sizeof(array) / sizeof(array[0]); i++) {\n    total |= array[i]; // Toplam yerine bitwise OR kullanılıyor\n}\n// Total, 7 (111) değerini alır.\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:24.377094"
  },
  {
    "question": "İki sayının bit düzeyinde AND işlemini nasıl yaparız?",
    "answer": "C dilinde iki sayının bit düzeyinde AND işlemi için '&' operatörünü kullanırız. Örneğin: int a = 5; // 0101 in binary\nint b = 3; // 0011 in binary\nint result = a & b; // result = 1; // 0001 in binary. Bu işlem, her iki sayıdaki bitlerin aynı olduğu durumlarda 1 döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.975851"
  },
  {
    "question": "Bir sayının en düşük bitini (LSB) nasıl kontrol ederiz?",
    "answer": "Bir sayının en düşük bitini kontrol etmek için, sayıyı 1 ile AND işlemi yaparız. Örneğin: int num = 6; // 0110 in binary\nif (num & 1) {\n    printf(\"LSB 1\");\n} else {\n    printf(\"LSB 0\");\n}. Bu, sayının tek mi çift mi olduğunu belirlememizi sağlar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.975891"
  },
  {
    "question": "Bir sayının bitlerini tersine çevirmek için hangi yöntemi kullanabiliriz?",
    "answer": "Bitleri tersine çevirmek için döngü ve bit kaydırma kullanabiliriz. Örneğin: int reverseBits(int n) {\n    int result = 0;\n    for (int i = 0; i < 32; i++) {\n        result |= (n & 1) << (31 - i);\n        n >>= 1;\n    }\n    return result;\n}. Bu fonksiyon, verilen sayının bitlerini tersine çevirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.975940"
  },
  {
    "question": "Bir sayıyı 1 bit sola kaydırmak ne anlama gelir ve nasıl yapılır?",
    "answer": "Bir sayıyı 1 bit sola kaydırmak, sayıyı 2 ile çarpmak anlamına gelir. C dilinde bu işlem '<<' operatörü ile yapılır. Örneğin: int a = 3; // 0011 in binary\nint b = a << 1; // b = 6; // 0110 in binary. Bu, a'yı 1 bit sola kaydırarak b'yi oluşturur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.975967"
  },
  {
    "question": "Bir sayının 1 bit sağa kaydırılmasının etkisi nedir?",
    "answer": "Bir sayıyı 1 bit sağa kaydırmak, sayıyı 2 ile bölmek gibidir. C dilinde bu işlemi '>>' operatörü ile yapabiliriz. Örneğin: int a = 8; // 1000 in binary\nint b = a >> 1; // b = 4; // 0100 in binary. Bu işlem, a'yı 1 bit sağa kaydırır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.975988"
  },
  {
    "question": "Verilen bir sayının bitlerinin toplamını nasıl hesaplayabiliriz?",
    "answer": "Bitlerin toplamını hesaplamak için, sayının her bir bitini kontrol ederek 1 olan bitlerin sayısını artırabiliriz. Örneğin: int countBits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}. Bu fonksiyon, verilen sayının bitlerinin toplamını döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976009"
  },
  {
    "question": "Bir sayının 2'nin kuvveti olup olmadığını nasıl kontrol ederiz?",
    "answer": "Bir sayının 2'nin kuvveti olup olmadığını kontrol etmek için, sayının pozitif ve yalnızca bir 1 bitine sahip olup olmadığını kontrol edebiliriz. Örneğin: bool isPowerOfTwo(int n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}. Bu fonksiyon, sayının 2'nin kuvveti olup olmadığını döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976032"
  },
  {
    "question": "İki sayının bit düzeyinde OR işlemini nasıl yaparız?",
    "answer": "İki sayının bit düzeyinde OR işlemi için '|' operatörünü kullanırız. Örneğin: int a = 5; // 0101 in binary\nint b = 3; // 0011 in binary\nint result = a | b; // result = 7; // 0111 in binary. Bu işlem, her iki sayının bitlerinden en az birinin 1 olduğu durumlarda 1 döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976054"
  },
  {
    "question": "Belirli bir bitin değerini nasıl değiştirebiliriz?",
    "answer": "Belirli bir bitin değerini değiştirmek için, o bitin maskeleme işlemini yapabiliriz. Örneğin: int toggleBit(int n, int bitPosition) {\n    return n ^ (1 << bitPosition);\n}. Bu fonksiyon, n sayısındaki 'bitPosition' bitinin değerini değiştirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976072"
  },
  {
    "question": "İki sayının bit düzeyinde XOR işlemini nasıl yaparız?",
    "answer": "İki sayının bit düzeyinde XOR işlemi için '^' operatörünü kullanırız. Örneğin: int a = 5; // 0101 in binary\nint b = 3; // 0011 in binary\nint result = a ^ b; // result = 6; // 0110 in binary. Bu işlem, her iki sayının bitlerinden yalnızca birinin 1 olduğu durumlarda 1 döner.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976092"
  },
  {
    "question": "Bir sayının tüm bitlerini sıfırlamanın en basit yolu nedir?",
    "answer": "Bir sayının tüm bitlerini sıfırlamak için, sayıyı 0 ile atamak yeterlidir. Örneğin: int n = 15; // 1111 in binary\nn = 0; // Tüm bitler sıfır olur. Bu, sayının tüm bitlerini sıfırlamanın en basit yoludur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:41:51.976114"
  },
  {
    "question": "İki tam sayının bitwise AND işlemi ile nasıl karşılaştırılacağını gösteren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint bitwise_and(int a, int b) {\n    return a & b;\n}\n\nint main() {\n    int x = 5; // 0101\n    int y = 3; // 0011\n    printf(\"%d AND %d = %d\\n\", x, y, bitwise_and(x, y)); // 1 (0001)\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608623"
  },
  {
    "question": "Bir tam sayının en düşük bitini nasıl alabileceğinizi gösteren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint get_lowest_bit(int n) {\n    return n & -n;\n}\n\nint main() {\n    int num = 12; // 1100\n    printf(\"%d'nin en düşük bit değeri: %d\\n\", num, get_lowest_bit(num)); // 4 (0100)\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608665"
  },
  {
    "question": "Bir tam sayının bitlerini tersine çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nunsigned int reverse_bits(unsigned int n) {\n    unsigned int rev = 0;\n    for (int i = 0; i < 32; i++) {\n        rev <<= 1;\n        if (n & 1)\n            rev ^= 1;\n        n >>= 1;\n    }\n    return rev;\n}\n\nint main() {\n    unsigned int num = 13; // 1101\n    printf(\"%d'nin ters bit değeri: %d\\n\", num, reverse_bits(num)); // 11 (1011)\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608699"
  },
  {
    "question": "İki tam sayıyı bitwise XOR işlemi ile karşılaştıran bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint bitwise_xor(int a, int b) {\n    return a ^ b;\n}\n\nint main() {\n    int x = 4; // 0100\n    int y = 5; // 0101\n    printf(\"%d XOR %d = %d\\n\", x, y, bitwise_xor(x, y)); // 1 (0001)\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608725"
  },
  {
    "question": "Bir sayının bit düzeyinde kaydırma işlemi ile çarpımını gösteren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint multiply_by_power_of_two(int n, int power) {\n    return n << power;\n}\n\nint main() {\n    int num = 3;\n    int power = 2;\n    printf(\"%d x 2^%d = %d\\n\", num, power, multiply_by_power_of_two(num, power)); // 12\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608751"
  },
  {
    "question": "Bir tam sayı içinde belirli bir bitin set edilip edilmediğini kontrol eden bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint is_bit_set(int n, int position) {\n    return (n & (1 << position)) != 0;\n}\n\nint main() {\n    int num = 5; // 0101\n    int pos = 2;\n    printf(\"%d sayısında %d. bit %s\\n\", num, pos, is_bit_set(num, pos) ? \"set\" : \"set değil\"); // set\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608785"
  },
  {
    "question": "Bir tam sayının bitlerini sayan bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint count_bits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\nint main() {\n    int num = 29; // 11101\n    printf(\"%d sayısındaki bit sayısı: %d\\n\", num, count_bits(num)); // 4\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608807"
  },
  {
    "question": "Bir tam sayının en yüksek bitini bulmak için bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint get_highest_bit(int n) {\n    int position = 0;\n    while (n >>= 1) {\n        position++;\n    }\n    return position;\n}\n\nint main() {\n    int num = 18; // 10010\n    printf(\"%d'nin en yüksek bit pozisyonu: %d\\n\", num, get_highest_bit(num)); // 4\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608843"
  },
  {
    "question": "Bir tam sayı dizisindeki tüm elemanların bitwise OR işlemi ile birleştirildiği bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint bitwise_or_array(int arr[], int size) {\n    int result = 0;\n    for (int i = 0; i < size; i++) {\n        result |= arr[i];\n    }\n    return result;\n}\n\nint main() {\n    int arr[] = {1, 2, 4};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin bitwise OR sonucu: %d\\n\", bitwise_or_array(arr, size)); // 7\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608876"
  },
  {
    "question": "Verilen bir sayının tüm bitlerini tersine çeviren bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nunsigned int flip_bits(unsigned int n) {\n    return ~n;\n}\n\nint main() {\n    unsigned int num = 6; // 0110\n    printf(\"%d'nin tüm bitleri ters çevrildiğinde: %d\\n\", num, flip_bits(num)); // 4294967295 - 6 = 4294967290\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:42:18.608900"
  },
  {
    "question": "Bir sayının çift veya tek olduğunu kontrol eden bir bit işlemi yazın.",
    "answer": "Bir sayının çift veya tek olduğunu anlamak için en son bitini kontrol edebiliriz. Eğer son bit 0 ise sayı çifttir, 1 ise tektir. Aşağıda bu kontrolü yapan bir C kodu bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint isEven(int num) {\n    return (num & 1) == 0;\n}\n\nint main() {\n    int number = 5;\n    if (isEven(number)) {\n        printf(\"%d çift bir sayıdır.\\n\", number);\n    } else {\n        printf(\"%d tek bir sayıdır.\\n\", number);\n    }\n    return 0;\n}\n```\nBu kodda `isEven` fonksiyonu input olarak aldığı `num` sayısının en son bitini kontrol eder.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836591"
  },
  {
    "question": "Bir sayının belirli bir bitini ayarlayan (set) bir fonksiyon yazın.",
    "answer": "Belirli bir bitin değerini 1 yapmak için bitwise OR işlemi kullanılır. Aşağıda bir sayının belirli bir bitini ayarlayan bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint setBit(int num, int bitPosition) {\n    return num | (1 << bitPosition);\n}\n\nint main() {\n    int number = 10; // 1010\n    int bitToSet = 1;\n    int result = setBit(number, bitToSet);\n    printf(\"Sonuç: %d\\n\", result); // 1010 | 0010 = 1012\n    return 0;\n}\n```\nBu kodda `setBit` fonksiyonu, `num` sayısının `bitPosition` konumundaki bitini 1 yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836662"
  },
  {
    "question": "İki sayının bitwise XOR sonucu olan bir fonksiyon yazın ve bu fonksiyonun nasıl çalıştığını açıklayın.",
    "answer": "Bitwise XOR işlemi (^) iki sayının aynı bitleri 1 olduğunda 0, farklı olduğunda 1 döndürmesini sağlar. Aşağıda XOR işlemi yapan bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint bitwiseXOR(int a, int b) {\n    return a ^ b;\n}\n\nint main() {\n    int x = 5; // 0101\n    int y = 3; // 0011\n    int result = bitwiseXOR(x, y);\n    printf(\"XOR sonucu: %d\\n\", result); // 0110 = 6\n    return 0;\n}\n```\nBu fonksiyon, verilen iki sayının bitwise XOR'unu döndürür.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836705"
  },
  {
    "question": "Bir sayının belirli bir bitini sıfırlayan (clear) bir fonksiyon yazın.",
    "answer": "Belirli bir bitin değerini 0 yapmak için bitwise AND işlemi ve bitin tersini alarak kullanabiliriz. Aşağıda bir sayının belirli bir bitini sıfırlayan bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint clearBit(int num, int bitPosition) {\n    return num & ~(1 << bitPosition);\n}\n\nint main() {\n    int number = 15; // 1111\n    int bitToClear = 2;\n    int result = clearBit(number, bitToClear);\n    printf(\"Sonuç: %d\\n\", result); // 1111 & 1101 = 1101 (13)\n    return 0;\n}\n```\nBurada `clearBit` fonksiyonu, `num` sayısının `bitPosition` konumundaki bitini 0 yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836729"
  },
  {
    "question": "Bir sayının bitlerini tersine çeviren bir fonksiyon yazın.",
    "answer": "Bir sayının tüm bitlerini tersine çevirmek için bitwise NOT işlemi (tilde) kullanılır. Aşağıda bu işlemi gerçekleştiren bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint reverseBits(int num) {\n    return ~num;\n}\n\nint main() {\n    int number = 5; // 0000 0101\n    int result = reverseBits(number);\n    printf(\"Tersine çevrilmiş bitler: %d\\n\", result); // 1111 1010\n    return 0;\n}\n```\n`reverseBits` fonksiyonu, verilen sayının tüm bitlerini tersine çevirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836751"
  },
  {
    "question": "Bir sayının en sağdaki 1 bitini bulan bir fonksiyon yazın.",
    "answer": "Bir sayının en sağdaki 1 bitini bulmak için `num & -num` işlemi kullanılabilir. Bu işlem, sayının en sağdaki 1 bitinin konumunu döndürür. Aşağıdaki kodda bu işlemi gerçekleştiren bir fonksiyon bulunmaktadır:\n\n```c\n#include <stdio.h>\n\nint findLowestSetBit(int num) {\n    return num & -num;\n}\n\nint main() {\n    int number = 18; // 10010\n    int result = findLowestSetBit(number);\n    printf(\"En sağdaki 1 biti: %d\\n\", result); // 00010\n    return 0;\n}\n```\nBu fonksiyon, verilen sayının en sağdaki 1 bitini bulur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836772"
  },
  {
    "question": "Bir sayının bitlerini sağa kaydıran bir fonksiyon yazın ve bu fonksiyonun kullanımını gösterin.",
    "answer": "Bitleri sağa kaydırmak için bitwise sağa kaydırma işlemi (`>>`) kullanılır. Aşağıda bu işlemi gerçekleştiren bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint rightShift(int num, int positions) {\n    return num >> positions;\n}\n\nint main() {\n    int number = 16; // 10000\n    int shifted = rightShift(number, 2);\n    printf(\"Sağa kaydırılmış sonuç: %d\\n\", shifted); // 00100 (4)\n    return 0;\n}\n```\nBurada `rightShift` fonksiyonu, verilen sayıyı belirtilen konum kadar sağa kaydırır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836800"
  },
  {
    "question": "İki sayının bitlerini değiştiren (swap) bir fonksiyon yazın.",
    "answer": "İki sayının bitlerini değiştirmek için XOR işlemi kullanabiliriz. Aşağıdaki fonksiyon iki sayının bitlerini değiştirir:\n\n```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    *a = *a ^ *b;\n    *b = *a ^ *b;\n    *a = *a ^ *b;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"Değiştirilen değerler: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```\nBu kodda `swap` fonksiyonu, iki sayının bitlerini XOR işlemi ile değiştirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836824"
  },
  {
    "question": "Bir sayının 1 bitlerinin sayısını bulan bir fonksiyon yazın.",
    "answer": "Bir sayının içinde kaç tane 1 biti olduğunu bulmak için bir döngü ve bitwise AND işlemi kullanılabilir. Aşağıda bu işlemi gerçekleştiren bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint countSetBits(int num) {\n    int count = 0;\n    while (num) {\n        count += (num & 1);\n        num >>= 1;\n    }\n    return count;\n}\n\nint main() {\n    int number = 29; // 11101\n    int result = countSetBits(number);\n    printf(\"1 bitlerinin sayısı: %d\\n\", result); // 4\n    return 0;\n}\n```\nBu fonksiyon, verilen sayıda kaç tane 1 biti olduğunu sayar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836846"
  },
  {
    "question": "Bir sayıyı belirli bir bit sayısı kadar sola kaydırarak yeni değeri hesaplayan bir fonksiyon yazın.",
    "answer": "Bitleri sola kaydırmak için bitwise sola kaydırma işlemi (`<<`) kullanılır. Aşağıda bu işlemi gerçekleştiren bir fonksiyon verilmiştir:\n\n```c\n#include <stdio.h>\n\nint leftShift(int num, int positions) {\n    return num << positions;\n}\n\nint main() {\n    int number = 3; // 0000 0011\n    int shifted = leftShift(number, 3);\n    printf(\"Sola kaydırılmış sonuç: %d\\n\", shifted); // 24\n    return 0;\n}\n```\nBurada `leftShift` fonksiyonu, verilen sayıyı belirtilen konum kadar sola kaydırır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:02.836884"
  },
  {
    "question": "Bir tam sayının en düşük bitini (LSB) sıfırlamak için hangi bit işlemini kullanmalıyım? Örnek bir kod göster.",
    "answer": "Bir tam sayının en düşük bitini sıfırlamak için bit AND işlemini kullanabiliriz. Örneğin, eğer num değişkeni bir tam sayıyı tutuyorsa, en düşük biti sıfırlamak için 'num & ~1' işlemini yapabiliriz. Kod örneği:\n\n```c\nint num = 5; // 0101 in binary\nnum = num & ~1; // Sonuç: 0100 (4)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312649"
  },
  {
    "question": "Bir sayının çift mi yoksa tek mi olduğunu kontrol etmek için en etkili yöntem nedir?",
    "answer": "Bir sayının çift veya tek olduğunu kontrol etmek için en düşük bitine bakabiliriz. Eğer en düşük bit 0 ise sayı çifttir, eğer 1 ise tektir. Bunu yapmak için & operatörünü kullanabiliriz. Kod örneği:\n\n```c\nint num = 7;\nif (num & 1) {\n    printf(\"Tek\");\n} else {\n    printf(\"Çift\");\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312695"
  },
  {
    "question": "Bir tam sayının 3. bitini (0'dan başlayarak) set etmek (1 yapmak) için hangi işlemi kullanmalıyım?",
    "answer": "Bir tam sayının belirli bir bitini set etmek için OR işlemi kullanabiliriz. Bit maskesi oluşturmak için 1'i sola kaydırabiliriz. 3. biti set etmek için 1 << 3 işlemi yaparak bit maskesini oluştururuz. Örnek:\n\n```c\nint num = 2; // 0010 in binary\nnum |= (1 << 3); // Sonuç: 1010 (10)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312732"
  },
  {
    "question": "Bir sayının 4. bitini sıfırlamak için hangi bit işlemini kullanmalıyım? Örnek bir kod göster.",
    "answer": "Bir sayının belirli bir bitini sıfırlamak için AND işlemi ve bit maskesi kullanabiliriz. 4. biti sıfırlamak için 1'i sola kaydırıp tersini alırız. Örnek:\n\n```c\nint num = 18; // 10010 in binary\nnum &= ~(1 << 4); // Sonuç: 00010 (2)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312761"
  },
  {
    "question": "Bir tam sayının 2. ve 3. bitlerini tersine çevirmek için ne yapmalıyım?",
    "answer": "Bir tam sayının belirli bitlerini tersine çevirmek için XOR işlemi kullanabiliriz. Bit maskesi oluşturarak 2. ve 3. bitleri tersine çevirebiliriz. Örnek kod:\n\n```c\nint num = 10; // 1010 in binary\nnum ^= (1 << 2) | (1 << 3); // Sonuç: 1110 (14)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312789"
  },
  {
    "question": "Bir sayının bitlerini tersine çevirmek için hangi yöntemleri kullanabilirim? Kısa bir açıklama yap.",
    "answer": "Bir tam sayının bitlerini tersine çevirmek için bir döngü içinde en düşük bit ile en yüksek bit arasında karşılık gelen bitleri değiştirebiliriz. Bunun dışında, bazı platformlarda yerleşik fonksiyonlar da bulunabilir. Örnek:\n\n```c\nunsigned int reverseBits(unsigned int n) {\n    unsigned int result = 0;\n    for (int i = 0; i < 32; i++) {\n        result <<= 1;\n        result |= (n & 1);\n        n >>= 1;\n    }\n    return result;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312819"
  },
  {
    "question": "Bir tam sayının belirli bir bitini kontrol etmek için ne yapmalıyım? Örnek bir kod göster.",
    "answer": "Bir bitin kontrolü için o bitin maskesini oluşturup AND işlemi yapabiliriz. Örneğin, 5. bitin kontrolü için 1 << 5 kullanarak maskeyi oluştururuz. Örnek:\n\n```c\nint num = 42; // 00101010 in binary\nif (num & (1 << 5)) {\n    printf(\"5. bit set\");\n} else {\n    printf(\"5. bit sıfır\");\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312867"
  },
  {
    "question": "Bir tamsayıyı 1 ile sağa kaydırmanın etkisini açıklayın ve bir örnek verin.",
    "answer": "Bir tamsayıyı 1 ile sağa kaydırmak, sayının değeri ikiye bölmek anlamına gelir. Bu, tam sayı için sağa kaydırma işlemi ile yapılır. Örnek:\n\n```c\nint num = 8; // 1000 in binary\nnum >>= 1; // Sonuç: 4 (0100)\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312893"
  },
  {
    "question": "Bir sayının tüm bitlerini ters çevirmek için bir makro tanımlayın.",
    "answer": "Tüm bitleri ters çevirmek için bir makro tanımlayabiliriz. Bu makro, XOR işlemi ile tüm bitleri 1 ile tersine çevirmek için kullanılacaktır. Örnek makro:\n\n```c\n#define REVERSE_BITS(x) (~(x))\nint main() {\n    int num = 5; // 00000101 in binary\n    int reversed = REVERSE_BITS(num); // Sonuç: 11111010\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312916"
  },
  {
    "question": "Bit işlemleri ile bir sayının 0 ile 255 arasında olup olmadığını kontrol etmek için bir fonksiyon yazın.",
    "answer": "Bir sayının 0 ile 255 arasında olup olmadığını kontrol etmek için bit işlemi yaparak en yüksek 8 bitin sıfır olup olmadığını kontrol edebiliriz. Örnek:\n\n```c\nint isInRange(int num) {\n    return (num & ~0xFF) == 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:28.312948"
  },
  {
    "question": "Bir sayının çift veya tek olup olmadığını kontrol eden bir fonksiyon nasıl yazılır? Bit işlemleri kullanarak optimize edin.",
    "answer": "Bir sayının çift veya tek olduğunu kontrol etmek için en son bitine bakabiliriz. Aşağıdaki fonksiyon, bu kontrolü bitwise AND operatörü (&) ile yapar:\n\n```c\n#include <stdbool.h>\n\nbool is_even(int num) {\n    return (num & 1) == 0;\n}\n```\nBu yöntem, sayının sadece en son bitini kontrol ettiği için hızlıdır ve gereksiz hesaplamalardan kaçınır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.996753"
  },
  {
    "question": "İki sayının en büyük ortak bölenini (GCD) bit işlemleri kullanarak nasıl hesaplayabiliriz?",
    "answer": "Euclid'in algoritmasını bit işlemleri ile optimize edilmiş haliyle uygulayabiliriz:\n\n```c\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a & b);\n}\n```\nBu yaklaşım, a ve b'nin bitlerini kullanarak GCD'yi hesaplar ve klasik bölme işlemlerinden daha hızlıdır.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.996822"
  },
  {
    "question": "Bir tamsayıyı ters çevirmek için bit işlemleri kullanarak nasıl bir fonksiyon yazabiliriz?",
    "answer": "Aşağıdaki fonksiyon, verilen tamsayının bitlerini tersine çevirir:\n\n```c\nunsigned int reverse_bits(unsigned int n) {\n    unsigned int reversed = 0;\n    for (int i = 0; i < sizeof(n) * 8; i++) {\n        reversed <<= 1;\n        if (n & 1) reversed |= 1;\n        n >>= 1;\n    }\n    return reversed;\n}\n```\nBu fonksiyon bitleri tek tek kontrol ederek ters çevirir, her bir adımda bit kaydırma işlemleri yapar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.996866"
  },
  {
    "question": "Bir tamsayı dizisindeki tüm elemanların bit düzeyinde OR işlemini yapan bir fonksiyon yazın. Performansı artırmak için bit işlemleri kullanın.",
    "answer": "Aşağıdaki fonksiyon, dizideki tüm sayıları bitwise OR ile birleştirir:\n\n```c\nint bitwise_or(int* arr, int size) {\n    int result = 0;\n    for (int i = 0; i < size; i++) {\n        result |= arr[i];\n    }\n    return result;\n}\n```\nBu yöntem, her bir elemanı tek tek kontrol eder ve sonuçta tüm elemanların OR işlemini gerçekleştirir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.996934"
  },
  {
    "question": "Bir sayının binary (ikilik) temsilindeki 1'lerin sayısını hesaplayan bir fonksiyon yazın. Bit işlemleri kullanarak optimize edin.",
    "answer": "Hamming ağırlığını hesaplamak için aşağıdaki fonksiyonu kullanabiliriz:\n\n```c\nint count_set_bits(unsigned int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n```\nBu fonksiyon, sayının her bir bitini kontrol ederek 1'lerin sayısını toplar ve bit kaydırma işlemi ile döngü oluşturur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.996995"
  },
  {
    "question": "Bir sayının bit düzeyinde tüm bitlerini tersine çeviren bir fonksiyon yazın. Performans açısından nasıl iyileştirebilirsiniz?",
    "answer": "Aşağıdaki örnek, bit ters çevirmeyi optimize etmek için bir maske kullanır:\n\n```c\nunsigned int flip_bits(unsigned int n) {\n    return ~n;\n}\n```\nBu yöntem, tüm bitleri değiştirmek için NOT operatörünü kullanır ve en hızlı yöntemlerden biridir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.997047"
  },
  {
    "question": "Verilen bir tamsayı dizisindeki bit seviyesindeki en büyük değeri bulmak için bir fonksiyon yazın.",
    "answer": "Aşağıdaki fonksiyon, bitwise AND işlemi ile dizideki en büyük değeri bulur:\n\n```c\nint max_bitwise_and(int* arr, int size) {\n    int max_value = arr[0];\n    for (int i = 1; i < size; i++) {\n        max_value = max_value & arr[i];\n    }\n    return max_value;\n}\n```\nBu yöntem, her bir elemanın AND değerini alarak en büyük değeri bulur.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.997080"
  },
  {
    "question": "Bir tamsayıyı belirli bir pozisyondaki bitini değiştiren bir fonksiyon yazın. Bit işlemleri kullanarak bunu nasıl yaparsınız?",
    "answer": "Aşağıdaki fonksiyon, belirli bir pozisyondaki bitin değerini değiştirmek için kullanılır:\n\n```c\nint toggle_bit(int n, int pos) {\n    return n ^ (1 << pos);\n}\n```\nBu yöntem, XOR işlemi ile belirtilen pozisyondaki bitin değerini tersine çevirir ve oldukça etkilidir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.997114"
  },
  {
    "question": "Bit düzeyinde çarpma işlemi gerçekleştiren bir fonksiyon yazın. Performansı artırmak için bit manipülasyonlarını nasıl kullanırsınız?",
    "answer": "Aşağıdaki fonksiyon, bit kaydırma işlemleri ile çarpma işlemi yapar:\n\n```c\nint bitwise_multiply(int a, int b) {\n    int result = 0;\n    while (b) {\n        if (b & 1) result += a;\n        a <<= 1;\n        b >>= 1;\n    }\n    return result;\n}\n```\nBu yöntem, b'nin her bir bitini kontrol ederek a'yı uygun miktarda kaydırır ve toplar.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.997150"
  },
  {
    "question": "Bir tamsayıyı verilen bir değere göre bit düzeyinde sola kaydıran bir fonksiyon yazın. Performansı nasıl artırabilirsiniz?",
    "answer": "Aşağıdaki fonksiyon, bit kaydırma işlemi ile sola kaydırma yapar:\n\n```c\nunsigned int left_shift(unsigned int n, int positions) {\n    return n << positions;\n}\n```\nBu yöntem, verilen sayıyı belirtilen sayıda sola kaydırarak daha hızlı ve etkili bir şekilde sonuç verir.",
    "category": "advanced_topics",
    "topic": "bit_operations",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Bit işlemleri",
    "timestamp": "2025-06-01T17:43:56.997201"
  },
  {
    "question": "Fibonacci dizisinin n'inci terimini hesaplamak için bir özyinelemeli fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n = 5; // 5. Fibonacci terimini bulmak istiyoruz.\n    printf(\"Fibonacci(%d) = %d\\n\", n, fibonacci(n));\n    return 0;\n}\n\n// Bu kod, Fibonacci dizisinin n'inci terimini hesaplamak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818797"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için bir özyinelemeli fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int n = 5; // 5! hesaplanacak\n    printf(\"%d! = %d\\n\", n, faktoriyel(n));\n    return 0;\n}\n\n// Bu kod, verilen bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818839"
  },
  {
    "question": "Bir dizinin toplamını hesaplamak için özyinelemeli bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint diziToplam(int dizi[], int n) {\n    if (n <= 0) return 0;\n    return dizi[n - 1] + diziToplam(dizi, n - 1);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin toplamı = %d\\n\", diziToplam(dizi, n));\n    return 0;\n}\n\n// Bu kod, verilen bir dizinin toplamını bulmak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818863"
  },
  {
    "question": "Bir sayının n'inci kuvvetini hesaplmak için özyinelemeli bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint kuvvet(int base, int exp) {\n    if (exp == 0) return 1;\n    return base * kuvvet(base, exp - 1);\n}\n\nint main() {\n    int base = 2, exp = 3; // 2'nin 3. kuvveti\n    printf(\"%d^%d = %d\\n\", base, exp, kuvvet(base, exp));\n    return 0;\n}\n\n// Bu kod, bir sayının belirli bir kuvvetini hesaplamak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818888"
  },
  {
    "question": "Bir sayının pozitif mi negatif mi olduğunu belirleyen özyinelemeli bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nconst char* pozitifMiNegatifMi(int n) {\n    if (n > 0) return \"Pozitif\";\n    if (n < 0) return \"Negatif\";\n    return \"Sıfır\";\n}\n\nint main() {\n    int n = -5; // kontrol edilecek sayı\n    printf(\"%d sayısı %s\\n\", n, pozitifMiNegatifMi(n));\n    return 0;\n}\n\n// Bu kod, bir sayının pozitif, negatif veya sıfır olduğunu belirlemek için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818914"
  },
  {
    "question": "Verilen bir sayı için asal sayıları belirlemek için özyinelemeli bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint asalMi(int n, int i) {\n    if (n <= 2) return (n == 2) ? 1 : 0;\n    if (n % i == 0) return 0;\n    if (i * i > n) return 1;\n    return asalMi(n, i + 1);\n}\n\nint main() {\n    int n = 11; // kontrol edilecek sayı\n    if (asalMi(n, 2)) \n        printf(\"%d asal bir sayıdır.\\n\", n);\n    else \n        printf(\"%d asal bir sayı değildir.\\n\", n);\n    return 0;\n}\n\n// Bu kod, verilen bir sayının asal olup olmadığını belirlemek için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818942"
  },
  {
    "question": "Bir metin içindeki karakterlerin sayısını özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "#include <stdio.h>\n\nint karakterSayisi(char* str) {\n    if (*str == '\\0') return 0;\n    return 1 + karakterSayisi(str + 1);\n}\n\nint main() {\n    char str[] = \"Merhaba\"; // karakter sayısını hesaplayacağız\n    printf(\"Karakter sayısı = %d\\n\", karakterSayisi(str));\n    return 0;\n}\n\n// Bu kod, bir metindeki karakter sayısını bulmak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818967"
  },
  {
    "question": "Bir sayının rakamlarının toplamını özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "#include <stdio.h>\n\nint rakamToplam(int n) {\n    if (n == 0) return 0;\n    return (n % 10) + rakamToplam(n / 10);\n}\n\nint main() {\n    int n = 1234; // rakam toplamı hesaplanacak\n    printf(\"%d sayısının rakamlarının toplamı = %d\\n\", n, rakamToplam(n));\n    return 0;\n}\n\n// Bu kod, bir sayının rakamlarının toplamını bulmak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.818990"
  },
  {
    "question": "Bir sayının tersini özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "#include <stdio.h>\n\nvoid ters(int n) {\n    if (n == 0) return;\n    printf(\"%d\", n % 10);\n    ters(n / 10);\n}\n\nint main() {\n    int n = 1234; // tersini almak istediğimiz sayı\n    printf(\"%d sayısının tersi: \", n);\n    ters(n);\n    printf(\"\\n\");\n    return 0;\n}\n\n// Bu kod, bir sayının tersini yazdırmak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.819010"
  },
  {
    "question": "Bir dizideki en büyük sayıyı bulmak için özyinelemeli bir fonksiyon yazın.",
    "answer": "#include <stdio.h>\n\nint enBuyuk(int dizi[], int n) {\n    if (n == 1) return dizi[0];\n    int max = enBuyuk(dizi, n - 1);\n    return (dizi[n - 1] > max) ? dizi[n - 1] : max;\n}\n\nint main() {\n    int dizi[] = {3, 5, 2, 9, 1};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizideki en büyük sayı = %d\\n\", enBuyuk(dizi, n));\n    return 0;\n}\n\n// Bu kod, verilen bir dizideki en büyük sayıyı bulmak için özyinelemeli bir fonksiyon kullanır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:44:31.819043"
  },
  {
    "question": "Fibonacci sayılarını hesaplamak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n = 10; // 10. Fibonacci sayısını bulmak için\n    printf(\"Fibonacci(%d) = %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```\nBu kodda, `fibonacci` fonksiyonu kendisini özyinelemeli olarak çağırarak Fibonacci sayısını hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196281"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Faktöriyel, pozitif bir tamsayın çarpanlarının çarpımıdır. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    int n = 5; // 5! hesaplamak için\n    printf(\"%d! = %d\\n\", n, faktoriyel(n));\n    return 0;\n}\n```\nBu kod `faktoriyel` fonksiyonu kullanarak 5 faktöriyelini hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196324"
  },
  {
    "question": "Bir dizideki elemanların toplamını hesaplamak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Dizinin elemanlarının toplamını hesaplamak için özyinelemeli bir fonksiyon kullanabiliriz. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint diziTopla(int dizi[], int n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return dizi[n - 1] + diziTopla(dizi, n - 1);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizinin toplamı = %d\\n\", diziTopla(dizi, n));\n    return 0;\n}\n```\n`diziTopla` fonksiyonu dizinin elemanlarını özyinelemeli olarak toplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196350"
  },
  {
    "question": "Bir stringin ters çevrilmesi için eksik olan fonksiyonu tamamlayın.",
    "answer": "Bir stringin tersine çevrilmesi, karakterlerin sırasını değiştirmek için özyineleme kullanılarak yapılabilir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid tersCevir(char *str, int start, int end) {\n    if (start >= end) {\n        return;\n    }\n    char temp = str[start];\n    str[start] = str[end];\n    str[end] = temp;\n    tersCevir(str, start + 1, end - 1);\n}\n\nint main() {\n    char str[] = \"Merhaba\";\n    int n = strlen(str);\n    tersCevir(str, 0, n - 1);\n    printf(\"Ters çevrilmiş string: %s\\n\", str);\n    return 0;\n}\n```\n`tersCevir` fonksiyonu karakterleri özyinelemeli olarak değiştirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196373"
  },
  {
    "question": "Bir sayının pozitif tam bölenlerini bulmak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Bir sayının pozitif tam bölenlerini bulmak için özyinelemeli bir fonksiyon kullanılabilir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nvoid bolenleriBul(int n, int i) {\n    if (i > n) {\n        return;\n    }\n    if (n % i == 0) {\n        printf(\"%d \\n\", i);\n    }\n    bolenleriBul(n, i + 1);\n}\n\nint main() {\n    int n = 12; // 12 sayısının bölenlerini bulmak için\n    printf(\"%d sayısının pozitif tam bölenleri:\\n\", n);\n    bolenleriBul(n, 1);\n    return 0;\n}\n```\n`bolenleriBul` fonksiyonu sayının bölenlerini özyinelemeli olarak bulur ve yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196399"
  },
  {
    "question": "Bir dizideki maksimum elemanı bulmak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Bir dizideki maksimum elemanı bulmak için özyinelemeli bir yaklaşım kullanılabilir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint maxBul(int dizi[], int n) {\n    if (n == 1) {\n        return dizi[0];\n    }\n    int max = maxBul(dizi, n - 1);\n    return (dizi[n - 1] > max) ? dizi[n - 1] : max;\n}\n\nint main() {\n    int dizi[] = {3, 5, 2, 9, 1};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizideki maksimum eleman = %d\\n\", maxBul(dizi, n));\n    return 0;\n}\n```\n`maxBul` fonksiyonu dizideki maksimum elemanı özyinelemeli olarak bulur.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196422"
  },
  {
    "question": "Bir dizi elemanını ters sırayla yazdırmak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Dizi elemanlarını ters sırayla yazdırmak için özyinelemeli bir fonksiyon kullanılabilir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nvoid tersYazdir(int dizi[], int n) {\n    if (n <= 0) {\n        return;\n    }\n    printf(\"%d \", dizi[n - 1]);\n    tersYazdir(dizi, n - 1);\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int n = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizi elemanları ters sırayla: \");\n    tersYazdir(dizi, n);\n    printf(\"\\n\");\n    return 0;\n}\n```\n`tersYazdir` fonksiyonu dizi elemanlarını ters sırayla yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196447"
  },
  {
    "question": "Bir stringin içinde belirli bir karakterin kaç kez geçtiğini bulmak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Bir stringde belirli bir karakterin sayısını bulmak için özyinelemeli bir fonksiyon kullanabiliriz. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint karakterSay(char *str, char c) {\n    if (*str == '\\0') {\n        return 0;\n    }\n    return (*str == c) + karakterSay(str + 1, c);\n}\n\nint main() {\n    char str[] = \"merhaba dünya\";\n    char c = 'a';\n    printf(\"'%c' karakteri stringde %d kez geçiyor.\\n\", c, karakterSay(str, c));\n    return 0;\n}\n```\n`karakterSay` fonksiyonu, verilen karakterin string içinde kaç kez geçtiğini özyinelemeli olarak hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196478"
  },
  {
    "question": "Bir sayının basamaklarının toplamını hesaplamak için eksik olan fonksiyonu tamamlayın.",
    "answer": "Bir sayının basamaklarının toplamını bulmak için özyinelemeli bir fonksiyon kullanılabilir. Aşağıdaki kodda eksik kısım tamamlanmıştır:\n\n```c\n#include <stdio.h>\n\nint basamakTopla(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    return (n % 10) + basamakTopla(n / 10);\n}\n\nint main() {\n    int n = 1234; // 1234 sayısının basamak toplamını bulmak için\n    printf(\"%d sayısının basamak toplamı = %d\\n\", n, basamakTopla(n));\n    return 0;\n}\n```\n`basamakTopla` fonksiyonu, bir sayının basamaklarını özyinelemeli olarak toplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:15.196503"
  },
  {
    "question": "Fibonacci dizisinin n'inci terimini özyinelemeli bir fonksiyonla hesaplayın. Ancak, sonucun negatif olmaması gerektiğini kontrol edin.",
    "answer": "#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n < 0) {\n        printf(\"Negatif bir sayı girdiniz!\\n\");\n        return -1;\n    }\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &n);\n    int result = fibonacci(n);\n    if (result != -1) {\n        printf(\"Fibonacci(%d) = %d\\n\", n, result);\n    }\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242253"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını özyinelemeli bir fonksiyon kullanarak hesaplayın.",
    "answer": "#include <stdio.h>\n\nint arraySum(int arr[], int size) {\n    if (size == 0) return 0;\n    return arr[size - 1] + arraySum(arr, size - 1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin toplamı: %d\\n\", arraySum(arr, size));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242294"
  },
  {
    "question": "Bir sayının faktöriyelini özyinelemeli bir fonksiyon ile hesaplayın. Girdi 0'dan küçükse, uygun bir hata mesajı döndürün.",
    "answer": "#include <stdio.h>\n\nint factorial(int n) {\n    if (n < 0) {\n        printf(\"Negatif bir sayı girdiniz! Faktöriyel tanımsızdır.\\n\");\n        return -1;\n    }\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int n;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &n);\n    int result = factorial(n);\n    if (result != -1) {\n        printf(\"%d! = %d\\n\", n, result);\n    }\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242332"
  },
  {
    "question": "Bir sayının tersini özyinelemeli bir fonksiyon kullanarak yazdırın. Girdi negatifse, uygun bir mesaj gösterin.",
    "answer": "#include <stdio.h>\n\nvoid reverse(int n) {\n    if (n < 0) {\n        printf(\"Negatif sayının tersi tanımsızdır.\\n\");\n        return;\n    }\n    if (n == 0) return;\n    printf(\"%d\", n % 10);\n    reverse(n / 10);\n}\n\nint main() {\n    int n;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &n);\n    printf(\"Sayının tersi: \");\n    reverse(n);\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242365"
  },
  {
    "question": "Bir stringin palindrom olup olmadığını özyinelemeli bir fonksiyon kullanarak kontrol edin.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char str[], int start, int end) {\n    if (start >= end) return 1;\n    if (str[start] != str[end]) return 0;\n    return isPalindrome(str, start + 1, end - 1);\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    scanf(\"%s\", str);\n    int length = strlen(str);\n    if (isPalindrome(str, 0, length - 1)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242391"
  },
  {
    "question": "Bir sayının basamak sayısını özyinelemeli bir fonksiyon kullanarak hesaplayın.",
    "answer": "#include <stdio.h>\n\nint countDigits(int n) {\n    if (n < 10) return 1;\n    return 1 + countDigits(n / 10);\n}\n\nint main() {\n    int n;\n    printf(\"Bir tamsayı girin: \");\n    scanf(\"%d\", &n);\n    if (n < 0) n = -n; // Negatif sayıyı pozitif yap\n    printf(\"%d sayısının basamak sayısı: %d\\n\", n, countDigits(n));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242414"
  },
  {
    "question": "Bir dizideki en büyük sayıyı özyinelemeli bir fonksiyonla bulun.",
    "answer": "#include <stdio.h>\n\nint findMax(int arr[], int size) {\n    if (size == 1) return arr[0];\n    int maxOfRest = findMax(arr, size - 1);\n    return (arr[size - 1] > maxOfRest) ? arr[size - 1] : maxOfRest;\n}\n\nint main() {\n    int arr[] = {3, 5, 1, 8, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin en büyük elemanı: %d\\n\", findMax(arr, size));\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242437"
  },
  {
    "question": "Bir stringin karakterlerini özyinelemeli bir fonksiyonla büyük harfe çevirin.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nvoid toUpperCase(char str[], int index) {\n    if (str[index] == '\\0') return;\n    str[index] = toupper(str[index]);\n    toUpperCase(str, index + 1);\n}\n\nint main() {\n    char str[100];\n    printf(\"Bir string girin: \");\n    scanf(\"%s\", str);\n    toUpperCase(str, 0);\n    printf(\"Büyük harfli hali: %s\\n\", str);\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242466"
  },
  {
    "question": "Bir sayının pozitif bölenlerini özyinelemeli bir fonksiyonla yazdırın.",
    "answer": "#include <stdio.h>\n\nvoid printDivisors(int n, int i) {\n    if (i > n) return;\n    if (n % i == 0) printf(\"%d \", i);\n    printDivisors(n, i + 1);\n}\n\nint main() {\n    int n;\n    printf(\"Bir pozitif tamsayı girin: \");\n    scanf(\"%d\", &n);\n    printf(\"%d sayısının bölenleri: \", n);\n    printDivisors(n, 1);\n    printf(\"\\n\");\n    return 0;\n}",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:45:43.242489"
  },
  {
    "question": "Bir sayı dizisindeki en büyük sayıyı bulmak için özyinelemeli bir fonksiyon yazdım. Ancak sonuç her zaman -1 dönüyor. Neden?",
    "answer": "Muhtemelen dizinin ilk elemanını kontrol edip onu döndürmüyorsunuz. Özyinelemeli fonksiyonunuza bir çıkış koşulu eklemeniz gerek. Dizi boşsa, -1 döndürmek yerine ilk elemanı kontrol etmelisiniz. Aşağıdaki gibi bir düzeltme yapabilirsiniz:\n\n```c\nint max(int arr[], int n) {\n    if (n == 0) return -1; // Dizi boşsa -1 dön\n    if (n == 1) return arr[0]; // Tek eleman varsa onu döndür\n    int maxOfRest = max(arr, n - 1); // Geriye kalanların maksimumunu bul\n    return (arr[n-1] > maxOfRest) ? arr[n-1] : maxOfRest; // En büyük olanı döndür\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.628824"
  },
  {
    "question": "Fibonacci sayıları için yazdığım özyinelemeli fonksiyon çok yavaş çalışıyor. Neden bu kadar yavaş?",
    "answer": "Fibonacci hesaplama işlemi, her sayıyı hesaplamak için önceki iki sayıyı yeniden hesaplıyor. Bu nedenle, zaman karmaşıklığı üssel bir boyuta ulaşıyor. Bunu düzeltmek için dinamik programlama veya memoization kullanabilirsiniz. Örneğin:\n\n```c\nint fib(int n, int memo[]) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n]; // Önceden hesaplandıysa dön\n    memo[n] = fib(n - 1, memo) + fib(n - 2, memo); // Hesapla ve sakla\n    return memo[n];\n}\n\nint fibonacci(int n) {\n    int memo[n + 1];\n    for (int i = 0; i <= n; i++) memo[i] = -1; // Başlangıçta tüm değerleri -1 yap\n    return fib(n, memo);\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.628873"
  },
  {
    "question": "Özyinelemeli bir fonksiyonla bir dizinin toplamını hesaplıyorum ama sonuç yanlış çıkıyor. Neden?",
    "answer": "Muhtemelen çıkış koşulunuz yanlış tanımlanmış. Dizi uzunluğu 0 olduğunda 0 dönmesi gerektiğini unutmayın. İşte düzeltme:\n\n```c\nint sum(int arr[], int n) {\n    if (n <= 0) return 0; // Dizi boşsa 0 döndür\n    return arr[n-1] + sum(arr, n - 1); // Son elemanı ekle ve kalan diziyle tekrar çağır\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.628913"
  },
  {
    "question": "Özyinelemeli bir fonksiyonla bir kelimenin tersini alıyorum, ama çıktıda her harf eksik. Neden?",
    "answer": "Fonksiyonunuzu her seferinde harfin eksik olmasına neden olan bir kesme şartı yoksa, dizinin sonuna erişemiyor olabilirsiniz. Aşağıdaki gibi bir düzeltme yapmalısınız:\n\n```c\nvoid reverse(char str[], int start, int end) {\n    if (start >= end) return; // Kesme koşulu\n    char temp = str[start];\n    str[start] = str[end];\n    str[end] = temp;\n    reverse(str, start + 1, end - 1); // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.628943"
  },
  {
    "question": "Bir sayı kümesinin faktöriyelini hesaplamak için yazdığım fonksiyon sonsuz döngüye girdi. Neden?",
    "answer": "Faktöriyel hesaplamasında çıkış koşulunu doğru ayarlamak çok önemlidir. Genellikle 0! = 1 kabul edilir. İşte düzeltme:\n\n```c\nint factorial(int n) {\n    if (n < 0) return -1; // Negatif sayılar için geçersiz\n    if (n == 0) return 1; // 0! = 1\n    return n * factorial(n - 1); // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.628971"
  },
  {
    "question": "İkili ağaçta düğüm sayısını bulmak için yazdığım özyinelemeli fonksiyon doğru çalışmıyor. Sorun ne olabilir?",
    "answer": "Muhtemelen düğüm kontrolü yapmadan fonksiyonu çağırıyorsunuz. Düğüm boş ise 0 döndürmelisiniz. Düzeltmek için şu şekilde güncelleyin:\n\n```c\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nint countNodes(struct Node* node) {\n    if (node == NULL) return 0; // Düğüm boşsa 0 döndür\n    return 1 + countNodes(node->left) + countNodes(node->right); // Say\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.629021"
  },
  {
    "question": "Bir dizideki tüm alt dizilerin toplamını bulmaya çalışıyorum ama sonuçlar beklediğim gibi değil. Neden?",
    "answer": "Alt dizilerin toplamını hesaplarken dizinin her elemanını incelemeniz ve her alt dizi için toplamı çıkarmanız gerekiyor. Muhtemelen yanlış bir döngü kullanıyorsunuz. İşte bir düzeltme örneği:\n\n```c\nint sumSubarrays(int arr[], int n) {\n    if (n == 0) return 0; // Dizi boşsa 0 döndür\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for (int k = i; k <= j; k++) {\n                sum += arr[k]; // Alt dizinin toplamı\n            }\n        }\n    }\n    return sum;\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.629052"
  },
  {
    "question": "Bir dizideki belirli bir sayının kaç kere geçtiğini bulmak için özyinelemeli bir fonksiyon yazdım, ama her seferinde aynı değeri döndürüyor. Neden?",
    "answer": "Çıkış koşulunuz yanlış tanımlanmış olabilir. Dizi uzunluğu sıfır olduğunda 0 döndürmek gerekiyor. Düzeltmek için şu şekilde güncelleyebilirsiniz:\n\n```c\nint countOccurrences(int arr[], int n, int x) {\n    if (n <= 0) return 0; // Dizi boşsa 0 döndür\n    return (arr[n-1] == x ? 1 : 0) + countOccurrences(arr, n - 1, x); // Say\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.629092"
  },
  {
    "question": "Bir dizi içindeki elemanları sıralamak için yazdığım özyinelemeli fonksiyon çalışmıyor. Hatalı mı?",
    "answer": "Özyinelemeli sıralama için doğru algoritmayı kullanmanız lazım. Hangi algoritmayı kullandığınıza bağlı. Örneğin, merge sort kullanıyorsanız, birleşim aşamasını doğru yapmadıysanız sorun çıkabilir. İşte bir merge sort örneği:\n\n```c\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n    i = 0; j = 0; k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:46:58.629121"
  },
  {
    "question": "Özyinelemeli bir fonksiyon nedir ve neden kullanılır?",
    "answer": "Özyinelemeli bir fonksiyon, kendisini çağıran bir fonksiyondur. Genellikle, karmaşık görevleri daha basit alt görevlerine ayırmak için kullanılır. Bu, özellikle tekrar eden işlemlerin ve veri yapılarının (örneğin, ağaçlar veya listesel yapılar) yönetimi için yararlıdır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570186"
  },
  {
    "question": "Faktöriyel hesaplamak için özyinelemeli bir fonksiyon nasıl yazılır?",
    "answer": "Faktöriyel, n sayısının 1'den n'e kadar olan sayıların çarpımını temsil eder. Özyinelemeli bir fonksiyon şöyle yazılabilir: \n\n```c\nint faktoriyel(int n) {\n    if (n == 0) return 1;  // Taban durumu\n    return n * faktoriyel(n - 1);  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570229"
  },
  {
    "question": "Bir dizinin elemanlarını toplamak için özyineleme nasıl kullanılabilir?",
    "answer": "Dizinin elemanlarını toplamak için özyinelemeli bir fonksiyon yazabiliriz. Örneğin: \n\n```c\nint diziTopla(int dizi[], int boyut) {\n    if (boyut == 0) return 0;  // Taban durumu\n    return dizi[boyut - 1] + diziTopla(dizi, boyut - 1);  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570254"
  },
  {
    "question": "Bir Fibonacci dizisi elemanını özyineleme ile nasıl hesaplayabiliriz?",
    "answer": "Fibonacci dizisinde her sayı, önceki iki sayının toplamına eşittir. Özyinelemeli bir fonksiyon şöyle yazılabilir: \n\n```c\nint fibonacci(int n) {\n    if (n == 0) return 0;  // Taban durumu\n    if (n == 1) return 1;  // Taban durumu\n    return fibonacci(n - 1) + fibonacci(n - 2);  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570278"
  },
  {
    "question": "Bir metindeki karakterlerin sayısını özyineleme ile nasıl bulabiliriz?",
    "answer": "Bir metin dizisindeki karakterleri saymak için özyinelemeli bir fonksiyon şöyle yazılabilir: \n\n```c\nint karakterSay(char *metin) {\n    if (*metin == '\\0') return 0;  // Taban durumu\n    return 1 + karakterSay(metin + 1);  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570300"
  },
  {
    "question": "Özyineleme ile bir sayının tersini nasıl bulabiliriz?",
    "answer": "Bir sayının tersini bulmak için, sayının son basamağını alıp, geri kalan kısmın tersini hesaplayabiliriz. Özyinelemeli fonksiyon şöyle yazılır: \n\n```c\nint ters(int n, int tersSayisi) {\n    if (n == 0) return tersSayisi;  // Taban durumu\n    tersSayisi = tersSayisi * 10 + (n % 10);  // Son basamağı al\n    return ters(n / 10, tersSayisi);  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570321"
  },
  {
    "question": "Bir dizideki en büyük elemanı özyineleyerek nasıl bulabiliriz?",
    "answer": "Dizinin en büyük elemanını bulmak için özyinelemeli bir fonksiyon yazabiliriz: \n\n```c\nint enBuyuk(int dizi[], int boyut) {\n    if (boyut == 1) return dizi[0];  // Taban durumu\n    int max = enBuyuk(dizi, boyut - 1);  // Özyineleme\n    return (dizi[boyut - 1] > max) ? dizi[boyut - 1] : max;  // En büyük karşılaştırması\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570350"
  },
  {
    "question": "Özyineleme ile bir dizinin elemanlarını ters sırada yazdırabilir miyiz?",
    "answer": "Dizinin elemanlarını ters sırada yazdırmak için özyinelemeli bir fonksiyon şöyle yazılabilir: \n\n```c\nvoid tersYazdir(int dizi[], int boyut) {\n    if (boyut == 0) return;  // Taban durumu\n    tersYazdir(dizi, boyut - 1);  // Özyineleme\n    printf(\"%d \", dizi[boyut - 1]);  // Elemanı yazdır\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570373"
  },
  {
    "question": "Özyinelemeli bir algoritma kullanarak bir sayı dizisinin ortalamasını nasıl hesaplayabiliriz?",
    "answer": "Bir sayı dizisinin ortalamasını hesaplarken toplamı ve eleman sayısını özyinelemeli olarak bulabiliriz: \n\n```c\nfloat ortalama(int dizi[], int boyut) {\n    if (boyut == 0) return 0;  // Taban durumu\n    return (dizi[boyut - 1] + (ortalama(dizi, boyut - 1) * (boyut - 1))) / boyut;  // Özyineleme\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570399"
  },
  {
    "question": "Bir dizi üzerindeki tüm kombinasyonları bulmak için özyineleme nasıl kullanılabilir?",
    "answer": "Dizinin tüm kombinasyonlarını bulmak için bir özyineleme fonksiyonu yazabiliriz. Örneğin: \n\n```c\nvoid kombinasyon(int dizi[], int n, int k, int *sonuc, int index) {\n    if (k == 0) {\n        for (int i = 0; i < index; i++) printf(\"%d \", sonuc[i]);\n        printf(\"\\n\");\n        return;\n    }\n    for (int i = 0; i < n; i++) {\n        sonuc[index] = dizi[i];\n        kombinasyon(dizi + i + 1, n - i - 1, k - 1, sonuc, index + 1);  // Özyineleme\n    }\n}\n```",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:47:54.570425"
  },
  {
    "question": "Özyinelemeli bir fonksiyon ile faktöriyel hesaplamanın nasıl yapıldığını açıkla.",
    "answer": "Faktöriyel, bir sayının pozitif tam sayı olarak çarpanları ile çarpılmasıdır. Özyinelemeli bir fonksiyon ile hesaplamak için, n! = n * (n-1)! formülü kullanılır. Bu durumda, temel durum n = 0 veya n = 1 olduğunda 1 döndürülür. Örneğin:\n\n```c\nint faktoriyel(int n) {\n    if (n <= 1) return 1; // Temel durum\n    return n * faktoriyel(n - 1); // Özyineleme\n}\n```\nBu fonksiyon, n'in değerine göre kendisini çağırarak sonucu hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.138837"
  },
  {
    "question": "Özyineleme kullanarak Fibonacci dizisini hesaplayan bir fonksiyon yaz.",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Özyinelemeli bir fonksiyon ile hesaplamak için:\n\n```c\nint fibonacci(int n) {\n    if (n <= 0) return 0;     // Temel durum\n    if (n == 1) return 1;     // Temel durum\n    return fibonacci(n - 1) + fibonacci(n - 2); // Özyineleme\n}\n```\nBu fonksiyon, n için Fibonacci sayısını hesaplar ve kendisini iki kez çağırarak önceki iki Fibonacci sayısını toplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.138898"
  },
  {
    "question": "Bir dizideki elemanların toplamını özyinelemeli bir fonksiyon ile nasıl hesaplayabiliriz?",
    "answer": "Dizinin toplamını hesaplamak için, dizinin ilk elemanını alıp geri kalan elemanların toplamını kendisi ile toplamak yeterlidir. Özyinelemeli bir fonksiyon örneği:\n\n```c\nint diziToplam(int dizi[], int boyut) {\n    if (boyut == 0) return 0; // Temel durum\n    return dizi[0] + diziToplam(dizi + 1, boyut - 1); // Özyineleme\n}\n```\nBurada, dizinin ilk elemanını topladıktan sonra, kalan elemanlar üzerinde aynı fonksiyon çağrılır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.138955"
  },
  {
    "question": "Bir string içindeki karakterlerin tersine çevrilmesi için özyinelemeli bir fonksiyon yaz.",
    "answer": "Bir stringin tersini almak için, ilk karakteri alıp geri kalan karakterlerin tersini hesaplayarak birleştirebiliriz. Özyinelemeli fonksiyon:\n\n```c\n#include <string.h>\n\nvoid tersCevir(char *str) {\n    int uzunluk = strlen(str);\n    if (uzunluk == 0) return; // Temel durum\n    printf(\"%c\", str[uzunluk - 1]); // Son karakteri yazdır\n    str[uzunluk - 1] = '\\0'; // Son karakteri null yap\n    tersCevir(str); // Özyineleme\n}\n```\nBu fonksiyon, stringin son karakterini yazdırır ve ardından kendisini çağırarak stringin geri kalanını ters çevirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139000"
  },
  {
    "question": "Bir sayının 2 tabanındaki karşılığını özyinelemeli olarak nasıl hesaplayabiliriz?",
    "answer": "Bir sayının ikilik tabanındaki temsilini bulmak için, sayıyı 2'ye bölebilir ve kalanı kullanarak özyinelemeli bir şekilde çalışabiliriz. Örneğin:\n\n```c\nvoid ikiliYaz(int n) {\n    if (n == 0) return; // Temel durum\n    ikiliYaz(n / 2); // Özyineleme\n    printf(\"%d\", n % 2); // Kalanı yazdır\n}\n```\nBu fonksiyon, sayıyı 2'ye bölerek kalanı bulur ve bunu yazdırmak için özyineleme uygulayarak en son basamaktan başlayarak çalışır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139044"
  },
  {
    "question": "Özyineleme kullanarak bir dizideki en büyük elemanı nasıl bulabiliriz?",
    "answer": "Dizinin en büyük elemanını bulmak için, ilk elemanı alıp geri kalan elemanlar arasındaki en büyük değeri bulmak yeterlidir. Özyinelemeli örnek:\n\n```c\nint enBuyuk(int dizi[], int boyut) {\n    if (boyut == 1) return dizi[0]; // Temel durum\n    int max = enBuyuk(dizi + 1, boyut - 1); // Özyineleme\n    return (dizi[0] > max) ? dizi[0] : max; // Karşılaştırma\n}\n```\nBu fonksiyon, dizinin ilk elemanını kontrol eder ve geri kalan elemanlar arasındaki en büyük değeri döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139085"
  },
  {
    "question": "Bir binary tree'de özyineleme ile dolaşma (in-order traversal) nasıl yapılır?",
    "answer": "Binary tree'de in-order traversal, önce sol alt ağacı, ardından kök düğümü ve en son sağ alt ağacı ziyaret etmek anlamına gelir. Özyinelemeli bir fonksiyon:\n\n```c\nstruct Dugum {\n    int veri;\n    struct Dugum *sol;\n    struct Dugum *sag;\n};\n\nvoid inOrder(struct Dugum *dugum) {\n    if (dugum != NULL) {\n        inOrder(dugum->sol); // Sol alt ağaç\n        printf(\"%d \", dugum->veri); // Kök düğüm\n        inOrder(dugum->sag); // Sağ alt ağaç\n    }\n}\n```\nBu fonksiyon, her düğüm için sol çocuk, kök ve sağ çocuk sırayla ziyaret edilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139134"
  },
  {
    "question": "Bir sayının n'inci kuvvetini özyinelemeli olarak nasıl hesaplayabiliriz?",
    "answer": "Bir sayının n'inci kuvvetini hesaplamak için, a^n = a * a^(n-1) formülünü kullanabiliriz. Özyinelemeli bir fonksiyon:\n\n```c\ndouble kuvvet(double a, int n) {\n    if (n == 0) return 1; // Temel durum\n    if (n < 0) return 1 / kuvvet(a, -n); // Negatif kuvvet için\n    return a * kuvvet(a, n - 1); // Özyineleme\n}\n```\nBu fonksiyon, eğer n pozitif ise a'yı kendisi ile çarpar, eğer n negatif ise tersini alır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139174"
  },
  {
    "question": "Bir tamsayı dizisini özyinelemeli olarak sıralamak için nasıl bir yaklaşım kullanabiliriz?",
    "answer": "Özyinelemeli olarak sıralama yapmak için, hızlı sıralama (quicksort) algoritmasını kullanabiliriz. Dizi üzerinde özyineleme ile işlem yapmak için:\n\n```c\nvoid quicksort(int dizi[], int sol, int sag) {\n    if (sol < sag) {\n        int pivot = dizi[sag];\n        int i = sol - 1;\n        for (int j = sol; j < sag; j++) {\n            if (dizi[j] < pivot) {\n                i++;\n                int temp = dizi[i];\n                dizi[i] = dizi[j];\n                dizi[j] = temp;\n            }\n        }\n        int temp = dizi[i + 1];\n        dizi[i + 1] = dizi[sag];\n        dizi[sag] = temp;\n        quicksort(dizi, sol, i);\n        quicksort(dizi, i + 2, sag);\n    }\n}\n```\nBu fonksiyon, dizi üzerinde pivot alarak elemanları karşılaştırır ve sıralama işlemini özyineleme ile devam ettirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139220"
  },
  {
    "question": "Bir sayı dizisindeki en küçük tam sayıyı özyinelemeli bir fonksiyon ile nasıl bulabiliriz?",
    "answer": "Dizinin en küçük elemanını bulmak için, ilk elemanı alıp geri kalan elemanlar arasındaki en küçük değeri bulmak yeterlidir. Özyinelemeli örnek:\n\n```c\nint enKucuk(int dizi[], int boyut) {\n    if (boyut == 1) return dizi[0]; // Temel durum\n    int min = enKucuk(dizi + 1, boyut - 1); // Özyineleme\n    return (dizi[0] < min) ? dizi[0] : min; // Karşılaştırma\n}\n```\nBu fonksiyon, dizinin ilk elemanını kontrol eder ve geri kalan elemanlar arasındaki en küçük değeri döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:48:34.139268"
  },
  {
    "question": "Fibonacci sayılarını özyinelemeli bir fonksiyon kullanarak nasıl hesaplayabilirim?",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Özyinelemeli bir fonksiyon kullanarak Fibonacci sayısını hesaplamak için, n'in 0 veya 1 olduğu durumları baz durumları olarak tanımlayabiliriz. Bu durumda, fonksiyon n'e ulaşmak için kendisini çağırarak n-1 ve n-2 ile hesaplama yapar.\n\n```c\nint fibonacci(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\nBu fonksiyon, n'in değeri küçük olduğunda verimli çalışır fakat büyük n değerleri için işlem süresi uzun olacaktır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253044"
  },
  {
    "question": "Bir dizinin elemanlarını tersine çevirmek için özyinelemeli bir fonksiyon nasıl yazılır?",
    "answer": "Bir dizinin elemanlarını tersine çevirmek için özyinelemeli bir fonksiyon yazmak, dizinin ilk elemanını alıp geri kalanını ters çevirip sonrasında ilk elemanı eklemekle mümkündür. Fonksiyon, dizinin boyutu 0'a ulaştığında baz durumuna geçer.\n\n```c\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}\n```\nBu yöntem, dizinin elemanlarını yerinde değiştirerek tersine çevirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253087"
  },
  {
    "question": "Bir sayının faktöriyelini özyinelemeli bir fonksiyonla nasıl hesaplayabilirim?",
    "answer": "Faktöriyel, n! ifadesiyle gösterilir ve n pozitif bir tamsayı olduğunda, n! = n * (n-1)! şeklinde tanımlanır. Baz durumumuz 0! = 1 olmalıdır. Özyinelemeli bir fonksiyon yazmak için şu şekilde ilerleyebiliriz:\n\n```c\nint factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n```\nBu fonksiyon, n'in değerine göre kendisini tekrar çağırarak faktöriyel hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253112"
  },
  {
    "question": "Özyineleme kullanarak bir stringin palindrom olup olmadığını nasıl kontrol edebilirim?",
    "answer": "Bir stringin palindrom olup olmadığını kontrol etmek için, stringin başındaki ve sonundaki karakterlerin eşit olup olmadığını kontrol ederiz. Eğer eşitse, stringin geri kalan kısmını kontrol etmek için özyinelemeli bir fonksiyon çağırabiliriz. Baz durumunda stringin uzunluğu 0 veya 1 olduğunda palindrom olarak kabul edebiliriz.\n\n```c\nint isPalindrome(char *str, int start, int end) {\n    if (start >= end) return 1;\n    if (str[start] != str[end]) return 0;\n    return isPalindrome(str, start + 1, end - 1);\n}\n```\nBu fonksiyon, stringin palindrom olup olmadığını döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253139"
  },
  {
    "question": "Özyinelemeli bir fonksiyonla bir ağacın düğüm sayısını nasıl bulabilirim?",
    "answer": "Bir ikili ağacın düğüm sayısını bulmak için, her düğümün sol ve sağ alt ağaçlarının düğüm sayısını toplarız. Baz durumumuz, düğüm NULL olduğunda 0 döndürmektir. Aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nint countNodes(struct Node *node) {\n    if (node == NULL) return 0;\n    return 1 + countNodes(node->left) + countNodes(node->right);\n}\n```\nBu fonksiyon, ağacın tüm düğümlerini sayarak geri döner.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253163"
  },
  {
    "question": "Bir tam sayının basamak toplamını özyinelemeli bir fonksiyonla nasıl hesaplayabilirim?",
    "answer": "Bir tam sayının basamak toplamını bulmak için, sayının son basamağını alır ve sayıyı 10'a böleriz. Baz durumumuz, sayının 0 olduğunda toplamın 0 olduğudur. Fonksiyonu aşağıdaki gibi tanımlayabiliriz:\n\n```c\nint sumOfDigits(int n) {\n    if (n == 0) return 0;\n    return n % 10 + sumOfDigits(n / 10);\n}\n```\nBu fonksiyon, sayının tüm basamaklarını toplar ve sonucu döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253188"
  },
  {
    "question": "Bir dizideki en büyük sayıyı özyinelemeli bir fonksiyon kullanarak nasıl bulabilirim?",
    "answer": "Bir dizideki en büyük sayıyı bulmak için, dizinin ilk elemanını en büyük sayı olarak alır ve geri kalan elemanlarla karşılaştırarak en büyük olanı buluruz. Baz durumumuz, dizinin boyutunun 1 olduğudur. Fonksiyon şu şekilde yazılabilir:\n\n```c\nint findMax(int arr[], int n) {\n    if (n == 1) return arr[0];\n    int max = findMax(arr, n - 1);\n    return (arr[n - 1] > max) ? arr[n - 1] : max;\n}\n```\nBu fonksiyon, dizinin en büyük elemanını döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253213"
  },
  {
    "question": "Özyineleme kullanarak bir dizinin toplamını nasıl hesaplayabilirim?",
    "answer": "Bir dizinin toplamını bulmak için ilk elemanı alır ve geri kalan elemanların toplamıyla toplarız. Baz durumumuz, dizinin boyutunun 0 olmasıdır. Fonksiyon aşağıdaki gibi yazılabilir:\n\n```c\nint sumArray(int arr[], int n) {\n    if (n <= 0) return 0;\n    return arr[n - 1] + sumArray(arr, n - 1);\n}\n```\nBu fonksiyon, dizinin tüm elemanlarının toplamını döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253235"
  },
  {
    "question": "Bir dizideki elemanların kombinasyonlarını özyinelemeli bir fonksiyon ile nasıl yazabilirim?",
    "answer": "Dizinin elemanlarının kombinasyonlarını bulmak için, her elemanı bir kombinasyona ekleyip geri kalan elemanlarla özyinelemeli bir şekilde işlem yapabiliriz. Baz durumumuz, kombinasyonun tamamlandığı durumu temsil eder. Aşağıdaki gibi bir fonksiyon yazılabilir:\n\n```c\nvoid combine(char *arr, int start, int n, int r, char *result, int index) {\n    if (index == r) {\n        for (int i = 0; i < r; i++)\n            printf(\"%c \", result[i]);\n        printf(\"\\n\");\n        return;\n    }\n    for (int i = start; i <= n - 1 && n - i + 1 >= r - index; i++) {\n        result[index] = arr[i];\n        combine(arr, i + 1, n, r, result, index + 1);\n    }\n}\n```\nBu fonksiyon, dizideki tüm kombinasyonları yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253260"
  },
  {
    "question": "Bir dizinin elemanlarını özyinelemeli olarak sıralamak için nasıl bir fonksiyon yazabilirim?",
    "answer": "Dizinin elemanlarını özyinelemeli olarak sıralamak için quicksort algoritmasını kullanabiliriz. Baz durumumuz, dizinin boyutunun 1 veya 0 olduğudur. Aşağıda temel bir quicksort uygulaması gösterilmektedir:\n\n```c\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pivotIndex = partition(arr, low, high);\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n}\n```\nPartition fonksiyonu, dizinin pivotunu seçerek elemanları ona göre sıralar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:06.253285"
  },
  {
    "question": "Fibonacci sayılarının ninci terimini hesaplayan bir özyinelemeli fonksiyon yaz.",
    "answer": "Fibonacci sayıları, her sayının kendisinden önceki iki sayının toplamı olduğu bir seridir. Özyinelemeli bir fonksiyon yazarak bu serinin n'inci terimini hesaplayabiliriz:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) return n;  // Temel durum: fibonacci(0) = 0, fibonacci(1) = 1\n    return fibonacci(n - 1) + fibonacci(n - 2);  // Özyineleme\n}\n\nint main() {\n    int n = 5;  // Örnek: 5. Fibonacci sayısını bulalım\n    printf(\"%d. Fibonacci sayısı: %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```\nBu fonksiyon, n <= 1 koşuluyla temel durumu tanımlar ve diğer durumlarda özyinelemeli olarak kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345789"
  },
  {
    "question": "Bir sayı dizisinin toplamını hesaplayan özyinelemeli bir fonksiyon yaz.",
    "answer": "Bir dizi elemanlarının toplamını hesaplamak için özyinelemeli bir yöntem kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint sumArray(int arr[], int size) {\n    if (size <= 0) return 0;  // Temel durum: dizi boşsa toplam 0\n    return arr[size - 1] + sumArray(arr, size - 1);  // Son elemanı al ve geri kalanını topla\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin toplamı: %d\\n\", sumArray(arr, size));\n    return 0;\n}\n```\nBu fonksiyon, dizinin son elemanını alır ve geriye kalan elemanların toplamını hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345830"
  },
  {
    "question": "Bir pozitif tam sayının faktöriyelini hesaplayan bir özyinelemeli fonksiyon yaz.",
    "answer": "Faktöriyel, pozitif bir tam sayının kendisi dahil 1’e kadar olan tüm pozitif tam sayıların çarpımını ifade eder. Aşağıda özyinelemeli bir faktöriyel hesaplama fonksiyonu verilmiştir:\n\n```c\n#include <stdio.h>\n\nint factorial(int n) {\n    if (n == 0 || n == 1) return 1;  // Temel durum: 0! = 1 ve 1! = 1\n    return n * factorial(n - 1);  // Özyineleme\n}\n\nint main() {\n    int n = 5;  // Örnek: 5! hesaplayalım\n    printf(\"%d! = %d\\n\", n, factorial(n));\n    return 0;\n}\n```\nBu fonksiyon, n’in faktöriyelini hesaplamak için kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345856"
  },
  {
    "question": "Bir tam sayının tersini (yani, basamaklarını ters çeviren) hesaplayan bir özyinelemeli fonksiyon yaz.",
    "answer": "Bir tam sayıyı ters çevirmek için, her basamağı almak ve geri çağırarak birleştirmek mümkündür:\n\n```c\n#include <stdio.h>\n\nint reverseNumber(int n) {\n    static int reversed = 0;  // Statik değişken, her çağrıda değerini korur\n    if (n == 0) return reversed;  // Temel durum\n    reversed = reversed * 10 + n % 10;  // Son basamağı al\n    return reverseNumber(n / 10);  // Özyineleme\n}\n\nint main() {\n    int n = 12345;  // Örnek: 12345 sayısını ters çevirelim\n    printf(\"Ters çevrilmiş sayı: %d\\n\", reverseNumber(n));\n    return 0;\n}\n```\nBu fonksiyon, her çağrıda son basamağı alır ve geri kalan sayıyı ters çevirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345891"
  },
  {
    "question": "Bir dizinin en büyük elemanını bulmak için özyinelemeli bir fonksiyon yaz.",
    "answer": "Bir dizi içindeki en büyük elemanı bulmak için özyinelemeli bir yöntem kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint maxArray(int arr[], int size) {\n    if (size == 1) return arr[0];  // Temel durum: sadece bir eleman var\n    int maxOfRest = maxArray(arr, size - 1);  // Geriye kalanını bul\n    return (arr[size - 1] > maxOfRest) ? arr[size - 1] : maxOfRest;  // En büyük olanı döndür\n}\n\nint main() {\n    int arr[] = {3, 1, 4, 1, 5, 9};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin en büyük elemanı: %d\\n\", maxArray(arr, size));\n    return 0;\n}\n```\nBu fonksiyon, dizinin son elemanını ve geri kalanını karşılaştırarak en büyük elemanı döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345915"
  },
  {
    "question": "Bir sayıyı belirtilen basamak sayısına göre 10 tabanına göre üslü hale getiren bir özyinelemeli fonksiyon yaz.",
    "answer": "Bir sayının üslü değerini hesaplamak için özyinelemeli bir fonksiyon yazılabilir:\n\n```c\n#include <stdio.h>\n\nint power(int base, int exp) {\n    if (exp == 0) return 1;  // Temel durum: her sayının 0. kuvveti 1'dir\n    return base * power(base, exp - 1);  // Özyineleme\n}\n\nint main() {\n    int base = 2, exp = 3;  // Örnek: 2^3 hesaplayalım\n    printf(\"%d^%d = %d\\n\", base, exp, power(base, exp));\n    return 0;\n}\n```\nBu fonksiyon, belirtilen tabanı belirtilen üst ile çarparak sonuca ulaşır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345948"
  },
  {
    "question": "Bir dizideki elemanları tersine döndüren özyinelemeli bir fonksiyon yaz.",
    "answer": "Bir dizinin elemanlarını özyinelemeli olarak tersine döndürmek için aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) return;  // Temel durum: başlangıç, sonu geçerse dur\n    // Elemanları yer değiştir\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);  // Özyineleme\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, 0, size - 1);\n    printf(\"Ters çevrilmiş dizi: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, dizinin başlangıç ve son elemanlarını değiştirerek tersine döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345971"
  },
  {
    "question": "Bir stringin uzunluğunu hesaplayan özyinelemeli bir fonksiyon yaz.",
    "answer": "Bir stringin uzunluğunu bulmak için özyinelemeli bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n\nint stringLength(const char *str) {\n    if (*str == '\\0') return 0;  // Temel durum: stringin sonu\n    return 1 + stringLength(str + 1);  // Özyineleme\n}\n\nint main() {\n    const char *str = \"Merhaba!\";  // Örnek string\n    printf(\"Stringin uzunluğu: %d\\n\", stringLength(str));\n    return 0;\n}\n```\nBu fonksiyon, her çağrıda bir karakter atlayarak toplam uzunluğu hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.345992"
  },
  {
    "question": "Bir sayının n’inci kuvvetini özyinelemeli bir şekilde hesaplayan bir fonksiyon yaz.",
    "answer": "Bir sayının n’inci kuvvetini hesaplamak için özyinelemeli bir yöntem kullanılabilir:\n\n```c\n#include <stdio.h>\n\nint power(int base, int exp) {\n    if (exp == 0) return 1;  // Temel durum: her sayının 0. kuvveti 1\n    return base * power(base, exp - 1);  // Özyineleme\n}\n\nint main() {\n    int base = 3, exp = 4;  // Örnek: 3^4 hesaplayalım\n    printf(\"%d^%d = %d\\n\", base, exp, power(base, exp));\n    return 0;\n}\n```\nBu fonksiyon, temel duruma ulaşana kadar kendisini çağırır ve her adımda sayıyı çarparak sonucu bulur.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:49:41.346019"
  },
  {
    "question": "Fibonacci sayılarının n'inci terimini hesaplayan bir özyinelemeli fonksiyon yazın.",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Özyinelemeli bir fonksiyonla, n'inci Fibonacci sayısını şu şekilde hesaplayabiliriz:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) return n; // 0 ve 1 için doğrudan dön\n    return fibonacci(n - 1) + fibonacci(n - 2); // Özyineleme\n}\n\nint main() {\n    int n = 5;\n    printf(\"Fibonacci(%d) = %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```\nBu fonksiyon, n'inci Fibonacci sayısını bulmak için kendisini iki kez çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834154"
  },
  {
    "question": "Bir sayının faktöriyelini hesaplamak için özyinelemeli bir fonksiyon yazın.",
    "answer": "Faktöriyel, pozitif bir tam sayının 1'den n'e kadar olan tüm sayıların çarpımıdır. Özyinelemeli bir şekilde hesaplamak için:\n\n```c\n#include <stdio.h>\n\nint faktoriyel(int n) {\n    if (n <= 1) return 1; // 0 ve 1 için faktöriyel 1'dir\n    return n * faktoriyel(n - 1); // Özyineleme\n}\n\nint main() {\n    int n = 5;\n    printf(\"Faktöriyel(%d) = %d\\n\", n, faktoriyel(n));\n    return 0;\n}\n```\nBu fonksiyon, n'inci sayının faktöriyelini hesaplarken kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834215"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını bulan özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir dizinin toplamını bulmak için dizinin elemanlarını özyineleme ile toplamak mümkündür:\n\n```c\n#include <stdio.h>\n\nint diziToplam(int dizi[], int n) {\n    if (n <= 0) return 0; // Dizi boşsa toplam 0'dır\n    return dizi[n - 1] + diziToplam(dizi, n - 1); // Özyineleme\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizi toplamı = %d\\n\", diziToplam(dizi, boyut));\n    return 0;\n}\n```\nBurada fonksiyon, dizinin son elemanını alır ve geri kalan elemanların toplamını bulmak için kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834256"
  },
  {
    "question": "Verilen bir sayının tersini hesaplayan özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir sayının tersini bulmak için sayıyı özyinelemeli olarak işlem yapabiliriz:\n\n```c\n#include <stdio.h>\n\nint ters(int n, int tersSonucu) {\n    if (n == 0) return tersSonucu; // Tüm rakamlar tersine çevrildiğinde\n    tersSonucu = tersSonucu * 10 + n % 10; // Sonraki rakamı ekle\n    return ters(n / 10, tersSonucu); // Özyineleme\n}\n\nint main() {\n    int n = 12345;\n    printf(\"Ters = %d\\n\", ters(n, 0));\n    return 0;\n}\n```\nBu fonksiyon, sayının her basamağını alır ve tersini oluşturur.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834298"
  },
  {
    "question": "Bir dizideki en büyük elemanı bulan özyinelemeli bir fonksiyon yazın.",
    "answer": "Dizideki en büyük elemanı bulmak için özyineleme ile karşılaştırma yapabiliriz:\n\n```c\n#include <stdio.h>\n\nint enBuyuk(int dizi[], int n) {\n    if (n == 1) return dizi[0]; // Tek eleman kalırsa, o en büyüktür\n    int max = enBuyuk(dizi, n - 1); // Geriye kalan elemanları kontrol et\n    return (dizi[n - 1] > max) ? dizi[n - 1] : max; // En büyük olanı döndür\n}\n\nint main() {\n    int dizi[] = {3, 5, 7, 2, 8};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    printf(\"Dizideki en büyük eleman = %d\\n\", enBuyuk(dizi, boyut));\n    return 0;\n}\n```\nFonksiyon, dizinin son elemanıyla geri kalanını kontrol eder ve en büyük değeri döndürür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834340"
  },
  {
    "question": "Bir kelimenin palindrom olup olmadığını kontrol eden özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir kelime palindrom ise, baştan sona ve sondan başa okunuşu aynıdır. Özyineleme ile kontrol etmek için:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint palindrom(char *kelime, int bas, int son) {\n    if (bas >= son) return 1; // Tüm karşılaştırmalar tamamlandığında\n    if (kelime[bas] != kelime[son]) return 0; // Farklı karakterler\n    return palindrom(kelime, bas + 1, son - 1); // Özyineleme\n}\n\nint main() {\n    char kelime[] = \"radar\";\n    int uzunluk = strlen(kelime);\n    if (palindrom(kelime, 0, uzunluk - 1))\n        printf(\"'%s' bir palindromdur.\\n\", kelime);\n    else\n        printf(\"'%s' bir palindrom değildir.\\n\", kelime);\n    return 0;\n}\n```\nBu fonksiyon, kelimenin başından ve sonundan başlayarak kontrol eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834385"
  },
  {
    "question": "Bir sayının pozitif olup olmadığını kontrol eden özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir sayının pozitif olup olmadığını kontrol etmek için:\n\n```c\n#include <stdio.h>\n\nint pozitifMi(int n) {\n    if (n > 0) return 1; // Pozitif\n    if (n == 0) return 0; // Sıfır\n    return pozitifMi(n + 1); // Negatif sayılar için özyineleme\n}\n\nint main() {\n    int n = -5;\n    if (pozitifMi(n))\n        printf(\"%d pozitif bir sayıdır.\\n\", n);\n    else\n        printf(\"%d pozitif bir sayı değildir.\\n\", n);\n    return 0;\n}\n```\nBu fonksiyon, sayıyı pozitif hale getirene kadar kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834429"
  },
  {
    "question": "Bir pozitif tam sayının 2'nin kuvveti olup olmadığını kontrol eden özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir sayının 2'nin kuvveti olup olmadığını kontrol etmek için:\n\n```c\n#include <stdio.h>\n\nint ikiKuvvetiMi(int n) {\n    if (n < 1) return 0; // 0 ve negatif sayılar değil\n    if (n == 1) return 1; // 2^0 = 1\n    return (n % 2 == 0) ? ikiKuvvetiMi(n / 2) : 0; // Özyineleme\n}\n\nint main() {\n    int n = 16;\n    if (ikiKuvvetiMi(n))\n        printf(\"%d bir 2'nin kuvvetidir.\\n\", n);\n    else\n        printf(\"%d bir 2'nin kuvveti değildir.\\n\", n);\n    return 0;\n}\n```\nBu fonksiyon, sayıyı 2'ye bölerek kontrol eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834482"
  },
  {
    "question": "Bir dizinin elemanlarını ters çeviren özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir diziyi ters çevirmek için:\n\n```c\n#include <stdio.h>\n\nvoid diziTersCevir(int dizi[], int bas, int son) {\n    if (bas >= son) return; // Tüm elemanlar yer değiştirdiğinde çık\n    int temp = dizi[bas];\n    dizi[bas] = dizi[son];\n    dizi[son] = temp; // Elemanları yer değiştir\n    diziTersCevir(dizi, bas + 1, son - 1); // Özyineleme\n}\n\nint main() {\n    int dizi[] = {1, 2, 3, 4, 5};\n    int boyut = sizeof(dizi) / sizeof(dizi[0]);\n    diziTersCevir(dizi, 0, boyut - 1);\n    printf(\"Ters çevrilmiş dizi: \\\n\");\n    for (int i = 0; i < boyut; i++) {\n        printf(\"%d \", dizi[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, dizinin baş ve son elemanlarını yer değiştirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:50:38.834538"
  },
  {
    "question": "Fibonacci dizisinin n'inci terimini özyinelemeli bir fonksiyonla hesaplayın.",
    "answer": "Fibonacci dizisi, her sayının kendisinden önceki iki sayının toplamı olduğu bir dizidir. Özyinelemeli bir fonksiyon kullanarak Fibonacci dizisini hesaplamak için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n = 10;\n    printf(\"Fibonacci dizisinin %d. terimi: %d\\n\", n, fibonacci(n));\n    return 0;\n}\n```\nBu fonksiyon, n'inci Fibonacci terimini bulmak için n'in 0 veya 1 olması durumunda doğrudan döndürür, aksi takdirde özyinelemeli çağrılarla hesaplama yapar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427318"
  },
  {
    "question": "Verilen bir sayının faktöriyelini özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "Faktöriyel, pozitif bir tam sayının kendisi de dahil olmak üzere tüm pozitif tam sayıların çarpımıdır. Özyinelemeli bir faktöriyel hesaplamak için aşağıdaki fonksiyonu kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int n = 5;\n    printf(\"%d! = %d\\n\", n, factorial(n));\n    return 0;\n}\n```\nBu fonksiyon, n'in 0 olması durumunda 1 döndürerek durur; diğer durumlarda n faktöriyelini hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427360"
  },
  {
    "question": "Bir dizideki elemanların toplamını özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "Bir dizinin toplamını hesaplamak için özyineleme kullanabiliriz. Aşağıdaki örnekte, bir dizinin toplamını bulmak için bir fonksiyon yazıyoruz:\n\n```c\n#include <stdio.h>\n\nint sum(int arr[], int n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return arr[n - 1] + sum(arr, n - 1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizinin toplamı: %d\\n\", sum(arr, n));\n    return 0;\n}\n```\nBu fonksiyon, dizinin son elemanını toplar ve kalan elemanların toplamını bulmak için özyinelemeli olarak kendisini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427386"
  },
  {
    "question": "Bir dizideki en büyük sayıyı özyinelemeli bir fonksiyon ile bulun.",
    "answer": "Özyinelemeli bir fonksiyon ile dizideki en büyük sayıyı bulmak için aşağıdaki kodu kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nint max(int arr[], int n) {\n    if (n == 1) {\n        return arr[0];\n    }\n    int max_of_rest = max(arr, n - 1);\n    return (arr[n - 1] > max_of_rest) ? arr[n - 1] : max_of_rest;\n}\n\nint main() {\n    int arr[] = {3, 5, 2, 9, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Dizideki en büyük sayı: %d\\n\", max(arr, n));\n    return 0;\n}\n```\nBu fonksiyon, dizinin son elemanını kontrol eder ve geri kalan elemanlarla karşılaştırarak en büyük sayıyı bulur.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427410"
  },
  {
    "question": "Bir karakter dizisinde palindrom olup olmadığını özyinelemeli bir fonksiyon ile kontrol edin.",
    "answer": "Bir palindrom, tersten okununca da aynı olan bir dizidir. Özyinelemeli bir fonksiyon kullanarak bunu kontrol edebiliriz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char str[], int start, int end) {\n    if (start >= end) {\n        return 1;\n    }\n    if (str[start] != str[end]) {\n        return 0;\n    }\n    return isPalindrome(str, start + 1, end - 1);\n}\n\nint main() {\n    char str[] = \"radar\";\n    int length = strlen(str);\n    if (isPalindrome(str, 0, length - 1)) {\n        printf(\"'%s' bir palindromdur.\\n\", str);\n    } else {\n        printf(\"'%s' bir palindrom değildir.\\n\", str);\n    }\n    return 0;\n}\n```\nBu fonksiyon, dizinin başındaki ve sonundaki karakterleri karşılaştırarak özyinelemeli olarak kontrol eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427437"
  },
  {
    "question": "Bir sayının 2'lik tabanda ikili gösterimini özyinelemeli bir fonksiyon ile yazdırın.",
    "answer": "Bir sayının ikili gösterimini hesaplamak için aşağıdaki özyinelemeli fonksiyonu kullanabiliriz:\n\n```c\n#include <stdio.h>\n\nvoid printBinary(int n) {\n    if (n > 1) {\n        printBinary(n / 2);\n    }\n    printf(\"%d\", n % 2);\n}\n\nint main() {\n    int n = 10;\n    printf(\"%d sayısının ikili gösterimi: \", n);\n    printBinary(n);\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, sayıyı 2'ye bölerek sonuçları geri döndürür ve sonrasında kalanları yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427464"
  },
  {
    "question": "Verilen bir pozitif tamsayı için tüm bölenleri özyinelemeli bir fonksiyon ile bulun.",
    "answer": "Özyinelemeli olarak bir sayının bölenlerini bulmak için aşağıdaki fonksiyonu yazabiliriz:\n\n```c\n#include <stdio.h>\n\nvoid findDivisors(int n, int i) {\n    if (i > n) {\n        return;\n    }\n    if (n % i == 0) {\n        printf(\"%d \\n\", i);\n    }\n    findDivisors(n, i + 1);\n}\n\nint main() {\n    int n = 12;\n    printf(\"%d sayısının bölenleri: \\n\", n);\n    findDivisors(n, 1);\n    return 0;\n}\n```\nBu fonksiyon, 1'den başlayarak sayının bölenlerini kontrol eder ve bulduğu bölenleri yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427490"
  },
  {
    "question": "Bir dizinin elemanlarını tersine çevirmek için özyinelemeli bir fonksiyon yazın.",
    "answer": "Bir diziyi tersine çevirmek için aşağıdaki özyinelemeli fonksiyonu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) {\n        return;\n    }\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    reverseArray(arr, 0, n - 1);\n    printf(\"Tersine çevrilmiş dizi: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu fonksiyon, başlangıç ve son indekslerini karşılaştırarak elemanları yer değiştirir ve diziyi tersine çevirir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427543"
  },
  {
    "question": "Bir sayının basamak toplamını özyinelemeli bir fonksiyon ile hesaplayın.",
    "answer": "Bir sayının basamak toplamını bulmak için özyinelemeli bir fonksiyon aşağıdaki gibi yazılabilir:\n\n```c\n#include <stdio.h>\n\nint digitSum(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    return (n % 10) + digitSum(n / 10);\n}\n\nint main() {\n    int n = 12345;\n    printf(\"%d sayısının basamak toplamı: %d\\n\", n, digitSum(n));\n    return 0;\n}\n```\nBu fonksiyon, sayının son basamağını toplar ve kalan sayıyı özyinelemeli olarak kontrol eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:51:22.427575"
  },
  {
    "question": "Bir dizideki en büyük sayıyı bulmak için özyinelemeli bir fonksiyon yazın. Ancak, bu fonksiyonu optimize etmek için dizinin uzunluğunu parametre olarak geçin.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nint findMax(int arr[], int n) {\n    if (n == 1) {\n        return arr[0];\n    }\n    int maxOfRest = findMax(arr, n - 1);\n    return (arr[n - 1] > maxOfRest) ? arr[n - 1] : maxOfRest;\n}\n```\n\nBu fonksiyon, dizinin son elemanını kontrol ederek kendisini çağırır. Ancak, tekrar eden hesaplamalardan kaçınmak için dizinin uzunluğunu parametre olarak alması önemlidir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207209"
  },
  {
    "question": "Fibonacci sayılarını özyinelemeli olarak hesaplayan bir fonksiyon yazın. Ancak, performansı artırmak için 'memoizasyon' yöntemini kullanın.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint fib(int n, int memo[]) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n];\n    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);\n    return memo[n];\n}\n\nint main() {\n    int n = 10;\n    int memo[n + 1];\n    for (int i = 0; i <= n; i++) memo[i] = -1;\n    printf(\"Fibonacci %d: %d\\n\", n, fib(n, memo));\n    return 0;\n}\n```\n\nBu yöntem, daha önce hesaplanan Fibonacci değerlerini saklayarak tekrar hesaplamalardan kaçınır ve performansı önemli ölçüde artırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207263"
  },
  {
    "question": "Bir dizinin elemanlarının toplamını bulmak için özyinelemeli bir fonksiyon yazın. Ancak, bu fonksiyonu yazarken gereksiz hesaplamalardan kaçının.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nint sumArray(int arr[], int n) {\n    if (n <= 0) return 0;\n    return arr[n - 1] + sumArray(arr, n - 1);\n}\n```\n\nBu fonksiyon, dizinin son elemanından başlayarak toplamı hesaplar. 'n' parametresi sayesinde dizi boyutunu düzgün bir şekilde kontrol eder.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207301"
  },
  {
    "question": "Bir kelimenin tersini özyinelemeli olarak döndüren bir fonksiyon yazın. Basit ama etkili bir çözüm olmalıdır.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char str[], int start, int end) {\n    if (start >= end) return;\n    char temp = str[start];\n    str[start] = str[end];\n    str[end] = temp;\n    reverseString(str, start + 1, end - 1);\n}\n\nint main() {\n    char str[] = \"Hello\";\n    reverseString(str, 0, strlen(str) - 1);\n    printf(\"Ters: %s\\n\", str);\n    return 0;\n}\n```\n\nBu fonksiyon, kelimenin başından ve sonundan başlayarak karakterleri takas eder ve özyinelemeli olarak kendini çağırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207333"
  },
  {
    "question": "Bir ağaç yapısında düğümlerin sayısını hesaplamak için özyinelemeli bir fonksiyon yazın. Ağaç yapısını nasıl temsil edeceğinizi düşünün.",
    "answer": "Aşağıdaki gibi bir ağaç yapısı ve fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nint countNodes(Node* root) {\n    if (root == NULL) return 0;\n    return 1 + countNodes(root->left) + countNodes(root->right);\n}\n```\n\nBu fonksiyon, ağaçtaki her bir düğüm için kendisini çağırarak toplam düğüm sayısını hesaplar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207369"
  },
  {
    "question": "Verilen bir pozitif tam sayının faktöriyelini özyinelemeli olarak hesaplayan bir fonksiyon yazın. Ancak, hesaplama sırasında performansı artırmak için küçük önlemler alın.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nunsigned long long factorial(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * factorial(n - 1);\n}\n```\n\nBu fonksiyon, faktöriyel hesaplamasını özyinelemeli olarak yapar. N değeri 0 veya 1 olduğunda, hesaplamanın hemen bitmesini sağlar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207412"
  },
  {
    "question": "Bir dizide belirli bir elemanın sayısını özyinelemeli olarak bulan bir fonksiyon yazın. Performansı artırmak için dizinin uzunluğunu kontrol edin.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\nint countOccurrences(int arr[], int n, int x) {\n    if (n <= 0) return 0;\n    return (arr[n - 1] == x ? 1 : 0) + countOccurrences(arr, n - 1, x);\n}\n```\n\nBu fonksiyon, dizinin her bir elemanını kontrol ederek belirli bir sayının kaç kez geçtiğini sayar. 'n' parametresi ile dizinin boyutunu kontrol ederek performansı artırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207449"
  },
  {
    "question": "Bir diziyi özyinelemeli olarak sıralamak için quicksort algoritmasını uygulayan bir fonksiyon yazın. Performansı artırmak için uygun pivot seçimi yapın.",
    "answer": "Aşağıdaki gibi bir quicksort fonksiyonu yazabilirsiniz:\n\n```c\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quicksort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quicksort(arr, low, pi - 1);\n        quicksort(arr, pi + 1, high);\n    }\n}\n```\n\nBu fonksiyon, dizi elemanlarını özyinelemeli olarak sıralamak için quicksort algoritmasını kullanır. Pivot seçiminde son elemanı alarak daha iyi bir performans sağlar.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207486"
  },
  {
    "question": "Bir dizideki tüm alt dizileri özyinelemeli olarak bulan bir fonksiyon yazın. Ancak, her alt diziyi yazdırmadan önce kontrol etmelisiniz.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nvoid printSubarrays(int arr[], int start, int end, int n) {\n    if (start >= n) return;\n    if (end == n) {\n        printSubarrays(arr, start + 1, start + 1, n);\n        return;\n    }\n    printf(\"[\");\n    for (int i = start; i < end; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"]\\n\");\n    printSubarrays(arr, start, end + 1, n);\n}\n\nint main() {\n    int arr[] = {1, 2, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printSubarrays(arr, 0, 0, n);\n    return 0;\n}\n```\n\nBu fonksiyon, dizinin tüm alt dizilerini özyinelemeli olarak bulur ve her bir alt dizi için kontrol yaparak yazdırır.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207541"
  },
  {
    "question": "Bir metindeki tüm harflerin frekansını özyinelemeli olarak hesaplayan bir fonksiyon yazın. Ancak, büyük ve küçük harfleri ayırt etmeyin.",
    "answer": "Aşağıdaki gibi bir fonksiyon yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid countCharFrequency(char str[], int index, int freq[]) {\n    if (str[index] == '\\0') return;\n    char lowerChar = tolower(str[index]);\n    if (lowerChar >= 'a' && lowerChar <= 'z') {\n        freq[lowerChar - 'a']++;\n    }\n    countCharFrequency(str, index + 1, freq);\n}\n\nint main() {\n    char str[] = \"Hello World\";\n    int freq[26] = {0};\n    countCharFrequency(str, 0, freq);\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            printf(\"%c: %d\\n\", 'a' + i, freq[i]);\n        }\n    }\n    return 0;\n}\n```\n\nBu fonksiyon, metindeki her bir harfi kontrol ederek frekansını sayar ve büyük küçük harf ayrımı yapmaz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:07.207579"
  },
  {
    "question": "Özyinelemeli bir fonksiyon kullanarak Fibonacci serisini nasıl hesaplayabiliriz? Bunun yanı sıra, bu fonksiyonun performansını nasıl iyileştirebiliriz?",
    "answer": "Özyinelemeli bir Fibonacci hesaplama fonksiyonu şöyle tanımlanabilir:\n\n```c\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\nAncak bu yaklaşım, 'n' değeri büyüdükçe büyük bir performans kaybına yol açar çünkü aynı değerleri birden fazla kez hesaplar. Bunu önlemek için dinamik programlama veya memoization kullanabiliriz:\n\n```c\nint memo[100];  // 100 size için bir diziyi tanımlıyoruz\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    if (memo[n] != -1) return memo[n];  // Eğer daha önce hesaplandıysa, döndür\n    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);\n    return memo[n];\n}\n\nvoid initialize() {\n    memset(memo, -1, sizeof(memo));  // Diziyi -1 ile başlat\n}\n```\nBu şekilde, hesaplanan değerleri saklayarak performansı büyük ölçüde artırabiliriz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430287"
  },
  {
    "question": "Bir dizideki tüm alt dizileri bulmak için özyinelemeli bir fonksiyon nasıl yazılır? Performans açısından nasıl iyileştirme yapabiliriz?",
    "answer": "Alt dizileri bulmak için aşağıdaki gibi bir özyinelemeli fonksiyon tanımlayabiliriz:\n\n```c\nvoid findSubarrays(int arr[], int start, int end) {\n    if (start > end) return;\n    for (int i = start; i <= end; i++) {\n        for (int j = i; j <= end; j++) {\n            for (int k = i; k <= j; k++) {\n                printf(\"%d \", arr[k]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    findSubarrays(arr, start + 1, end);\n}\n```\nBu yaklaşım, O(n^3) zaman karmaşıklığına sahiptir. Performansı artırmak için döngüleri tek bir özyinelemeli yapı içinde birleştirebilir ve daha az tekrar eden hesaplamalar yapabiliriz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430336"
  },
  {
    "question": "Bir dizinin elemanlarını özyinelemeli olarak ters çevirmek için nasıl bir algoritma yazabiliriz? Ayrıca, bu algoritmanın verimliliğini artırmak için ne yapabiliriz?",
    "answer": "Dizinin elemanlarını ters çevirmek için aşağıdaki gibi bir özyinelemeli fonksiyon yazabiliriz:\n\n```c\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}\n```\nBu fonksiyon O(n) zaman karmaşıklığına sahiptir ve yerinde dönüşüm yaparak ek bellek kullanmaz. Performansı artırmak için, bu algoritmanın zaten ters çevrilmiş olup olmadığını kontrol edebiliriz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430380"
  },
  {
    "question": "Bir ağaç veri yapısında özyinelemeli olarak derinlik öncelikli (pre-order) dolaşım yapmak için nasıl bir fonksiyon yazabiliriz? Bu fonksiyonu optimize etmenin yolu nedir?",
    "answer": "Bir ağaçta pre-order dolaşım yapmak için şöyle bir fonksiyon yazabiliriz:\n\n```c\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nvoid preOrder(struct Node* node) {\n    if (node == NULL) return;\n    printf(\"%d \", node->data);\n    preOrder(node->left);\n    preOrder(node->right);\n}\n```\nBu fonksiyon, her düğümü bir kez ziyaret ettiği için O(n) zaman karmaşıklığına sahiptir. Ancak, derinlik öncelikli dolaşım sırasında düğümlerin tekrar ziyaret edilmesini önlemek için her düğüm için bir işaretçi kullanarak kontrol mekanizması eklenebilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430431"
  },
  {
    "question": "Bir sayı dizisinin elemanlarının toplamını özyinelemeli bir fonksiyon ile nasıl hesaplayabiliriz? Performansı artırmak için neler yapabiliriz?",
    "answer": "Dizi elemanlarının toplamını hesaplamak için şöyle bir fonksiyon yazabiliriz:\n\n```c\nint sumArray(int arr[], int n) {\n    if (n <= 0) return 0;\n    return arr[n - 1] + sumArray(arr, n - 1);\n}\n```\nBu fonksiyon O(n) zaman karmaşıklığındadır. Performance optimizasyonu için dizi yerine birim testleri veya toplama işlemine giden değerleri toplayarak hesaplamak daha verimli olabilir. Belirli bir eşik değerine (örneğin 100 eleman) ulaşıldığında, döngü kullanılarak işlem yapılabilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430469"
  },
  {
    "question": "Özyinelemeli bir fonksiyonla bir karakter dizisinin palindrom olup olmadığını nasıl kontrol edebiliriz? Kodun optimizasyonu için önerileriniz nelerdir?",
    "answer": "Bir karakter dizisinin palindrom olup olmadığını kontrol etmek için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nint isPalindrome(char* str, int left, int right) {\n    if (left >= right) return 1;\n    if (str[left] != str[right]) return 0;\n    return isPalindrome(str, left + 1, right - 1);\n}\n```\nBu fonksiyon O(n) zaman karmaşıklığına sahiptir. Performansı artırmak için, dizinin uzunluğunu bir kez hesaplayıp, her çağrıda tekrarlamadan kullanabiliriz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430522"
  },
  {
    "question": "Bir sayı dizisinden belirli bir toplamı veren tüm kombinasyonları bulmak için özyinelemeli bir fonksiyon nasıl yazılır? Bu fonksiyonu nasıl optimize edebiliriz?",
    "answer": "Belirli bir toplamı veren kombinasyonları bulmak için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nvoid findCombinations(int arr[], int n, int sum, int index, int data[], int dataIndex) {\n    if (sum == 0) {\n        for (int i = 0; i < dataIndex; i++) printf(\"%d \", data[i]);\n        printf(\"\\n\");\n        return;\n    }\n    if (sum < 0 || index >= n) return;\n    data[dataIndex] = arr[index];\n    findCombinations(arr, n, sum - arr[index], index + 1, data, dataIndex + 1);\n    findCombinations(arr, n, sum, index + 1, data, dataIndex);\n}\n```\nBu fonksiyon O(2^n) zaman karmaşıklığına sahiptir. Optimizasyon için, tekrar eden kombinasyonları önlemek adına bir set veri yapısı kullanılabilir.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430563"
  },
  {
    "question": "Bir dizideki belirli bir öğenin var olup olmadığını özyinelemeli bir fonksiyon kullanarak nasıl kontrol edebiliriz? Performansını artırmak için önerileriniz nelerdir?",
    "answer": "Bir dizideki belirli bir öğenin varlığını kontrol etmek için şöyle bir fonksiyon yazabiliriz:\n\n```c\nint contains(int arr[], int n, int target) {\n    if (n <= 0) return 0;\n    if (arr[n - 1] == target) return 1;\n    return contains(arr, n - 1, target);\n}\n```\nBu fonksiyon O(n) zaman karmaşıklığına sahiptir. Performansı artırmak için ikili arama gibi daha verimli algoritmalar kullanılabilir, ancak bu yalnızca dizi sıralıysa mümkündür.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430602"
  },
  {
    "question": "Özyinelemeli bir fonksiyon ile bir tamsayıyı faktöriyelini nasıl hesaplarız? Bu süreçte bellek yönetimi ve optimizasyon açısından dikkat edilmesi gerekenler nelerdir?",
    "answer": "Bir tamsayının faktöriyelini hesaplamak için aşağıdaki gibi bir fonksiyon yazabiliriz:\n\n```c\nint factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n```\nBu fonksiyon O(n) zaman karmaşıklığına sahiptir. Ancak, büyük 'n' değerleri için stack overflow riski taşır. Bunun önüne geçmek için iteratif bir çözüm veya tail recursion kullanabiliriz. Ayrıca, büyük sayılar için veri türü olarak long long kullanmayı göz önünde bulundurmalıyız.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430642"
  },
  {
    "question": "Bir dosya sistemindeki dosyaların ve dizinlerin özyinelemeli olarak listelenmesi için nasıl bir fonksiyon yazabiliriz? Performansı artırmak için hangi stratejileri kullanabiliriz?",
    "answer": "Dosya sistemindeki dosyaları ve dizinleri listelemek için şöyle bir fonksiyon yazabiliriz:\n\n```c\n#include <dirent.h>\n\nvoid listFilesRecursively(const char *basePath) {\n    struct dirent *dp;\n    DIR *dir = opendir(basePath);\n    if (dir == NULL) return;\n    while ((dp = readdir(dir)) != NULL) {\n        if (dp->d_type == DT_DIR) {\n            char path[1000];\n            sprintf(path, \"%s/%s\", basePath, dp->d_name);\n            listFilesRecursively(path);\n        } else {\n            printf(\"%s/%s\\n\", basePath, dp->d_name);\n        }\n    }\n    closedir(dir);\n}\n```\nBu fonksiyon, dosyaları ve dizinleri özyinelemeli olarak listeler. Performans açısından, gereksiz dizinleri atlamak için bir filtreleme mekanizması ekleyebiliriz ve çok derin dizin yapılarında stack overflow riskini azaltmak için bir iteratif yaklaşım tercih edebiliriz.",
    "category": "advanced_topics",
    "topic": "recursion",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Recursion (özyinelemeli fonksiyonlar)",
    "timestamp": "2025-06-01T17:52:46.430692"
  },
  {
    "question": "Kullanıcıdan komut satırında iki sayı alıp bu sayıların toplamını hesaplayan bir C programının eksik kodunu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int toplam = sayi1 + sayi2;\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n\n// Açıklama: Program, komut satırından iki sayı alarak, bu sayıların toplamını hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644257"
  },
  {
    "question": "Bir dosyanın adını komut satırı argümanı olarak alıp içeriğini ekrana yazdıran bir C programı yazın. Eksik kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\\n\");\n        return 1;\n    }\n\n    char ch;\n    while ((ch = fgetc(dosya)) != EOF) {\n        putchar(ch);\n    }\n\n    fclose(dosya);\n    return 0;\n}\n\n// Açıklama: Kod, verilen dosyanın içeriğini okuyarak ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644332"
  },
  {
    "question": "Kullanıcının komut satırına girdiği bir kelimenin reversini (tersini) bulan C programını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir kelime girin.\\n\");\n        return 1;\n    }\n\n    char *kelime = argv[1];\n    int uzunluk = strlen(kelime);\n\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(kelime[i]);\n    }\n    putchar('\\n');\n\n    return 0;\n}\n\n// Açıklama: Program, komut satırında verilen kelimeyi ters çevirerek ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644364"
  },
  {
    "question": "Kullanıcıdan alınan bir sayı aralığında (başlangıç ve bitiş) asal sayıları bulan C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint asalMi(int sayi) {\n    if (sayi < 2) return 0;\n    for (int i = 2; i <= sayi / 2; i++) {\n        if (sayi % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen başlangıç ve bitiş sayıları girin.\\n\");\n        return 1;\n    }\n\n    int baslangic = atoi(argv[1]);\n    int bitis = atoi(argv[2]);\n\n    printf(\"Asal sayılar: \");\n    for (int i = baslangic; i <= bitis; i++) {\n        if (asalMi(i)) {\n            printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n// Açıklama: Bu program, verilen aralıkta asal sayıları bulur ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644398"
  },
  {
    "question": "Kullanıcının girdiği bir dosya adındaki kelime sayısını hesaplayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı.\\n\");\n        return 1;\n    }\n\n    char kelime[100];\n    int kelimeSayisi = 0;\n    while (fscanf(dosya, \"%s\", kelime) != EOF) {\n        kelimeSayisi++;\n    }\n\n    fclose(dosya);\n    printf(\"Kelime sayısı: %d\\n\", kelimeSayisi);\n    return 0;\n}\n\n// Açıklama: Verilen dosyada geçen kelimelerin sayısını bulur ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644428"
  },
  {
    "question": "Kullanıcının komut satırında girdiği bir metni büyük harflere çeviren bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir metin girin.\\n\");\n        return 1;\n    }\n\n    char *metin = argv[1];\n\n    for (int i = 0; metin[i] != '\\0'; i++) {\n        putchar(toupper(metin[i]));\n    }\n    putchar('\\n');\n\n    return 0;\n}\n\n// Açıklama: Program, komut satırında verilen metni büyük harflerle yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644459"
  },
  {
    "question": "Kullanıcının komut satırında verdiği bir stringin uzunluğunu hesaplayan bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir string girin.\\n\");\n        return 1;\n    }\n\n    char *string = argv[1];\n    int uzunluk = strlen(string);\n\n    printf(\"String uzunluğu: %d\\n\", uzunluk);\n    return 0;\n}\n\n// Açıklama: Program, verilen stringin uzunluğunu hesaplayıp ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644488"
  },
  {
    "question": "Kullanıcının komut satırında verdiği iki dosyanın boyutunu karşılaştıran bir C programının eksik bölümünü tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki dosya adı girin.\\n\");\n        return 1;\n    }\n\n    FILE *dosya1 = fopen(argv[1], \"r\");\n    FILE *dosya2 = fopen(argv[2], \"r\");\n\n    if (dosya1 == NULL || dosya2 == NULL) {\n        printf(\"Dosyalardan biri açılamadı.\\n\");\n        return 1;\n    }\n\n    fseek(dosya1, 0, SEEK_END);\n    fseek(dosya2, 0, SEEK_END);\n    long boyut1 = ftell(dosya1);\n    long boyut2 = ftell(dosya2);\n\n    fclose(dosya1);\n    fclose(dosya2);\n\n    if (boyut1 > boyut2) {\n        printf(\"%s daha büyüktür.\\n\", argv[1]);\n    } else if (boyut1 < boyut2) {\n        printf(\"%s daha büyüktür.\\n\", argv[2]);\n    } else {\n        printf(\"İki dosya eşit boyuttadır.\\n\");\n    }\n    return 0;\n}\n\n// Açıklama: Program, verilen iki dosyanın boyutlarını karşılaştırır ve hangi dosyanın daha büyük olduğunu belirtir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644533"
  },
  {
    "question": "Kullanıcının girdiği bir tam sayıyı negatiften pozitif hale getiren bir C programının eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir tam sayı girin.\\n\");\n        return 1;\n    }\n\n    int sayi = atoi(argv[1]);\n    if (sayi < 0) {\n        sayi = -sayi;\n    }\n\n    printf(\"Pozitif hali: %d\\n\", sayi);\n    return 0;\n}\n\n// Açıklama: Program, kullanıcıdan alınan negatif bir sayıyı pozitif hale getirir ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:26.644563"
  },
  {
    "question": "Bir programın komut satırından aldığı iki sayıyı toplayan bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen iki sayı girin.\\n\");\n        return 1;\n    }\n    int a = atoi(argv[1]);\n    int b = atoi(argv[2]);\n    printf(\"Toplam: %d\\n\", a + b);\n    return 0;\n}\n\n// Bu program kullanıcıdan iki sayı alır ve bu sayıların toplamını ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186267"
  },
  {
    "question": "Bir dosyanın adını komut satırından alan ve dosyayı okuyan bir işlev tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        printf(\"Dosya açılamadı.\\n\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n    fclose(file);\n    return 0;\n}\n\n// Bu program, komut satırından verilen dosya adını alır ve o dosyadaki içeriği ekrana basar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186310"
  },
  {
    "question": "Komut satırından girilen bir dizi sayının ortalamasını hesaplayan bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Lütfen sayı girin.\\n\");\n        return 1;\n    }\n    int sum = 0;\n    for (int i = 1; i < argc; i++) {\n        sum += atoi(argv[i]);\n    }\n    printf(\"Ortalama: %.2f\\n\", (float)sum / (argc - 1));\n    return 0;\n}\n\n// Bu program, komut satırından verilen sayıları toplar ve ortalamasını hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186338"
  },
  {
    "question": "Komut satırından bir kelime ve sayıyı alarak kelimeyi belirtilen sayıda yazdıran bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen bir kelime ve bir sayı girin.\\n\");\n        return 1;\n    }\n    int count = atoi(argv[2]);\n    for (int i = 0; i < count; i++) {\n        printf(\"%s\\n\", argv[1]);\n    }\n    return 0;\n}\n\n// Bu program, komut satırından bir kelime ve bir sayı alır, kelimeyi belirtilen sayıda ekrana basar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186367"
  },
  {
    "question": "Bir URL alarak HTTP isteği yapan bir programın eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <curl/curl.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir URL girin.\\n\");\n        return 1;\n    }\n    CURL *curl;\n    CURLcode res;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"Curl hata: %s\\n\", curl_easy_strerror(res));\n        }\n        curl_easy_cleanup(curl);\n    }\n    curl_global_cleanup();\n    return 0;\n}\n\n// Bu program, komut satırından aldığı URL'ye bir HTTP isteği yapar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186392"
  },
  {
    "question": "Komut satırından bir dosya yolu alarak dosya boyutunu hesaplayan bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya yolu girin.\\n\");\n        return 1;\n    }\n    struct stat st;\n    if (stat(argv[1], &st) == 0) {\n        printf(\"Dosya boyutu: %lld bayt\\n\", (long long)st.st_size);\n    } else {\n        perror(\"Dosya bilgileri alınamadı.\");\n    }\n    return 0;\n}\n\n// Bu program, komut satırından aldığı dosya yolunu kullanarak dosyanın boyutunu hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186418"
  },
  {
    "question": "Komut satırından alınan bir isim ve soyisimle birlikte tam ad oluşturup yazdıran bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Lütfen isim ve soyisim girin.\\n\");\n        return 1;\n    }\n    printf(\"Tam Ad: %s %s\\n\", argv[1], argv[2]);\n    return 0;\n}\n\n// Bu program, komut satırından alınan isim ve soyismi birleştirip tam adı ekrana basar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186446"
  },
  {
    "question": "Komut satırından girilen bir dizi kelimeyi alfabetik sıraya dizen bir kodu tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Lütfen en az bir kelime girin.\\n\");\n        return 1;\n    }\n    qsort(&argv[1], argc - 1, sizeof(char *), compare);\n    printf(\"Sıralı Kelimeler:\\n\");\n    for (int i = 1; i < argc; i++) {\n        printf(\"%s\\n\", argv[i]);\n    }\n    return 0;\n}\n\n// Bu program, komut satırından alınan kelimeleri alfabetik sıraya dizip yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186471"
  },
  {
    "question": "Bir dosyadaki kelime sayısını sayan bir programın eksik kısmını tamamlayın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Lütfen bir dosya adı girin.\\n\");\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (!file) {\n        printf(\"Dosya açılamadı.\\n\");\n        return 1;\n    }\n    int count = 0;\n    char word[100];\n    while (fscanf(file, \"%99s\", word) == 1) {\n        count++;\n    }\n    fclose(file);\n    printf(\"Kelime Sayısı: %d\\n\", count);\n    return 0;\n}\n\n// Bu program, komut satırından verilen dosya adındaki kelimelerin sayısını hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:53:59.186494"
  },
  {
    "question": "Bir dosya adını komut satırından alarak, dosyanın içeriğini ekrana yazan bir C programı nasıl tamamlanır?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n    fclose(file);\n    return 0;\n}\n// Bu program, kullanıcıdan bir dosya adı alarak o dosyanın içeriğini okur ve ekrana yazar. Eğer dosya açılamazsa hata mesajı verir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238349"
  },
  {
    "question": "Komut satırından birden fazla sayıyı alıp, bu sayıların toplamını hesaplayan bir C programını tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir sayı sağlamalısınız.\\n\");\n        return 1;\n    }\n    int toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atoi(argv[i]);\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n// Bu program, komut satırında girilen sayıları toplayarak toplam değeri ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238394"
  },
  {
    "question": "Bir komut satırı argümanı olarak verilen bir dizenin uzunluğunu hesaplayan bir C programı nasıl yazılır?",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dize>\\n\", argv[0]);\n        return 1;\n    }\n    printf(\"Dizenin uzunluğu: %lu\\n\", strlen(argv[1]));\n    return 0;\n}\n// Bu program, komut satırından alınan bir dizeyi alır ve uzunluğunu hesaplayarak ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238438"
  },
  {
    "question": "Komut satırından bir dosya adı alarak, dosyanın boyutunu hesaplayan bir program yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    fseek(file, 0, SEEK_END);\n    long boyut = ftell(file);\n    fclose(file);\n    printf(\"Dosya boyutu: %ld bayt\\n\", boyut);\n    return 0;\n}\n// Bu program, verilen bir dosyanın boyutunu bayt cinsinden hesaplayıp ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238467"
  },
  {
    "question": "Kullanıcının komut satırında girdiği iki tarih arasındaki gün sayısını hesaplayan bir C programını tamamla.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <tarih1> <tarih2> (yyyy-mm-dd)\\n\", argv[0]);\n        return 1;\n    }\n    struct tm t1 = {0}, t2 = {0};\n    sscanf(argv[1], \"%d-%d-%d\", &t1.tm_year, &t1.tm_mon, &t1.tm_mday);\n    sscanf(argv[2], \"%d-%d-%d\", &t2.tm_year, &t2.tm_mon, &t2.tm_mday);\n    t1.tm_year -= 1900;\n    t1.tm_mon -= 1;\n    t2.tm_year -= 1900;\n    t2.tm_mon -= 1;\n    time_t zaman1 = mktime(&t1);\n    time_t zaman2 = mktime(&t2);\n    double fark = difftime(zaman2, zaman1);\n    printf(\"Gün sayısı: %.0f\\n\", fark / (60 * 60 * 24));\n    return 0;\n}\n// Bu program, iki tarih arasında kaç gün olduğunu hesaplar ve sonucu ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238498"
  },
  {
    "question": "Komut satırından bir dosya adı ve bir kelime alarak, dosyada bu kelimenin kaç kez geçtiğini sayan bir program yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <dosya_adı> <kelime>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char *kelime = argv[2];\n    char satir[256];\n    int sayac = 0;\n    while (fgets(satir, sizeof(satir), file)) {\n        char *ptr = satir;\n        while ((ptr = strstr(ptr, kelime)) != NULL) {\n            sayac++;\n            ptr++;\n        }\n    }\n    fclose(file);\n    printf(\"Kelime '%s' %d kez bulundu.\\n\", kelime, sayac);\n    return 0;\n}\n// Bu program, belirtilen bir dosyada verilen kelimenin kaç kez geçtiğini sayar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238551"
  },
  {
    "question": "Komut satırında girilen bir dizi tam sayıyı sıralayıp ekrana yazan bir C programı nasıl yazılır?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid sıralama(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir sayı sağlamalısınız.\\n\");\n        return 1;\n    }\n    int n = argc - 1;\n    int sayilar[n];\n    for (int i = 0; i < n; i++) {\n        sayilar[i] = atoi(argv[i + 1]);\n    }\n    sıralama(sayilar, n);\n    printf(\"Sıralı diziler:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu program, komut satırında verilen sayıları sıralar ve sıralı diziyi ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238581"
  },
  {
    "question": "Bir komut satırı argümanı olarak verilen bir tam sayının asal olup olmadığını kontrol eden bir C programı yaz.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint asal_mi(int sayi) {\n    if (sayi <= 1) return 0;\n    for (int i = 2; i * i <= sayi; i++) {\n        if (sayi % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <tam_sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    if (asal_mi(sayi)) {\n        printf(\"%d asal bir sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n// Bu program, kullanıcıdan alınan bir sayının asal olup olmadığını kontrol eder ve sonucu ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238621"
  },
  {
    "question": "Kullanıcının komut satırında girdiği bir listeyi tersine çevirip ekrana yazan bir C programı nasıl tamamlanır?",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir argüman sağlamalısınız.\\n\");\n        return 1;\n    }\n    printf(\"Tersine çevrilmiş liste:\");\n    for (int i = argc - 1; i > 0; i--) {\n        printf(\" %s\", argv[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu program, komut satırında girilen argümanları ters sırada ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_completion",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:54:43.238652"
  },
  {
    "question": "Bir programda komut satırından iki sayı alıp bunları toplayan bir fonksiyon yazdım. Çalıştırırken sayıları girip programı başlattığımda sonuç 0 çıkıyor. Sorun ne olabilir?",
    "answer": "Muhtemelen sayıları string formatında alıyorsunuz ve bunu toplarken sayılara dönüştürmüyorsunuz. Örneğin, bu durumda kullanılan kod şöyle olmalı: `int a = atoi(argv[1]); int b = atoi(argv[2]);` gibi bir dönüşüm yapmalısınız. `atoi` fonksiyonu string'i tam sayıya çevirir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.560908"
  },
  {
    "question": "Komut satırından bir dosyanın adını alıp içeriğini yazdıran bir programda, dosya bulunamadı hatası alıyorum. Neden?",
    "answer": "Bu hata genellikle dosya adının yanlış girilmesinden kaynaklanır. Ayrıca, dosyanın bulunduğunuz dizinde olup olmadığını kontrol edin. Dosya yolu belirtilmemişse, program çalıştırılırken geçerli dizinde dosyanın olup olmadığını kontrol edin.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.560958"
  },
  {
    "question": "Geçerli bir dosya adı girmeme rağmen programım yine de çalışmıyor. Hangi hatalar olabilir?",
    "answer": "Dosya izinleri kontrol edilmelidir. Eğer dosyayı okuma izniniz yoksa, program dosyayı açamayacak ve hata verecektir. Dosyanın izinlerini kontrol etmek için terminalde `ls -l filename` komutunu kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.560988"
  },
  {
    "question": "Bir programda komut satırından birden fazla argüman alıyorum ama sadece ilki işleniyor. Neden?",
    "answer": "Programınızın diğer argümanları işlememesi, genellikle döngü yapısında bir hata olmasından kaynaklanır. `for (int i = 1; i < argc; i++)` döngüsünü kullanarak tüm argümanları kontrol etmeli ve işlemlerinizi bu döngü içinde gerçekleştirmelisiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561017"
  },
  {
    "question": "Bir programda komut satırından bir argümanı alıp bunu bir tam sayıya dönüştürmeye çalışıyorum ama hata alıyorum. Neden?",
    "answer": "Alınan argümanın tam sayıya dönüştürülmesinde yine `atoi` veya `strtol` gibi dönüşüm fonksiyonları kullanılmalıdır. Eğer girdi uygun bir tam sayı değilse, dönüşüm sırasında hata alırsınız. Girdiyi kontrol etmek için `isdigit` fonksiyonunu kullanabilirsiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561055"
  },
  {
    "question": "Programımda varsayılan bir değer belirlemek istiyorum ama komut satırında hiç argüman girmezsem sonuç 0 çıkıyor. Bunu nasıl düzeltebilirim?",
    "answer": "Eğer `argc` 1 ise, bu durumda hiçbir argüman verilmediği anlamına gelir. Bu durumda varsayılan bir değer atamak için `if (argc == 1) { value = DEFAULT_VALUE; }` şeklinde bir kontrol eklemelisiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561107"
  },
  {
    "question": "Komut satırında bir kelime alıp bunu tersine çeviren bir program yazdım ama sonuç her zaman aynı çıkıyor. Neden?",
    "answer": "Bu durumda muhtemelen ters çevirme işlemini gerçekleştiren fonksiyonda bir hata vardır. Örneğin, kelimeyi tersine çevirmek için bir döngü kullanmayı unuttuysanız, her zaman başlangıçtaki kelimeyi döndürecektir. Örnek olarak: `for (int i = length - 1; i >= 0; i--)` şeklinde bir döngü kullanılmalıdır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561141"
  },
  {
    "question": "Komut satırından bir float sayısı alıyorum ama programım hata veriyor. Hangi hatalar olabilir?",
    "answer": "Komut satırından alınan değerler her zaman string olarak gelir. `atof` veya `strtof` fonksiyonları kullanarak bu string'i float'a çevirmelisiniz. Ayrıca, eğer virgül ile ondalık sayı kullanıyorsanız, bunu nokta ile değiştirmelisiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561170"
  },
  {
    "question": "Programımda komut satırından bir dizin alıyorum ama dizin yoksa hata vermesini istiyorum. Bunu nasıl yapabilirim?",
    "answer": "Dizinin var olup olmadığını kontrol etmek için `stat` veya `access` fonksiyonlarını kullanabilirsiniz. Örneğin: `if (access(dir_name, F_OK) == -1) { perror(\"Dizin bulunamadı\"); exit(1); }` şeklinde bir kontrol yapmalısınız.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561201"
  },
  {
    "question": "Programımı çalıştırdığımda beklediğimden çok fazla argüman alıyorum. Bunun nedeni nedir?",
    "answer": "Muhtemelen komut satırında argümanlarınızı ayırmak için boşluk yerine yanlış bir karakter kullanıyorsunuz. Her argümanı doğru bir şekilde ayırdığınızdan emin olun. Eğer bir argüman içinde boşluk varsa, o argümanı çift tırnak içinde vermelisiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561228"
  },
  {
    "question": "Komut satırındaki argümanları saymaya çalışıyorum ama her zaman 1 çıkıyor. Sorun nerede?",
    "answer": "Eğer `argc` değişkenini kontrol ediyorsanız, `argc` program adını da içerir. İlk argüman programın adı olduğundan, gerçek argüman sayısını `argc - 1` olarak hesaplamalısınız.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:16.561254"
  },
  {
    "question": "Programım komut satırında argüman olarak bir sayı alıyor ama her zaman 0 olarak çıkıyor. Neden?",
    "answer": "Eğer programınız 'atoi' veya 'strtol' gibi bir fonksiyon kullanıyorsa, komut satırındaki argümanları kontrol etmediğiniz veya argümanın doğru şekilde alındığından emin olmadığınız için bu durum gerçekleşebilir. Örneğin, komut satırında 'myprogram 5' şeklinde çalıştırmalısınız. Kodda da 'argv[1]' değerini kullanarak argümanı almalısınız. Doğru kullanım: 'int number = atoi(argv[1]);'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212219"
  },
  {
    "question": "Komut satırında 3 argüman bekleyen programım 2 argümanla çalıştırıldığında çöküyor. Nasıl önleyebilirim?",
    "answer": "Programınızda argüman sayısını kontrol etmediğiniz için bu hata meydana geliyor. Çalıştırmadan önce, 'argc' değerini kontrol ederek beklenen argüman sayısından az ise bir hata mesajı vererek programın çalışmasını engelleyebilirsiniz. Örneğin: 'if (argc < 4) { printf(\"Eksik argümanlar!\"); return 1; }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212265"
  },
  {
    "question": "Bir dosya adı komut satırında argüman olarak alınıyor ama dosya mevcut değil hatası alıyorum. Neden?",
    "answer": "Muhtemelen dosya adını komut satırında yanlış yazdınız veya dosya mevcut değil. Bu durumda, programınızda dosya açma fonksiyonunu kullandığınız yerde, dosyanın varlığını kontrol etmelisiniz. Örneğin: 'FILE *file = fopen(argv[1], \"r\"); if (file == NULL) { perror(\"Dosya açılamadı\"); return 1; }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212296"
  },
  {
    "question": "Komut satırında birden fazla argüman geçmek istiyorum ama sadece ilk argümanı alabiliyorum. Neden?",
    "answer": "Muhtemelen program kodunuzda sadece 'argv[1]' kullanıyorsunuz. Eğer birden fazla argüman almak istiyorsanız, her argüman için 'argv' dizisinin ilgili indeksini kullanmalısınız. Örneğin: 'printf(\"1. argüman: %s\n\", argv[1]); printf(\"2. argüman: %s\n\", argv[2]);'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212324"
  },
  {
    "question": "Bir bayrak (flag) olarak argüman almaya çalışıyorum ama programım bu bayrağı görmüyor. Neden?",
    "answer": "Eğer argümanlarınızı '-flag' şeklinde geçiyorsanız, programınızda bu bayrağı kontrol etmek için dizinin ilk elemanını kontrol etmeniz gerekebilir. Örneğin: 'if (strcmp(argv[1], \"-flag\") == 0) {...}'. Ayrıca, bayrakları kontrol etmeden önce argüman sayısını kontrol etmeyi unutmayın.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212353"
  },
  {
    "question": "Komut satırında girilen bir kelimeyi tersine çevirmek istiyorum ancak çıktım yanlış. Hangi hata var?",
    "answer": "Muhtemelen, girdiğiniz kelimeyi tersine çevirmek için doğru algoritmayı uygulamadınız. Örneğin, 'strrev' gibi bir fonksiyon kullanmak yerine, kendi ters çevirme fonksiyonunuzu yazmalısınız. Örnek: 'for (int i = strlen(argv[1]) - 1; i >= 0; i--) { printf(\"%c\", argv[1][i]); }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212381"
  },
  {
    "question": "Çok sayıda argüman geçiriyorum ama bellekte taşma hatası alıyorum. Neden?",
    "answer": "Eğer programınızda dinamik bellek kullanıyorsanız ve bellek allocate etme işlemlerini doğru yapmadıysanız bu hata meydana gelebilir. Özellikle, geçilen argüman sayısını kontrol etmeden bir dizi allocate ediyorsanız, bellek taşması yaşanabilir. Örneğin: 'char **args = malloc(argc * sizeof(char*));' şeklinde allocate edin.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212406"
  },
  {
    "question": "Bir dosyanın içeriklerini komut satırından alıp yazdırmak istiyorum, fakat çıktı boş. Neden?",
    "answer": "Muhtemelen dosya okuma işlemi sırasında bir hata alıyorsunuz, ancak bu hatayı kontrol etmiyorsunuz. Dosyayı açtıktan sonra, 'fgets' veya 'fread' gibi fonksiyonları kullanarak okuma yapmayı deneyin ve hata kontrolü ekleyin. Örneğin: 'while (fgets(buffer, sizeof(buffer), file) != NULL) { printf(\"%s\", buffer); }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212440"
  },
  {
    "question": "Programımda bir argümanı tam sayı olarak kullanmaya çalışıyorum ama hata alıyorum. Sebebi ne olabilir?",
    "answer": "Eğer argümanı tam sayıya dönüştürmeden önce kontrol etmiyorsanız, geçersiz bir değer girişi yapıldığında hata alabilirsiniz. Öncelikle, 'isdigit' veya 'strtol' ile dönüşüm sağlamadan önce argümanı kontrol etmelisiniz. Örneğin: 'char *end; long value = strtol(argv[1], &end, 10); if (*end != '\\0') { printf(\"Geçersiz tam sayı!\\n\"); return 1; }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212469"
  },
  {
    "question": "Komut satırında alınan bir dizeyi büyük harfe çevirmek istiyorum ama sonuç beklediğim gibi değil. Hata nerede?",
    "answer": "Dizeyi büyük harfe çevirirken, 'toupper' fonksiyonunu doğrudan kullanmanız gerekiyor; ancak her karakter için ayrı ayrı uygulamanız gerektiği için bir döngü kullanmanız şart. Örnek: 'for (int i = 0; argv[1][i] != '\\0'; i++) { argv[1][i] = toupper(argv[1][i]); }'.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:55:40.212500"
  },
  {
    "question": "Komut satırında verilen argümanları doğru bir şekilde işleyemeyen bir C programı yazdım. Programın çıktısı her zaman 0 olarak dönüyor. Sorunu nasıl bulabilirim?",
    "answer": "Programın argümanları nasıl işlediğini kontrol edin. Argümanları bir döngü ile geçerken 'argc' ve 'argv' kullanarak değerleri kontrol edin. Örneğin: `for (int i = 1; i < argc; i++) { printf(\"Argüman %d: %s\\n\", i, argv[i]); }` Bu şekilde, geçilen argümanları görebilirsiniz. Eğer her zaman 0 dönüyorsa, muhtemelen 'argc' değeri 1'dir ve argüman yoktur.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450196"
  },
  {
    "question": "Komut satırında iki tam sayı alıp bunları toplayan bir program yazdım. Ancak, çıktıda beklediğim gibi bir toplam göremiyorum. Neden?",
    "answer": "Muhtemel hata, argümanları tam sayıya dönüştürmemiş olmanız. 'atoi' veya 'strtol' gibi fonksiyonları kullanarak string argümanlarını tam sayılara çevirmelisiniz. Örnek: `int a = atoi(argv[1]); int b = atoi(argv[2]); printf(\"Toplam: %d\\n\", a + b);`. Ayrıca, kullanıcıdan yeterli argüman verilmediğinde bir kontrol eklemeyi unutmayın.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450250"
  },
  {
    "question": "Bir dosyanın adını komut satırından alarak dosyayı açan programda 'file not found' hatası alıyorum. Sorunun kaynağı ne olabilir?",
    "answer": "Dosya adını almadan önce 'argc' kontrolü yapmadıysanız, bu durumda 'argv[1]' erişimi geçersiz bir bellek konumuna gidebilir. 'argc' kontrolü yaparak bu durumu önleyebilirsiniz: `if (argc < 2) { printf(\"Dosya adı verilmedi!\\n\"); return 1; }` Ayrıca, dosya yolunun doğru yazıldığından ve dosyanın mevcut olduğundan emin olun.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450289"
  },
  {
    "question": "Komut satırında birden fazla argüman alıp, bunların her birini ayrı ayrı işleyen bir programım var. Ancak, son argümanda hata alıyorum. Neden?",
    "answer": "Belki de son argümanı işlerken döngü sınırlarını doğru ayarlamamış olabilirsiniz. 'for (int i = 1; i < argc; i++)' yerine 'for (int i = 1; i <= argc; i++)' yazdıysanız, 'argv[argc]' bellek hatasına neden olacaktır. Düzgün sınır kullanarak hatayı düzeltebilirsiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450330"
  },
  {
    "question": "Komut satırından bir float değeri alıyorum ama çıktıda beklediğim gibi bir sonuç göremiyorum. Ne yapmalıyım?",
    "answer": "Muhtemelen stringi float'a dönüştürmek için 'atof' veya 'strtof' kullanmadınız. Örneğin: `float f = atof(argv[1]); printf(\"Float değeri: %f\\n\", f);` Ayrıca, kullanıcıdan gelen değerin geçerliliğini kontrol etmek iyi bir uygulamadır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450364"
  },
  {
    "question": "Komut satırından aldığım bir dosyanın içeriğini okuyan programım başarısız oluyor. Hatanın kaynağı ne olabilir?",
    "answer": "Muhtemel hata, dosya açma işleminde kullanılan yolun hatalı olması veya dosyanın açılmadan önce kontrol edilmemesidir. `FILE *file = fopen(argv[1], \"r\"); if (file == NULL) { perror(\"Dosya açılamadı\"); return 1; }` şeklinde bir kontrol ekleyerek, dosyanın açılıp açılmadığını doğrulayabilirsiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450409"
  },
  {
    "question": "Bir karakter dizisi alıp, bu dizinin uzunluğunu hesaplayan bir programda 'segmentation fault' alıyorum. Neden?",
    "answer": "Muhtemel sebep, 'argv' dizisine erişirken geçersiz bir indeks kullanmanız. 'argc' değerinin 1'den büyük olup olmadığını kontrol etmiyorsanız, 'argv[1]' bellek hatasına neden olabilir. `if (argc < 2) { printf(\"Argüman eksik\\n\"); return 1; }` şeklinde bir kontrol ekleyin.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450442"
  },
  {
    "question": "Komut satırından bir dizi argüman alıp bunları bir dosyaya yazmak istiyorum ama dosya yazma işlemi başarısız oluyor. Hatanın kaynağı nedir?",
    "answer": "Dosyayı yazma modunda açmayı unuttuysanız veya dosya yolu hatalıysa bu hata oluşabilir. Dosyayı yazma modu ile açmalısınız: `FILE *file = fopen(\"output.txt\", \"w\");`. Ayrıca, dosyanın yazılabilir olduğundan emin olun.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450478"
  },
  {
    "question": "Komut satırından kullanıcıdan bir seçim alıp bu seçime göre işlem yapan bir programda beklenmedik sonuçlar alıyorum. Sorun ne olabilir?",
    "answer": "Kullanıcının girdiği seçimin geçerliliğini kontrol etmediyseniz, yanlış seçimler yapılabilir. Örneğin: `if (strcmp(argv[1], \"1\") == 0) { /* işlem */ }` koşulu ile girişleri kontrol edin. Kullanıcıdan hangi seçeneklerin geçerli olduğunu belirtmeyi unutmayın.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450531"
  },
  {
    "question": "Yazdığım programda komut satırından alınan argümanların sayısını doğru saymadığımı düşünüyorum. Hangi kontrolleri yapmalıyım?",
    "answer": "Argüman sayısını kontrol etmek için 'argc' değerini kullanmalısınız. 'argc' başlangıçta program adı dahil tüm argümanların sayısını gösterir. Örneğin: `printf(\"Gelen argüman sayısı: %d\\n\", argc - 1);` şeklinde bir çıktı ile argüman sayısını ve durumu değerlendirebilirsiniz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "debugging",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:04.450563"
  },
  {
    "question": "Komut satırı argümanları nedir ve neden kullanılır?",
    "answer": "Komut satırı argümanları, bir programı çalıştırırken komut satırına eklenen verilerdir. Bu argümanlar, programın işlevselliğini genişletmek ve kullanıcıdan girdi almak için kullanılır. Örneğin, bir dosya yolunu veya bir ayar değerini belirlemek için kullanılabilir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281108"
  },
  {
    "question": "C dilinde komut satırı argümanlarını nasıl tanımlarım?",
    "answer": "C dilinde komut satırı argümanları 'main' fonksiyonunun parametreleri olarak tanımlanır. 'int main(int argc, char *argv[])' şeklinde tanımlayarak, 'argc' argüman sayısını ve 'argv' ise argümanların string dizisini temsil eder. Örneğin, 'argc' 3 ise, 3 argüman verilmiştir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281146"
  },
  {
    "question": "Bir programda kullanıcıdan bir isim argümanı alıp nasıl ekrana yazdırabilirim?",
    "answer": "Aşağıdaki örnekte, kullanıcıdan bir isim alınıp ekrana yazdırılmaktadır: \n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        printf(\"Merhaba, %s!\\n\", argv[1]);\n    } else {\n        printf(\"Lütfen bir isim girin.\\n\");\n    }\n    return 0;\n}\n``` Bu kod, komut satırında isim argümanı verilmesini gerektirir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281173"
  },
  {
    "question": "Komut satırı argümanları bir programda nasıl kontrol edilir?",
    "answer": "Komut satırı argümanlarının sayısını 'argc' ile kontrol edebiliriz. Örneğin, eğer kullanıcı gereken argümanları vermezse, uygun bir hata mesajı gösterebiliriz. Aşağıdaki örnekte, 2 argüman beklenmektedir ve eksikse hata verilmiştir:\n```c\nif (argc != 3) {\n    printf(\"Hata: 2 argüman girilmelidir.\\n\");\n    return 1;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281194"
  },
  {
    "question": "Bir dosya yolunu komut satırı argümanı olarak nasıl kullanabilirim?",
    "answer": "Aşağıdaki örnekte, kullanıcıdan bir dosya yolu alınıp o dosyanın içeriği okunmaya çalışılmaktadır:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Dosya yolu girilmelidir.\\n\");\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (!file) {\n        printf(\"Dosya açılamadı.\\n\");\n        return 1;\n    }\n    fclose(file);\n    printf(\"Dosya başarıyla açıldı.\\n\");\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281217"
  },
  {
    "question": "Bir programda birden fazla argüman nasıl işlenir?",
    "answer": "Birden fazla argümanı işlemek için bir döngü kullanabiliriz. Aşağıdaki örnekte, kullanıcıdan birden fazla isim alınıp her biri ekrana yazdırılmaktadır:\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    for (int i = 1; i < argc; i++) {\n        printf(\"Merhaba, %s!\\n\", argv[i]);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281237"
  },
  {
    "question": "Komut satırı argümanlarının türlerini nasıl belirleyebilirim?",
    "answer": "Argümanların türlerini belirlemek için argümanları parse edebiliriz. Örneğin, bir sayısal değeri kontrol etmek istiyorsak, atoi veya strtol gibi fonksiyonlar kullanarak string'i integer'a dönüştürebiliriz. Aşağıda bir örnek bulunmaktadır:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        int sayi = atoi(argv[1]);\n        printf(\"Girdiğiniz sayı: %d\\n\", sayi);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281256"
  },
  {
    "question": "Komut satırı argümanlarını nasıl kullanarak bir hesap makinesi yapabilirim?",
    "answer": "Aşağıda basit bir hesap makinesi örneği verilmiştir. Bu örnekte kullanıcıdan iki sayı ve bir işlem türü (toplama, çıkarma) alınmaktadır:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        printf(\"Kullanım: ./hesap_makinesi <sayı1> <işlem> <sayı2>\\n\");\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[3]);\n    char *islem = argv[2];\n\n    if (strcmp(islem, \"+\") == 0) {\n        printf(\"Sonuç: %d\\n\", sayi1 + sayi2);\n    } else if (strcmp(islem, \"-\") == 0) {\n        printf(\"Sonuç: %d\\n\", sayi1 - sayi2);\n    } else {\n        printf(\"Geçersiz işlem!\\n\");\n        return 1;\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281279"
  },
  {
    "question": "Kullanıcıdan bir dizinin boyutunu argüman olarak alarak nasıl dizi oluşturabilirim?",
    "answer": "Aşağıdaki örnekte, kullanıcıdan bir dizi boyutu alınıp o kadar eleman içeren bir dizi oluşturulmaktadır:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: ./dizi_programı <boyut>\\n\");\n        return 1;\n    }\n    int boyut = atoi(argv[1]);\n    int *dizi = malloc(boyut * sizeof(int));\n    if (dizi == NULL) {\n        printf(\"Bellek ayırma hatası!\\n\");\n        return 1;\n    }\n    printf(\"Dizi başarıyla oluşturuldu.\\n\");\n    free(dizi);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281304"
  },
  {
    "question": "Komut satırından alınan argümanları nasıl sıralayabilirim?",
    "answer": "Komut satırından alınan argümanları sıralamak için öncelikle argümanları bir diziye kopyalayabiliriz, ardından sıralama algoritmalarından birini uygulayabiliriz. Aşağıdaki örnek, basit bir sıralama yapmaktadır:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    for (int i = 1; i < argc; i++) {\n        for (int j = i + 1; j < argc; j++) {\n            if (strcmp(argv[i], argv[j]) > 0) {\n                char *temp = argv[i];\n                argv[i] = argv[j];\n                argv[j] = temp;\n            }\n        }\n    }\n    printf(\"Sıralı argümanlar: \\\n\");\n    for (int i = 1; i < argc; i++) {\n        printf(\"%s \\\n\", argv[i]);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:56:35.281323"
  },
  {
    "question": "Komut satırında nasıl bir dosya adı argümanı alabilirim ve bu dosyayı nasıl açarım?",
    "answer": "C dilinde komut satırı argümanları, main fonksiyonunun parametreleri olan 'int argc, char *argv[]' ile işlenir. 'argc', argüman sayısını, 'argv' ise argümanların bir dizi olarak tutulmasını sağlar. Örneğin, bir dosya adı alıp bunu açmak için şu şekilde bir kod yazabiliriz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s dosya_adı.txt\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    // Dosya açıldı, burada okuma işlemleri yapılabilir\n    fclose(file);\n    return 0;\n}\n```\nBu kod, dosya adını komut satırından alır ve dosyayı açmaya çalışır. Eğer dosya açılamazsa, hata mesajı verir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.282975"
  },
  {
    "question": "Birden fazla komut satırı argümanı almak ve işlemek için hangi yöntemleri kullanabilirim?",
    "answer": "Birden fazla argümanı işlemek için yine 'argc' ve 'argv' kullanılır. Argümanları döngü ile işleyebiliriz. Örneğin, birden fazla dosya adı alıp her birini açalım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s dosya1 dosya2 ...\\n\", argv[0]);\n        return 1;\n    }\n    for (int i = 1; i < argc; i++) {\n        FILE *file = fopen(argv[i], \"r\");\n        if (file == NULL) {\n            perror(argv[i]);\n            continue;\n        }\n        printf(\"%s dosyası açıldı.\\n\", argv[i]);\n        fclose(file);\n    }\n    return 0;\n}\n```\nBu kod, birden fazla dosya adı alır ve her bir dosyayı açmaya çalışır. Açılmayan dosyalar için hata mesajı verir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283046"
  },
  {
    "question": "Argümanlardan bazılarını zorunlu, bazılarını isteğe bağlı hale nasıl getirebilirim?",
    "answer": "Zorunlu ve isteğe bağlı argümanları ayırt etmek için, her bir argümanın konumuna göre kontrol yapabiliriz. İlk argüman zorunlu, diğerleri isteğe bağlı olarak değerlendirilebilir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Zorunlu argümanı girmediniz! Kullanım: %s zorunlu_argüman [isteğe_bağlı_argümanlar]\\n\", argv[0]);\n        return 1;\n    }\n    printf(\"Zorunlu argüman: %s\\n\", argv[1]);\n    if (argc > 2) {\n        printf(\"İsteğe bağlı argümanlar:\\n\");\n        for (int i = 2; i < argc; i++) {\n            printf(\"%s\\n\", argv[i]);\n        }\n    }\n    return 0;\n}\n```\nBu kod, en az bir zorunlu argüman alır ve isteğe bağlı argümanları listeleyebilir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283109"
  },
  {
    "question": "Komut satırı argümanlarını belirli bir formata göre nasıl doğrularım?",
    "answer": "Argümanların belirli bir formatta olup olmadığını kontrol etmek için, öncelikle argümanları alıp her bir argümanı kontrol etmeliyiz. Örneğin, bir email adresinin formatını kontrol edelim:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isValidEmail(const char *email) {\n    const char *at = strchr(email, '@');\n    return (at != NULL && strchr(at, '.') != NULL);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s email_adresi\\n\", argv[0]);\n        return 1;\n    }\n    if (isValidEmail(argv[1])) {\n        printf(\"Geçerli email: %s\\n\", argv[1]);\n    } else {\n        printf(\"Geçersiz email formatı!\\n\");\n    }\n    return 0;\n}\n```\nBu kod, bir email adresi alır ve geçerliliğini kontrol eder.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283152"
  },
  {
    "question": "Komut satırından alınan argümanları bir dosyaya nasıl kaydedebilirim?",
    "answer": "Komut satırından alınan argümanları bir dosyaya kaydetmek için, önce dosyayı açıp ardından argümanları yazmamız gerekir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s dosya_adı.txt argüman1 [argüman2 ...]\\n\", argv[0]);\n        return 1;\n    }\n    FILE *file = fopen(argv[1], \"w\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    for (int i = 2; i < argc; i++) {\n        fprintf(file, \"%s\\n\", argv[i]);\n    }\n    fclose(file);\n    printf(\"Argümanlar %s dosyasına kaydedildi.\\n\", argv[1]);\n    return 0;\n}\n```\nBu kod, ilk argümanı dosya adı olarak alır ve sonraki argümanları bu dosyaya kaydeder.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283190"
  },
  {
    "question": "Komut satırından gelen argümanları sayı olarak nasıl işleyebilirim?",
    "answer": "Argümanları sayıya çevirmek için 'atoi' veya 'atof' gibi fonksiyonlar kullanabiliriz. Aşağıda birden fazla sayıyı toplamak için bir örnek verilmiştir:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s sayı1 sayı2 ...\\n\", argv[0]);\n        return 1;\n    }\n    int toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atoi(argv[i]);\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu kod, sayıları toplar ve sonucu ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283230"
  },
  {
    "question": "Komut satırından alınan argümanların içerdiği özel karakterleri nasıl ele alabilirim?",
    "answer": "Özel karakterlerin doğru bir şekilde işlenmesi için, argümanları analiz edebilir ve gerekli temizleme işlemlerini gerçekleştirebiliriz. Örneğin, bir argümanda '@' karakteri varsa, bu karakteri kaldırarak işleyelim:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nvoid removeSpecialChars(char *str) {\n    char *src = str, *dest = str;\n    while (*src) {\n        if (*src != '@') {\n            *dest++ = *src;\n        }\n        src++;\n    }\n    *dest = '\\0';\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s argüman\\n\", argv[0]);\n        return 1;\n    }\n    removeSpecialChars(argv[1]);\n    printf(\"Temizlenmiş argüman: %s\\n\", argv[1]);\n    return 0;\n}\n```\nBu kod, '@' karakterini temizler ve geri kalan argümanı ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283272"
  },
  {
    "question": "Argümanları dosya yolu olarak kullanarak dosyaların varlığını nasıl kontrol edebilirim?",
    "answer": "Dosya yollarının varlığını kontrol etmek için 'fopen' fonksiyonunu kullanabiliriz. Aşağıdaki örnek, argüman olarak verilen dosyaların varlığını kontrol eder:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s dosya1 [dosya2 ...]\\n\", argv[0]);\n        return 1;\n    }\n    for (int i = 1; i < argc; i++) {\n        if (fopen(argv[i], \"r\")) {\n            printf(\"%s dosyası var.\\n\", argv[i]);\n        } else {\n            printf(\"%s dosyası yok.\\n\", argv[i]);\n        }\n    }\n    return 0;\n}\n```\nBu kod, komut satırından alınan her dosyanın varlığını kontrol eder ve sonucu ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "explanation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:00.283317"
  },
  {
    "question": "Bir komut satırı programı yazın, kullanıcıdan isim alıp selam versin.",
    "answer": "Aşağıdaki C kodu, komut satırından bir isim argümanı alır ve o isme selam verir:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s <isim>\\n\", argv[0]);\n        return 1;\n    }\n    printf(\"Merhaba, %s!\\n\", argv[1]);\n    return 0;\n}\n```\nBu kodda, kullanıcı isim girmediği takdirde bir hata mesajı gösteriliyor.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431661"
  },
  {
    "question": "Bir komut satırı programı yazın, iki sayıyı toplasın.",
    "answer": "Aşağıdaki C kodu, komut satırından iki sayı alır ve toplamını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayı1> <sayı2>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    printf(\"Toplam: %d\\n\", sayi1 + sayi2);\n    return 0;\n}\n```\nBurada `atoi` fonksiyonu, string değerlerini tam sayılara dönüştürmek için kullanılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431699"
  },
  {
    "question": "Bir komut satırı programı yazın, kullanıcıdan bir dosya adı alıp içeriğini göstersin.",
    "answer": "Aşağıdaki C kodu, verilen dosya adındaki içeriği okur ve ekrana yazdırır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adi>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n    char c;\n    while ((c = fgetc(dosya)) != EOF) {\n        putchar(c);\n    }\n    fclose(dosya);\n    return 0;\n}\n```\nBu program, kullanıcıdan dosya adını alır ve dosyanın içeriğini ekrana basar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431728"
  },
  {
    "question": "Kullanıcıdan bir metin alıp, karakter sayısını sayan bir program yazın.",
    "answer": "Aşağıdaki C kodu, kullanıcıdan bir metin alır ve içindeki karakter sayısını hesaplar:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <metin>\\n\", argv[0]);\n        return 1;\n    }\n    printf(\"Karakter sayısı: %lu\\n\", strlen(argv[1]));\n    return 0;\n}\n```\nBurada `strlen` fonksiyonu, string'in uzunluğunu hesaplamak için kullanılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431753"
  },
  {
    "question": "Bir komut satırı uygulaması yazın, kullanıcıdan bir sayı alıp faktöriyelini hesaplasın.",
    "answer": "Aşağıdaki C kodu, verilen sayının faktöriyelini hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long faktoryel(int n) {\n    if (n == 0) return 1;\n    return n * faktoryel(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    printf(\"%d! = %llu\\n\", sayi, faktoryel(sayi));\n    return 0;\n}\n```\nBu program, kullanıcıdan bir sayı alır ve faktöriyelini hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431779"
  },
  {
    "question": "Kullanıcıdan iki sayı alıp, küçük olanı bulan bir program yazın.",
    "answer": "Aşağıdaki C kodu, iki sayıyı karşılaştırarak en küçüğünü bulur:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayı1> <sayı2>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int kucuk = (sayi1 < sayi2) ? sayi1 : sayi2;\n    printf(\"Küçük sayı: %d\\n\", kucuk);\n    return 0;\n}\n```\nBu program, kullanıcıdan iki sayı alır ve en küçük olanını ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431804"
  },
  {
    "question": "Bir komut satırı programı yazın, verilen bir sayının çift veya tek olduğunu kontrol etsin.",
    "answer": "Aşağıdaki C kodu, verilen sayının çift mi tek mi olduğunu kontrol eder:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    if (sayi % 2 == 0) {\n        printf(\"%d bir çift sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d bir tek sayıdır.\\n\", sayi);\n    }\n    return 0;\n}\n```\nBu program, kullanıcının girdiği sayının çift veya tek olduğunu belirler.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431833"
  },
  {
    "question": "Kullanıcıdan bir sayı alıp, o sayının asal olup olmadığını kontrol eden bir program yazın.",
    "answer": "Aşağıdaki C kodu, verilen sayının asal olup olmadığını kontrol eder:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool asalMi(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    if (asalMi(sayi)) {\n        printf(\"%d bir asal sayıdır.\\n\", sayi);\n    } else {\n        printf(\"%d asal bir sayı değildir.\\n\", sayi);\n    }\n    return 0;\n}\n```\nBu program, kullanıcının girdiği sayının asal olup olmadığını kontrol eder.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431864"
  },
  {
    "question": "Bir komut satırı programı yazın, kullanıcıdan bir metin alıp, tersini yazsın.",
    "answer": "Aşağıdaki C kodu, verilen metni tersine çevirir ve ekrana yazdırır:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <metin>\\n\", argv[0]);\n        return 1;\n    }\n    char *metin = argv[1];\n    int uzunluk = strlen(metin);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(metin[i]);\n    }\n    putchar('\\n');\n    return 0;\n}\n```\nBu program, kullanıcıdan aldığı metni ters çevirir ve ekrana basar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "basic",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:58:33.431891"
  },
  {
    "question": "Bir program yazın, bu program verilen adın uzunluğunu hesaplasın. Komut satırı argümanları olarak bir isim alacak.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <isim>\\n\", argv[0]);\n        return 1;\n    }\n    int uzunluk = strlen(argv[1]);\n    printf(\"'%s' isminin uzunluğu: %d\\n\", argv[1], uzunluk);\n    return 0;\n}\n// Bu program, komut satırından girilen bir ismin uzunluğunu hesaplar ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651243"
  },
  {
    "question": "Kullanıcıdan iki sayı alarak bu sayıların toplamını hesaplayan bir program yazın. Sayılar komut satırı argümanları olarak alınacak.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayi1> <sayi2>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int toplam = sayi1 + sayi2;\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n// Bu program, iki sayıyı komut satırından alarak toplamını hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651302"
  },
  {
    "question": "Komut satırı argümanları ile bir dosya adı alarak, dosyanın var olup olmadığını kontrol eden bir program yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    if (fopen(argv[1], \"r\") != NULL) {\n        printf(\"Dosya var: %s\\n\", argv[1]);\n    } else {\n        printf(\"Dosya bulunamadı: %s\\n\", argv[1]);\n    }\n    return 0;\n}\n// Bu program, verilen dosya adının var olup olmadığını kontrol eder.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651336"
  },
  {
    "question": "Bir program yazın, bu program komut satırı argümanı olarak verilen bir metni ters çevirsin.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <metin>\\n\", argv[0]);\n        return 1;\n    }\n    int uzunluk = strlen(argv[1]);\n    for (int i = uzunluk - 1; i >= 0; i--) {\n        putchar(argv[1][i]);\n    }\n    putchar('\\n');\n    return 0;\n}\n// Bu program, verilen metni ters çevirerek ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651365"
  },
  {
    "question": "Bir program yazın, komut satırı argümanları olarak bir dizi tam sayı alarak, bu sayıların ortalamasını hesaplasın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir tam sayı girmelisiniz!\\n\");\n        return 1;\n    }\n    double toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atoi(argv[i]);\n    }\n    double ortalama = toplam / (argc - 1);\n    printf(\"Ortalama: %f\\n\", ortalama);\n    return 0;\n}\n// Bu program, verilen tam sayıların ortalamasını hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651398"
  },
  {
    "question": "Bir metin dosyası alarak, dosyadaki satır sayısını hesaplayan bir program yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı: %s\\n\", argv[1]);\n        return 1;\n    }\n    int satirSayisi = 0;\n    char satir[256];\n    while (fgets(satir, sizeof(satir), dosya)) {\n        satirSayisi++;\n    }\n    fclose(dosya);\n    printf(\"Satır sayısı: %d\\n\", satirSayisi);\n    return 0;\n}\n// Bu program, verilen bir metin dosyasındaki satır sayısını sayar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651424"
  },
  {
    "question": "Kullanıcıdan komut satırı argümanı olarak bir dosya adı alarak, dosyanın içeriğini ekrana yazdıran bir program yazın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (dosya == NULL) {\n        printf(\"Dosya açılamadı: %s\\n\", argv[1]);\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(dosya)) != EOF) {\n        putchar(ch);\n    }\n    fclose(dosya);\n    return 0;\n}\n// Bu program, verilen dosyanın içeriğini ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651457"
  },
  {
    "question": "Bir program yazın, bu program komut satırı argümanı olarak verilen bir tam sayının faktöriyelini hesaplasın.",
    "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    int sonuc = faktoriyel(sayi);\n    printf(\"%d! = %d\\n\", sayi, sonuc);\n    return 0;\n}\n// Bu program, verilen bir sayının faktöriyelini hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651488"
  },
  {
    "question": "Bir program yazın, komut satırı argümanları ile verilen birkaç kelimeyi birleştirip tek bir cümle halinde yazdıran bir program.",
    "answer": "#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"En az bir kelime girmelisiniz!\\n\");\n        return 1;\n    }\n    for (int i = 1; i < argc; i++) {\n        printf(\"%s%s\", argv[i], (i < argc - 1) ? \" \" : \"\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// Bu program, verilen kelimeleri birleştirerek tek bir cümle halinde yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T17:59:09.651541"
  },
  {
    "question": "Bir C programında komut satırı argümanlarını kullanarak bir dosyayı okumak ve içeriğini ekrana yazdırmak için nasıl bir yapı oluşturabilirim?",
    "answer": "Aşağıdaki gibi bir kod parçacığı oluşturabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    fclose(file);\n    return 0;\n}\n```\nBu kod, komut satırından bir dosya adı alır ve o dosyanın içeriğini ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667657"
  },
  {
    "question": "Komut satırı argümanları ile bir toplama işlemi yaparak iki sayıyı nasıl toplayabilirim?",
    "answer": "Aşağıdaki kod, iki sayıyı komut satırından alıp toplamını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <sayi1> <sayi2>\\n\", argv[0]);\n        return 1;\n    }\n\n    int sayi1 = atoi(argv[1]);\n    int sayi2 = atoi(argv[2]);\n    int toplam = sayi1 + sayi2;\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu program, iki sayıyı alarak toplamını hesaplar ve ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667722"
  },
  {
    "question": "Bir C programında komut satırı argümanları ile birden fazla dosya alıp, her bir dosyanın satır sayısını nasıl hesaplayabilirim?",
    "answer": "Aşağıdaki örnek, verilen dosyaların satır sayılarını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s <dosya1> <dosya2> ...\\n\", argv[0]);\n        return 1;\n    }\n\n    for (int i = 1; i < argc; i++) {\n        FILE *file = fopen(argv[i], \"r\");\n        if (file == NULL) {\n            perror(\"Dosya açılamadı\");\n            continue;\n        }\n\n        int satirSayisi = 0;\n        char ch;\n        while ((ch = fgetc(file)) != EOF) {\n            if (ch == '\\n') {\n                satirSayisi++;\n            }\n        }\n\n        fclose(file);\n        printf(\"%s dosyasındaki satır sayısı: %d\\n\", argv[i], satirSayisi);\n    }\n    return 0;\n}\n```\nBu program, birden fazla dosya alarak her birinin satır sayısını hesaplar ve gösterir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667782"
  },
  {
    "question": "Bir C uygulamasında, komut satırı argümanları ile kullanıcıdan bir dizin adı alıp, o dizindeki dosyaların listesini nasıl çıkarabilirim?",
    "answer": "Aşağıdaki kod, belirtilen dizindeki dosyaların listesini çıkarır:\n\n```c\n#include <stdio.h>\n#include <dirent.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dizin_adı>\\n\", argv[0]);\n        return 1;\n    }\n\n    DIR *d = opendir(argv[1]);\n    if (d == NULL) {\n        perror(\"Dizin açılamadı\");\n        return 1;\n    }\n\n    struct dirent *entry;\n    while ((entry = readdir(d)) != NULL) {\n        printf(\"%s\\n\", entry->d_name);\n    }\n\n    closedir(d);\n    return 0;\n}\n```\nBu program, verilen dizindeki dosyaların adlarını ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667846"
  },
  {
    "question": "Komut satırı argümanları kullanarak bir kullanıcıdan belirli bir kelimeyi alıp, o kelimenin bir dosyada kaç kez geçtiğini nasıl bulabilirim?",
    "answer": "Aşağıdaki program, bir dosyada belirli bir kelimenin kaç kez geçtiğini sayar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <dosya_adı> <kelime>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Dosya açılamadı\");\n        return 1;\n    }\n\n    char *kelime = argv[2];\n    char satir[256];\n    int sayac = 0;\n\n    while (fgets(satir, sizeof(satir), file)) {\n        char *ptr = satir;\n        while ((ptr = strstr(ptr, kelime)) != NULL) {\n            sayac++;\n            ptr += strlen(kelime);\n        }\n    }\n\n    fclose(file);\n    printf(\"'%s' kelimesi %d kez bulundu.\\n\", kelime, sayac);\n    return 0;\n}\n```\nBu kod, belirlenen kelimenin kaç kez geçtiğini sayar ve sonucu gösterir.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667926"
  },
  {
    "question": "Komut satırı argümanları ile bir programı başlattıktan sonra, başka bir programı nasıl çalıştırabilirim ve sonuçlarını ekrana yazdırabilirim?",
    "answer": "Aşağıdaki örnek, komut satırı argümanları ile başka bir programı çalıştırır ve çıktısını ekrana yazdırır:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s <program> [argümanlar...]\\n\", argv[0]);\n        return 1;\n    }\n\n    char *cmd = argv[1];\n    char *args[argc];\n    for (int i = 1; i < argc; i++) {\n        args[i - 1] = argv[i];\n    }\n    args[argc - 1] = NULL;\n\n    pid_t pid = fork();\n    if (pid == 0) {\n        execvp(cmd, args);\n        perror(\"execvp başarısız\");\n        exit(1);\n    } else if (pid < 0) {\n        perror(\"Fork başarısız\");\n        return 1;\n    } else {\n        wait(NULL);\n    }\n\n    return 0;\n}\n```\nBu program, verilen bir başka programı çalıştırır ve çıktısını yakalamak için kullanılır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.667982"
  },
  {
    "question": "Komut satırı argümanları kullanarak bir dizi içindeki elemanları sıralamak için nasıl bir algoritma uygulayabilirim?",
    "answer": "Aşağıdaki kod, komut satırı argümanları kullanarak sayıları sıralar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s <sayi1> <sayi2> ...\\n\", argv[0]);\n        return 1;\n    }\n\n    int n = argc - 1;\n    int sayilar[n];\n    for (int i = 1; i < argc; i++) {\n        sayilar[i - 1] = atoi(argv[i]);\n    }\n\n    qsort(sayilar, n, sizeof(int), compare);\n\n    printf(\"Sıralı sayılar:\");\n    for (int i = 0; i < n; i++) {\n        printf(\" %d\", sayilar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\nBu program, verilen sayıları sıralar ve sıralı haliyle ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.668032"
  },
  {
    "question": "Bir C programında komut satırı argümanları ile bir diziye eleman ekleyip, toplamını nasıl hesaplayabilirim?",
    "answer": "Aşağıdaki örnek, komut satırı argümanları ile bir dizi oluşturarak toplamını hesaplar:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Kullanım: %s <sayi1> <sayi2> ...\\n\", argv[0]);\n        return 1;\n    }\n\n    int toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atoi(argv[i]);\n    }\n\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu program, argüman olarak verilen sayıları toplar ve sonucu ekrana yazdırır.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.668085"
  },
  {
    "question": "Bir C programında komut satırı argümanları ile bir kullanıcıdan bir tarih alıp, o tarihin geçerliliğini kontrol etmek için nasıl bir yöntem izleyebilirim?",
    "answer": "Aşağıdaki kod, komut satırı argümanları ile verilen tarihin geçerliliğini kontrol eder:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint tarihGeçerliMi(int gun, int ay, int yil) {\n    if (yil < 1582 || ay < 1 || ay > 12 || gun < 1 || gun > 31) {\n        return 0;\n    }\n    if (ay == 2) {\n        if ((yil % 4 == 0 && yil % 100 != 0) || (yil % 400 == 0)) {\n            return gun <= 29;\n        }\n        return gun <= 28;\n    }\n    if (ay == 4 || ay == 6 || ay == 9 || ay == 11) {\n        return gun <= 30;\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        printf(\"Kullanım: %s <gun> <ay> <yil>\\n\", argv[0]);\n        return 1;\n    }\n\n    int gun = atoi(argv[1]);\n    int ay = atoi(argv[2]);\n    int yil = atoi(argv[3]);\n\n    if (tarihGeçerliMi(gun, ay, yil)) {\n        printf(\"Tarih geçerlidir.\\n\");\n    } else {\n        printf(\"Tarih geçersizdir.\\n\");\n    }\n\n    return 0;\n}\n```\nBu program, verilen tarihi kontrol eder ve geçerli olup olmadığını belirler.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "implementation",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:00:09.668153"
  },
  {
    "question": "Komut satırı argümanlarını nasıl kontrol edebilirim ve geçersiz argümanlar için hata mesajı nasıl gösterebilirim?",
    "answer": "Kodunuzu başlarken, 'argc' ve 'argv' parametrelerini kullanarak komut satırı argümanlarını kontrol edebilirsiniz. Geçersiz argümanlar için basit bir hata mesajı yazabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Hata: Lütfen bir argüman girin!\\n\");\n        return 1;\n    }\n    // Devam eden işlemler...\n    return 0;\n}\n```\nBu örnekte, programa bir argüman verilmezse hata mesajı gösteriliyor.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378383"
  },
  {
    "question": "Dizinin elemanlarını komut satırından alarak nasıl işlemler yapabilirim?",
    "answer": "Komut satırından bir dizi elemanı alıp bunları toplamak için şu örneği kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    int toplam = 0;\n    for (int i = 1; i < argc; i++) {\n        toplam += atoi(argv[i]);\n    }\n    printf(\"Toplam: %d\\n\", toplam);\n    return 0;\n}\n```\nBu örnekte, komut satırından tamsayı argümanları alıp bunları topluyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378423"
  },
  {
    "question": "Komut satırında bir dosya yolunu nasıl alabilir ve bu dosyanın varlığını kontrol edebilirim?",
    "answer": "Dosya yolunu komut satırından almak için 'argv' kullanarak ve ardından 'fopen' ile dosyanın varlığını kontrol edebilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <dosya_yolu>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"r\");\n    if (!dosya) {\n        printf(\"Dosya bulunamadı: %s\\n\", argv[1]);\n        return 1;\n    }\n    fclose(dosya);\n    printf(\"Dosya bulundu!\\n\");\n    return 0;\n}\n```\nBu kod, belirtilen dosyanın varlığını kontrol eder.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378452"
  },
  {
    "question": "Birden fazla argüman alıp bunları bir liste olarak nasıl yazdırabilirim?",
    "answer": "Birden fazla argüman alıp bunları döngü ile yazdırmak için şu kodu kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"Girilen argümanlar:\\n\");\n    for (int i = 1; i < argc; i++) {\n        printf(\"%s\\n\", argv[i]);\n    }\n    return 0;\n}\n```\nBu örnekte, tüm argümanları bir liste olarak ekrana yazdırıyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378476"
  },
  {
    "question": "Komut satırından alacağım argümanların belirli bir formatta olup olmadığını nasıl kontrol ederim?",
    "answer": "Örneğin, bir e-posta adresinin formatını kontrol etmek için basit bir regex kullanabilirsiniz. Ancak, C'de regex kullanmak için 'regex.h' kütüphanesini kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <regex.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <e-posta>\\n\", argv[0]);\n        return 1;\n    }\n    regex_t regex;\n    int reti = regcomp(&regex, \"^[^@]+@[^@]+\\.[^@]+$, 0);\n    if (reti) {\n        printf(\"Regex compilasyonu başarısız!\\n\");\n        return 1;\n    }\n    reti = regexec(&regex, argv[1], 0, NULL, 0);\n    if (reti == REG_NOMATCH) {\n        printf(\"Geçersiz e-posta formatı!\\n\");\n    } else {\n        printf(\"Geçerli e-posta formatı!\\n\");\n    }\n    regfree(&regex);\n    return 0;\n}\n```\nBu örnekte, e-posta adresinin geçerliliğini kontrol ediyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378535"
  },
  {
    "question": "Komut satırından argüman alarak bir işlemin sonucunu nasıl dosyaya yazabilirim?",
    "answer": "Komut satırından gelen bir argüman ile sonucu bir dosyaya yazmak için şu şekilde bir kod yazabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Kullanım: %s <dosya_adi> <yazilacak_metin>\\n\", argv[0]);\n        return 1;\n    }\n    FILE *dosya = fopen(argv[1], \"w\");\n    if (!dosya) {\n        printf(\"Dosya açılamadı: %s\\n\", argv[1]);\n        return 1;\n    }\n    fprintf(dosya, \"%s\\n\", argv[2]);\n    fclose(dosya);\n    printf(\"Yazma işlemi başarılı!\\n\");\n    return 0;\n}\n```\nBu kod, bir dosya adı ve yazılacak metin alarak dosyaya metni yazar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378586"
  },
  {
    "question": "Argümanları sıralı bir şekilde nasıl işleyebilirim?",
    "answer": "Argümanları sıralı bir şekilde işlemek için basit bir sıralama algoritması yazabilirsiniz. Örneğin, 'bubble sort' algoritması ile:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char **x, char **y) {\n    char *temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid bubbleSort(char *arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (strcmp(arr[j], arr[j+1]) > 0) {\n                swap(&arr[j], &arr[j+1]);\n            }\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    bubbleSort(argv + 1, argc - 1);\n    printf(\"Sıralı argümanlar:\\n\");\n    for (int i = 1; i < argc; i++) {\n        printf(\"%s\\n\", argv[i]);\n    }\n    return 0;\n}\n```\nBu örnekte, argümanları sıralayıp yazdırıyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378609"
  },
  {
    "question": "Bir argüman olarak bir sayı alıp, bu sayının faktöriyelini nasıl hesaplayabilirim?",
    "answer": "Faktöriyel hesaplamak için basit bir fonksiyon kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <sayı>\\n\", argv[0]);\n        return 1;\n    }\n    int sayi = atoi(argv[1]);\n    printf(\"%d sayısının faktöriyeli: %llu\\n\", sayi, faktoriyel(sayi));\n    return 0;\n}\n```\nBu kod, bir sayı alıp faktöriyelini hesaplar.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378637"
  },
  {
    "question": "Argümanlardan gelen bir tarih bilgisini nasıl kontrol ederim?",
    "answer": "Tarih bilgisinin formatını kontrol etmek için basit bir kontrol yapabilirsiniz:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint tarihKontrol(char *tarih) {\n    if (strlen(tarih) != 10) return 0;\n    if (tarih[4] != '-' || tarih[7] != '-') return 0;\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Kullanım: %s <YYYY-MM-DD>\\n\", argv[0]);\n        return 1;\n    }\n    if (!tarihKontrol(argv[1])) {\n        printf(\"Geçersiz tarih formatı!\\n\");\n    } else {\n        printf(\"Geçerli tarih formatı!\\n\");\n    }\n    return 0;\n}\n```\nBu örnekte, YYYY-MM-DD formatındaki bir tarihin geçerliliğini kontrol ediyoruz.",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "intermediate",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:05.378659"
  },
  {
    "question": "Komut satırı argümanlarını nasıl kontrol edebilirim ve yanlış argümanlar alındığında hata mesajı vermek için hangi yapıyı kullanmalıyım?",
    "answer": "Komut satırı argümanlarını kontrol etmek için \"argc\" ve \"argv\" parametrelerini kullanabilirsiniz. Eğer beklenmedik bir argüman alırsanız, kullanıcıya bilgi vermek için standart çıktıya hata mesajı basabilirsiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Hata: İki argüman giriniz.\\n\");\n        return 1;\n    }\n    // İlgili işlemler...\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318380"
  },
  {
    "question": "Bir komut satırı uygulamasında argümanları parse etmek için hangi kütüphaneleri kullanabilirim?",
    "answer": "C dilinde argümanları parse etmek için \"getopt\" gibi kütüphaneleri kullanabilirsiniz. Bu, opsiyonel argümanları ve flag'leri yönetmek için idealdir. Örnek kullanım:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    int opt;\n    while ((opt = getopt(argc, argv, \"a:b:c\")) != -1) {\n        switch (opt) {\n            case 'a':\n                printf(\"A argümanı: %s\\n\", optarg);\n                break;\n            case 'b':\n                printf(\"B argümanı: %s\\n\", optarg);\n                break;\n            case 'c':\n                printf(\"C flag'i aktif.\\n\");\n                break;\n            default:\n                fprintf(stderr, \"Yanlış argüman.\\n\");\n                exit(EXIT_FAILURE);\n        }\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318424"
  },
  {
    "question": "Argümanları alırken bellek yönetimi ile ilgili nelere dikkat etmeliyim?",
    "answer": "Argümanları işlerken bellek yönetimi kritik bir konudur. Özellikle argümanları kopyalarken ve dinamik bellek allocate ederken dikkatli olmalısınız. Örneğin, malloc ile dinamik bellek ayırdıysanız, işiniz bittiğinde free ile serbest bırakmalısınız:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) return 1;\n    char *arg_copy = malloc(strlen(argv[1]) + 1);\n    if (arg_copy == NULL) return 1;\n    strcpy(arg_copy, argv[1]);\n    // Kullanım...\n    free(arg_copy);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318450"
  },
  {
    "question": "Birden fazla komut satırı argümanı nasıl işlenir? Örnekle göster.",
    "answer": "Birden fazla argümanı işlemenin basit bir yolu, bunları bir döngü ile gezmektir. Aşağıdaki örnekte, verilen argümanları topluyoruz:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    for (int i = 1; i < argc; i++) {\n        printf(\"Argüman %d: %s\\n\", i, argv[i]);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318475"
  },
  {
    "question": "Komut satırı argümanlarında özel karakterler (örn. boşluk) nasıl yönetilir?",
    "answer": "Argümanlarda boşluk veya özel karakterler kullanmak için argümanları çift tırnak içinde vermek gereklidir. Örneğin: `./program \"argüman 1\" \"argüman 2\"`. Kodda bu argümanları doğrudan kullanabilirsiniz:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        printf(\"İlk argüman: %s\\n\", argv[1]);\n    }\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318503"
  },
  {
    "question": "Bir uygulamada varsayılan argüman ayarları nasıl yapılır?",
    "answer": "Varsayılan argüman ayarları, argüman sayısı kontrol edildikten sonra ayarlanabilir. Örnek:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    int value = 10; // Varsayılan değer\n    if (argc > 1) {\n        value = atoi(argv[1]); // Argümandan değer al\n    }\n    printf(\"Değer: %d\\n\", value);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318542"
  },
  {
    "question": "Komut satırı argümanlarında hata kontrolü yapmanın en iyi yöntemleri nelerdir?",
    "answer": "Hata kontrolü için, argüman sayısını ve türünü kontrol etmek önemlidir. Her argüman için geçerlilik kontrolü yaparak kullanıcıyı bilgilendirebilirsiniz:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Hata: Tek bir argüman gerekli.\\n\");\n        return 1;\n    }\n    int num = atoi(argv[1]);\n    if (num == 0 && argv[1][0] != '0') {\n        fprintf(stderr, \"Hata: Geçersiz sayısal argüman.\\n\");\n        return 1;\n    }\n    printf(\"Argüman: %d\\n\", num);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318568"
  },
  {
    "question": "Komut satırında argümanların sıralamasını nasıl kontrol edebilirim?",
    "answer": "Argümanların sıralamasını kontrol etmek için, belirli bir sıra bekliyorsanız, argümanları kontrol ederken indekslerine dikkat etmelisiniz. Örneğin:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        fprintf(stderr, \"Hata: İki argüman giriniz.\\n\");\n        return 1;\n    }\n    if (argv[1][0] != '-') {\n        fprintf(stderr, \"Hata: İlk argüman bir seçenek olmalı.\\n\");\n        return 1;\n    }\n    // İşlem...\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318590"
  },
  {
    "question": "Komut satırından alınan argümanların uzunluğunu nasıl kontrol edebilirim?",
    "answer": "Argümanların uzunluğunu kontrol etmek için, \"strlen\" fonksiyonunu kullanabilirsiniz. Bu, argümanın boyutunu anlamanıza yardımcı olur:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) return 1;\n    if (strlen(argv[1]) > 10) {\n        fprintf(stderr, \"Hata: Argüman 10 karakterden uzun olamaz.\\n\");\n        return 1;\n    }\n    printf(\"Argüman: %s\\n\", argv[1]);\n    return 0;\n}\n```",
    "category": "advanced_topics",
    "topic": "command_line",
    "problem_type": "code_review",
    "difficulty": "advanced",
    "topic_name": "Komut satırı argümanları",
    "timestamp": "2025-06-01T18:01:40.318621"
  }
]